"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-transform";
exports.ids = ["vendor-chunks/prosemirror-transform"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-transform/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; } catch (e) { return typeof fn === \"function\"; } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.cjs\");\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n  return value & lower16;\n}\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\nvar DEL_BEFORE = 1,\n  DEL_AFTER = 2,\n  DEL_ACROSS = 4,\n  DEL_SIDE = 8;\nvar MapResult = function () {\n  function MapResult(pos, delInfo, recover) {\n    _classCallCheck(this, MapResult);\n    this.pos = pos;\n    this.delInfo = delInfo;\n    this.recover = recover;\n  }\n  _createClass(MapResult, [{\n    key: \"deleted\",\n    get: function get() {\n      return (this.delInfo & DEL_SIDE) > 0;\n    }\n  }, {\n    key: \"deletedBefore\",\n    get: function get() {\n      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n  }, {\n    key: \"deletedAfter\",\n    get: function get() {\n      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n  }, {\n    key: \"deletedAcross\",\n    get: function get() {\n      return (this.delInfo & DEL_ACROSS) > 0;\n    }\n  }]);\n  return MapResult;\n}();\nvar StepMap = function () {\n  function StepMap(ranges) {\n    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    _classCallCheck(this, StepMap);\n    this.ranges = ranges;\n    this.inverted = inverted;\n    if (!ranges.length && StepMap.empty) return StepMap.empty;\n  }\n  _createClass(StepMap, [{\n    key: \"recover\",\n    value: function recover(value) {\n      var diff = 0,\n        index = recoverIndex(value);\n      if (!this.inverted) for (var i = 0; i < index; i++) diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n      return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, false);\n    }\n  }, {\n    key: \"map\",\n    value: function map(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, true);\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(pos, assoc, simple) {\n      var diff = 0,\n        oldIndex = this.inverted ? 2 : 1,\n        newIndex = this.inverted ? 1 : 2;\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n          newSize = this.ranges[i + newIndex],\n          end = start + oldSize;\n        if (pos <= end) {\n          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n          var result = start + diff + (side < 0 ? 0 : newSize);\n          if (simple) return result;\n          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;\n          return new MapResult(result, del, recover);\n        }\n        diff += newSize - oldSize;\n      }\n      return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n  }, {\n    key: \"touches\",\n    value: function touches(pos, recover) {\n      var diff = 0,\n        index = recoverIndex(recover);\n      var oldIndex = this.inverted ? 2 : 1,\n        newIndex = this.inverted ? 1 : 2;\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n          end = start + oldSize;\n        if (pos <= end && i == index * 3) return true;\n        diff += this.ranges[i + newIndex] - oldSize;\n      }\n      return false;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      var oldIndex = this.inverted ? 2 : 1,\n        newIndex = this.inverted ? 1 : 2;\n      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i],\n          oldStart = start - (this.inverted ? diff : 0),\n          newStart = start + (this.inverted ? 0 : diff);\n        var oldSize = this.ranges[i + oldIndex],\n          newSize = this.ranges[i + newIndex];\n        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n        diff += newSize - oldSize;\n      }\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new StepMap(this.ranges, !this.inverted);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n  }], [{\n    key: \"offset\",\n    value: function offset(n) {\n      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n  }]);\n  return StepMap;\n}();\nStepMap.empty = new StepMap([]);\nvar Mapping = function () {\n  function Mapping() {\n    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var mirror = arguments.length > 1 ? arguments[1] : undefined;\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;\n    _classCallCheck(this, Mapping);\n    this.maps = maps;\n    this.mirror = mirror;\n    this.from = from;\n    this.to = to;\n  }\n  _createClass(Mapping, [{\n    key: \"slice\",\n    value: function slice() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;\n      return new Mapping(this.maps, this.mirror, from, to);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n  }, {\n    key: \"appendMap\",\n    value: function appendMap(map, mirrors) {\n      this.to = this.maps.push(map);\n      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);\n    }\n  }, {\n    key: \"appendMapping\",\n    value: function appendMapping(mapping) {\n      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n        var mirr = mapping.getMirror(i);\n        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n      }\n    }\n  }, {\n    key: \"getMirror\",\n    value: function getMirror(n) {\n      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n  }, {\n    key: \"setMirror\",\n    value: function setMirror(n, m) {\n      if (!this.mirror) this.mirror = [];\n      this.mirror.push(n, m);\n    }\n  }, {\n    key: \"appendMappingInverted\",\n    value: function appendMappingInverted(mapping) {\n      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n        var mirr = mapping.getMirror(i);\n        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n      }\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      var inverse = new Mapping();\n      inverse.appendMappingInverted(this);\n      return inverse;\n    }\n  }, {\n    key: \"map\",\n    value: function map(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      if (this.mirror) return this._map(pos, assoc, true);\n      for (var i = this.from; i < this.to; i++) pos = this.maps[i].map(pos, assoc);\n      return pos;\n    }\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, false);\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(pos, assoc, simple) {\n      var delInfo = 0;\n      for (var i = this.from; i < this.to; i++) {\n        var map = this.maps[i],\n          result = map.mapResult(pos, assoc);\n        if (result.recover != null) {\n          var corr = this.getMirror(i);\n          if (corr != null && corr > i && corr < this.to) {\n            i = corr;\n            pos = this.maps[corr].recover(result.recover);\n            continue;\n          }\n        }\n        delInfo |= result.delInfo;\n        pos = result.pos;\n      }\n      return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n  }]);\n  return Mapping;\n}();\nvar stepsByID = Object.create(null);\nvar Step = function () {\n  function Step() {\n    _classCallCheck(this, Step);\n  }\n  _createClass(Step, [{\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      return null;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\");\n      var type = stepsByID[json.stepType];\n      if (!type) throw new RangeError(\"No step type \".concat(json.stepType, \" defined\"));\n      return type.fromJSON(schema, json);\n    }\n  }, {\n    key: \"jsonID\",\n    value: function jsonID(id, stepClass) {\n      if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n      stepsByID[id] = stepClass;\n      stepClass.prototype.jsonID = id;\n      return stepClass;\n    }\n  }]);\n  return Step;\n}();\nvar StepResult = function () {\n  function StepResult(doc, failed) {\n    _classCallCheck(this, StepResult);\n    this.doc = doc;\n    this.failed = failed;\n  }\n  _createClass(StepResult, null, [{\n    key: \"ok\",\n    value: function ok(doc) {\n      return new StepResult(doc, null);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(message) {\n      return new StepResult(null, message);\n    }\n  }, {\n    key: \"fromReplace\",\n    value: function fromReplace(doc, from, to, slice) {\n      try {\n        return StepResult.ok(doc.replace(from, to, slice));\n      } catch (e) {\n        if (e instanceof prosemirrorModel.ReplaceError) return StepResult.fail(e.message);\n        throw e;\n      }\n    }\n  }]);\n  return StepResult;\n}();\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline) child = f(child, parent, i);\n    mapped.push(child);\n  }\n  return prosemirrorModel.Fragment.fromArray(mapped);\n}\nvar AddMarkStep = function (_Step) {\n  _inherits(AddMarkStep, _Step);\n  var _super = _createSuper(AddMarkStep);\n  function AddMarkStep(from, to, mark) {\n    var _this;\n    _classCallCheck(this, AddMarkStep);\n    _this = _super.call(this);\n    _this.from = from;\n    _this.to = to;\n    _this.mark = mark;\n    return _this;\n  }\n  _createClass(AddMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this2 = this;\n      var oldSlice = doc.slice(this.from, this.to),\n        $from = doc.resolve(this.from);\n      var parent = $from.node($from.sharedDepth(this.to));\n      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node, parent) {\n        if (!node.isAtom || !parent.type.allowsMarkType(_this2.mark.type)) return node;\n        return node.mark(_this2.mark.addToSet(node.marks));\n      }, parent), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"addMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n  return AddMarkStep;\n}(Step);\nStep.jsonID(\"addMark\", AddMarkStep);\nvar RemoveMarkStep = function (_Step2) {\n  _inherits(RemoveMarkStep, _Step2);\n  var _super2 = _createSuper(RemoveMarkStep);\n  function RemoveMarkStep(from, to, mark) {\n    var _this3;\n    _classCallCheck(this, RemoveMarkStep);\n    _this3 = _super2.call(this);\n    _this3.from = from;\n    _this3.to = to;\n    _this3.mark = mark;\n    return _this3;\n  }\n  _createClass(RemoveMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this4 = this;\n      var oldSlice = doc.slice(this.from, this.to);\n      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node) {\n        return node.mark(_this4.mark.removeFromSet(node.marks));\n      }, doc), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new AddMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"removeMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n  return RemoveMarkStep;\n}(Step);\nStep.jsonID(\"removeMark\", RemoveMarkStep);\nvar AddNodeMarkStep = function (_Step3) {\n  _inherits(AddNodeMarkStep, _Step3);\n  var _super3 = _createSuper(AddNodeMarkStep);\n  function AddNodeMarkStep(pos, mark) {\n    var _this5;\n    _classCallCheck(this, AddNodeMarkStep);\n    _this5 = _super3.call(this);\n    _this5.pos = pos;\n    _this5.mark = mark;\n    return _this5;\n  }\n  _createClass(AddNodeMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at mark step's position\");\n      var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (node) {\n        var newSet = this.mark.addToSet(node.marks);\n        if (newSet.length == node.marks.length) {\n          for (var i = 0; i < node.marks.length; i++) if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);\n          return new AddNodeMarkStep(this.pos, this.mark);\n        }\n      }\n      return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"addNodeMark\",\n        pos: this.pos,\n        mark: this.mark.toJSON()\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n  }]);\n  return AddNodeMarkStep;\n}(Step);\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\nvar RemoveNodeMarkStep = function (_Step4) {\n  _inherits(RemoveNodeMarkStep, _Step4);\n  var _super4 = _createSuper(RemoveNodeMarkStep);\n  function RemoveNodeMarkStep(pos, mark) {\n    var _this6;\n    _classCallCheck(this, RemoveNodeMarkStep);\n    _this6 = _super4.call(this);\n    _this6.pos = pos;\n    _this6.mark = mark;\n    return _this6;\n  }\n  _createClass(RemoveNodeMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at mark step's position\");\n      var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node || !this.mark.isInSet(node.marks)) return this;\n      return new AddNodeMarkStep(this.pos, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"removeNodeMark\",\n        pos: this.pos,\n        mark: this.mark.toJSON()\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n  }]);\n  return RemoveNodeMarkStep;\n}(Step);\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\nvar ReplaceStep = function (_Step5) {\n  _inherits(ReplaceStep, _Step5);\n  var _super5 = _createSuper(ReplaceStep);\n  function ReplaceStep(from, to, slice) {\n    var _this7;\n    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, ReplaceStep);\n    _this7 = _super5.call(this);\n    _this7.from = from;\n    _this7.to = to;\n    _this7.slice = slice;\n    _this7.structure = structure;\n    return _this7;\n  }\n  _createClass(ReplaceStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail(\"Structure replace would overwrite content\");\n      return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      if (from.deletedAcross && to.deletedAcross) return null;\n      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;\n      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n        var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n        var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n        return new ReplaceStep(other.from, this.to, _slice, this.structure);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        stepType: \"replace\",\n        from: this.from,\n        to: this.to\n      };\n      if (this.slice.size) json.slice = this.slice.toJSON();\n      if (this.structure) json.structure = true;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n      return new ReplaceStep(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n  }]);\n  return ReplaceStep;\n}(Step);\nStep.jsonID(\"replace\", ReplaceStep);\nvar ReplaceAroundStep = function (_Step6) {\n  _inherits(ReplaceAroundStep, _Step6);\n  var _super6 = _createSuper(ReplaceAroundStep);\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert) {\n    var _this8;\n    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    _classCallCheck(this, ReplaceAroundStep);\n    _this8 = _super6.call(this);\n    _this8.from = from;\n    _this8.to = to;\n    _this8.gapFrom = gapFrom;\n    _this8.gapTo = gapTo;\n    _this8.slice = slice;\n    _this8.insert = insert;\n    _this8.structure = structure;\n    return _this8;\n  }\n  _createClass(ReplaceAroundStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail(\"Structure gap-replace would overwrite content\");\n      var gap = doc.slice(this.gapFrom, this.gapTo);\n      if (gap.openStart || gap.openEnd) return StepResult.fail(\"Gap is not a flat range\");\n      var inserted = this.slice.insertAt(this.insert, gap.content);\n      if (!inserted) return StepResult.fail(\"Content does not fit in gap\");\n      return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var gap = this.gapTo - this.gapFrom;\n      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n        to = mapping.mapResult(this.to, -1);\n      var gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n      var gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;\n      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        stepType: \"replaceAround\",\n        from: this.from,\n        to: this.to,\n        gapFrom: this.gapFrom,\n        gapTo: this.gapTo,\n        insert: this.insert\n      };\n      if (this.slice.size) json.slice = this.slice.toJSON();\n      if (this.structure) json.structure = true;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n  }]);\n  return ReplaceAroundStep;\n}(Step);\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from),\n    dist = to - from,\n    depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false;\n}\nfunction _addMark(tr, from, to, mark) {\n  var removed = [],\n    added = [];\n  var removing, adding;\n  tr.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) return;\n    var marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from),\n        end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n        }\n      }\n      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));\n    }\n  });\n  removed.forEach(function (s) {\n    return tr.step(s);\n  });\n  added.forEach(function (s) {\n    return tr.step(s);\n  });\n}\nfunction _removeMark(tr, from, to, mark) {\n  var matched = [],\n    step = 0;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) return;\n    step++;\n    var toRemove = null;\n    if (mark instanceof prosemirrorModel.MarkType) {\n      var set = node.marks,\n        found;\n      while (found = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark];\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n          _found = void 0;\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;\n        }\n        if (_found) {\n          _found.to = end;\n          _found.step = step;\n        } else {\n          matched.push({\n            style: style,\n            from: Math.max(pos, from),\n            to: end,\n            step: step\n          });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));\n  });\n}\nfunction _clearIncompatible(tr, pos, parentType) {\n  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;\n  var clearNewlines = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var node = tr.doc.nodeAt(pos);\n  var replSteps = [],\n    cur = pos + 1;\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i),\n      end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type);\n    if (!allowed) {\n      replSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));\n    } else {\n      match = allowed;\n      for (var j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n      if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n        var m = void 0,\n          newline = /\\r?\\n|\\r/g,\n          slice = void 0;\n        while (m = newline.exec(child.text)) {\n          if (!slice) slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n        }\n      }\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);\n    tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));\n  }\n  for (var _i = replSteps.length - 1; _i >= 0; _i--) tr.step(replSteps[_i]);\n}\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth),\n      endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;\n  }\n  return null;\n}\nfunction _lift(tr, range, target) {\n  var $from = range.$from,\n    $to = range.$to,\n    depth = range.depth;\n  var gapStart = $from.before(depth + 1),\n    gapEnd = $to.after(depth + 1);\n  var start = gapStart,\n    end = gapEnd;\n  var before = prosemirrorModel.Fragment.empty,\n    openStart = 0;\n  for (var d = depth, splitting = false; d > target; d--) if (splitting || $from.index(d) > 0) {\n    splitting = true;\n    before = prosemirrorModel.Fragment.from($from.node(d).copy(before));\n    openStart++;\n  } else {\n    start--;\n  }\n  var after = prosemirrorModel.Fragment.empty,\n    openEnd = 0;\n  for (var _d = depth, _splitting = false; _d > target; _d--) if (_splitting || $to.after(_d + 1) < $to.end(_d)) {\n    _splitting = true;\n    after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));\n    openEnd++;\n  } else {\n    end++;\n  }\n  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\nfunction findWrapping(range, nodeType) {\n  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) return null;\n  return around.map(withAttrs).concat({\n    type: nodeType,\n    attrs: attrs\n  }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) {\n  return {\n    type: type,\n    attrs: null\n  };\n}\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent,\n    startIndex = range.startIndex,\n    endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) return null;\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n  var parent = range.parent,\n    startIndex = range.startIndex,\n    endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) return null;\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n  for (var i = startIndex; innerMatch && i < endIndex; i++) innerMatch = innerMatch.matchType(parent.child(i).type);\n  if (!innerMatch || !innerMatch.validEnd) return null;\n  return inside;\n}\nfunction _wrap2(tr, range, wrappers) {\n  var content = prosemirrorModel.Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd) throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n    }\n    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n  var start = range.start,\n    end = range.end;\n  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction _setBlockType(tr, from, to, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  var mapFrom = tr.steps.length;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    var attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n      var convertNewlines = null;\n      if (type.schema.linebreakReplacement) {\n        var pre = type.whitespace == \"pre\",\n          supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n        if (pre && !supportLinebreak) convertNewlines = false;else if (!pre && supportLinebreak) convertNewlines = true;\n      }\n      if (convertNewlines === false) replaceLinebreaks(tr, node, pos, mapFrom);\n      _clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n      var mapping = tr.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1),\n        endM = mapping.map(pos + node.nodeSize, 1);\n      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n      if (convertNewlines === true) replaceNewlines(tr, node, pos, mapFrom);\n      return false;\n    }\n  });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n  node.forEach(function (child, offset) {\n    if (child.isText) {\n      var m,\n        newline = /\\r?\\n|\\r/g;\n      while (m = newline.exec(child.text)) {\n        var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n      }\n    }\n  });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n  node.forEach(function (child, offset) {\n    if (child.type == child.type.schema.linebreakReplacement) {\n      var start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n      tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n    }\n  });\n}\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos),\n    index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n}\nfunction _setNodeMarkup(tr, pos, type, attrs, marks) {\n  var node = tr.doc.nodeAt(pos);\n  if (!node) throw new RangeError(\"No node at given position\");\n  if (!type) type = node.type;\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n  if (!type.validContent(node.content)) throw new RangeError(\"Invalid content for node type \" + type.name);\n  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));\n}\nfunction canSplit(doc, pos) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  var $pos = doc.resolve(pos),\n    base = $pos.depth - depth;\n  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d),\n      _index = $pos.index(d);\n    if (node.type.spec.isolating) return false;\n    var rest = node.content.cutByIndex(_index, node.childCount);\n    var overrideChild = typesAfter && typesAfter[i + 1];\n    if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n    var after = typesAfter && typesAfter[i] || node;\n    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;\n  }\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction _split(tr, pos) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  var $pos = tr.doc.resolve(pos),\n    before = prosemirrorModel.Fragment.empty,\n    after = prosemirrorModel.Fragment.empty;\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));\n}\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos),\n    index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\nfunction canAppendWithSubstitutedLinebreaks(a, b) {\n  if (!b.content.size) a.type.compatibleContent(b.type);\n  var match = a.contentMatchAt(a.childCount);\n  var linebreakReplacement = a.type.schema.linebreakReplacement;\n  for (var i = 0; i < b.childCount; i++) {\n    var child = b.child(i);\n    var type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n    match = match.matchType(type);\n    if (!match) return false;\n    if (!a.type.allowsMarks(child.marks)) return false;\n  }\n  return match.validEnd;\n}\nfunction joinable(a, b) {\n  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n}\nfunction joinPoint(doc, pos) {\n  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var $pos = doc.resolve(pos);\n  for (var d = $pos.depth;; d--) {\n    var before = void 0,\n      after = void 0,\n      index = $pos.index(d);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;\n    if (d == 0) break;\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\nfunction _join(tr, pos, depth) {\n  var convertNewlines = null;\n  var linebreakReplacement = tr.doc.type.schema.linebreakReplacement;\n  var $before = tr.doc.resolve(pos - depth),\n    beforeType = $before.node().type;\n  if (linebreakReplacement && beforeType.inlineContent) {\n    var pre = beforeType.whitespace == \"pre\";\n    var supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n    if (pre && !supportLinebreak) convertNewlines = false;else if (!pre && supportLinebreak) convertNewlines = true;\n  }\n  var mapFrom = tr.steps.length;\n  if (convertNewlines === false) {\n    var $after = tr.doc.resolve(pos + depth);\n    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n  }\n  if (beforeType.inlineContent) _clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n  var mapping = tr.mapping.slice(mapFrom),\n    start = mapping.map(pos - depth);\n  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), prosemirrorModel.Slice.empty, true));\n  if (convertNewlines === true) {\n    var $full = tr.doc.resolve(start);\n    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n  }\n  return tr;\n}\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;\n  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {\n    var index = $pos.index(d);\n    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);\n    if (index > 0) return null;\n  }\n  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {\n    var _index2 = $pos.indexAfter(_d2);\n    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);\n    if (_index2 < $pos.node(_d2).childCount) return null;\n  }\n  return null;\n}\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) return pos;\n  var content = slice.content;\n  for (var i = 0; i < slice.openStart; i++) content = content.firstChild.content;\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d),\n        fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n    }\n  }\n  return null;\n}\nfunction replaceStep(doc, from) {\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;\n  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirrorModel.Slice.empty;\n  if (from == to && !slice.size) return null;\n  var $from = doc.resolve(from),\n    $to = doc.resolve(to);\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);\n  return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\nvar Fitter = function () {\n  function Fitter($from, $to, unplaced) {\n    _classCallCheck(this, Fitter);\n    this.$from = $from;\n    this.$to = $to;\n    this.unplaced = unplaced;\n    this.frontier = [];\n    this.placed = prosemirrorModel.Fragment.empty;\n    for (var i = 0; i <= $from.depth; i++) {\n      var node = $from.node(i);\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      });\n    }\n    for (var _i2 = $from.depth; _i2 > 0; _i2--) this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));\n  }\n  _createClass(Fitter, [{\n    key: \"depth\",\n    get: function get() {\n      return this.frontier.length - 1;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      while (this.unplaced.size) {\n        var fit = this.findFittable();\n        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();\n      }\n      var moveInline = this.mustMoveInline(),\n        placedSize = this.placed.size - this.depth - this.$from.depth;\n      var $from = this.$from,\n        $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n      if (!$to) return null;\n      var content = this.placed,\n        openStart = $from.depth,\n        openEnd = $to.depth;\n      while (openStart && openEnd && content.childCount == 1) {\n        content = content.firstChild.content;\n        openStart--;\n        openEnd--;\n      }\n      var slice = new prosemirrorModel.Slice(content, openStart, openEnd);\n      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n      if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);\n      return null;\n    }\n  }, {\n    key: \"findFittable\",\n    value: function findFittable() {\n      var startDepth = this.unplaced.openStart;\n      for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n        var node = cur.firstChild;\n        if (cur.childCount > 1) openEnd = 0;\n        if (node.type.spec.isolating && openEnd <= d) {\n          startDepth = d;\n          break;\n        }\n        cur = node.content;\n      }\n      for (var pass = 1; pass <= 2; pass++) {\n        for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n          var fragment = void 0,\n            parent = null;\n          if (sliceDepth) {\n            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n            fragment = parent.content;\n          } else {\n            fragment = this.unplaced.content;\n          }\n          var first = fragment.firstChild;\n          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n            var _this$frontier$fronti = this.frontier[frontierDepth],\n              type = _this$frontier$fronti.type,\n              match = _this$frontier$fronti.match,\n              _wrap = void 0,\n              inject = null;\n            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {\n              sliceDepth: sliceDepth,\n              frontierDepth: frontierDepth,\n              parent: parent,\n              inject: inject\n            };else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {\n              sliceDepth: sliceDepth,\n              frontierDepth: frontierDepth,\n              parent: parent,\n              wrap: _wrap\n            };\n            if (parent && match.matchType(parent.type)) break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"openMore\",\n    value: function openMore() {\n      var _this$unplaced = this.unplaced,\n        content = _this$unplaced.content,\n        openStart = _this$unplaced.openStart,\n        openEnd = _this$unplaced.openEnd;\n      var inner = contentAt(content, openStart);\n      if (!inner.childCount || inner.firstChild.isLeaf) return false;\n      this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n      return true;\n    }\n  }, {\n    key: \"dropNode\",\n    value: function dropNode() {\n      var _this$unplaced2 = this.unplaced,\n        content = _this$unplaced2.content,\n        openStart = _this$unplaced2.openStart,\n        openEnd = _this$unplaced2.openEnd;\n      var inner = contentAt(content, openStart);\n      if (inner.childCount <= 1 && openStart > 0) {\n        var openAtEnd = content.size - openStart <= openStart + inner.size;\n        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n      } else {\n        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n      }\n    }\n  }, {\n    key: \"placeNodes\",\n    value: function placeNodes(_ref) {\n      var sliceDepth = _ref.sliceDepth,\n        frontierDepth = _ref.frontierDepth,\n        parent = _ref.parent,\n        inject = _ref.inject,\n        wrap = _ref.wrap;\n      while (this.depth > frontierDepth) this.closeFrontierNode();\n      if (wrap) for (var i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i]);\n      var slice = this.unplaced,\n        fragment = parent ? parent.content : slice.content;\n      var openStart = slice.openStart - sliceDepth;\n      var taken = 0,\n        add = [];\n      var _this$frontier$fronti2 = this.frontier[frontierDepth],\n        match = _this$frontier$fronti2.match,\n        type = _this$frontier$fronti2.type;\n      if (inject) {\n        for (var _i3 = 0; _i3 < inject.childCount; _i3++) add.push(inject.child(_i3));\n        match = match.matchFragment(inject);\n      }\n      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n      while (taken < fragment.childCount) {\n        var next = fragment.child(taken),\n          matches = match.matchType(next.type);\n        if (!matches) break;\n        taken++;\n        if (taken > 1 || openStart == 0 || next.content.size) {\n          match = matches;\n          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n        }\n      }\n      var toEnd = taken == fragment.childCount;\n      if (!toEnd) openEndCount = -1;\n      this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));\n      this.frontier[frontierDepth].match = match;\n      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();\n      for (var _i4 = 0, cur = fragment; _i4 < openEndCount; _i4++) {\n        var node = cur.lastChild;\n        this.frontier.push({\n          type: node.type,\n          match: node.contentMatchAt(node.childCount)\n        });\n        cur = node.content;\n      }\n      this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n  }, {\n    key: \"mustMoveInline\",\n    value: function mustMoveInline() {\n      if (!this.$to.parent.isTextblock) return -1;\n      var top = this.frontier[this.depth],\n        level;\n      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;\n      var depth = this.$to.depth,\n        after = this.$to.after(depth);\n      while (depth > 1 && after == this.$to.end(--depth)) ++after;\n      return after;\n    }\n  }, {\n    key: \"findCloseLevel\",\n    value: function findCloseLevel($to) {\n      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n        var _this$frontier$i = this.frontier[i],\n          match = _this$frontier$i.match,\n          type = _this$frontier$i.type;\n        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        var fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit) continue;\n        for (var d = i - 1; d >= 0; d--) {\n          var _this$frontier$d = this.frontier[d],\n            _match = _this$frontier$d.match,\n            _type = _this$frontier$d.type;\n          var matches = contentAfterFits($to, d, _type, _match, true);\n          if (!matches || matches.childCount) continue scan;\n        }\n        return {\n          depth: i,\n          fit: fit,\n          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n        };\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close($to) {\n      var close = this.findCloseLevel($to);\n      if (!close) return null;\n      while (this.depth > close.depth) this.closeFrontierNode();\n      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);\n      $to = close.move;\n      for (var d = close.depth + 1; d <= $to.depth; d++) {\n        var node = $to.node(d),\n          add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n        this.openFrontierNode(node.type, node.attrs, add);\n      }\n      return $to;\n    }\n  }, {\n    key: \"openFrontierNode\",\n    value: function openFrontierNode(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var top = this.frontier[this.depth];\n      top.match = top.match.matchType(type);\n      this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));\n      this.frontier.push({\n        type: type,\n        match: type.contentMatch\n      });\n    }\n  }, {\n    key: \"closeFrontierNode\",\n    value: function closeFrontierNode() {\n      var open = this.frontier.pop();\n      var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);\n      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n  }]);\n  return Fitter;\n}();\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content);\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) fragment = fragment.firstChild.content;\n  return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node;\n  var frag = node.content;\n  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));\n  }\n  return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth),\n    index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null;\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++) if (!type.allowsMarks(fragment.child(i).marks)) return true;\n  return false;\n}\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent;\n}\nfunction _replaceRange(tr, from, to, slice) {\n  if (!slice.size) return tr.deleteRange(from, to);\n  var $from = tr.doc.resolve(from),\n    $to = tr.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));\n  var targetDepths = coveredDepths($from, tr.doc.resolve(to));\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.definingAsContext || spec.isolating) break;\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);\n  }\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  var leftNodes = [],\n    preferredDepth = slice.openStart;\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) break;\n    content = node.content;\n  }\n  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {\n    var leftNode = leftNodes[_d3],\n      def = definesContent(leftNode.type);\n    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = _d3;else if (def || !leftNode.type.isTextblock) break;\n  }\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) continue;\n    for (var _i5 = 0; _i5 < targetDepths.length; _i5++) {\n      var targetDepth = targetDepths[(_i5 + preferredTargetIndex) % targetDepths.length],\n        expand = true;\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n      var parent = $from.node(targetDepth - 1),\n        index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n    }\n  }\n  var startSteps = tr.steps.length;\n  for (var _i6 = targetDepths.length - 1; _i6 >= 0; _i6--) {\n    tr.replace(from, to, slice);\n    if (tr.steps.length > startSteps) break;\n    var depth = targetDepths[_i6];\n    if (depth < 0) continue;\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));\n  }\n  return fragment;\n}\nfunction _replaceRangeWith(tr, from, to, node) {\n  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(tr.doc, from, node.type);\n    if (point != null) from = to = point;\n  }\n  tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));\n}\nfunction _deleteRange(tr, from, to) {\n  var $from = tr.doc.resolve(from),\n    $to = tr.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i],\n      last = i == covered.length - 1;\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr[\"delete\"]($from.start(depth), $to.end(depth));\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr[\"delete\"]($from.before(depth), $to.after(depth));\n  }\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1))) return tr[\"delete\"]($from.before(d), to);\n  }\n  tr[\"delete\"](from, to);\n}\nfunction coveredDepths($from, $to) {\n  var result = [],\n    minDepth = Math.min($from.depth, $to.depth);\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);\n  }\n  return result;\n}\nvar AttrStep = function (_Step7) {\n  _inherits(AttrStep, _Step7);\n  var _super7 = _createSuper(AttrStep);\n  function AttrStep(pos, attr, value) {\n    var _this9;\n    _classCallCheck(this, AttrStep);\n    _this9 = _super7.call(this);\n    _this9.pos = pos;\n    _this9.attr = attr;\n    _this9.value = value;\n    return _this9;\n  }\n  _createClass(AttrStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at attribute step's position\");\n      var attrs = Object.create(null);\n      for (var name in node.attrs) attrs[name] = node.attrs[name];\n      attrs[this.attr] = this.value;\n      var updated = node.type.create(attrs, null, node.marks);\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"attr\",\n        pos: this.pos,\n        attr: this.attr,\n        value: this.value\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\" || typeof json.attr != \"string\") throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n      return new AttrStep(json.pos, json.attr, json.value);\n    }\n  }]);\n  return AttrStep;\n}(Step);\nStep.jsonID(\"attr\", AttrStep);\nvar DocAttrStep = function (_Step8) {\n  _inherits(DocAttrStep, _Step8);\n  var _super8 = _createSuper(DocAttrStep);\n  function DocAttrStep(attr, value) {\n    var _this10;\n    _classCallCheck(this, DocAttrStep);\n    _this10 = _super8.call(this);\n    _this10.attr = attr;\n    _this10.value = value;\n    return _this10;\n  }\n  _createClass(DocAttrStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var attrs = Object.create(null);\n      for (var name in doc.attrs) attrs[name] = doc.attrs[name];\n      attrs[this.attr] = this.value;\n      var updated = doc.type.create(attrs, doc.content, doc.marks);\n      return StepResult.ok(updated);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      return this;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"docAttr\",\n        attr: this.attr,\n        value: this.value\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.attr != \"string\") throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n      return new DocAttrStep(json.attr, json.value);\n    }\n  }]);\n  return DocAttrStep;\n}(Step);\nStep.jsonID(\"docAttr\", DocAttrStep);\nexports.TransformError = function (_Error) {\n  _inherits(TransformError, _Error);\n  var _super9 = _createSuper(TransformError);\n  function TransformError() {\n    _classCallCheck(this, TransformError);\n    return _super9.apply(this, arguments);\n  }\n  return _createClass(TransformError);\n}(_wrapNativeSuper(Error));\nexports.TransformError = function TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err;\n};\nexports.TransformError.prototype = Object.create(Error.prototype);\nexports.TransformError.prototype.constructor = exports.TransformError;\nexports.TransformError.prototype.name = \"TransformError\";\nvar Transform = function () {\n  function Transform(doc) {\n    _classCallCheck(this, Transform);\n    this.doc = doc;\n    this.steps = [];\n    this.docs = [];\n    this.mapping = new Mapping();\n  }\n  _createClass(Transform, [{\n    key: \"before\",\n    get: function get() {\n      return this.docs.length ? this.docs[0] : this.doc;\n    }\n  }, {\n    key: \"step\",\n    value: function step(_step) {\n      var result = this.maybeStep(_step);\n      if (result.failed) throw new exports.TransformError(result.failed);\n      return this;\n    }\n  }, {\n    key: \"maybeStep\",\n    value: function maybeStep(step) {\n      var result = step.apply(this.doc);\n      if (!result.failed) this.addStep(step, result.doc);\n      return result;\n    }\n  }, {\n    key: \"docChanged\",\n    get: function get() {\n      return this.steps.length > 0;\n    }\n  }, {\n    key: \"addStep\",\n    value: function addStep(step, doc) {\n      this.docs.push(this.doc);\n      this.steps.push(step);\n      this.mapping.appendMap(step.getMap());\n      this.doc = doc;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirrorModel.Slice.empty;\n      var step = replaceStep(this.doc, from, to, slice);\n      if (step) this.step(step);\n      return this;\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(from, to, content) {\n      return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(from, to) {\n      return this.replace(from, to, prosemirrorModel.Slice.empty);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, content) {\n      return this.replaceWith(pos, pos, content);\n    }\n  }, {\n    key: \"replaceRange\",\n    value: function replaceRange(from, to, slice) {\n      _replaceRange(this, from, to, slice);\n      return this;\n    }\n  }, {\n    key: \"replaceRangeWith\",\n    value: function replaceRangeWith(from, to, node) {\n      _replaceRangeWith(this, from, to, node);\n      return this;\n    }\n  }, {\n    key: \"deleteRange\",\n    value: function deleteRange(from, to) {\n      _deleteRange(this, from, to);\n      return this;\n    }\n  }, {\n    key: \"lift\",\n    value: function lift(range, target) {\n      _lift(this, range, target);\n      return this;\n    }\n  }, {\n    key: \"join\",\n    value: function join(pos) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      _join(this, pos, depth);\n      return this;\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(range, wrappers) {\n      _wrap2(this, range, wrappers);\n      return this;\n    }\n  }, {\n    key: \"setBlockType\",\n    value: function setBlockType(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      var type = arguments.length > 2 ? arguments[2] : undefined;\n      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      _setBlockType(this, from, to, type, attrs);\n      return this;\n    }\n  }, {\n    key: \"setNodeMarkup\",\n    value: function setNodeMarkup(pos, type) {\n      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var marks = arguments.length > 3 ? arguments[3] : undefined;\n      _setNodeMarkup(this, pos, type, attrs, marks);\n      return this;\n    }\n  }, {\n    key: \"setNodeAttribute\",\n    value: function setNodeAttribute(pos, attr, value) {\n      this.step(new AttrStep(pos, attr, value));\n      return this;\n    }\n  }, {\n    key: \"setDocAttribute\",\n    value: function setDocAttribute(attr, value) {\n      this.step(new DocAttrStep(attr, value));\n      return this;\n    }\n  }, {\n    key: \"addNodeMark\",\n    value: function addNodeMark(pos, mark) {\n      this.step(new AddNodeMarkStep(pos, mark));\n      return this;\n    }\n  }, {\n    key: \"removeNodeMark\",\n    value: function removeNodeMark(pos, mark) {\n      if (!(mark instanceof prosemirrorModel.Mark)) {\n        var node = this.doc.nodeAt(pos);\n        if (!node) throw new RangeError(\"No node at position \" + pos);\n        mark = mark.isInSet(node.marks);\n        if (!mark) return this;\n      }\n      this.step(new RemoveNodeMarkStep(pos, mark));\n      return this;\n    }\n  }, {\n    key: \"split\",\n    value: function split(pos) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;\n      _split(this, pos, depth, typesAfter);\n      return this;\n    }\n  }, {\n    key: \"addMark\",\n    value: function addMark(from, to, mark) {\n      _addMark(this, from, to, mark);\n      return this;\n    }\n  }, {\n    key: \"removeMark\",\n    value: function removeMark(from, to, mark) {\n      _removeMark(this, from, to, mark);\n      return this;\n    }\n  }, {\n    key: \"clearIncompatible\",\n    value: function clearIncompatible(pos, parentType, match) {\n      _clearIncompatible(this, pos, parentType, match);\n      return this;\n    }\n  }]);\n  return Transform;\n}();\nexports.AddMarkStep = AddMarkStep;\nexports.AddNodeMarkStep = AddNodeMarkStep;\nexports.AttrStep = AttrStep;\nexports.DocAttrStep = DocAttrStep;\nexports.MapResult = MapResult;\nexports.Mapping = Mapping;\nexports.RemoveMarkStep = RemoveMarkStep;\nexports.RemoveNodeMarkStep = RemoveNodeMarkStep;\nexports.ReplaceAroundStep = ReplaceAroundStep;\nexports.ReplaceStep = ReplaceStep;\nexports.Step = Step;\nexports.StepMap = StepMap;\nexports.StepResult = StepResult;\nexports.Transform = Transform;\nexports.canJoin = canJoin;\nexports.canSplit = canSplit;\nexports.dropPoint = dropPoint;\nexports.findWrapping = findWrapping;\nexports.insertPoint = insertPoint;\nexports.joinPoint = joinPoint;\nexports.liftTarget = liftTarget;\nexports.replaceStep = replaceStep;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDO0FBQ3R0QiwyQ0FBMkMsbUNBQW1DLHlDQUF5QyxPQUFPLHdEQUF3RCxnQkFBZ0IsdUJBQXVCLGtEQUFrRCxrQ0FBa0MsdURBQXVELHNCQUFzQjtBQUM5WCxpQ0FBaUMsTUFBTSxxRUFBcUUsWUFBWTtBQUN4SCwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7QUFDNVksaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTtBQUN6SyxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7QUFDcFgsa0RBQWtELDBFQUEwRSxlQUFlLDRCQUE0QixtRkFBbUY7QUFDMVAsd0NBQXdDLHVCQUF1Qix5RkFBeUY7QUFDeEosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZO0FBQ3hULDhCQUE4Qix1R0FBdUcsbURBQW1EO0FBQ3hMLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGtEQUFrRCwwQ0FBMEM7QUFDNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7QUFDL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHO0FBQ3hRLCtCQUErQix1Q0FBdUM7QUFDdEUscUNBQXFDLGlFQUFpRSxzQ0FBc0MsMEJBQTBCLCtDQUErQywyQ0FBMkMsdUVBQXVFO0FBQ3ZV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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw0Q0FBNEM7QUFDNUMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsWUFBWTtBQUNaLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHBcXE9uZURyaXZlXFxEZXNrdG9wXFxOQVJSQVRJVkUgTkVYVVNcXGFpLWdlbmVyYXRvclxcbm9kZV9tb2R1bGVzXFxwcm9zZW1pcnJvci10cmFuc2Zvcm1cXGRpc3RcXGluZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgdHJ5IHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7IH0gfVxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIHByb3NlbWlycm9yTW9kZWwgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1tb2RlbCcpO1xudmFyIGxvd2VyMTYgPSAweGZmZmY7XG52YXIgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7XG4gIHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2O1xufVxuZnVuY3Rpb24gcmVjb3ZlckluZGV4KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmIGxvd2VyMTY7XG59XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjtcbn1cbnZhciBERUxfQkVGT1JFID0gMSxcbiAgREVMX0FGVEVSID0gMixcbiAgREVMX0FDUk9TUyA9IDQsXG4gIERFTF9TSURFID0gODtcbnZhciBNYXBSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcFJlc3VsdChwb3MsIGRlbEluZm8sIHJlY292ZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwUmVzdWx0KTtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgIHRoaXMucmVjb3ZlciA9IHJlY292ZXI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE1hcFJlc3VsdCwgW3tcbiAgICBrZXk6IFwiZGVsZXRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVkQmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQkVGT1JFIHwgREVMX0FDUk9TUykpID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlZEFmdGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQUZURVIgfCBERUxfQUNST1NTKSkgPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVkQWNyb3NzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9BQ1JPU1MpID4gMDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hcFJlc3VsdDtcbn0oKTtcbnZhciBTdGVwTWFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGVwTWFwKHJhbmdlcykge1xuICAgIHZhciBpbnZlcnRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZXBNYXApO1xuICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSkgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFN0ZXBNYXAsIFt7XG4gICAga2V5OiBcInJlY292ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3Zlcih2YWx1ZSkge1xuICAgICAgdmFyIGRpZmYgPSAwLFxuICAgICAgICBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICBpZiAoIXRoaXMuaW52ZXJ0ZWQpIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpbmRleCAqIDNdICsgZGlmZiArIHJlY292ZXJPZmZzZXQodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBSZXN1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwUmVzdWx0KHBvcykge1xuICAgICAgdmFyIGFzc29jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAocG9zKSB7XG4gICAgICB2YXIgYXNzb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICB2YXIgZGlmZiA9IDAsXG4gICAgICAgIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLFxuICAgICAgICBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKSBicmVhaztcbiAgICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLFxuICAgICAgICAgIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdLFxuICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICB2YXIgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICBpZiAoc2ltcGxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHZhciByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKSBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvdWNoZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgIHZhciBkaWZmID0gMCxcbiAgICAgICAgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsXG4gICAgICAgIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICBpZiAoc3RhcnQgPiBwb3MpIGJyZWFrO1xuICAgICAgICB2YXIgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sXG4gICAgICAgICAgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICBpZiAocG9zIDw9IGVuZCAmJiBpID09IGluZGV4ICogMykgcmV0dXJuIHRydWU7XG4gICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSAtIG9sZFNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvckVhY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaChmKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsXG4gICAgICAgIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0sXG4gICAgICAgICAgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLFxuICAgICAgICAgIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLFxuICAgICAgICAgIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKHRoaXMucmFuZ2VzLCAhdGhpcy5pbnZlcnRlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJvZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2Zmc2V0KG4pIHtcbiAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0ZXBNYXA7XG59KCk7XG5TdGVwTWFwLmVtcHR5ID0gbmV3IFN0ZXBNYXAoW10pO1xudmFyIE1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gICAgdmFyIG1hcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgIHZhciBtaXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG1hcHMubGVuZ3RoO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXBwaW5nKTtcbiAgICB0aGlzLm1hcHMgPSBtYXBzO1xuICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy50byA9IHRvO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhNYXBwaW5nLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZSgpIHtcbiAgICAgIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLm1hcHMubGVuZ3RoO1xuICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgdGhpcy50byA9IHRoaXMubWFwcy5wdXNoKG1hcCk7XG4gICAgICBpZiAobWlycm9ycyAhPSBudWxsKSB0aGlzLnNldE1pcnJvcih0aGlzLm1hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZE1hcHBpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgc3RhcnRTaXplID0gdGhpcy5tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcubWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWlycm9yKG4pIHtcbiAgICAgIGlmICh0aGlzLm1pcnJvcikgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1pcnJvci5sZW5ndGg7IGkrKykgaWYgKHRoaXMubWlycm9yW2ldID09IG4pIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1pcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNaXJyb3IobiwgbSkge1xuICAgICAgaWYgKCF0aGlzLm1pcnJvcikgdGhpcy5taXJyb3IgPSBbXTtcbiAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZE1hcHBpbmdJbnZlcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgZm9yICh2YXIgaSA9IG1hcHBpbmcubWFwcy5sZW5ndGggLSAxLCB0b3RhbFNpemUgPSB0aGlzLm1hcHMubGVuZ3RoICsgbWFwcGluZy5tYXBzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICB2YXIgaW52ZXJzZSA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKHBvcykge1xuICAgICAgdmFyIGFzc29jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgaWYgKHRoaXMubWlycm9yKSByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykgcG9zID0gdGhpcy5tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFJlc3VsdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXBSZXN1bHQocG9zKSB7XG4gICAgICB2YXIgYXNzb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX21hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgdmFyIGRlbEluZm8gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXBzW2ldLFxuICAgICAgICAgIHJlc3VsdCA9IG1hcC5tYXBSZXN1bHQocG9zLCBhc3NvYyk7XG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcbiAgICAgICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICBpID0gY29ycjtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxJbmZvIHw9IHJlc3VsdC5kZWxJbmZvO1xuICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hcHBpbmc7XG59KCk7XG52YXIgc3RlcHNCeUlEID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBTdGVwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGVwKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVwKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoU3RlcCwgW3tcbiAgICBrZXk6IFwiZ2V0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcCgpIHtcbiAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShvdGhlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHZhciB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHN0ZXAgdHlwZSBcIi5jb25jYXQoanNvbi5zdGVwVHlwZSwgXCIgZGVmaW5lZFwiKSk7XG4gICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqc29uSURcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ganNvbklEKGlkLCBzdGVwQ2xhc3MpIHtcbiAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzdGVwIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgIHJldHVybiBzdGVwQ2xhc3M7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdGVwO1xufSgpO1xudmFyIFN0ZXBSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0ZXBSZXN1bHQoZG9jLCBmYWlsZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcFJlc3VsdCk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFN0ZXBSZXN1bHQsIG51bGwsIFt7XG4gICAga2V5OiBcIm9rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9rKGRvYykge1xuICAgICAgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZhaWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21SZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21SZXBsYWNlKGRvYywgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayhkb2MucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBwcm9zZW1pcnJvck1vZGVsLlJlcGxhY2VFcnJvcikgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChlLm1lc3NhZ2UpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RlcFJlc3VsdDtcbn0oKTtcbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgdmFyIG1hcHBlZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpIGNoaWxkID0gY2hpbGQuY29weShtYXBGcmFnbWVudChjaGlsZC5jb250ZW50LCBmLCBjaGlsZCkpO1xuICAgIGlmIChjaGlsZC5pc0lubGluZSkgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgIG1hcHBlZC5wdXNoKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbnZhciBBZGRNYXJrU3RlcCA9IGZ1bmN0aW9uIChfU3RlcCkge1xuICBfaW5oZXJpdHMoQWRkTWFya1N0ZXAsIF9TdGVwKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihBZGRNYXJrU3RlcCk7XG4gIGZ1bmN0aW9uIEFkZE1hcmtTdGVwKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZGRNYXJrU3RlcCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5mcm9tID0gZnJvbTtcbiAgICBfdGhpcy50byA9IHRvO1xuICAgIF90aGlzLm1hcmsgPSBtYXJrO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQWRkTWFya1N0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSxcbiAgICAgICAgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgdmFyIHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgdmFyIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShfdGhpczIubWFyay50eXBlKSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlLm1hcmsoX3RoaXMyLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgfSwgcGFyZW50KSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nKSB7XG4gICAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksXG4gICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lcmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lcmdlKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJiBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiYgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSkgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0ZXBUeXBlOiBcImFkZE1hcmtcIixcbiAgICAgICAgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBZGRNYXJrU3RlcDtcbn0oU3RlcCk7XG5TdGVwLmpzb25JRChcImFkZE1hcmtcIiwgQWRkTWFya1N0ZXApO1xudmFyIFJlbW92ZU1hcmtTdGVwID0gZnVuY3Rpb24gKF9TdGVwMikge1xuICBfaW5oZXJpdHMoUmVtb3ZlTWFya1N0ZXAsIF9TdGVwMik7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFJlbW92ZU1hcmtTdGVwKTtcbiAgZnVuY3Rpb24gUmVtb3ZlTWFya1N0ZXAoZnJvbSwgdG8sIG1hcmspIHtcbiAgICB2YXIgX3RoaXMzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW1vdmVNYXJrU3RlcCk7XG4gICAgX3RoaXMzID0gX3N1cGVyMi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMy5mcm9tID0gZnJvbTtcbiAgICBfdGhpczMudG8gPSB0bztcbiAgICBfdGhpczMubWFyayA9IG1hcms7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUmVtb3ZlTWFya1N0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgIHZhciBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm1hcmsoX3RoaXM0Lm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHZhciBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSxcbiAgICAgICAgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwICYmIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJiB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKSByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RlcFR5cGU6IFwicmVtb3ZlTWFya1wiLFxuICAgICAgICBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgdG86IHRoaXMudG9cbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlbW92ZU1hcmtTdGVwO1xufShTdGVwKTtcblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG52YXIgQWRkTm9kZU1hcmtTdGVwID0gZnVuY3Rpb24gKF9TdGVwMykge1xuICBfaW5oZXJpdHMoQWRkTm9kZU1hcmtTdGVwLCBfU3RlcDMpO1xuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihBZGROb2RlTWFya1N0ZXApO1xuICBmdW5jdGlvbiBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSB7XG4gICAgdmFyIF90aGlzNTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWRkTm9kZU1hcmtTdGVwKTtcbiAgICBfdGhpczUgPSBfc3VwZXIzLmNhbGwodGhpcyk7XG4gICAgX3RoaXM1LnBvcyA9IHBvcztcbiAgICBfdGhpczUubWFyayA9IG1hcms7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQWRkTm9kZU1hcmtTdGVwLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShkb2MpIHtcbiAgICAgIHZhciBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoIW5vZGUpIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgdmFyIHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KGRvYykge1xuICAgICAgdmFyIG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHZhciBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgIGlmIChuZXdTZXQubGVuZ3RoID09IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKSBpZiAoIW5vZGUubWFya3NbaV0uaXNJblNldChuZXdTZXQpKSByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHZhciBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLFxuICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICBtYXJrOiB0aGlzLm1hcmsudG9KU09OKClcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBZGROb2RlTWFya1N0ZXA7XG59KFN0ZXApO1xuU3RlcC5qc29uSUQoXCJhZGROb2RlTWFya1wiLCBBZGROb2RlTWFya1N0ZXApO1xudmFyIFJlbW92ZU5vZGVNYXJrU3RlcCA9IGZ1bmN0aW9uIChfU3RlcDQpIHtcbiAgX2luaGVyaXRzKFJlbW92ZU5vZGVNYXJrU3RlcCwgX1N0ZXA0KTtcbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoUmVtb3ZlTm9kZU1hcmtTdGVwKTtcbiAgZnVuY3Rpb24gUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgbWFyaykge1xuICAgIHZhciBfdGhpczY7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbW92ZU5vZGVNYXJrU3RlcCk7XG4gICAgX3RoaXM2ID0gX3N1cGVyNC5jYWxsKHRoaXMpO1xuICAgIF90aGlzNi5wb3MgPSBwb3M7XG4gICAgX3RoaXM2Lm1hcmsgPSBtYXJrO1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFJlbW92ZU5vZGVNYXJrU3RlcCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoZG9jKSB7XG4gICAgICB2YXIgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgaWYgKCFub2RlKSByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgIHZhciB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KGRvYykge1xuICAgICAgdmFyIG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5tYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsXG4gICAgICAgIHBvczogdGhpcy5wb3MsXG4gICAgICAgIG1hcms6IHRoaXMubWFyay50b0pTT04oKVxuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlbW92ZU5vZGVNYXJrU3RlcDtcbn0oU3RlcCk7XG5TdGVwLmpzb25JRChcInJlbW92ZU5vZGVNYXJrXCIsIFJlbW92ZU5vZGVNYXJrU3RlcCk7XG52YXIgUmVwbGFjZVN0ZXAgPSBmdW5jdGlvbiAoX1N0ZXA1KSB7XG4gIF9pbmhlcml0cyhSZXBsYWNlU3RlcCwgX1N0ZXA1KTtcbiAgdmFyIF9zdXBlcjUgPSBfY3JlYXRlU3VwZXIoUmVwbGFjZVN0ZXApO1xuICBmdW5jdGlvbiBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpIHtcbiAgICB2YXIgX3RoaXM3O1xuICAgIHZhciBzdHJ1Y3R1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXBsYWNlU3RlcCk7XG4gICAgX3RoaXM3ID0gX3N1cGVyNS5jYWxsKHRoaXMpO1xuICAgIF90aGlzNy5mcm9tID0gZnJvbTtcbiAgICBfdGhpczcudG8gPSB0bztcbiAgICBfdGhpczcuc2xpY2UgPSBzbGljZTtcbiAgICBfdGhpczcuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIHJldHVybiBfdGhpczc7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFJlcGxhY2VTdGVwLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShkb2MpIHtcbiAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy50bykpIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcCgpIHtcbiAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydChkb2MpIHtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nKSB7XG4gICAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksXG4gICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2Uob3RoZXIpIHtcbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIHZhciBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkgOiBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZSh0aGlzLnNsaWNlLmNvbnRlbnQuYXBwZW5kKG90aGVyLnNsaWNlLmNvbnRlbnQpLCB0aGlzLnNsaWNlLm9wZW5TdGFydCwgb3RoZXIuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyLnRvID09IHRoaXMuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuU3RhcnQgJiYgIW90aGVyLnNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgdmFyIF9zbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkgOiBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgX3NsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBqc29uID0ge1xuICAgICAgICBzdGVwVHlwZTogXCJyZXBsYWNlXCIsXG4gICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgdG86IHRoaXMudG9cbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zbGljZS5zaXplKSBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSkganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZVN0ZXAuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlcGxhY2VTdGVwO1xufShTdGVwKTtcblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG52YXIgUmVwbGFjZUFyb3VuZFN0ZXAgPSBmdW5jdGlvbiAoX1N0ZXA2KSB7XG4gIF9pbmhlcml0cyhSZXBsYWNlQXJvdW5kU3RlcCwgX1N0ZXA2KTtcbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoUmVwbGFjZUFyb3VuZFN0ZXApO1xuICBmdW5jdGlvbiBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLCB0bywgZ2FwRnJvbSwgZ2FwVG8sIHNsaWNlLCBpbnNlcnQpIHtcbiAgICB2YXIgX3RoaXM4O1xuICAgIHZhciBzdHJ1Y3R1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IGZhbHNlO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG4gICAgX3RoaXM4ID0gX3N1cGVyNi5jYWxsKHRoaXMpO1xuICAgIF90aGlzOC5mcm9tID0gZnJvbTtcbiAgICBfdGhpczgudG8gPSB0bztcbiAgICBfdGhpczguZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgX3RoaXM4LmdhcFRvID0gZ2FwVG87XG4gICAgX3RoaXM4LnNsaWNlID0gc2xpY2U7XG4gICAgX3RoaXM4Lmluc2VydCA9IGluc2VydDtcbiAgICBfdGhpczguc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIHJldHVybiBfdGhpczg7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFJlcGxhY2VBcm91bmRTdGVwLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShkb2MpIHtcbiAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHwgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmdhcFRvLCB0aGlzLnRvKSkpIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICB2YXIgZ2FwID0gZG9jLnNsaWNlKHRoaXMuZ2FwRnJvbSwgdGhpcy5nYXBUbyk7XG4gICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZCkgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkdhcCBpcyBub3QgYSBmbGF0IHJhbmdlXCIpO1xuICAgICAgdmFyIGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgaWYgKCFpbnNlcnRlZCkgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCwgdGhpcy5nYXBUbywgdGhpcy50byAtIHRoaXMuZ2FwVG8sIHRoaXMuc2xpY2Uuc2l6ZSAtIHRoaXMuaW5zZXJ0XSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoZG9jKSB7XG4gICAgICB2YXIgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgKyBnYXAsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0LCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCArIGdhcCwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykucmVtb3ZlQmV0d2Vlbih0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuZ2FwVG8gLSB0aGlzLmZyb20pLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hcChtYXBwaW5nKSB7XG4gICAgICB2YXIgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksXG4gICAgICAgIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgdmFyIGdhcEZyb20gPSB0aGlzLmZyb20gPT0gdGhpcy5nYXBGcm9tID8gZnJvbS5wb3MgOiBtYXBwaW5nLm1hcCh0aGlzLmdhcEZyb20sIC0xKTtcbiAgICAgIHZhciBnYXBUbyA9IHRoaXMudG8gPT0gdGhpcy5nYXBUbyA/IHRvLnBvcyA6IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgIHN0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIixcbiAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLFxuICAgICAgICBnYXBUbzogdGhpcy5nYXBUbyxcbiAgICAgICAgaW5zZXJ0OiB0aGlzLmluc2VydFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKSBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBqc29uLmdhcEZyb20sIGpzb24uZ2FwVG8sIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVwbGFjZUFyb3VuZFN0ZXA7XG59KFN0ZXApO1xuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgdmFyICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksXG4gICAgZGlzdCA9IHRvIC0gZnJvbSxcbiAgICBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICBkZXB0aC0tO1xuICAgIGRpc3QtLTtcbiAgfVxuICBpZiAoZGlzdCA+IDApIHtcbiAgICB2YXIgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKSByZXR1cm4gdHJ1ZTtcbiAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICBkaXN0LS07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9hZGRNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICB2YXIgcmVtb3ZlZCA9IFtdLFxuICAgIGFkZGVkID0gW107XG4gIHZhciByZW1vdmluZywgYWRkaW5nO1xuICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zLCBwYXJlbnQpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUpIHJldHVybjtcbiAgICB2YXIgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLFxuICAgICAgICBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICB2YXIgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghbWFya3NbaV0uaXNJblNldChuZXdTZXQpKSB7XG4gICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKSByZW1vdmluZy50byA9IGVuZDtlbHNlIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydCkgYWRkaW5nLnRvID0gZW5kO2Vsc2UgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgIH1cbiAgfSk7XG4gIHJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0ci5zdGVwKHMpO1xuICB9KTtcbiAgYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB0ci5zdGVwKHMpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICB2YXIgbWF0Y2hlZCA9IFtdLFxuICAgIHN0ZXAgPSAwO1xuICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgaWYgKCFub2RlLmlzSW5saW5lKSByZXR1cm47XG4gICAgc3RlcCsrO1xuICAgIHZhciB0b1JlbW92ZSA9IG51bGw7XG4gICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBwcm9zZW1pcnJvck1vZGVsLk1hcmtUeXBlKSB7XG4gICAgICB2YXIgc2V0ID0gbm9kZS5tYXJrcyxcbiAgICAgICAgZm91bmQ7XG4gICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAodG9SZW1vdmUgfHwgKHRvUmVtb3ZlID0gW10pKS5wdXNoKGZvdW5kKTtcbiAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWFyaykge1xuICAgICAgaWYgKG1hcmsuaXNJblNldChub2RlLm1hcmtzKSkgdG9SZW1vdmUgPSBbbWFya107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUmVtb3ZlID0gbm9kZS5tYXJrcztcbiAgICB9XG4gICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdG9SZW1vdmVbaV0sXG4gICAgICAgICAgX2ZvdW5kID0gdm9pZCAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSkgX2ZvdW5kID0gbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZvdW5kKSB7XG4gICAgICAgICAgX2ZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgIF9mb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaGVkLnB1c2goe1xuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSxcbiAgICAgICAgICAgIHRvOiBlbmQsXG4gICAgICAgICAgICBzdGVwOiBzdGVwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBtYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gX2NsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUpIHtcbiAgdmFyIG1hdGNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBwYXJlbnRUeXBlLmNvbnRlbnRNYXRjaDtcbiAgdmFyIGNsZWFyTmV3bGluZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICB2YXIgcmVwbFN0ZXBzID0gW10sXG4gICAgY3VyID0gcG9zICsgMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQoaSksXG4gICAgICBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICB2YXIgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlKTtcbiAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9IGFsbG93ZWQ7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkLm1hcmtzLmxlbmd0aDsgaisrKSBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgaWYgKGNsZWFyTmV3bGluZXMgJiYgY2hpbGQuaXNUZXh0ICYmIHBhcmVudFR5cGUud2hpdGVzcGFjZSAhPSBcInByZVwiKSB7XG4gICAgICAgIHZhciBtID0gdm9pZCAwLFxuICAgICAgICAgIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZyxcbiAgICAgICAgICBzbGljZSA9IHZvaWQgMDtcbiAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICBpZiAoIXNsaWNlKSBzbGljZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShwYXJlbnRUeXBlLnNjaGVtYS50ZXh0KFwiIFwiLCBwYXJlbnRUeXBlLmFsbG93ZWRNYXJrcyhjaGlsZC5tYXJrcykpKSwgMCwgMCk7XG4gICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciArIG0uaW5kZXgsIGN1ciArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCwgc2xpY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjdXIgPSBlbmQ7XG4gIH1cbiAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgIHZhciBmaWxsID0gbWF0Y2guZmlsbEJlZm9yZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShmaWxsLCAwLCAwKSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSByZXBsU3RlcHMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkgdHIuc3RlcChyZXBsU3RlcHNbX2ldKTtcbn1cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgdmFyIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcbiAgZm9yICh2YXIgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIHZhciBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSxcbiAgICAgIGVuZEluZGV4ID0gcmFuZ2UuJHRvLmluZGV4QWZ0ZXIoZGVwdGgpO1xuICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKSByZXR1cm4gZGVwdGg7XG4gICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICB2YXIgJGZyb20gPSByYW5nZS4kZnJvbSxcbiAgICAkdG8gPSByYW5nZS4kdG8sXG4gICAgZGVwdGggPSByYW5nZS5kZXB0aDtcbiAgdmFyIGdhcFN0YXJ0ID0gJGZyb20uYmVmb3JlKGRlcHRoICsgMSksXG4gICAgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gIHZhciBzdGFydCA9IGdhcFN0YXJ0LFxuICAgIGVuZCA9IGdhcEVuZDtcbiAgdmFyIGJlZm9yZSA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksXG4gICAgb3BlblN0YXJ0ID0gMDtcbiAgZm9yICh2YXIgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKSBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgYmVmb3JlID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICBvcGVuU3RhcnQrKztcbiAgfSBlbHNlIHtcbiAgICBzdGFydC0tO1xuICB9XG4gIHZhciBhZnRlciA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksXG4gICAgb3BlbkVuZCA9IDA7XG4gIGZvciAodmFyIF9kID0gZGVwdGgsIF9zcGxpdHRpbmcgPSBmYWxzZTsgX2QgPiB0YXJnZXQ7IF9kLS0pIGlmIChfc3BsaXR0aW5nIHx8ICR0by5hZnRlcihfZCArIDEpIDwgJHRvLmVuZChfZCkpIHtcbiAgICBfc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICBhZnRlciA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShfZCkuY29weShhZnRlcikpO1xuICAgIG9wZW5FbmQrKztcbiAgfSBlbHNlIHtcbiAgICBlbmQrKztcbiAgfVxuICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBnYXBTdGFydCwgZ2FwRW5kLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICB2YXIgaW5uZXJSYW5nZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogcmFuZ2U7XG4gIHZhciBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gIHZhciBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICBpZiAoIWlubmVyKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGFyb3VuZC5tYXAod2l0aEF0dHJzKS5jb25jYXQoe1xuICAgIHR5cGU6IG5vZGVUeXBlLFxuICAgIGF0dHJzOiBhdHRyc1xuICB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGF0dHJzOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQsXG4gICAgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXgsXG4gICAgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgdmFyIGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gIGlmICghYXJvdW5kKSByZXR1cm4gbnVsbDtcbiAgdmFyIG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdJbnNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCxcbiAgICBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCxcbiAgICBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICB2YXIgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gIHZhciBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gIGlmICghaW5zaWRlKSByZXR1cm4gbnVsbDtcbiAgdmFyIGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICB2YXIgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBpbnNpZGU7XG59XG5mdW5jdGlvbiBfd3JhcDIodHIsIHJhbmdlLCB3cmFwcGVycykge1xuICB2YXIgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG4gIGZvciAodmFyIGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHdyYXBwZXJzW2ldLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaC52YWxpZEVuZCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXcmFwcGVyIHR5cGUgZ2l2ZW4gdG8gVHJhbnNmb3JtLndyYXAgZG9lcyBub3QgZm9ybSB2YWxpZCBjb250ZW50IG9mIGl0cyBwYXJlbnQgd3JhcHBlclwiKTtcbiAgICB9XG4gICAgY29udGVudCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICB9XG4gIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LFxuICAgIGVuZCA9IHJhbmdlLmVuZDtcbiAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgc3RhcnQsIGVuZCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gX3NldEJsb2NrVHlwZSh0ciwgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG4gIGlmICghdHlwZS5pc1RleHRibG9jaykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gIHZhciBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgdmFyIGF0dHJzSGVyZSA9IHR5cGVvZiBhdHRycyA9PSBcImZ1bmN0aW9uXCIgPyBhdHRycyhub2RlKSA6IGF0dHJzO1xuICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRyc0hlcmUpICYmIGNhbkNoYW5nZVR5cGUodHIuZG9jLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MpLCB0eXBlKSkge1xuICAgICAgdmFyIGNvbnZlcnROZXdsaW5lcyA9IG51bGw7XG4gICAgICBpZiAodHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIHByZSA9IHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiLFxuICAgICAgICAgIHN1cHBvcnRMaW5lYnJlYWsgPSAhIXR5cGUuY29udGVudE1hdGNoLm1hdGNoVHlwZSh0eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCk7XG4gICAgICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspIGNvbnZlcnROZXdsaW5lcyA9IGZhbHNlO2Vsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaykgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IGZhbHNlKSByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgIF9jbGVhckluY29tcGF0aWJsZSh0ciwgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zLCAxKSwgdHlwZSwgdW5kZWZpbmVkLCBjb252ZXJ0TmV3bGluZXMgPT09IG51bGwpO1xuICAgICAgdmFyIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgdmFyIHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksXG4gICAgICAgIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRyc0hlcmUsIG51bGwsIG5vZGUubWFya3MpKSwgMCwgMCksIDEsIHRydWUpKTtcbiAgICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IHRydWUpIHJlcGxhY2VOZXdsaW5lcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0KSB7XG4gICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgdmFyIG0sXG4gICAgICAgIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZztcbiAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIDEgKyBvZmZzZXQgKyBtLmluZGV4KTtcbiAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQsIHN0YXJ0ICsgMSwgbm9kZS50eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudC5jcmVhdGUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgbm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgb2Zmc2V0KSB7XG4gICAgaWYgKGNoaWxkLnR5cGUgPT0gY2hpbGQudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIDEgKyBvZmZzZXQpO1xuICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQsIHN0YXJ0ICsgMSwgbm9kZS50eXBlLnNjaGVtYS50ZXh0KFwiXFxuXCIpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICB2YXIgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksXG4gICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIF9zZXROb2RlTWFya3VwKHRyLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICB2YXIgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgaWYgKCFub2RlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIik7XG4gIGlmICghdHlwZSkgdHlwZSA9IG5vZGUudHlwZTtcbiAgdmFyIG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gIGlmIChub2RlLmlzTGVhZikgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSk7XG4gIGlmICghdHlwZS52YWxpZENvbnRlbnQobm9kZS5jb250ZW50KSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKTtcbn1cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zKSB7XG4gIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgdmFyIHR5cGVzQWZ0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLFxuICAgIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gIHZhciBpbm5lclR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbdHlwZXNBZnRlci5sZW5ndGggLSAxXSB8fCAkcG9zLnBhcmVudDtcbiAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fCAhaW5uZXJUeXBlLnR5cGUudmFsaWRDb250ZW50KCRwb3MucGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleCgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgIHZhciBub2RlID0gJHBvcy5ub2RlKGQpLFxuICAgICAgX2luZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChfaW5kZXgsIG5vZGUuY2hpbGRDb3VudCk7XG4gICAgdmFyIG92ZXJyaWRlQ2hpbGQgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaSArIDFdO1xuICAgIGlmIChvdmVycmlkZUNoaWxkKSByZXN0ID0gcmVzdC5yZXBsYWNlQ2hpbGQoMCwgb3ZlcnJpZGVDaGlsZC50eXBlLmNyZWF0ZShvdmVycmlkZUNoaWxkLmF0dHJzKSk7XG4gICAgdmFyIGFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldIHx8IG5vZGU7XG4gICAgaWYgKCFub2RlLmNhblJlcGxhY2UoX2luZGV4ICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gIHZhciBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgcmV0dXJuICRwb3Mubm9kZShiYXNlKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGJhc2VUeXBlID8gYmFzZVR5cGUudHlwZSA6ICRwb3Mubm9kZShiYXNlICsgMSkudHlwZSk7XG59XG5mdW5jdGlvbiBfc3BsaXQodHIsIHBvcykge1xuICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHZhciB0eXBlc0FmdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gIHZhciAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKSxcbiAgICBiZWZvcmUgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LFxuICAgIGFmdGVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgIGJlZm9yZSA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbSgkcG9zLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICB2YXIgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgIGFmdGVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHR5cGVBZnRlciA/IHR5cGVBZnRlci50eXBlLmNyZWF0ZSh0eXBlQWZ0ZXIuYXR0cnMsIGFmdGVyKSA6ICRwb3Mubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gIH1cbiAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKSxcbiAgICBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzKGEsIGIpIHtcbiAgaWYgKCFiLmNvbnRlbnQuc2l6ZSkgYS50eXBlLmNvbXBhdGlibGVDb250ZW50KGIudHlwZSk7XG4gIHZhciBtYXRjaCA9IGEuY29udGVudE1hdGNoQXQoYS5jaGlsZENvdW50KTtcbiAgdmFyIGxpbmVicmVha1JlcGxhY2VtZW50ID0gYS50eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmNoaWxkQ291bnQ7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGIuY2hpbGQoaSk7XG4gICAgdmFyIHR5cGUgPSBjaGlsZC50eXBlID09IGxpbmVicmVha1JlcGxhY2VtZW50ID8gYS50eXBlLnNjaGVtYS5ub2Rlcy50ZXh0IDogY2hpbGQudHlwZTtcbiAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFhLnR5cGUuYWxsb3dzTWFya3MoY2hpbGQubWFya3MpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG1hdGNoLnZhbGlkRW5kO1xufVxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzKGEsIGIpKTtcbn1cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcykge1xuICB2YXIgZGlyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAtMTtcbiAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgIHZhciBiZWZvcmUgPSB2b2lkIDAsXG4gICAgICBhZnRlciA9IHZvaWQgMCxcbiAgICAgIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICBpZiAoZCA9PSAkcG9zLmRlcHRoKSB7XG4gICAgICBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmU7XG4gICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgIH0gZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgIGluZGV4Kys7XG4gICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICB9XG4gICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKSByZXR1cm4gcG9zO1xuICAgIGlmIChkID09IDApIGJyZWFrO1xuICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9qb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gIHZhciBjb252ZXJ0TmV3bGluZXMgPSBudWxsO1xuICB2YXIgbGluZWJyZWFrUmVwbGFjZW1lbnQgPSB0ci5kb2MudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQ7XG4gIHZhciAkYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocG9zIC0gZGVwdGgpLFxuICAgIGJlZm9yZVR5cGUgPSAkYmVmb3JlLm5vZGUoKS50eXBlO1xuICBpZiAobGluZWJyZWFrUmVwbGFjZW1lbnQgJiYgYmVmb3JlVHlwZS5pbmxpbmVDb250ZW50KSB7XG4gICAgdmFyIHByZSA9IGJlZm9yZVR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiO1xuICAgIHZhciBzdXBwb3J0TGluZWJyZWFrID0gISFiZWZvcmVUeXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobGluZWJyZWFrUmVwbGFjZW1lbnQpO1xuICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspIGNvbnZlcnROZXdsaW5lcyA9IGZhbHNlO2Vsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaykgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgfVxuICB2YXIgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gZmFsc2UpIHtcbiAgICB2YXIgJGFmdGVyID0gdHIuZG9jLnJlc29sdmUocG9zICsgZGVwdGgpO1xuICAgIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCAkYWZ0ZXIubm9kZSgpLCAkYWZ0ZXIuYmVmb3JlKCksIG1hcEZyb20pO1xuICB9XG4gIGlmIChiZWZvcmVUeXBlLmlubGluZUNvbnRlbnQpIF9jbGVhckluY29tcGF0aWJsZSh0ciwgcG9zICsgZGVwdGggLSAxLCBiZWZvcmVUeXBlLCAkYmVmb3JlLm5vZGUoKS5jb250ZW50TWF0Y2hBdCgkYmVmb3JlLmluZGV4KCkpLCBjb252ZXJ0TmV3bGluZXMgPT0gbnVsbCk7XG4gIHZhciBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKSxcbiAgICBzdGFydCA9IG1hcHBpbmcubWFwKHBvcyAtIGRlcHRoKTtcbiAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoc3RhcnQsIG1hcHBpbmcubWFwKHBvcyArIGRlcHRoLCAtMSksIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHksIHRydWUpKTtcbiAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gdHJ1ZSkge1xuICAgIHZhciAkZnVsbCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0KTtcbiAgICByZXBsYWNlTmV3bGluZXModHIsICRmdWxsLm5vZGUoKSwgJGZ1bGwuYmVmb3JlKCksIHRyLnN0ZXBzLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpIHJldHVybiBwb3M7XG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKSBmb3IgKHZhciBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKSByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgIGlmIChpbmRleCA+IDApIHJldHVybiBudWxsO1xuICB9XG4gIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpIGZvciAodmFyIF9kMiA9ICRwb3MuZGVwdGggLSAxOyBfZDIgPj0gMDsgX2QyLS0pIHtcbiAgICB2YXIgX2luZGV4MiA9ICRwb3MuaW5kZXhBZnRlcihfZDIpO1xuICAgIGlmICgkcG9zLm5vZGUoX2QyKS5jYW5SZXBsYWNlV2l0aChfaW5kZXgyLCBfaW5kZXgyLCBub2RlVHlwZSkpIHJldHVybiAkcG9zLmFmdGVyKF9kMiArIDEpO1xuICAgIGlmIChfaW5kZXgyIDwgJHBvcy5ub2RlKF9kMikuY2hpbGRDb3VudCkgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gIHZhciAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHJldHVybiBwb3M7XG4gIHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKykgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICBmb3IgKHZhciBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICB2YXIgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgIHZhciBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShkKSxcbiAgICAgICAgZml0cyA9IGZhbHNlO1xuICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgfVxuICAgICAgaWYgKGZpdHMpIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tKSB7XG4gIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZnJvbTtcbiAgdmFyIHNsaWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5O1xuICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSkgcmV0dXJuIG51bGw7XG4gIHZhciAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLFxuICAgICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKSByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gIHJldHVybiBuZXcgRml0dGVyKCRmcm9tLCAkdG8sIHNsaWNlKS5maXQoKTtcbn1cbmZ1bmN0aW9uIGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJiAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG52YXIgRml0dGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaXR0ZXIoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRml0dGVyKTtcbiAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgdGhpcy4kdG8gPSAkdG87XG4gICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICB0aGlzLnBsYWNlZCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGkpKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pMiA9ICRmcm9tLmRlcHRoOyBfaTIgPiAwOyBfaTItLSkgdGhpcy5wbGFjZWQgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJGZyb20ubm9kZShfaTIpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRml0dGVyLCBbe1xuICAgIGtleTogXCJkZXB0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICAgICAgdmFyIGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgIGlmIChmaXQpIHRoaXMucGxhY2VOb2RlcyhmaXQpO2Vsc2UgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLFxuICAgICAgICBwbGFjZWRTaXplID0gdGhpcy5wbGFjZWQuc2l6ZSAtIHRoaXMuZGVwdGggLSB0aGlzLiRmcm9tLmRlcHRoO1xuICAgICAgdmFyICRmcm9tID0gdGhpcy4kZnJvbSxcbiAgICAgICAgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgaWYgKCEkdG8pIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnBsYWNlZCxcbiAgICAgICAgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsXG4gICAgICAgIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gICAgICB3aGlsZSAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgfVxuICAgICAgdmFyIHNsaWNlID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSk7XG4gICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRGaXR0YWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRml0dGFibGUoKSB7XG4gICAgICB2YXIgc3RhcnREZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0O1xuICAgICAgZm9yICh2YXIgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY3VyLmNoaWxkQ291bnQgPiAxKSBvcGVuRW5kID0gMDtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBvcGVuRW5kIDw9IGQpIHtcbiAgICAgICAgICBzdGFydERlcHRoID0gZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICAgICAgZm9yICh2YXIgc2xpY2VEZXB0aCA9IHBhc3MgPT0gMSA/IHN0YXJ0RGVwdGggOiB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDsgc2xpY2VEZXB0aCA+PSAwOyBzbGljZURlcHRoLS0pIHtcbiAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB2b2lkIDAsXG4gICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgIGlmIChzbGljZURlcHRoKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgdmFyIF90aGlzJGZyb250aWVyJGZyb250aSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sXG4gICAgICAgICAgICAgIHR5cGUgPSBfdGhpcyRmcm9udGllciRmcm9udGkudHlwZSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSBfdGhpcyRmcm9udGllciRmcm9udGkubWF0Y2gsXG4gICAgICAgICAgICAgIF93cmFwID0gdm9pZCAwLFxuICAgICAgICAgICAgICBpbmplY3QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKSA6IHBhcmVudCAmJiB0eXBlLmNvbXBhdGlibGVDb250ZW50KHBhcmVudC50eXBlKSkpIHJldHVybiB7XG4gICAgICAgICAgICAgIHNsaWNlRGVwdGg6IHNsaWNlRGVwdGgsXG4gICAgICAgICAgICAgIGZyb250aWVyRGVwdGg6IGZyb250aWVyRGVwdGgsXG4gICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICBpbmplY3Q6IGluamVjdFxuICAgICAgICAgICAgfTtlbHNlIGlmIChwYXNzID09IDIgJiYgZmlyc3QgJiYgKF93cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSkgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2xpY2VEZXB0aDogc2xpY2VEZXB0aCxcbiAgICAgICAgICAgICAgZnJvbnRpZXJEZXB0aDogZnJvbnRpZXJEZXB0aCxcbiAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICAgIHdyYXA6IF93cmFwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBtYXRjaC5tYXRjaFR5cGUocGFyZW50LnR5cGUpKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3Blbk1vcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Blbk1vcmUoKSB7XG4gICAgICB2YXIgX3RoaXMkdW5wbGFjZWQgPSB0aGlzLnVucGxhY2VkLFxuICAgICAgICBjb250ZW50ID0gX3RoaXMkdW5wbGFjZWQuY29udGVudCxcbiAgICAgICAgb3BlblN0YXJ0ID0gX3RoaXMkdW5wbGFjZWQub3BlblN0YXJ0LFxuICAgICAgICBvcGVuRW5kID0gX3RoaXMkdW5wbGFjZWQub3BlbkVuZDtcbiAgICAgIHZhciBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgaWYgKCFpbm5lci5jaGlsZENvdW50IHx8IGlubmVyLmZpcnN0Q2hpbGQuaXNMZWFmKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLnVucGxhY2VkID0gbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSwgTWF0aC5tYXgob3BlbkVuZCwgaW5uZXIuc2l6ZSArIG9wZW5TdGFydCA+PSBjb250ZW50LnNpemUgLSBvcGVuRW5kID8gb3BlblN0YXJ0ICsgMSA6IDApKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcm9wTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcm9wTm9kZSgpIHtcbiAgICAgIHZhciBfdGhpcyR1bnBsYWNlZDIgPSB0aGlzLnVucGxhY2VkLFxuICAgICAgICBjb250ZW50ID0gX3RoaXMkdW5wbGFjZWQyLmNvbnRlbnQsXG4gICAgICAgIG9wZW5TdGFydCA9IF90aGlzJHVucGxhY2VkMi5vcGVuU3RhcnQsXG4gICAgICAgIG9wZW5FbmQgPSBfdGhpcyR1bnBsYWNlZDIub3BlbkVuZDtcbiAgICAgIHZhciBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIHZhciBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0IC0gMSwgMSksIG9wZW5TdGFydCAtIDEsIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBsYWNlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2VOb2RlcyhfcmVmKSB7XG4gICAgICB2YXIgc2xpY2VEZXB0aCA9IF9yZWYuc2xpY2VEZXB0aCxcbiAgICAgICAgZnJvbnRpZXJEZXB0aCA9IF9yZWYuZnJvbnRpZXJEZXB0aCxcbiAgICAgICAgcGFyZW50ID0gX3JlZi5wYXJlbnQsXG4gICAgICAgIGluamVjdCA9IF9yZWYuaW5qZWN0LFxuICAgICAgICB3cmFwID0gX3JlZi53cmFwO1xuICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKSB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICBpZiAod3JhcCkgZm9yICh2YXIgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKSB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICB2YXIgc2xpY2UgPSB0aGlzLnVucGxhY2VkLFxuICAgICAgICBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgIHZhciBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICAgICAgdmFyIHRha2VuID0gMCxcbiAgICAgICAgYWRkID0gW107XG4gICAgICB2YXIgX3RoaXMkZnJvbnRpZXIkZnJvbnRpMiA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sXG4gICAgICAgIG1hdGNoID0gX3RoaXMkZnJvbnRpZXIkZnJvbnRpMi5tYXRjaCxcbiAgICAgICAgdHlwZSA9IF90aGlzJGZyb250aWVyJGZyb250aTIudHlwZTtcbiAgICAgIGlmIChpbmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgaW5qZWN0LmNoaWxkQ291bnQ7IF9pMysrKSBhZGQucHVzaChpbmplY3QuY2hpbGQoX2kzKSk7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgfVxuICAgICAgdmFyIG9wZW5FbmRDb3VudCA9IGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICB2YXIgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSxcbiAgICAgICAgICBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcykgYnJlYWs7XG4gICAgICAgIHRha2VuKys7XG4gICAgICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgaWYgKCF0b0VuZCkgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcbiAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKSB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwLCBjdXIgPSBmcmFnbWVudDsgX2k0IDwgb3BlbkVuZENvdW50OyBfaTQrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudClcbiAgICAgICAgfSk7XG4gICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGgsIHRha2VuKSwgc2xpY2Uub3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKSA6IHNsaWNlRGVwdGggPT0gMCA/IHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkgOiBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtdXN0TW92ZUlubGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgIGlmICghdGhpcy4kdG8ucGFyZW50LmlzVGV4dGJsb2NrKSByZXR1cm4gLTE7XG4gICAgICB2YXIgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXSxcbiAgICAgICAgbGV2ZWw7XG4gICAgICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8IHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpIHJldHVybiAtMTtcbiAgICAgIHZhciBkZXB0aCA9IHRoaXMuJHRvLmRlcHRoLFxuICAgICAgICBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgICAgIHdoaWxlIChkZXB0aCA+IDEgJiYgYWZ0ZXIgPT0gdGhpcy4kdG8uZW5kKC0tZGVwdGgpKSArK2FmdGVyO1xuICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQ2xvc2VMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2xvc2VMZXZlbCgkdG8pIHtcbiAgICAgIHNjYW46IGZvciAodmFyIGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX3RoaXMkZnJvbnRpZXIkaSA9IHRoaXMuZnJvbnRpZXJbaV0sXG4gICAgICAgICAgbWF0Y2ggPSBfdGhpcyRmcm9udGllciRpLm1hdGNoLFxuICAgICAgICAgIHR5cGUgPSBfdGhpcyRmcm9udGllciRpLnR5cGU7XG4gICAgICAgIHZhciBkcm9wSW5uZXIgPSBpIDwgJHRvLmRlcHRoICYmICR0by5lbmQoaSArIDEpID09ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gKGkgKyAxKSk7XG4gICAgICAgIHZhciBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgIGlmICghZml0KSBjb250aW51ZTtcbiAgICAgICAgZm9yICh2YXIgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgIHZhciBfdGhpcyRmcm9udGllciRkID0gdGhpcy5mcm9udGllcltkXSxcbiAgICAgICAgICAgIF9tYXRjaCA9IF90aGlzJGZyb250aWVyJGQubWF0Y2gsXG4gICAgICAgICAgICBfdHlwZSA9IF90aGlzJGZyb250aWVyJGQudHlwZTtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCBfdHlwZSwgX21hdGNoLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KSBjb250aW51ZSBzY2FuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGVwdGg6IGksXG4gICAgICAgICAgZml0OiBmaXQsXG4gICAgICAgICAgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCR0bykge1xuICAgICAgdmFyIGNsb3NlID0gdGhpcy5maW5kQ2xvc2VMZXZlbCgkdG8pO1xuICAgICAgaWYgKCFjbG9zZSkgcmV0dXJuIG51bGw7XG4gICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKSB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7XG4gICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgZm9yICh2YXIgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICB2YXIgbm9kZSA9ICR0by5ub2RlKGQpLFxuICAgICAgICAgIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcGVuRnJvbnRpZXJOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5Gcm9udGllck5vZGUodHlwZSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdO1xuICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VGcm9udGllck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VGcm9udGllck5vZGUoKSB7XG4gICAgICB2YXIgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICB2YXIgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgaWYgKGFkZC5jaGlsZENvdW50KSB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRml0dGVyO1xufSgpO1xuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gIGlmIChkZXB0aCA9PSAwKSByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgaWYgKGRlcHRoID09IDApIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCk7XG4gIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKSBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gIGlmIChvcGVuU3RhcnQgPD0gMCkgcmV0dXJuIG5vZGU7XG4gIHZhciBmcmFnID0gbm9kZS5jb250ZW50O1xuICBpZiAob3BlblN0YXJ0ID4gMSkgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTtcbiAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICBmcmFnID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGZyYWcpLmFwcGVuZChmcmFnKTtcbiAgICBpZiAob3BlbkVuZCA8PSAwKSBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICB9XG4gIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gIHZhciBub2RlID0gJHRvLm5vZGUoZGVwdGgpLFxuICAgIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gIGlmIChpbmRleCA9PSBub2RlLmNoaWxkQ291bnQgJiYgIXR5cGUuY29tcGF0aWJsZUNvbnRlbnQobm9kZS50eXBlKSkgcmV0dXJuIG51bGw7XG4gIHZhciBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIGlmICghdHlwZS5hbGxvd3NNYXJrcyhmcmFnbWVudC5jaGlsZChpKS5tYXJrcykpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWZpbmVzQ29udGVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIF9yZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICBpZiAoIXNsaWNlLnNpemUpIHJldHVybiB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gIHZhciAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLFxuICAgICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKSByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gIHZhciB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKSB0YXJnZXREZXB0aHMucG9wKCk7XG4gIHZhciBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gIGZvciAodmFyIGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICB2YXIgc3BlYyA9ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjO1xuICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuZGVmaW5pbmdBc0NvbnRleHQgfHwgc3BlYy5pc29sYXRpbmcpIGJyZWFrO1xuICAgIGlmICh0YXJnZXREZXB0aHMuaW5kZXhPZihkKSA+IC0xKSBwcmVmZXJyZWRUYXJnZXQgPSBkO2Vsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpIHRhcmdldERlcHRocy5zcGxpY2UoMSwgMCwgLWQpO1xuICB9XG4gIHZhciBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gIHZhciBsZWZ0Tm9kZXMgPSBbXSxcbiAgICBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgZm9yICh2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIGkgPSAwOzsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgaWYgKGkgPT0gc2xpY2Uub3BlblN0YXJ0KSBicmVhaztcbiAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICB9XG4gIGZvciAodmFyIF9kMyA9IHByZWZlcnJlZERlcHRoIC0gMTsgX2QzID49IDA7IF9kMy0tKSB7XG4gICAgdmFyIGxlZnROb2RlID0gbGVmdE5vZGVzW19kM10sXG4gICAgICBkZWYgPSBkZWZpbmVzQ29udGVudChsZWZ0Tm9kZS50eXBlKTtcbiAgICBpZiAoZGVmICYmICFsZWZ0Tm9kZS5zYW1lTWFya3VwKCRmcm9tLm5vZGUoTWF0aC5hYnMocHJlZmVycmVkVGFyZ2V0KSAtIDEpKSkgcHJlZmVycmVkRGVwdGggPSBfZDM7ZWxzZSBpZiAoZGVmIHx8ICFsZWZ0Tm9kZS50eXBlLmlzVGV4dGJsb2NrKSBicmVhaztcbiAgfVxuICBmb3IgKHZhciBqID0gc2xpY2Uub3BlblN0YXJ0OyBqID49IDA7IGotLSkge1xuICAgIHZhciBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgdmFyIGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgIGlmICghaW5zZXJ0KSBjb250aW51ZTtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCB0YXJnZXREZXB0aHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgdmFyIHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhfaTUgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSxcbiAgICAgICAgZXhwYW5kID0gdHJ1ZTtcbiAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgIHRhcmdldERlcHRoID0gLXRhcmdldERlcHRoO1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudCA9ICRmcm9tLm5vZGUodGFyZ2V0RGVwdGggLSAxKSxcbiAgICAgICAgaW5kZXggPSAkZnJvbS5pbmRleCh0YXJnZXREZXB0aCAtIDEpO1xuICAgICAgaWYgKHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGluc2VydC50eXBlLCBpbnNlcnQubWFya3MpKSByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKGNsb3NlRnJhZ21lbnQoc2xpY2UuY29udGVudCwgMCwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRGVwdGgpLCBvcGVuRGVwdGgsIHNsaWNlLm9wZW5FbmQpKTtcbiAgICB9XG4gIH1cbiAgdmFyIHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gIGZvciAodmFyIF9pNiA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBfaTYgPj0gMDsgX2k2LS0pIHtcbiAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA+IHN0YXJ0U3RlcHMpIGJyZWFrO1xuICAgIHZhciBkZXB0aCA9IHRhcmdldERlcHRoc1tfaTZdO1xuICAgIGlmIChkZXB0aCA8IDApIGNvbnRpbnVlO1xuICAgIGZyb20gPSAkZnJvbS5iZWZvcmUoZGVwdGgpO1xuICAgIHRvID0gJHRvLmFmdGVyKGRlcHRoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvc2VGcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIG9sZE9wZW4sIG5ld09wZW4sIHBhcmVudCkge1xuICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgdmFyIGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgfVxuICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgdmFyIG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KDApO1xuICAgIHZhciBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gX3JlcGxhY2VSYW5nZVdpdGgodHIsIGZyb20sIHRvLCBub2RlKSB7XG4gIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICB2YXIgcG9pbnQgPSBpbnNlcnRQb2ludCh0ci5kb2MsIGZyb20sIG5vZGUudHlwZSk7XG4gICAgaWYgKHBvaW50ICE9IG51bGwpIGZyb20gPSB0byA9IHBvaW50O1xuICB9XG4gIHRyLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBfZGVsZXRlUmFuZ2UodHIsIGZyb20sIHRvKSB7XG4gIHZhciAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLFxuICAgICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgdmFyIGNvdmVyZWQgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwdGggPSBjb3ZlcmVkW2ldLFxuICAgICAgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ICYmIGRlcHRoID09IDAgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpIHJldHVybiB0cltcImRlbGV0ZVwiXSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKTtcbiAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSkgcmV0dXJuIHRyW1wiZGVsZXRlXCJdKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpO1xuICB9XG4gIGZvciAodmFyIGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICBpZiAoZnJvbSAtICRmcm9tLnN0YXJ0KGQpID09ICRmcm9tLmRlcHRoIC0gZCAmJiB0byA+ICRmcm9tLmVuZChkKSAmJiAkdG8uZW5kKGQpIC0gdG8gIT0gJHRvLmRlcHRoIC0gZCAmJiAkZnJvbS5zdGFydChkIC0gMSkgPT0gJHRvLnN0YXJ0KGQgLSAxKSAmJiAkZnJvbS5ub2RlKGQgLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGQgLSAxKSwgJHRvLmluZGV4KGQgLSAxKSkpIHJldHVybiB0cltcImRlbGV0ZVwiXSgkZnJvbS5iZWZvcmUoZCksIHRvKTtcbiAgfVxuICB0cltcImRlbGV0ZVwiXShmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gIGZvciAodmFyIGQgPSBtaW5EZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICBpZiAoc3RhcnQgPCAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKSB8fCAkdG8uZW5kKGQpID4gJHRvLnBvcyArICgkdG8uZGVwdGggLSBkKSB8fCAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgJHRvLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZykgYnJlYWs7XG4gICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fCBkID09ICRmcm9tLmRlcHRoICYmIGQgPT0gJHRvLmRlcHRoICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICR0by5wYXJlbnQuaW5saW5lQ29udGVudCAmJiBkICYmICR0by5zdGFydChkIC0gMSkgPT0gc3RhcnQgLSAxKSByZXN1bHQucHVzaChkKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEF0dHJTdGVwID0gZnVuY3Rpb24gKF9TdGVwNykge1xuICBfaW5oZXJpdHMoQXR0clN0ZXAsIF9TdGVwNyk7XG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEF0dHJTdGVwKTtcbiAgZnVuY3Rpb24gQXR0clN0ZXAocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgIHZhciBfdGhpczk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF0dHJTdGVwKTtcbiAgICBfdGhpczkgPSBfc3VwZXI3LmNhbGwodGhpcyk7XG4gICAgX3RoaXM5LnBvcyA9IHBvcztcbiAgICBfdGhpczkuYXR0ciA9IGF0dHI7XG4gICAgX3RoaXM5LnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzOTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQXR0clN0ZXAsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGRvYykge1xuICAgICAgdmFyIG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnMpIGF0dHJzW25hbWVdID0gbm9kZS5hdHRyc1tuYW1lXTtcbiAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgdmFyIHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXAoKSB7XG4gICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydChkb2MpIHtcbiAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAobWFwcGluZykge1xuICAgICAgdmFyIHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RlcFR5cGU6IFwiYXR0clwiLFxuICAgICAgICBwb3M6IHRoaXMucG9zLFxuICAgICAgICBhdHRyOiB0aGlzLmF0dHIsXG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAoanNvbi5wb3MsIGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBdHRyU3RlcDtcbn0oU3RlcCk7XG5TdGVwLmpzb25JRChcImF0dHJcIiwgQXR0clN0ZXApO1xudmFyIERvY0F0dHJTdGVwID0gZnVuY3Rpb24gKF9TdGVwOCkge1xuICBfaW5oZXJpdHMoRG9jQXR0clN0ZXAsIF9TdGVwOCk7XG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKERvY0F0dHJTdGVwKTtcbiAgZnVuY3Rpb24gRG9jQXR0clN0ZXAoYXR0ciwgdmFsdWUpIHtcbiAgICB2YXIgX3RoaXMxMDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jQXR0clN0ZXApO1xuICAgIF90aGlzMTAgPSBfc3VwZXI4LmNhbGwodGhpcyk7XG4gICAgX3RoaXMxMC5hdHRyID0gYXR0cjtcbiAgICBfdGhpczEwLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIF90aGlzMTA7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKERvY0F0dHJTdGVwLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShkb2MpIHtcbiAgICAgIHZhciBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGRvYy5hdHRycykgYXR0cnNbbmFtZV0gPSBkb2MuYXR0cnNbbmFtZV07XG4gICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciB1cGRhdGVkID0gZG9jLnR5cGUuY3JlYXRlKGF0dHJzLCBkb2MuY29udGVudCwgZG9jLm1hcmtzKTtcbiAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKHVwZGF0ZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFwKCkge1xuICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoZG9jKSB7XG4gICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKHRoaXMuYXR0ciwgZG9jLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RlcFR5cGU6IFwiZG9jQXR0clwiLFxuICAgICAgICBhdHRyOiB0aGlzLmF0dHIsXG4gICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBEb2NBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAoanNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERvY0F0dHJTdGVwO1xufShTdGVwKTtcblN0ZXAuanNvbklEKFwiZG9jQXR0clwiLCBEb2NBdHRyU3RlcCk7XG5leHBvcnRzLlRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoVHJhbnNmb3JtRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXI5ID0gX2NyZWF0ZVN1cGVyKFRyYW5zZm9ybUVycm9yKTtcbiAgZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybUVycm9yKTtcbiAgICByZXR1cm4gX3N1cGVyOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJhbnNmb3JtRXJyb3IpO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5leHBvcnRzLlRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IobWVzc2FnZSkge1xuICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgcmV0dXJuIGVycjtcbn07XG5leHBvcnRzLlRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5UcmFuc2Zvcm1FcnJvcjtcbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG52YXIgVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2Zvcm0oZG9jKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zZm9ybSk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgIHRoaXMuZG9jcyA9IFtdO1xuICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zZm9ybSwgW3tcbiAgICBrZXk6IFwiYmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAoX3N0ZXApIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChfc3RlcCk7XG4gICAgICBpZiAocmVzdWx0LmZhaWxlZCkgdGhyb3cgbmV3IGV4cG9ydHMuVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF5YmVTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICBpZiAoIXJlc3VsdC5mYWlsZWQpIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvY0NoYW5nZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFN0ZXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgIHRoaXMubWFwcGluZy5hcHBlbmRNYXAoc3RlcC5nZXRNYXAoKSk7XG4gICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKGZyb20pIHtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnJvbTtcbiAgICAgIHZhciBzbGljZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogcHJvc2VtaXJyb3JNb2RlbC5TbGljZS5lbXB0eTtcbiAgICAgIHZhciBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICBpZiAoc3RlcCkgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgX3JlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VSYW5nZVdpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgX3JlcGxhY2VSYW5nZVdpdGgodGhpcywgZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICBfZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICBfbGlmdCh0aGlzLCByYW5nZSwgdGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocG9zKSB7XG4gICAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICBfam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3cmFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyYXAocmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgICBfd3JhcDIodGhpcywgcmFuZ2UsIHdyYXBwZXJzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRCbG9ja1R5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmxvY2tUeXBlKGZyb20pIHtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZnJvbTtcbiAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICBfc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Tm9kZU1hcmt1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROb2RlTWFya3VwKHBvcywgdHlwZSkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICBfc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Tm9kZUF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROb2RlQXR0cmlidXRlKHBvcywgYXR0ciwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc3RlcChuZXcgQXR0clN0ZXAocG9zLCBhdHRyLCB2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERvY0F0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREb2NBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc3RlcChuZXcgRG9jQXR0clN0ZXAoYXR0ciwgdmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlTWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgIHRoaXMuc3RlcChuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZU5vZGVNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgaWYgKCEobWFyayBpbnN0YW5jZW9mIHByb3NlbWlycm9yTW9kZWwuTWFyaykpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRvYy5ub2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgcG9zaXRpb24gXCIgKyBwb3MpO1xuICAgICAgICBtYXJrID0gbWFyay5pc0luU2V0KG5vZGUubWFya3MpO1xuICAgICAgICBpZiAoIW1hcmspIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaXQocG9zKSB7XG4gICAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICB2YXIgdHlwZXNBZnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgX3NwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgX2FkZE1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZU1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgX3JlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFySW5jb21wYXRpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgIF9jbGVhckluY29tcGF0aWJsZSh0aGlzLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJhbnNmb3JtO1xufSgpO1xuZXhwb3J0cy5BZGRNYXJrU3RlcCA9IEFkZE1hcmtTdGVwO1xuZXhwb3J0cy5BZGROb2RlTWFya1N0ZXAgPSBBZGROb2RlTWFya1N0ZXA7XG5leHBvcnRzLkF0dHJTdGVwID0gQXR0clN0ZXA7XG5leHBvcnRzLkRvY0F0dHJTdGVwID0gRG9jQXR0clN0ZXA7XG5leHBvcnRzLk1hcFJlc3VsdCA9IE1hcFJlc3VsdDtcbmV4cG9ydHMuTWFwcGluZyA9IE1hcHBpbmc7XG5leHBvcnRzLlJlbW92ZU1hcmtTdGVwID0gUmVtb3ZlTWFya1N0ZXA7XG5leHBvcnRzLlJlbW92ZU5vZGVNYXJrU3RlcCA9IFJlbW92ZU5vZGVNYXJrU3RlcDtcbmV4cG9ydHMuUmVwbGFjZUFyb3VuZFN0ZXAgPSBSZXBsYWNlQXJvdW5kU3RlcDtcbmV4cG9ydHMuUmVwbGFjZVN0ZXAgPSBSZXBsYWNlU3RlcDtcbmV4cG9ydHMuU3RlcCA9IFN0ZXA7XG5leHBvcnRzLlN0ZXBNYXAgPSBTdGVwTWFwO1xuZXhwb3J0cy5TdGVwUmVzdWx0ID0gU3RlcFJlc3VsdDtcbmV4cG9ydHMuVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuZXhwb3J0cy5jYW5Kb2luID0gY2FuSm9pbjtcbmV4cG9ydHMuY2FuU3BsaXQgPSBjYW5TcGxpdDtcbmV4cG9ydHMuZHJvcFBvaW50ID0gZHJvcFBvaW50O1xuZXhwb3J0cy5maW5kV3JhcHBpbmcgPSBmaW5kV3JhcHBpbmc7XG5leHBvcnRzLmluc2VydFBvaW50ID0gaW5zZXJ0UG9pbnQ7XG5leHBvcnRzLmpvaW5Qb2ludCA9IGpvaW5Qb2ludDtcbmV4cG9ydHMubGlmdFRhcmdldCA9IGxpZnRUYXJnZXQ7XG5leHBvcnRzLnJlcGxhY2VTdGVwID0gcmVwbGFjZVN0ZXA7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-transform/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* binding */ AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* binding */ AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* binding */ AttrStep),\n/* harmony export */   DocAttrStep: () => (/* binding */ DocAttrStep),\n/* harmony export */   MapResult: () => (/* binding */ MapResult),\n/* harmony export */   Mapping: () => (/* binding */ Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* binding */ RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* binding */ RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* binding */ ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* binding */ ReplaceStep),\n/* harmony export */   Step: () => (/* binding */ Step),\n/* harmony export */   StepMap: () => (/* binding */ StepMap),\n/* harmony export */   StepResult: () => (/* binding */ StepResult),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   TransformError: () => (/* binding */ TransformError),\n/* harmony export */   canJoin: () => (/* binding */ canJoin),\n/* harmony export */   canSplit: () => (/* binding */ canSplit),\n/* harmony export */   dropPoint: () => (/* binding */ dropPoint),\n/* harmony export */   findWrapping: () => (/* binding */ findWrapping),\n/* harmony export */   insertPoint: () => (/* binding */ insertPoint),\n/* harmony export */   joinPoint: () => (/* binding */ joinPoint),\n/* harmony export */   liftTarget: () => (/* binding */ liftTarget),\n/* harmony export */   replaceStep: () => (/* binding */ replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) { return index + offset * factor16; }\nfunction recoverIndex(value) { return value & lower16; }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16; }\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nclass MapResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The mapped version of the position.\n    */\n    pos, \n    /**\n    @internal\n    */\n    delInfo, \n    /**\n    @internal\n    */\n    recover) {\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nclass StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    ranges, \n    /**\n    @internal\n    */\n    inverted = false) {\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty)\n            return StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted)\n            for (let i = 0; i < index; i++)\n                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    map(pos, assoc = 1) { return this._map(pos, assoc, true); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple)\n                    return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end)\n                    del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3)\n                return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n[rebasing](/docs/guide/#transform.rebasing) steps for\ncollaboration or history management.)\n*/\nclass Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(\n    /**\n    The step maps in this mapping.\n    */\n    maps = [], \n    /**\n    @internal\n    */\n    mirror, \n    /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */\n    from = 0, \n    /**\n    The end position in the `maps` array.\n    */\n    to = maps.length) {\n        this.maps = maps;\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from = 0, to = this.maps.length) {\n        return new Mapping(this.maps, this.mirror, from, to);\n    }\n    /**\n    @internal\n    */\n    copy() {\n        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map, mirrors) {\n        this.to = this.maps.push(map);\n        if (mirrors != null)\n            this.setMirror(this.maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n        for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n        if (this.mirror)\n            for (let i = 0; i < this.mirror.length; i++)\n                if (this.mirror[i] == n)\n                    return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n        if (!this.mirror)\n            this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n        for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n        if (this.mirror)\n            return this._map(pos, assoc, true);\n        for (let i = this.from; i < this.to; i++)\n            pos = this.maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for (let i = this.from; i < this.to; i++) {\n            let map = this.maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this.maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\n\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nclass Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() { return StepMap.empty; }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) { return null; }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema, json) {\n        if (!json || !json.stepType)\n            throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type)\n            throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n        if (id in stepsByID)\n            throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nclass StepResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The transformed document, if successful.\n    */\n    doc, \n    /**\n    The failure message, if unsuccessful.\n    */\n    failed) {\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc) { return new StepResult(doc, null); }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) { return new StepResult(null, message); }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        }\n        catch (e) {\n            if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError)\n                return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\n\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n        let child = fragment.child(i);\n        if (child.content.size)\n            child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline)\n            child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nclass AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(\n    /**\n    The start of the marked range.\n    */\n    from, \n    /**\n    The end of the marked range.\n    */\n    to, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent) => {\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))\n                return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nclass RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The start of the unmarked range.\n    */\n    from, \n    /**\n    The end of the unmarked range.\n    */\n    to, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, node => {\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nclass AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for (let i = 0; i < node.marks.length; i++)\n                    if (!node.marks[i].isInSet(newSet))\n                        return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nclass RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks))\n            return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nclass ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to))\n            return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross)\n            return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n            return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        }\n        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        }\n        else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = { stepType: \"replace\", from: this.from, to: this.to };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nclass ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The start of preserved range.\n    */\n    gapFrom, \n    /**\n    The end of preserved range.\n    */\n    gapTo, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */\n    insert, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n            contentBetween(doc, this.gapTo, this.to)))\n            return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd)\n            return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted)\n            return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n        let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)\n            return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = { stepType: \"replaceAround\", from: this.from, to: this.to,\n            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while (dist > 0) {\n            if (!next || next.isLeaf)\n                return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\n\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (!node.isInline)\n            return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for (let i = 0; i < marks.length; i++) {\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i]))\n                        removing.to = end;\n                    else\n                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start)\n                adding.to = end;\n            else\n                added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach(s => tr.step(s));\n    added.forEach(s => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isInline)\n            return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n            let set = node.marks, found;\n            while (found = mark.isInSet(set)) {\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks))\n                toRemove = [mark];\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for (let i = 0; i < toRemove.length; i++) {\n                let style = toRemove[i], found;\n                for (let j = 0; j < matched.length; j++) {\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style))\n                        found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                }\n                else {\n                    matched.push({ style, from: Math.max(pos, from), to: end, step });\n                }\n            }\n        }\n    });\n    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n        }\n        else {\n            match = allowed;\n            for (let j = 0; j < child.marks.length; j++)\n                if (!parentType.allowsMarkType(child.marks[j].type))\n                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n            if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n                let m, newline = /\\r?\\n|\\r/g, slice;\n                while (m = newline.exec(child.text)) {\n                    if (!slice)\n                        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n                    replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n                }\n            }\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n    }\n    for (let i = replSteps.length - 1; i >= 0; i--)\n        tr.step(replSteps[i]);\n}\n\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) &&\n        (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/\nfunction liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth;; --depth) {\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n        if (depth < range.depth && node.canReplace(index, endIndex, content))\n            return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n            break;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $from.index(d) > 0) {\n            splitting = true;\n            before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n            openStart++;\n        }\n        else {\n            start--;\n        }\n    let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $to.after(d + 1) < $to.end(d)) {\n            splitting = true;\n            after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n            openEnd++;\n        }\n        else {\n            end++;\n        }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/\nfunction findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner)\n        return null;\n    return around.map(withAttrs)\n        .concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) { return { type, attrs: null }; }\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around)\n        return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside)\n        return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for (let i = startIndex; innerMatch && i < endIndex; i++)\n        innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd)\n        return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd)\n                throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock)\n        throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        let attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n        if (node.isTextblock && !node.hasMarkup(type, attrsHere) &&\n            canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            let convertNewlines = null;\n            if (type.schema.linebreakReplacement) {\n                let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n                if (pre && !supportLinebreak)\n                    convertNewlines = false;\n                else if (!pre && supportLinebreak)\n                    convertNewlines = true;\n            }\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            if (convertNewlines === false)\n                replaceLinebreaks(tr, node, pos, mapFrom);\n            clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n            if (convertNewlines === true)\n                replaceNewlines(tr, node, pos, mapFrom);\n            return false;\n        }\n    });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n        if (child.isText) {\n            let m, newline = /\\r?\\n|\\r/g;\n            while (m = newline.exec(child.text)) {\n                let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n                tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n            }\n        }\n    });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n        if (child.type == child.type.schema.linebreakReplacement) {\n            let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n            tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n        throw new RangeError(\"No node at given position\");\n    if (!type)\n        type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf)\n        return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n        throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating ||\n        !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n        !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n        return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating)\n            return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let overrideChild = typesAfter && typesAfter[i + 1];\n        if (overrideChild)\n            rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n        let after = (typesAfter && typesAfter[i]) || node;\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n            return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/\nfunction canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n        $pos.parent.canReplace(index, index + 1);\n}\nfunction canAppendWithSubstitutedLinebreaks(a, b) {\n    if (!b.content.size)\n        a.type.compatibleContent(b.type);\n    let match = a.contentMatchAt(a.childCount);\n    let { linebreakReplacement } = a.type.schema;\n    for (let i = 0; i < b.childCount; i++) {\n        let child = b.child(i);\n        let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n        match = match.matchType(type);\n        if (!match)\n            return false;\n        if (!a.type.allowsMarks(child.marks))\n            return false;\n    }\n    return match.validEnd;\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/\nfunction joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for (let d = $pos.depth;; d--) {\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        }\n        else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        }\n        else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) &&\n            $pos.node(d).canReplace(index, index + 1))\n            return pos;\n        if (d == 0)\n            break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let convertNewlines = null;\n    let { linebreakReplacement } = tr.doc.type.schema;\n    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;\n    if (linebreakReplacement && beforeType.inlineContent) {\n        let pre = beforeType.whitespace == \"pre\";\n        let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n        if (pre && !supportLinebreak)\n            convertNewlines = false;\n        else if (!pre && supportLinebreak)\n            convertNewlines = true;\n    }\n    let mapFrom = tr.steps.length;\n    if (convertNewlines === false) {\n        let $after = tr.doc.resolve(pos + depth);\n        replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n    }\n    if (beforeType.inlineContent)\n        clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n    let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);\n    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true));\n    if (convertNewlines === true) {\n        let $full = tr.doc.resolve(start);\n        replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n    }\n    return tr;\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n        return pos;\n    if ($pos.parentOffset == 0)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.index(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.before(d + 1);\n            if (index > 0)\n                return null;\n        }\n    if ($pos.parentOffset == $pos.parent.content.size)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.indexAfter(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.after(d + 1);\n            if (index < $pos.node(d).childCount)\n                return null;\n        }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/\nfunction dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size)\n        return pos;\n    let content = slice.content;\n    for (let i = 0; i < slice.openStart; i++)\n        content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n        for (let d = $pos.depth; d >= 0; d--) {\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            }\n            else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits)\n                return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n\n/**\nFit a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (from == to && !slice.size)\n        return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice))\n        return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n        $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced) {\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        for (let i = 0; i <= $from.depth; i++) {\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for (let i = $from.depth; i > 0; i--)\n            this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() { return this.frontier.length - 1; }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while (this.unplaced.size) {\n            let fit = this.findFittable();\n            if (fit)\n                this.placeNodes(fit);\n            else\n                this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to)\n            return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n        if (moveInline > -1)\n            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n            return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n            let node = cur.firstChild;\n            if (cur.childCount > 1)\n                openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for (let pass = 1; pass <= 2; pass++) {\n            for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                }\n                else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))\n                        : parent && type.compatibleContent(parent.type)))\n                        return { sliceDepth, frontierDepth, parent, inject };\n                    // In pass 2, look for a set of wrapping nodes that make\n                    // `first` fit here.\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n                        return { sliceDepth, frontierDepth, parent, wrap };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type))\n                        break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf)\n            return false;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        }\n        else {\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while (this.depth > frontierDepth)\n            this.closeFrontierNode();\n        if (wrap)\n            for (let i = 0; i < wrap.length; i++)\n                this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for (let i = 0; i < inject.childCount; i++)\n                add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while (taken < fragment.childCount) {\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches)\n                break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd)\n            openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n            this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for (let i = 0, cur = fragment; i < openEndCount; i++) {\n            let node = cur.lastChild;\n            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n            : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock)\n            return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))\n            return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while (depth > 1 && after == this.$to.end(--depth))\n            ++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit)\n                continue;\n            for (let d = i - 1; d >= 0; d--) {\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount)\n                    continue scan;\n            }\n            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close)\n            return null;\n        while (this.depth > close.depth)\n            this.closeFrontierNode();\n        if (close.fit.childCount)\n            this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for (let d = close.depth + 1; d <= $to.depth; d++) {\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n        this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        if (add.childCount)\n            this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n        return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0)\n        return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n        fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n        return node;\n    let frag = node.content;\n    if (openStart > 1)\n        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0)\n            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n        return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n        if (!type.allowsMarks(fragment.child(i).marks))\n            return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size)\n        return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice))\n        return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0)\n        targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating)\n            break;\n        if (targetDepths.indexOf(d) > -1)\n            preferredTarget = d;\n        else if ($from.before(d) == pos)\n            targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for (let content = slice.content, i = 0;; i++) {\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart)\n            break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n        let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n            preferredDepth = d;\n        else if (def || !leftNode.type.isTextblock)\n            break;\n    }\n    for (let j = slice.openStart; j >= 0; j--) {\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert)\n            continue;\n        for (let i = 0; i < targetDepths.length; i++) {\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps)\n            break;\n        let depth = targetDepths[i];\n        if (depth < 0)\n            continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null)\n            from = to = point;\n    }\n    tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n        let depth = covered[i], last = i == covered.length - 1;\n        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n            return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n            return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d &&\n            $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))\n            return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) ||\n            $to.end(d) > $to.pos + ($to.depth - d) ||\n            $from.node(d).type.spec.isolating ||\n            $to.node(d).type.spec.isolating)\n            break;\n        if (start == $to.start(d) ||\n            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n                d && $to.start(d - 1) == start - 1))\n            result.push(d);\n    }\n    return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nclass AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for (let name in node.attrs)\n            attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n/**\nUpdate an attribute in the doc node.\n*/\nclass DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let attrs = Object.create(null);\n        for (let name in doc.attrs)\n            attrs[name] = doc.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = doc.type.create(attrs, doc.content, doc.marks);\n        return StepResult.ok(updated);\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n    map(mapping) {\n        return this;\n    }\n    toJSON() {\n        return { stepType: \"docAttr\", attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n        return new DocAttrStep(json.attr, json.value);\n    }\n}\nStep.jsonID(\"docAttr\", DocAttrStep);\n\n/**\n@internal\n*/\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nclass Transform {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(\n    /**\n    The current document (the result of applying the steps in the\n    transform).\n    */\n    doc) {\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */\n        this.steps = [];\n        /**\n        The documents before each of the steps.\n        */\n        this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */\n        this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */\n    get before() { return this.docs.length ? this.docs[0] : this.doc; }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed)\n            throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed)\n            this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step)\n            this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from, to, content) {\n        return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from, to) {\n        return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */\n    setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */\n    setDocAttribute(attr, value) {\n        this.step(new DocAttrStep(attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n        if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {\n            let node = this.doc.nodeAt(pos);\n            if (!node)\n                throw new RangeError(\"No node at position \" + pos);\n            mark = mark.isInSet(node.marks);\n            if (!mark)\n                return this;\n        }\n        this.step(new RemoveNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split.\n    */\n    split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLFFBQVE7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvREFBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvREFBSyxDQUFDLHVEQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0RBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1EQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwUyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxocFxcT25lRHJpdmVcXERlc2t0b3BcXE5BUlJBVElWRSBORVhVU1xcYWktZ2VuZXJhdG9yXFxub2RlX21vZHVsZXNcXHByb3NlbWlycm9yLXRyYW5zZm9ybVxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cbuKAmFtyZWJhc2luZ10oL2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZynigJkgc3RlcHMgZm9yXG5jb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG4qL1xuY2xhc3MgTWFwcGluZyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG1hcHBpbmcgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gbWFwcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGVwIG1hcHMgaW4gdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwcyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1pcnJvciwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXksIHVzZWQgd2hlbiBgbWFwYCBvclxuICAgIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIGZyb20gPSAwLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gICAgKi9cbiAgICB0byA9IG1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWFwcyA9IG1hcHM7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBzbGljZShmcm9tID0gMCwgdG8gPSB0aGlzLm1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLm1hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMubWFwcy5zbGljZSgpLCB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpLCB0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBzdGVwIG1hcCB0byB0aGUgZW5kIG9mIHRoaXMgbWFwcGluZy4gSWYgYG1pcnJvcnNgIGlzXG4gICAgZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuICAgIGltYWdlIG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMubWFwcy5sZW5ndGggLSAxLCBtaXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuICAgIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMubWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLm1hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuICAgIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGBhcHBlbmRNYXBgKS5cbiAgICAqL1xuICAgIGdldE1pcnJvcihuKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TWlycm9yKG4sIG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gW107XG4gICAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXBwaW5nLm1hcHMubGVuZ3RoIC0gMSwgdG90YWxTaXplID0gdGhpcy5tYXBzLmxlbmd0aCArIG1hcHBpbmcubWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBsZXQgaW52ZXJzZSA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgICAgICAgICBwb3MgPSB0aGlzLm1hcHNbaV0ubWFwKHBvcywgYXNzb2MpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuICAgIHJlc3VsdC5cbiAgICAqL1xuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRlbEluZm8gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMubWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xub25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG5zdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG5cbk5ldyBzdGVwcyBhcmUgZGVmaW5lZCBieSBjcmVhdGluZyBjbGFzc2VzIHRoYXQgZXh0ZW5kIGBTdGVwYCxcbm92ZXJyaWRpbmcgdGhlIGBhcHBseWAsIGBpbnZlcnRgLCBgbWFwYCwgYGdldE1hcGAgYW5kIGBmcm9tSlNPTmBcbm1ldGhvZHMsIGFuZCByZWdpc3RlcmluZyB5b3VyIGNsYXNzIHdpdGggYSB1bmlxdWVcbkpTT04tc2VyaWFsaXphdGlvbiBpZGVudGlmaWVyIHVzaW5nXG5bYFN0ZXAuanNvbklEYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkuXG4qL1xuY2xhc3MgU3RlcCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4gICAgYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4gICAgYW5kIHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXRNYXAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1lcmdlIHRoaXMgc3RlcCB3aXRoIGFub3RoZXIgb25lLCB0byBiZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4gICAgc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0ZXAgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2lsbCBjYWxsXG4gICAgdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc3RlcCB0eXBlICR7anNvbi5zdGVwVHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbiAgICBJRCB0byBhdHRhY2ggdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFVzZSB0aGlzIG1ldGhvZCB0b1xuICAgIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4gICAgdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbn1cbi8qKlxuVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxubmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbiovXG5jbGFzcyBTdGVwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudCwgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGZhaWx1cmUgbWVzc2FnZSwgaWYgdW5zdWNjZXNzZnVsLlxuICAgICovXG4gICAgZmFpbGVkKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBvayhkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmFpbChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKTsgfVxuICAgIC8qKlxuICAgIENhbGwgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aXRoIHRoZSBnaXZlblxuICAgIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4gICAgZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVwbGFjZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgICBsZXQgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICAgICAgaWYgKGNoaWxkLmlzSW5saW5lKVxuICAgICAgICAgICAgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgICAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbi8qKlxuQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIEFkZE1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSgkZnJvbS5zaGFyZWREZXB0aCh0aGlzLnRvKSk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzLm1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGRNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmVtb3ZlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcbi8qKlxuQWRkIGEgbWFyayB0byBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQWRkTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAobmV3U2V0Lmxlbmd0aCA9PSBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLm1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCBub2RlLm1hcmtzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEFkZE5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGROb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTm9kZU1hcmtcIiwgQWRkTm9kZU1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBSZW1vdmVOb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMubWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVOb2RlTWFya1wiLCBSZW1vdmVOb2RlTWFya1N0ZXApO1xuXG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG4qL1xuY2xhc3MgUmVwbGFjZVN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBUaGUgZ2l2ZW4gYHNsaWNlYCBzaG91bGQgZml0IHRoZSAnZ2FwJyBiZXR3ZWVuIGBmcm9tYCBhbmRcbiAgICBgdG9g4oCUdGhlIGRlcHRocyBtdXN0IGxpbmUgdXAsIGFuZCB0aGUgc3Vycm91bmRpbmcgbm9kZXMgbXVzdCBiZVxuICAgIGFibGUgdG8gYmUgam9pbmVkIHdpdGggdGhlIG9wZW4gc2lkZXMgb2YgdGhlIHNsaWNlLiBXaGVuXG4gICAgYHN0cnVjdHVyZWAgaXMgdHJ1ZSwgdGhlIHN0ZXAgd2lsbCBmYWlsIGlmIHRoZSBjb250ZW50IGJldHdlZW5cbiAgICBmcm9tIGFuZCB0byBpcyBub3QganVzdCBhIHNlcXVlbmNlIG9mIGNsb3NpbmcgYW5kIHRoZW4gb3BlbmluZ1xuICAgIHRva2VucyAodGhpcyBpcyB0byBndWFyZCBhZ2FpbnN0IHJlYmFzZWQgcmVwbGFjZSBzdGVwc1xuICAgIG92ZXJ3cml0aW5nIHNvbWV0aGluZyB0aGV5IHdlcmVuJ3Qgc3VwcG9zZWQgdG8pLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCkgfHwgb3RoZXIuc3RydWN0dXJlIHx8IHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UodGhpcy5zbGljZS5jb250ZW50LmFwcGVuZChvdGhlci5zbGljZS5jb250ZW50KSwgdGhpcy5zbGljZS5vcGVuU3RhcnQsIG90aGVyLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbnByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG5zbGljZS5cbiovXG5jbGFzcyBSZXBsYWNlQXJvdW5kU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UtYXJvdW5kIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIGdhcC5cbiAgICBgaW5zZXJ0YCBzaG91bGQgYmUgdGhlIHBvaW50IGluIHRoZSBzbGljZSBpbnRvIHdoaWNoIHRoZSBjb250ZW50XG4gICAgb2YgdGhlIGdhcCBzaG91bGQgYmUgbW92ZWQuIGBzdHJ1Y3R1cmVgIGhhcyB0aGUgc2FtZSBtZWFuaW5nIGFzXG4gICAgaXQgaGFzIGluIHRoZSBbYFJlcGxhY2VTdGVwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5SZXBsYWNlU3RlcCkgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcEZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwVG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIGluc2VydGVkLlxuICAgICovXG4gICAgaW5zZXJ0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICAgICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHxcbiAgICAgICAgICAgIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgbGV0IGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgICAgbGV0IGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGxldCBnYXBGcm9tID0gdGhpcy5mcm9tID09IHRoaXMuZ2FwRnJvbSA/IGZyb20ucG9zIDogbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSk7XG4gICAgICAgIGxldCBnYXBUbyA9IHRoaXMudG8gPT0gdGhpcy5nYXBUbyA/IHRvLnBvcyA6IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgICBpZiAoKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZUFyb3VuZFwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLCBnYXBUbzogdGhpcy5nYXBUbywgaW5zZXJ0OiB0aGlzLmluc2VydCB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBqc29uLmdhcEZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBUbyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmluc2VydCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChqc29uLmZyb20sIGpzb24udG8sIGpzb24uZ2FwRnJvbSwganNvbi5nYXBUbywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksIGRpc3QgPSB0byAtIGZyb20sIGRlcHRoID0gJGZyb20uZGVwdGg7XG4gICAgd2hpbGUgKGRpc3QgPiAwICYmIGRlcHRoID4gMCAmJiAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSA9PSAkZnJvbS5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGRpc3QtLTtcbiAgICB9XG4gICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGRpc3QtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZE1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IHJlbW92ZWQgPSBbXSwgYWRkZWQgPSBbXTtcbiAgICBsZXQgcmVtb3ZpbmcsIGFkZGluZztcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgICAgICBpZiAoIW1hcmsuaXNJblNldChtYXJrcykgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IG1hcmsuYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghbWFya3NbaV0uaXNJblNldChuZXdTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92aW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydClcbiAgICAgICAgICAgICAgICBhZGRpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG4gICAgYWRkZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgbWF0Y2hlZCA9IFtdLCBzdGVwID0gMDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RlcCsrO1xuICAgICAgICBsZXQgdG9SZW1vdmUgPSBudWxsO1xuICAgICAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmtUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQ7XG4gICAgICAgICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAgICAgICAgICh0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICAgICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gW21hcmtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZSAmJiB0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdG9SZW1vdmVbaV0sIGZvdW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQuc3RlcCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goeyBzdHlsZSwgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSwgdG86IGVuZCwgc3RlcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtYXRjaGVkLmZvckVhY2gobSA9PiB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKSk7XG59XG5mdW5jdGlvbiBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCA9IHBhcmVudFR5cGUuY29udGVudE1hdGNoLCBjbGVhck5ld2xpbmVzID0gdHJ1ZSkge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGxldCByZXBsU3RlcHMgPSBbXSwgY3VyID0gcG9zICsgMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSksIGVuZCA9IGN1ciArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBsZXQgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlKTtcbiAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyLCBlbmQsIFNsaWNlLmVtcHR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IGFsbG93ZWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkLm1hcmtzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50VHlwZS5hbGxvd3NNYXJrVHlwZShjaGlsZC5tYXJrc1tqXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAoY3VyLCBlbmQsIGNoaWxkLm1hcmtzW2pdKSk7XG4gICAgICAgICAgICBpZiAoY2xlYXJOZXdsaW5lcyAmJiBjaGlsZC5pc1RleHQgJiYgcGFyZW50VHlwZS53aGl0ZXNwYWNlICE9IFwicHJlXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nLCBzbGljZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJlbnRUeXBlLnNjaGVtYS50ZXh0KFwiIFwiLCBwYXJlbnRUeXBlLmFsbG93ZWRNYXJrcyhjaGlsZC5tYXJrcykpKSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIgKyBtLmluZGV4LCBjdXIgKyBtLmluZGV4ICsgbVswXS5sZW5ndGgsIHNsaWNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgICAgICBsZXQgZmlsbCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgU2xpY2UoZmlsbCwgMCwgMCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcmVwbFN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0ci5zdGVwKHJlcGxTdGVwc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChzdGFydCA9PSAwIHx8IG5vZGUuY2FuUmVwbGFjZShzdGFydCwgbm9kZS5jaGlsZENvdW50KSkgJiZcbiAgICAgICAgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHRhcmdldCBkZXB0aCB0byB3aGljaCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2VcbmNhbiBiZSBsaWZ0ZWQuIFdpbGwgbm90IGdvIGFjcm9zc1xuW2lzb2xhdGluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmlzb2xhdGluZykgcGFyZW50IG5vZGVzLlxuKi9cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGxldCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleChyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCk7XG4gICAgZm9yIChsZXQgZGVwdGggPSByYW5nZS5kZXB0aDs7IC0tZGVwdGgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSByYW5nZS4kZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcmFuZ2UuJGZyb20uaW5kZXgoZGVwdGgpLCBlbmRJbmRleCA9IHJhbmdlLiR0by5pbmRleEFmdGVyKGRlcHRoKTtcbiAgICAgICAgaWYgKGRlcHRoIDwgcmFuZ2UuZGVwdGggJiYgbm9kZS5jYW5SZXBsYWNlKGluZGV4LCBlbmRJbmRleCwgY29udGVudCkpXG4gICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwIHx8IG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyB8fCAhY2FuQ3V0KG5vZGUsIGluZGV4LCBlbmRJbmRleCkpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBsaWZ0KHRyLCByYW5nZSwgdGFyZ2V0KSB7XG4gICAgbGV0IHsgJGZyb20sICR0bywgZGVwdGggfSA9IHJhbmdlO1xuICAgIGxldCBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLCBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgICBsZXQgc3RhcnQgPSBnYXBTdGFydCwgZW5kID0gZ2FwRW5kO1xuICAgIGxldCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgb3BlblN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJGZyb20uaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eSwgb3BlbkVuZCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICR0by5hZnRlcihkICsgMSkgPCAkdG8uZW5kKGQpKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKCR0by5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCwgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLCBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHZhbGlkIHdheSB0byB3cmFwIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBpbiBhXG5ub2RlIG9mIHRoZSBnaXZlbiB0eXBlLiBNYXkgaW50cm9kdWNlIGV4dHJhIG5vZGVzIGFyb3VuZCBhbmQgaW5zaWRlXG50aGUgd3JhcHBlciBub2RlLCBpZiBuZWNlc3NhcnkuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCB3cmFwcGluZ1xuY291bGQgYmUgZm91bmQuIFdoZW4gYGlubmVyUmFuZ2VgIGlzIGdpdmVuLCB0aGF0IHJhbmdlJ3MgY29udGVudCBpc1xudXNlZCBhcyB0aGUgY29udGVudCB0byBmaXQgaW50byB0aGUgd3JhcHBpbmcsIGluc3RlYWQgb2YgdGhlXG5jb250ZW50IG9mIGByYW5nZWAuXG4qL1xuZnVuY3Rpb24gZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMgPSBudWxsLCBpbm5lclJhbmdlID0gcmFuZ2UpIHtcbiAgICBsZXQgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIGxldCBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICAgIGlmICghaW5uZXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycylcbiAgICAgICAgLmNvbmNhdCh7IHR5cGU6IG5vZGVUeXBlLCBhdHRycyB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHsgcmV0dXJuIHsgdHlwZSwgYXR0cnM6IG51bGwgfTsgfVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmICghYXJvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIGxldCBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKCFpbnNpZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBsYXN0VHlwZSA9IGluc2lkZS5sZW5ndGggPyBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdIDogdHlwZTtcbiAgICBsZXQgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICBpZiAoIWlubmVyTWF0Y2ggfHwgIWlubmVyTWF0Y2gudmFsaWRFbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBpbnNpZGU7XG59XG5mdW5jdGlvbiB3cmFwKHRyLCByYW5nZSwgd3JhcHBlcnMpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB3cmFwcGVyc1tpXS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXcmFwcGVyIHR5cGUgZ2l2ZW4gdG8gVHJhbnNmb3JtLndyYXAgZG9lcyBub3QgZm9ybSB2YWxpZCBjb250ZW50IG9mIGl0cyBwYXJlbnQgd3JhcHBlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG59XG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUodHIsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICAgIGlmICghdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBsZXQgYXR0cnNIZXJlID0gdHlwZW9mIGF0dHJzID09IFwiZnVuY3Rpb25cIiA/IGF0dHJzKG5vZGUpIDogYXR0cnM7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRyc0hlcmUpICYmXG4gICAgICAgICAgICBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBjb252ZXJ0TmV3bGluZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZSA9IHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiLCBzdXBwb3J0TGluZWJyZWFrID0gISF0eXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUodHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICAgICAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRyLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlLCB1bmRlZmluZWQsIGNvbnZlcnROZXdsaW5lcyA9PT0gbnVsbCk7XG4gICAgICAgICAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRNID0gbWFwcGluZy5tYXAocG9zLCAxKSwgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnNIZXJlLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VOZXdsaW5lcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZztcbiAgICAgICAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgMSArIG9mZnNldCArIG0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBzdGFydCArIDEsIG5vZGUudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQuY3JlYXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKSB7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09IGNoaWxkLnR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyAxICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBzdGFydCArIDEsIG5vZGUudHlwZS5zY2hlbWEudGV4dChcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbi8qKlxuQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG5XaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4qL1xuZnVuY3Rpb24gc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgbGV0IG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbiovXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICAgIGxldCBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICAgIGlmIChiYXNlIDwgMCB8fCAkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KGluZGV4LCBub2RlLmNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgb3ZlcnJpZGVDaGlsZCA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpICsgMV07XG4gICAgICAgIGlmIChvdmVycmlkZUNoaWxkKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIG92ZXJyaWRlQ2hpbGQudHlwZS5jcmVhdGUob3ZlcnJpZGVDaGlsZC5hdHRycykpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gICAgbGV0IGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICAgIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpO1xufVxuZnVuY3Rpb24gc3BsaXQodHIsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgIGxldCB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG4vKipcblRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbmpvaW5lZC5cbiovXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiZcbiAgICAgICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGNhbkFwcGVuZFdpdGhTdWJzdGl0dXRlZExpbmVicmVha3MoYSwgYikge1xuICAgIGlmICghYi5jb250ZW50LnNpemUpXG4gICAgICAgIGEudHlwZS5jb21wYXRpYmxlQ29udGVudChiLnR5cGUpO1xuICAgIGxldCBtYXRjaCA9IGEuY29udGVudE1hdGNoQXQoYS5jaGlsZENvdW50KTtcbiAgICBsZXQgeyBsaW5lYnJlYWtSZXBsYWNlbWVudCB9ID0gYS50eXBlLnNjaGVtYTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGxldCB0eXBlID0gY2hpbGQudHlwZSA9PSBsaW5lYnJlYWtSZXBsYWNlbWVudCA/IGEudHlwZS5zY2hlbWEubm9kZXMudGV4dCA6IGNoaWxkLnR5cGU7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEudHlwZS5hbGxvd3NNYXJrcyhjaGlsZC5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaC52YWxpZEVuZDtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzKGEsIGIpKTtcbn1cbi8qKlxuRmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdCBjYW4gYmUgam9pbmVkIHRvIHRoZVxuYmxvY2sgYmVmb3JlIChvciBhZnRlciBpZiBgZGlyYCBpcyBwb3NpdGl2ZSkuIFJldHVybnMgdGhlIGpvaW5hYmxlXG5wb2ludCwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcywgZGlyID0gLTEpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKGQgPT0gJHBvcy5kZXB0aCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlICYmICFiZWZvcmUuaXNUZXh0YmxvY2sgJiYgam9pbmFibGUoYmVmb3JlLCBhZnRlcikgJiZcbiAgICAgICAgICAgICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBkaXIgPCAwID8gJHBvcy5iZWZvcmUoZCkgOiAkcG9zLmFmdGVyKGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW4odHIsIHBvcywgZGVwdGgpIHtcbiAgICBsZXQgY29udmVydE5ld2xpbmVzID0gbnVsbDtcbiAgICBsZXQgeyBsaW5lYnJlYWtSZXBsYWNlbWVudCB9ID0gdHIuZG9jLnR5cGUuc2NoZW1hO1xuICAgIGxldCAkYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocG9zIC0gZGVwdGgpLCBiZWZvcmVUeXBlID0gJGJlZm9yZS5ub2RlKCkudHlwZTtcbiAgICBpZiAobGluZWJyZWFrUmVwbGFjZW1lbnQgJiYgYmVmb3JlVHlwZS5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBwcmUgPSBiZWZvcmVUeXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIjtcbiAgICAgICAgbGV0IHN1cHBvcnRMaW5lYnJlYWsgPSAhIWJlZm9yZVR5cGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShsaW5lYnJlYWtSZXBsYWNlbWVudCk7XG4gICAgICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoIXByZSAmJiBzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGV0ICRhZnRlciA9IHRyLmRvYy5yZXNvbHZlKHBvcyArIGRlcHRoKTtcbiAgICAgICAgcmVwbGFjZUxpbmVicmVha3ModHIsICRhZnRlci5ub2RlKCksICRhZnRlci5iZWZvcmUoKSwgbWFwRnJvbSk7XG4gICAgfVxuICAgIGlmIChiZWZvcmVUeXBlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MgKyBkZXB0aCAtIDEsIGJlZm9yZVR5cGUsICRiZWZvcmUubm9kZSgpLmNvbnRlbnRNYXRjaEF0KCRiZWZvcmUuaW5kZXgoKSksIGNvbnZlcnROZXdsaW5lcyA9PSBudWxsKTtcbiAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSksIHN0YXJ0ID0gbWFwcGluZy5tYXAocG9zIC0gZGVwdGgpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHN0YXJ0LCBtYXBwaW5nLm1hcChwb3MgKyBkZXB0aCwgLTEpLCBTbGljZS5lbXB0eSwgdHJ1ZSkpO1xuICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IHRydWUpIHtcbiAgICAgICAgbGV0ICRmdWxsID0gdHIuZG9jLnJlc29sdmUoc3RhcnQpO1xuICAgICAgICByZXBsYWNlTmV3bGluZXModHIsICRmdWxsLm5vZGUoKSwgJGZ1bGwuYmVmb3JlKCksIHRyLnN0ZXBzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSBwb2ludCB3aGVyZSBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgY2FuIGJlIGluc2VydGVkXG5uZWFyIGBwb3NgLCBieSBzZWFyY2hpbmcgdXAgdGhlIG5vZGUgaGllcmFyY2h5IHdoZW4gYHBvc2AgaXRzZWxmXG5pc24ndCBhIHZhbGlkIHBsYWNlIGJ1dCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbm9kZS4gUmV0dXJuXG5udWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmJlZm9yZShkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09ICRwb3MucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAkcG9zLm5vZGUoZCkuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5GaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG5zbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbmFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbnN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghc2xpY2UuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gKHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLnNpemUgPyAyIDogMSk7IHBhc3MrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG7igJhGaXTigJkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuW3N0ZXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG50aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG53b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbiovXG5mdW5jdGlvbiByZXBsYWNlU3RlcChkb2MsIGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAgIC8vIE9wdGltaXphdGlvbiAtLSBhdm9pZCB3b3JrIGlmIGl0J3Mgb2J2aW91cyB0aGF0IGl0J3Mgbm90IG5lZWRlZC5cbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KCk7XG59XG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxuY2xhc3MgRml0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkZnJvbSwgJHRvLCB1bnBsYWNlZCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxOyB9XG4gICAgZml0KCkge1xuICAgICAgICAvLyBBcyBsb25nIGFzIHRoZXJlJ3MgdW5wbGFjZWQgY29udGVudCwgdHJ5IHRvIHBsYWNlIHNvbWUgb2YgaXQuXG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGVpdGhlciBpbmNyZWFzZSB0aGUgb3BlbiBzY29yZSBvZiB0aGUgdW5wbGFjZWRcbiAgICAgICAgLy8gc2xpY2UsIG9yIGRyb3Agbm9kZXMgZnJvbSBpdCwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICAgICAgICAgIGlmIChmaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZU5vZGVzKGZpdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgICAgICAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgICAgICAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gICAgICAgIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICAgICAgICBsZXQgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgICBpZiAoISR0bylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKCRmcm9tLnBvcywgbW92ZUlubGluZSwgdGhpcy4kdG8ucG9zLCB0aGlzLiR0by5lbmQoKSwgc2xpY2UsIHBsYWNlZFNpemUpO1xuICAgICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4gICAgLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuICAgIC8vIGRlcHRocywgb25lIGZvciB0aGUgc2xpY2UgYW5kIG9uZSBmb3IgdGhlIGZyb250aWVyLlxuICAgIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RGVwdGggPSB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChjdXIuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIG9wZW5FbmQgPD0gZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gICAgICAgIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgICAgICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzbGljZURlcHRoID0gcGFzcyA9PSAxID8gc3RhcnREZXB0aCA6IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCwgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBtYXRjaCB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSwgd3JhcCwgaW5qZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAyLCBsb29rIGZvciBhIHNldCBvZiB3cmFwcGluZyBub2RlcyB0aGF0IG1ha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpcnN0YCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmICh3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgd3JhcCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3Blbk1vcmUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJvcE5vZGUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuICAgIC8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuICAgIC8vIGFwcGxpY2FibGUuXG4gICAgcGxhY2VOb2Rlcyh7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0LCB3cmFwIH0pIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAod3JhcClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMudW5wbGFjZWQsIGZyYWdtZW50ID0gcGFyZW50ID8gcGFyZW50LmNvbnRlbnQgOiBzbGljZS5jb250ZW50O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgICAgbGV0IHRha2VuID0gMCwgYWRkID0gW107XG4gICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgICAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbW91bnQgb2YgKGVuZCkgb3BlbiBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBmcmFnbWVudC4gV2hlbiAwLCB0aGUgcGFyZW50IGlzIG9wZW4sIGJ1dCBubyBtb3JlLiBXaGVuXG4gICAgICAgIC8vIG5lZ2F0aXZlLCBub3RoaW5nIGlzIG9wZW4uXG4gICAgICAgIGxldCBvcGVuRW5kQ291bnQgPSAoZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGgpIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAvLyBTY2FuIG92ZXIgdGhlIGZyYWdtZW50LCBmaXR0aW5nIGFzIG1hbnkgY2hpbGQgbm9kZXMgYXNcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0YWtlbisrO1xuICAgICAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gICAgICAgIGlmICghdG9FbmQpXG4gICAgICAgICAgICBvcGVuRW5kQ291bnQgPSAtMTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICAgICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdHlwZXMgbWF0Y2gsIGFuZCB0aGUgZW50aXJlIG5vZGUgd2FzIG1vdmVkLCBhbmRcbiAgICAgICAgLy8gaXQncyBub3Qgb3BlbiwgY2xvc2UgdGhpcyBmcm9udGllciBub2RlIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyID0gZnJhZ21lbnQ7IGkgPCBvcGVuRW5kQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpIH0pO1xuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgICAgICAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgICBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgeyBkZXB0aCB9ID0gdGhpcy4kdG8sIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSlcbiAgICAgICAgICAgICsrYWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gICAgZmluZENsb3NlTGV2ZWwoJHRvKSB7XG4gICAgICAgIHNjYW46IGZvciAobGV0IGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbaV07XG4gICAgICAgICAgICBsZXQgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IGZpdCA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBpLCB0eXBlLCBtYXRjaCwgZHJvcElubmVyKTtcbiAgICAgICAgICAgIGlmICghZml0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUsIG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGVwdGg6IGksIGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoJHRvKSB7XG4gICAgICAgIGxldCBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgICAgICAgaWYgKCFjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpO1xuICAgICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgICBmb3IgKGxldCBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgICBvcGVuRnJvbnRpZXJOb2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2ggfSk7XG4gICAgfVxuICAgIGNsb3NlRnJvbnRpZXJOb2RlKCkge1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICAgIGxldCBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoYWRkLmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9kZVN0YXJ0KG5vZGUsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPD0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKG9wZW5TdGFydCA+IDEpXG4gICAgICAgIGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7XG4gICAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgICAgIGlmIChvcGVuRW5kIDw9IDApXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGRlcHRoKSwgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICAgIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZSh0ciwgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgbGV0IHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sIHRyLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgLy8gQ2FuJ3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQsIHNvIHJlbW92ZSAwIGlmIGl0J3MgcHJlc2VudFxuICAgIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApXG4gICAgICAgIHRhcmdldERlcHRocy5wb3AoKTtcbiAgICAvLyBOZWdhdGl2ZSBudW1iZXJzIHJlcHJlc2VudCBub3QgZXhwYW5zaW9uIG92ZXIgdGhlIHdob2xlIG5vZGUgYXRcbiAgICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gICAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcbiAgICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gICAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgICAvLyBkZXB0aHMgZm9yIGFueSBkZXB0aCB0aGF0IGhhcyAkZnJvbSBhdCBpdHMgc3RhcnQgYW5kIGRvZXMgbm90XG4gICAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICAgICAgbGV0IHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICAgICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSlcbiAgICAgICAgICAgIHByZWZlcnJlZFRhcmdldCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpXG4gICAgICAgICAgICB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpdCBlYWNoIHBvc3NpYmxlIGRlcHRoIG9mIHRoZSBzbGljZSBpbnRvIGVhY2ggcG9zc2libGVcbiAgICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcbiAgICBsZXQgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICAgIGZvciAobGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICAvLyBCYWNrIHVwIHByZWZlcnJlZERlcHRoIHRvIGNvdmVyIGRlZmluaW5nIHRleHRibG9ja3MgZGlyZWN0bHlcbiAgICAvLyBhYm92ZSBpdCwgcG9zc2libHkgc2tpcHBpbmcgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrLlxuICAgIGZvciAobGV0IGQgPSBwcmVmZXJyZWREZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IGxlZnROb2Rlc1tkXSwgZGVmID0gZGVmaW5lc0NvbnRlbnQobGVmdE5vZGUudHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgIWxlZnROb2RlLnNhbWVNYXJrdXAoJGZyb20ubm9kZShNYXRoLmFicyhwcmVmZXJyZWRUYXJnZXQpIC0gMSkpKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIWxlZnROb2RlLnR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQgJiZcbiAgICAgICAgICAgICRmcm9tLnN0YXJ0KGQgLSAxKSA9PSAkdG8uc3RhcnQoZCAtIDEpICYmICRmcm9tLm5vZGUoZCAtIDEpLmNhblJlcGxhY2UoJGZyb20uaW5kZXgoZCAtIDEpLCAkdG8uaW5kZXgoZCAtIDEpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGQpLCB0byk7XG4gICAgfVxuICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG59XG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkZXB0aHMgZm9yIHdoaWNoICRmcm9tIC0gJHRvIHNwYW5zIHRoZVxuLy8gd2hvbGUgY29udGVudCBvZiB0aGUgbm9kZXMgYXQgdGhhdCBkZXB0aC5cbmZ1bmN0aW9uIGNvdmVyZWREZXB0aHMoJGZyb20sICR0bykge1xuICAgIGxldCByZXN1bHQgPSBbXSwgbWluRGVwdGggPSBNYXRoLm1pbigkZnJvbS5kZXB0aCwgJHRvLmRlcHRoKTtcbiAgICBmb3IgKGxldCBkID0gbWluRGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGQpO1xuICAgICAgICBpZiAoc3RhcnQgPCAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJHRvLmVuZChkKSA+ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAgICAgJHRvLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoc3RhcnQgPT0gJHRvLnN0YXJ0KGQpIHx8XG4gICAgICAgICAgICAoZCA9PSAkZnJvbS5kZXB0aCAmJiBkID09ICR0by5kZXB0aCAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICBkICYmICR0by5zdGFydChkIC0gMSkgPT0gc3RhcnQgLSAxKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEF0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBhdHRyaWJ1dGUgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIG5vZGUuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IG5vZGUuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcCh0aGlzLnBvcywgdGhpcy5hdHRyLCBkb2Mubm9kZUF0KHRoaXMucG9zKS5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEF0dHJTdGVwKHBvcy5wb3MsIHRoaXMuYXR0ciwgdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYXR0clwiLCBwb3M6IHRoaXMucG9zLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAoanNvbi5wb3MsIGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhdHRyXCIsIEF0dHJTdGVwKTtcbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgZG9jIG5vZGUuXG4qL1xuY2xhc3MgRG9jQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBkb2MuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGRvYy5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZG9jLnR5cGUuY3JlYXRlKGF0dHJzLCBkb2MuY29udGVudCwgZG9jLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2sodXBkYXRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcCh0aGlzLmF0dHIsIGRvYy5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiZG9jQXR0clwiLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRG9jQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAoanNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImRvY0F0dHJcIiwgRG9jQXR0clN0ZXApO1xuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmxldCBUcmFuc2Zvcm1FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xufTtcblRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIGVyci5fX3Byb3RvX18gPSBUcmFuc2Zvcm1FcnJvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGVycjtcbn07XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm1FcnJvcjtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJUcmFuc2Zvcm1FcnJvclwiO1xuLyoqXG5BYnN0cmFjdGlvbiB0byBidWlsZCB1cCBhbmQgdHJhY2sgYW4gYXJyYXkgb2ZcbltzdGVwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSByZXByZXNlbnRpbmcgYSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi5cblxuTW9zdCB0cmFuc2Zvcm1pbmcgbWV0aG9kcyByZXR1cm4gdGhlIGBUcmFuc2Zvcm1gIG9iamVjdCBpdHNlbGYsIHNvXG50aGF0IHRoZXkgY2FuIGJlIGNoYWluZWQuXG4qL1xuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmFuc2Zvcm0gdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudCAodGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNmb3JtKS5cbiAgICAqL1xuICAgIGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGRvY3VtZW50cyBiZWZvcmUgZWFjaCBvZiB0aGUgc3RlcHMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQSBtYXBwaW5nIHdpdGggdGhlIG1hcHMgZm9yIGVhY2ggb2YgdGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGJlZm9yZSgpIHsgcmV0dXJuIHRoaXMuZG9jcy5sZW5ndGggPyB0aGlzLmRvY3NbMF0gOiB0aGlzLmRvYzsgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgbmV3IHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm0sIHNhdmluZyB0aGUgcmVzdWx0LiBUaHJvd3MgYW5cbiAgICBlcnJvciB3aGVuIHRoZSBzdGVwIGZhaWxzLlxuICAgICovXG4gICAgc3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChzdGVwKTtcbiAgICAgICAgaWYgKHJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gYXBwbHkgYSBzdGVwIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIGlnbm9yaW5nIGl0IGlmIGl0XG4gICAgZmFpbHMuIFJldHVybnMgdGhlIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgbWF5YmVTdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0ZXAuYXBwbHkodGhpcy5kb2MpO1xuICAgICAgICBpZiAoIXJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCwgcmVzdWx0LmRvYyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gY2hhbmdlZCAod2hlbiB0aGVyZSBhcmUgYW55XG4gICAgc3RlcHMpLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2NzLnB1c2godGhpcy5kb2MpO1xuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgICAgIHRoaXMubWFwcGluZy5hcHBlbmRNYXAoc3RlcC5nZXRNYXAoKSk7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB3aXRoIHRoZVxuICAgIGdpdmVuIGBzbGljZWAuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHRoaXMuZG9jLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgIHRoaXMuc3RlcChzdGVwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQsIHdoaWNoIG1heSBiZSBhXG4gICAgZnJhZ21lbnQsIG5vZGUsIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGRlbGV0ZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBTbGljZS5lbXB0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEluc2VydCB0aGUgZ2l2ZW4gY29udGVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpbnNlcnQocG9zLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKHBvcywgcG9zLCBjb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4gc2xpY2UsIHVzaW5nXG4gICAgYGZyb21gLCBgdG9gLCBhbmQgdGhlIHNsaWNlJ3NcbiAgICBbYG9wZW5TdGFydGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TbGljZS5vcGVuU3RhcnQpIHByb3BlcnR5IGFzIGhpbnRzLCByYXRoZXJcbiAgICB0aGFuIGZpeGVkIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLiBUaGlzIG1ldGhvZCBtYXkgZ3JvdyB0aGVcbiAgICByZXBsYWNlZCBhcmVhIG9yIGNsb3NlIG9wZW4gbm9kZXMgaW4gdGhlIHNsaWNlIGluIG9yZGVyIHRvIGdldCBhXG4gICAgZml0IHRoYXQgaXMgbW9yZSBpbiBsaW5lIHdpdGggV1lTSVdZRyBleHBlY3RhdGlvbnMsIGJ5IGRyb3BwaW5nXG4gICAgZnVsbHkgY292ZXJlZCBwYXJlbnQgbm9kZXMgb2YgdGhlIHJlcGxhY2VkIHJlZ2lvbiB3aGVuIHRoZXkgYXJlXG4gICAgbWFya2VkIFtub24tZGVmaW5pbmcgYXNcbiAgICBjb250ZXh0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdBc0NvbnRleHQpLCBvciBpbmNsdWRpbmcgYW5cbiAgICBvcGVuIHBhcmVudCBub2RlIGZyb20gdGhlIHNsaWNlIHRoYXQgX2lzXyBtYXJrZWQgYXMgW2RlZmluaW5nXG4gICAgaXRzIGNvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQpLlxuICAgIFxuICAgIFRoaXMgaXMgdGhlIG1ldGhvZCwgZm9yIGV4YW1wbGUsIHRvIGhhbmRsZSBwYXN0ZS4gVGhlIHNpbWlsYXJcbiAgICBbYHJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybS5yZXBsYWNlKSBtZXRob2QgaXMgYSBtb3JlXG4gICAgcHJpbWl0aXZlIHRvb2wgd2hpY2ggd2lsbCBfbm90XyBtb3ZlIHRoZSBzdGFydCBhbmQgZW5kIG9mIGl0cyBnaXZlblxuICAgIHJhbmdlLCBhbmQgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IG5lZWQgbW9yZSBwcmVjaXNlXG4gICAgY29udHJvbCBvdmVyIHdoYXQgaGFwcGVucy5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZSwgYnV0IHVzZSBgZnJvbWAgYW5kIGB0b2AgYXNcbiAgICBoaW50cywgcmF0aGVyIHRoYW4gcHJlY2lzZSBwb3NpdGlvbnMuIFdoZW4gZnJvbSBhbmQgdG8gYXJlIHRoZSBzYW1lXG4gICAgYW5kIGFyZSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgcGFyZW50IG5vZGUgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgbm9kZSBkb2Vzbid0IGZpdCwgdGhpcyBtZXRob2QgbWF5IF9tb3ZlXyB0aGVtIG91dCB0b3dhcmRzIGEgcGFyZW50XG4gICAgdGhhdCBkb2VzIGFsbG93IHRoZSBnaXZlbiBub2RlIHRvIGJlIHBsYWNlZC4gV2hlbiB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICBjb21wbGV0ZWx5IGNvdmVycyBhIHBhcmVudCBub2RlLCB0aGlzIG1ldGhvZCBtYXkgY29tcGxldGVseSByZXBsYWNlXG4gICAgdGhhdCBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlV2l0aCh0aGlzLCBmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGdpdmVuIHJhbmdlLCBleHBhbmRpbmcgaXQgdG8gY292ZXIgZnVsbHkgY292ZXJlZFxuICAgIHBhcmVudCBub2RlcyB1bnRpbCBhIHZhbGlkIHJlcGxhY2UgaXMgZm91bmQuXG4gICAgKi9cbiAgICBkZWxldGVSYW5nZShmcm9tLCB0bykge1xuICAgICAgICBkZWxldGVSYW5nZSh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2Ugb2ZmIGZyb20gaXRzIHBhcmVudCwgaWYgdGhlcmVcbiAgICBpcyBzaWJsaW5nIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIGl0LCBhbmQgbW92ZSBpdCB1cCB0aGUgdHJlZSB0b1xuICAgIHRoZSBkZXB0aCBzcGVjaWZpZWQgYnkgYHRhcmdldGAuIFlvdSdsbCBwcm9iYWJseSB3YW50IHRvIHVzZVxuICAgIFtgbGlmdFRhcmdldGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0ubGlmdFRhcmdldCkgdG8gY29tcHV0ZSBgdGFyZ2V0YCwgdG8gbWFrZVxuICAgIHN1cmUgdGhlIGxpZnQgaXMgdmFsaWQuXG4gICAgKi9cbiAgICBsaWZ0KHJhbmdlLCB0YXJnZXQpIHtcbiAgICAgICAgbGlmdCh0aGlzLCByYW5nZSwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gdGhlIGJsb2NrcyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJZiBkZXB0aCBpcyAyLCB0aGVpclxuICAgIGxhc3QgYW5kIGZpcnN0IHNpYmxpbmdzIGFyZSBhbHNvIGpvaW5lZCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgam9pbihwb3MsIGRlcHRoID0gMSkge1xuICAgICAgICBqb2luKHRoaXMsIHBvcywgZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV3JhcCB0aGUgZ2l2ZW4gW3JhbmdlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlKSBpbiB0aGUgZ2l2ZW4gc2V0IG9mIHdyYXBwZXJzLlxuICAgIFRoZSB3cmFwcGVycyBhcmUgYXNzdW1lZCB0byBiZSB2YWxpZCBpbiB0aGlzIHBvc2l0aW9uLCBhbmQgc2hvdWxkXG4gICAgcHJvYmFibHkgYmUgY29tcHV0ZWQgd2l0aCBbYGZpbmRXcmFwcGluZ2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uZmluZFdyYXBwaW5nKS5cbiAgICAqL1xuICAgIHdyYXAocmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgICAgIHdyYXAodGhpcywgcmFuZ2UsIHdyYXBwZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdHlwZSBvZiBhbGwgdGV4dGJsb2NrcyAocGFydGx5KSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB0b1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHNldEJsb2NrVHlwZShmcm9tLCB0byA9IGZyb20sIHR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgICAgICBzZXRCbG9ja1R5cGUodGhpcywgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuICAgIFdoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiAgICAqL1xuICAgIHNldE5vZGVNYXJrdXAocG9zLCB0eXBlLCBhdHRycyA9IG51bGwsIG1hcmtzKSB7XG4gICAgICAgIHNldE5vZGVNYXJrdXAodGhpcywgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhIGdpdmVuIG5vZGUgdG8gYSBuZXcgdmFsdWUuXG4gICAgVGhlIGBwb3NgIGFkZHJlc3NlcyB0aGUgZG9jdW1lbnQgY29udGVudC4gVXNlIGBzZXREb2NBdHRyaWJ1dGVgXG4gICAgdG8gc2V0IGF0dHJpYnV0ZXMgb24gdGhlIGRvY3VtZW50IGl0c2VsZi5cbiAgICAqL1xuICAgIHNldE5vZGVBdHRyaWJ1dGUocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEF0dHJTdGVwKHBvcywgYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IHRvIGEgbmV3IHZhbHVlLlxuICAgICovXG4gICAgc2V0RG9jQXR0cmlidXRlKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgRG9jQXR0clN0ZXAoYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIG5vZGUgYXQgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIChvciBhIG1hcmsgb2YgdGhlIGdpdmVuIHR5cGUpIGZyb20gdGhlIG5vZGUgYXRcbiAgICBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICBpZiAoIShtYXJrIGluc3RhbmNlb2YgTWFyaykpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgICAgIG1hcmsgPSBtYXJrLmlzSW5TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAoIW1hcmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4gICAgZ3JlYXRlciB0aGFuIG9uZSwgYW55IG51bWJlciBvZiBub2RlcyBhYm92ZSB0aGF0LiBCeSBkZWZhdWx0LCB0aGVcbiAgICBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4gICAgdXNlIGFmdGVyIHRoZSBzcGxpdC5cbiAgICAqL1xuICAgIHNwbGl0KHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgICAgIHNwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgYWRkTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgbWFya3MgZnJvbSBpbmxpbmUgbm9kZXMgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgbWFya2AgaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXNcbiAgICBhIG1hcmsgdHlwZSwgcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCxcbiAgICByZW1vdmUgYWxsIG1hcmtzIG9mIGFueSB0eXBlLlxuICAgICovXG4gICAgcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICByZW1vdmVNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0XG4gICAgYHBvc2AgdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHNcbiAgICBhbiBvcHRpb25hbCBzdGFydGluZyBbY29udGVudCBtYXRjaF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkNvbnRlbnRNYXRjaCkgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIEFkZE5vZGVNYXJrU3RlcCwgQXR0clN0ZXAsIERvY0F0dHJTdGVwLCBNYXBSZXN1bHQsIE1hcHBpbmcsIFJlbW92ZU1hcmtTdGVwLCBSZW1vdmVOb2RlTWFya1N0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCwgU3RlcCwgU3RlcE1hcCwgU3RlcFJlc3VsdCwgVHJhbnNmb3JtLCBUcmFuc2Zvcm1FcnJvciwgY2FuSm9pbiwgY2FuU3BsaXQsIGRyb3BQb2ludCwgZmluZFdyYXBwaW5nLCBpbnNlcnRQb2ludCwgam9pblBvaW50LCBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-transform/dist/index.js\n");

/***/ })

};
;