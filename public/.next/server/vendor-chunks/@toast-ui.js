/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@toast-ui";
exports.ids = ["vendor-chunks/@toast-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ ToastUIEditor),\n/* harmony export */   EditorCore: () => (/* binding */ ToastUIEditorCore),\n/* harmony export */   \"default\": () => (/* binding */ ToastUIEditor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n/* harmony import */ var prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-inputrules */ \"(ssr)/./node_modules/prosemirror-inputrules/dist/index.js\");\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n/**\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics$1 = function(d, b) {\r\n    extendStatics$1 = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics$1(d, b);\r\n};\r\n\r\nfunction __extends$1(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics$1(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign$1 = function() {\r\n    __assign$1 = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray$1(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n}\n\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';\n * \n * // CommonJS\n * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties$2(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nvar forEachOwnProperties_1 = forEachOwnProperties$2;\n\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nvar extend_1 = extend;\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString$3(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nvar isString_1 = isString$3;\n\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray$3(obj) {\n  return obj instanceof Array;\n}\n\nvar isArray_1 = isArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from 'tui-code-snippet/collection/forEachArray';\n * \n * // CommonJS\n * const forEachArray = require('tui-code-snippet/collection/forEachArray'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray$3(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nvar forEachArray_1 = forEachArray$3;\n\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray$2 = isArray_1;\nvar forEachArray$2 = forEachArray_1;\nvar forEachOwnProperties$1 = forEachOwnProperties_1;\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from 'tui-code-snippet/collection/forEach'; \n * \n * // CommonJS\n * const forEach = require('tui-code-snippet/collection/forEach'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach$4(obj, iteratee, context) {\n  if (isArray$2(obj)) {\n    forEachArray$2(obj, iteratee, context);\n  } else {\n    forEachOwnProperties$1(obj, iteratee, context);\n  }\n}\n\nvar forEach_1 = forEach$4;\n\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$2 = isString_1;\nvar forEach$3 = forEach_1;\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString$2(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach$3(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nvar css_1 = css;\n\n/* eslint-disable complexity */\n\nvar isArray$1 = isArray_1;\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from 'tui-code-snippet/array/inArray';\n * \n * // CommonJS\n * const inArray = require('tui-code-snippet/array/inArray');\n *\n * const arr = ['one', 'two', 'three', 'four'];\n * const idx1 = inArray('one', arr, 3); // -1\n * const idx2 = inArray('one', arr); // 0\n */\nfunction inArray$4(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray$1(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nvar inArray_1 = inArray$4;\n\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined$4(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nvar isUndefined_1 = isUndefined$4;\n\n/**\n * @fileoverview Get HTML element's design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$3 = isUndefined_1;\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass$3(element) {\n  if (!element || !element.className) {\n    return '';\n  }\n\n  if (isUndefined$3(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nvar getClass_1 = getClass$3;\n\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isArray = isArray_1;\nvar isUndefined$2 = isUndefined_1;\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName$2(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n  if (isUndefined$2(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nvar _setClassName = setClassName$2;\n\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEach$2 = forEach_1;\nvar inArray$3 = inArray_1;\nvar getClass$2 = getClass_1;\nvar setClassName$1 = _setClassName;\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach$2(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$2(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach$2(cssClass, function(cls) {\n    if (inArray$3(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName$1(element, newClass);\n}\n\nvar addClass_1 = addClass;\n\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray$1 = forEachArray_1;\nvar inArray$2 = inArray_1;\nvar getClass$1 = getClass_1;\nvar setClassName = _setClassName;\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray$1(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass$1(element).split(/\\s+/);\n  newClass = [];\n  forEachArray$1(origin, function(name) {\n    if (inArray$2(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nvar removeClass_1 = removeClass;\n\n/**\n * @fileoverview Check whether the given variable is a number or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a number or not.\n * If the given variable is a number, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is number?\n * @memberof module:type\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number' || obj instanceof Number;\n}\n\nvar isNumber_1 = isNumber;\n\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull$1(obj) {\n  return obj === null;\n}\n\nvar isNull_1 = isNull$1;\n\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachOwnProperties = forEachOwnProperties_1;\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from 'tui-code-snippet/request/imagePing';\n * \n * // CommonJS\n * const imagePing = require('tui-code-snippet/request/imagePing');\n *\n * imagePing('https://www.google-analytics.com/collect', {\n *   v: 1,\n *   t: 'event',\n *   tid: 'trackingid',\n *   cid: 'cid',\n *   dp: 'dp',\n *   dh: 'dh'\n * });\n */\nfunction imagePing$1(url, trackingInfo) {\n  var trackingElement = document.createElement('img');\n  var queryString = '';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += '&' + key + '=' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + '?' + queryString;\n\n  trackingElement.style.display = 'none';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nvar imagePing_1 = imagePing$1;\n\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined$1 = isUndefined_1;\nvar imagePing = imagePing_1;\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = 'https://www.google-analytics.com/collect';\n  var hostname = location.hostname;\n  var hitType = 'event';\n  var eventCategory = 'use';\n  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined$1(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nvar sendHostname_1 = sendHostname;\n\n/Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar reEscapeChars$1 = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar XMLSPECIAL$1 = '[&<>\"]';\nvar reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, 'g');\nfunction replaceUnsafeChar$1(char) {\n    switch (char) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return char;\n    }\n}\nfunction escapeXml$1(text) {\n    if (reXmlSpecial$1.test(text)) {\n        return text.replace(reXmlSpecial$1, replaceUnsafeChar$1);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname_1('editor', 'UA-129966929-1');\n}\nfunction includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_1(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction repeat$1(text, count) {\n    var result = '';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties_1(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : \"\\\\\" + matched;\n    });\n}\nfunction escape$1(text) {\n    var aheadReplacer = function (matched) { return \"\\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + \"\\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, ' ');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(reEscapeChars$1, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf('\"') === -1) {\n        result = '\"\"';\n    }\n    else {\n        result = text.indexOf(\"'\") === -1 ? \"''\" : '()';\n    }\n    return result[0] + text + result[1];\n}\nfunction isNil(value) {\n    return isNull_1(value) || isUndefined_1(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== 'object' || typeof o2 !== 'object' || isNil(o1) || isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction between$1(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject$1(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = __assign$1({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject$1(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject$1(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject$1(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar forEachArray = forEachArray_1;\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from 'tui-code-snippet/collection/toArray'; \n * \n * // CommonJS\n * const toArray = require('tui-code-snippet/collection/toArray'); \n *\n * const arrayLike = {\n *   0: 'one',\n *   1: 'two',\n *   2: 'three',\n *   3: 'four',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray$1(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nvar toArray_1 = toArray$1;\n\nfunction createParagraph(schema, content) {\n    var paragraph = schema.nodes.paragraph;\n    if (!content) {\n        return paragraph.createAndFill();\n    }\n    return paragraph.create(null, isString_1(content) ? schema.text(content) : content);\n}\nfunction createTextNode$1(schema, text, marks) {\n    return schema.text(text, marks);\n}\nfunction createTextSelection(tr, from, to) {\n    if (to === void 0) { to = from; }\n    var contentSize = tr.doc.content.size;\n    var size = contentSize > 0 ? contentSize - 1 : 1;\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, Math.min(from, size), Math.min(to, size));\n}\nfunction addParagraph(tr, _a, schema) {\n    var pos = _a.pos;\n    tr.replaceWith(pos, pos, createParagraph(schema));\n    return tr.setSelection(createTextSelection(tr, pos + 1));\n}\nfunction replaceTextNode(_a) {\n    var state = _a.state, from = _a.from, startIndex = _a.startIndex, endIndex = _a.endIndex, createText = _a.createText;\n    var tr = state.tr, doc = state.doc, schema = state.schema;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        var _b = doc.child(i), nodeSize = _b.nodeSize, textContent = _b.textContent, content = _b.content;\n        var text = createText(textContent);\n        var node = text ? createTextNode$1(schema, text) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n        var mappedFrom = tr.mapping.map(from);\n        var mappedTo = mappedFrom + content.size;\n        tr.replaceWith(mappedFrom, mappedTo, node);\n        from += nodeSize;\n    }\n    return tr;\n}\nfunction splitAndExtendBlock(tr, pos, text, node) {\n    var textLen = text.length;\n    tr.split(pos)\n        .delete(pos - textLen, pos)\n        .insert(tr.mapping.map(pos), node)\n        .setSelection(createTextSelection(tr, tr.mapping.map(pos) - textLen));\n}\n\nfunction getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'htmlBlock' || type === 'htmlInline';\n}\nfunction isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === 'strike' ||\n        type === 'strong' ||\n        type === 'emph' ||\n        type === 'code' ||\n        type === 'link' ||\n        type === 'image');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'codeBlock';\n}\nfunction isListNode$1(mdNode) {\n    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type === 'ordered';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode$1(mdNode) && mdNode.listData.type !== 'ordered';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');\n}\nfunction isInlineNode$1(mdNode) {\n    switch (mdNode.type) {\n        case 'code':\n        case 'text':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'htmlInline':\n        case 'linebreak':\n        case 'softbreak':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case 'emph':\n            return \"*\" + text + \"*\";\n        case 'strong':\n            return \"**\" + text + \"**\";\n        case 'strike':\n            return \"~~\" + text + \"~~\";\n        case 'code':\n            return \"`\" + text + \"`\";\n        case 'link':\n        case 'image':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === 'link' ? '' : '!';\n            return delim + \"[\" + text + \"](\" + destination + (title ? \" \\\"\" + title + \"\\\"\" : '') + \")\";\n        default:\n            return null;\n    }\n}\nfunction isContainer$2(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getChildrenText$1(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === 'text') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join('');\n}\n\nvar widgetRules = [];\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return \"$$\" + info + \" \" + text + \"$$\";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap[\"widget\" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = \"widget\" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = '';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== 'text') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === 'text') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\nfunction getDefaultCommands() {\n    return {\n        deleteSelection: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.deleteSelection; },\n        selectAll: function () { return prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.selectAll; },\n        undo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo; },\n        redo: function () { return prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo; },\n    };\n}\n\nfunction placeholder(options) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: function (state) {\n                var doc = state.doc;\n                if (options.text &&\n                    doc.childCount === 1 &&\n                    doc.firstChild.isTextblock &&\n                    doc.firstChild.content.size === 0) {\n                    var placeHolder = document.createElement('span');\n                    addClass_1(placeHolder, 'placeholder');\n                    if (options.className) {\n                        addClass_1(placeHolder, options.className);\n                    }\n                    placeHolder.textContent = options.text;\n                    return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.widget(1, placeHolder)]);\n                }\n                return null;\n            },\n        },\n    });\n}\n\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray$1 = inArray_1;\nvar getClass = getClass_1;\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray$1(cssClass, origin) > -1;\n}\n\nvar hasClass_1 = hasClass;\n\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar inArray = inArray_1;\nvar toArray = toArray_1;\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nvar matches_1 = matches;\n\nvar TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTED_VALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLE_QUOTED_VALUE = \"'[^']*'\";\nvar DOUBLE_QUOTED_VALUE = '\"[^\"]*\"';\nvar ATTRIBUTE_VALUE = \"(?:\" + UNQUOTED_VALUE + \"|\" + SINGLE_QUOTED_VALUE + \"|\" + DOUBLE_QUOTED_VALUE + \")\";\nvar ATTRIBUTE_VALUE_SPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTE_VALUE + \")\";\nvar ATTRIBUTE$1 = \"\" + '(?:\\\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + \"?)\";\nvar OPEN_TAG = \"<(\" + TAG_NAME + \")(\" + ATTRIBUTE$1 + \")*\\\\s*/?>\";\nvar CLOSE_TAG = \"</(\" + TAG_NAME + \")\\\\s*[>]\";\nvar HTML_TAG = \"(?:\" + OPEN_TAG + \"|\" + CLOSE_TAG + \")\";\nvar reHTMLTag = new RegExp(\"^\" + HTML_TAG, 'i');\nvar reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar ALTERNATIVE_TAG_FOR_BR = '</p><p>';\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = 'toastui-editor-';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name_1 = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name_1)) {\n            className = name_1[0] ? name_1[1] : null;\n        }\n        else {\n            className = name_1;\n        }\n        if (className) {\n            result.push(\"\" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(' ');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + \"md-\" + className; }).join(' ');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray_1(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray_1(nodesToAppend) ? toArray_1(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode$1(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode$1(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_1(state)) {\n        state = !hasClass_1(element, className);\n    }\n    var toggleFn = state ? addClass_1 : removeClass_1;\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement('div');\n    if (isString_1(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString_1(found)) {\n        condition = function (target) { return matches_1(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top_1 = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top_1;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, '<p></p>');\n    var reHTMLTag = new RegExp(HTML_TAG, 'ig');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = \"</\" + tagName + \"><\" + tagName + \">\";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class=\"ProseMirror-separator\" alt=\"\">/g;\n    var reProseMirrorTrailingBreak = / class=\"ProseMirror-trailingBreak\"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, '');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');\n    return resultHTML;\n}\n\nvar pluginKey$1 = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('widget');\nvar MARGIN = 5;\nvar PopupWidget = /** @class */ (function () {\n    function PopupWidget(view, eventEmitter) {\n        var _this = this;\n        this.popup = null;\n        this.removeWidget = function () {\n            if (_this.popup) {\n                _this.rootEl.removeChild(_this.popup);\n                _this.popup = null;\n            }\n        };\n        this.rootEl = view.dom.parentElement;\n        this.eventEmitter = eventEmitter;\n        this.eventEmitter.listen('blur', this.removeWidget);\n        this.eventEmitter.listen('loadUI', function () {\n            _this.rootEl = closest(view.dom.parentElement, \".\" + cls('defaultUI'));\n        });\n        this.eventEmitter.listen('removePopupWidget', this.removeWidget);\n    }\n    PopupWidget.prototype.update = function (view) {\n        var widget = pluginKey$1.getState(view.state);\n        this.removeWidget();\n        if (widget) {\n            var node = widget.node, style = widget.style;\n            var _a = view.coordsAtPos(widget.pos), top_1 = _a.top, left = _a.left, bottom = _a.bottom;\n            var height = bottom - top_1;\n            var rect = this.rootEl.getBoundingClientRect();\n            var relTopPos = top_1 - rect.top;\n            css_1(node, { opacity: '0' });\n            this.rootEl.appendChild(node);\n            css_1(node, {\n                position: 'absolute',\n                left: left - rect.left + MARGIN + \"px\",\n                top: (style === 'bottom' ? relTopPos + height - MARGIN : relTopPos - height) + \"px\",\n                opacity: '1',\n            });\n            this.popup = node;\n            view.focus();\n        }\n    };\n    PopupWidget.prototype.destroy = function () {\n        this.eventEmitter.removeEventHandler('blur', this.removeWidget);\n    };\n    return PopupWidget;\n}());\nfunction addWidget(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey$1,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr) {\n                return tr.getMeta('widget');\n            },\n        },\n        view: function (editorView) {\n            return new PopupWidget(editorView, eventEmitter);\n        },\n    });\n}\n\nfunction addDefaultImageBlobHook(eventEmitter) {\n    eventEmitter.listen('addImageBlobHook', function (blob, callback) {\n        var reader = new FileReader();\n        reader.onload = function (_a) {\n            var target = _a.target;\n            return callback(target.result);\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nfunction emitImageBlobHook(eventEmitter, blob, type) {\n    var hook = function (imageUrl, altText) {\n        eventEmitter.emit('command', 'addImage', {\n            imageUrl: imageUrl,\n            altText: altText || blob.name || 'image',\n        });\n    };\n    eventEmitter.emit('addImageBlobHook', blob, hook, type);\n}\nfunction pasteImageOnly(items) {\n    var images = toArray_1(items).filter(function (_a) {\n        var type = _a.type;\n        return type.indexOf('image') !== -1;\n    });\n    if (images.length === 1) {\n        var item = images[0];\n        if (item) {\n            return item.getAsFile();\n        }\n    }\n    return null;\n}\n\nfunction dropImage(_a) {\n    var eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                drop: function (_, ev) {\n                    var _a;\n                    var items = (_a = ev.dataTransfer) === null || _a === void 0 ? void 0 : _a.files;\n                    if (items) {\n                        forEachArray_1(items, function (item) {\n                            if (item.type.indexOf('image') !== -1) {\n                                ev.preventDefault();\n                                ev.stopPropagation();\n                                emitImageBlobHook(eventEmitter, item, ev.type);\n                                return false;\n                            }\n                            return true;\n                        });\n                    }\n                    return true;\n                },\n            },\n        },\n    });\n}\n\nvar Node$2 = /** @class */ (function () {\n    function Node() {\n    }\n    Object.defineProperty(Node.prototype, \"type\", {\n        get: function () {\n            return 'node';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Node;\n}());\n\nfunction widgetNodeView(pmNode) {\n    var dom = document.createElement('span');\n    var node = widgetToDOM(pmNode.attrs.info, pmNode.textContent);\n    dom.className = 'tui-widget';\n    dom.appendChild(node);\n    return { dom: dom };\n}\nfunction isWidgetNode(pmNode) {\n    return pmNode.type.name === 'widget';\n}\nvar Widget = /** @class */ (function (_super) {\n    __extends$1(Widget, _super);\n    function Widget() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Widget.prototype, \"name\", {\n        get: function () {\n            return 'widget';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Widget.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    info: { default: null },\n                },\n                group: 'inline',\n                inline: true,\n                content: 'text*',\n                selectable: false,\n                atom: true,\n                toDOM: function () {\n                    return ['span', { class: 'tui-widget' }, 0];\n                },\n                parseDOM: [\n                    {\n                        tag: 'span.tui-widget',\n                        getAttrs: function (dom) {\n                            var text = dom.textContent;\n                            var _a = text.match(/\\$\\$(widget\\d+)/), info = _a[1];\n                            return { info: info };\n                        },\n                    },\n                ],\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Widget;\n}(Node$2));\n\nvar EditorBase = /** @class */ (function () {\n    function EditorBase(eventEmitter) {\n        this.timer = null;\n        this.el = document.createElement('div');\n        this.el.className = 'toastui-editor';\n        this.eventEmitter = eventEmitter;\n        this.placeholder = { text: '' };\n    }\n    EditorBase.prototype.createState = function () {\n        return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n            schema: this.schema,\n            plugins: this.createPlugins(),\n        });\n    };\n    EditorBase.prototype.initEvent = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, view = _a.view, editorType = _a.editorType;\n        view.dom.addEventListener('focus', function () { return eventEmitter.emit('focus', editorType); });\n        view.dom.addEventListener('blur', function () { return eventEmitter.emit('blur', editorType); });\n    };\n    EditorBase.prototype.emitChangeEvent = function (tr) {\n        this.eventEmitter.emit('caretChange', this.editorType);\n        if (tr.docChanged) {\n            this.eventEmitter.emit('change', this.editorType);\n        }\n    };\n    Object.defineProperty(EditorBase.prototype, \"defaultPlugins\", {\n        get: function () {\n            var rules = this.createInputRules();\n            var plugins = __spreadArray$1(__spreadArray$1([], this.keymaps), [\n                (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(__assign$1({ 'Shift-Enter': prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap.Enter }, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.baseKeymap)),\n                (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                placeholder(this.placeholder),\n                addWidget(this.eventEmitter),\n                dropImage(this.context),\n            ]);\n            return rules ? plugins.concat(rules) : plugins;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EditorBase.prototype.createInputRules = function () {\n        var widgetRules = getWidgetRules();\n        var rules = widgetRules.map(function (_a) {\n            var rule = _a.rule;\n            return new prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule(rule, function (state, match, start, end) {\n                var schema = state.schema, tr = state.tr, doc = state.doc;\n                var allMatched = match.input.match(new RegExp(rule, 'g'));\n                var pos = doc.resolve(start);\n                var parent = pos.parent;\n                var count = 0;\n                if (isWidgetNode(parent)) {\n                    parent = pos.node(pos.depth - 1);\n                }\n                parent.forEach(function (child) { return isWidgetNode(child) && (count += 1); });\n                // replace the content only if the count of matched rules in whole text is greater than current widget node count\n                if (allMatched.length > count) {\n                    var content = last$1(allMatched);\n                    var nodes = createNodesWithWidget(content, schema);\n                    // adjust start position based on widget content\n                    return tr.replaceWith(end - content.length + 1, end, nodes);\n                }\n                return null;\n            });\n        });\n        return rules.length ? (0,prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules)({ rules: rules }) : null;\n    };\n    EditorBase.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    EditorBase.prototype.createSchema = function () {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: this.specs.nodes,\n            marks: this.specs.marks,\n        });\n    };\n    EditorBase.prototype.createKeymaps = function (useCommandShortcut) {\n        var _a = getDefaultCommands(), undo = _a.undo, redo = _a.redo;\n        var allKeymaps = this.specs.keymaps(useCommandShortcut);\n        var historyKeymap = {\n            'Mod-z': undo(),\n            'Shift-Mod-z': redo(),\n        };\n        return useCommandShortcut ? allKeymaps.concat((0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(historyKeymap)) : allKeymaps;\n    };\n    EditorBase.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    EditorBase.prototype.createPluginProps = function () {\n        var _this = this;\n        return this.extraPlugins.map(function (plugin) { return plugin(_this.eventEmitter); });\n    };\n    EditorBase.prototype.focus = function () {\n        var _this = this;\n        this.clearTimer();\n        // prevent the error for IE11\n        this.timer = setTimeout(function () {\n            _this.view.focus();\n            _this.view.dispatch(_this.view.state.tr.scrollIntoView());\n        });\n    };\n    EditorBase.prototype.blur = function () {\n        this.view.dom.blur();\n    };\n    EditorBase.prototype.destroy = function () {\n        var _this = this;\n        this.clearTimer();\n        this.view.destroy();\n        Object.keys(this).forEach(function (prop) {\n            delete _this[prop];\n        });\n    };\n    EditorBase.prototype.moveCursorToStart = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.moveCursorToEnd = function (focus) {\n        var tr = this.view.state.tr;\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, tr.doc.content.size - 1)).scrollIntoView());\n        if (focus) {\n            this.focus();\n        }\n    };\n    EditorBase.prototype.setScrollTop = function (top) {\n        this.view.dom.scrollTop = top;\n    };\n    EditorBase.prototype.getScrollTop = function () {\n        return this.view.dom.scrollTop;\n    };\n    EditorBase.prototype.setPlaceholder = function (text) {\n        this.placeholder.text = text;\n        this.view.dispatch(this.view.state.tr.scrollIntoView());\n    };\n    EditorBase.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + \"px\" });\n    };\n    EditorBase.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + \"px\" });\n    };\n    EditorBase.prototype.getElement = function () {\n        return this.el;\n    };\n    return EditorBase;\n}());\n\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nvar isFunction_1 = isFunction;\n\nvar defaultCommandShortcuts = [\n    'Enter',\n    'Shift-Enter',\n    'Mod-Enter',\n    'Tab',\n    'Shift-Tab',\n    'Delete',\n    'Backspace',\n    'Mod-Delete',\n    'Mod-Backspace',\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight',\n    'Mod-d',\n    'Mod-D',\n    'Alt-ArrowUp',\n    'Alt-ArrowDown',\n];\nfunction execCommand(view, command, payload) {\n    view.focus();\n    return command(payload)(view.state, view.dispatch, view);\n}\nvar SpecManager = /** @class */ (function () {\n    function SpecManager(specs) {\n        this.specs = specs;\n    }\n    Object.defineProperty(SpecManager.prototype, \"nodes\", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === 'node'; })\n                .reduce(function (nodes, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, nodes), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SpecManager.prototype, \"marks\", {\n        get: function () {\n            return this.specs\n                .filter(function (spec) { return spec.type === 'mark'; })\n                .reduce(function (marks, _a) {\n                var _b;\n                var name = _a.name, schema = _a.schema;\n                return __assign$1(__assign$1({}, marks), (_b = {}, _b[name] = schema, _b));\n            }, {});\n        },\n        enumerable: false,\n        configurable: true\n    });\n    SpecManager.prototype.commands = function (view, addedCommands) {\n        var specCommands = this.specs\n            .filter(function (_a) {\n            var commands = _a.commands;\n            return commands;\n        })\n            .reduce(function (allCommands, spec) {\n            var commands = {};\n            var specCommand = spec.commands();\n            if (isFunction_1(specCommand)) {\n                commands[spec.name] = function (payload) { return execCommand(view, specCommand, payload); };\n            }\n            else {\n                Object.keys(specCommand).forEach(function (name) {\n                    commands[name] = function (payload) { return execCommand(view, specCommand[name], payload); };\n                });\n            }\n            return __assign$1(__assign$1({}, allCommands), commands);\n        }, {});\n        var defaultCommands = getDefaultCommands();\n        Object.keys(defaultCommands).forEach(function (name) {\n            specCommands[name] = function (payload) { return execCommand(view, defaultCommands[name], payload); };\n        });\n        if (addedCommands) {\n            Object.keys(addedCommands).forEach(function (name) {\n                specCommands[name] = function (payload) { return execCommand(view, addedCommands[name], payload); };\n            });\n        }\n        return specCommands;\n    };\n    SpecManager.prototype.keymaps = function (useCommandShortcut) {\n        var specKeymaps = this.specs.filter(function (spec) { return spec.keymaps; }).map(function (spec) { return spec.keymaps(); });\n        return specKeymaps.map(function (keys) {\n            if (!useCommandShortcut) {\n                Object.keys(keys).forEach(function (key) {\n                    if (!includes(defaultCommandShortcuts, key)) {\n                        delete keys[key];\n                    }\n                });\n            }\n            return (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)(keys);\n        });\n    };\n    SpecManager.prototype.setContext = function (context) {\n        this.specs.forEach(function (spec) {\n            spec.setContext(context);\n        });\n    };\n    return SpecManager;\n}());\n\nfunction resolveSelectionPos(selection) {\n    var from = selection.from, to = selection.to;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        return [from + 1, to - 1];\n    }\n    return [from, to];\n}\nfunction getMdLine(resolvedPos) {\n    return resolvedPos.index(0) + 1;\n}\nfunction getWidgetNodePos(node, chPos, direction) {\n    if (direction === void 0) { direction = 1; }\n    var additionalPos = 0;\n    node.forEach(function (child, pos) {\n        // add or subtract widget node tag\n        if (isWidgetNode(child) && pos + 2 < chPos) {\n            additionalPos += 2 * direction;\n        }\n    });\n    return additionalPos;\n}\nfunction getEditorToMdPos(doc, from, to) {\n    if (to === void 0) { to = from; }\n    var collapsed = from === to;\n    var startResolvedPos = doc.resolve(from);\n    var startLine = getMdLine(startResolvedPos);\n    var endLine = startLine;\n    var startOffset = startResolvedPos.start(1);\n    var endOffset = startOffset;\n    if (!collapsed) {\n        // prevent the end offset from pointing to the root document position\n        var endResolvedPos = doc.resolve(to === doc.content.size ? to - 1 : to);\n        endOffset = endResolvedPos.start(1);\n        endLine = getMdLine(endResolvedPos);\n        // To resolve the end offset excluding document tag size\n        if (endResolvedPos.pos === doc.content.size) {\n            to = doc.content.size - 2;\n        }\n    }\n    var startCh = Math.max(from - startOffset + 1, 1);\n    var endCh = Math.max(to - endOffset + 1, 1);\n    return [\n        [startLine, startCh + getWidgetNodePos(doc.child(startLine - 1), startCh, -1)],\n        [endLine, endCh + getWidgetNodePos(doc.child(endLine - 1), endCh, -1)],\n    ];\n}\nfunction getStartPosListPerLine(doc, endIndex) {\n    var startPosListPerLine = [];\n    for (var i = 0, pos = 0; i < endIndex; i += 1) {\n        var child = doc.child(i);\n        startPosListPerLine[i] = pos;\n        pos += child.nodeSize;\n    }\n    return startPosListPerLine;\n}\nfunction getMdToEditorPos(doc, startPos, endPos) {\n    var startPosListPerLine = getStartPosListPerLine(doc, endPos[0]);\n    var startIndex = startPos[0] - 1;\n    var endIndex = endPos[0] - 1;\n    var startNode = doc.child(startIndex);\n    var endNode = doc.child(endIndex);\n    // calculate the position corresponding to the line\n    var from = startPosListPerLine[startIndex];\n    var to = startPosListPerLine[endIndex];\n    // calculate the position corresponding to the character offset of the line\n    from += startPos[1] + getWidgetNodePos(startNode, startPos[1] - 1);\n    to += endPos[1] + getWidgetNodePos(endNode, endPos[1] - 1);\n    return [from, Math.min(to, doc.content.size)];\n}\nfunction getRangeInfo(selection) {\n    var $from = selection.$from, $to = selection.$to;\n    var from = selection.from, to = selection.to;\n    var doc = $from.doc;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection) {\n        $from = doc.resolve(from + 1);\n        $to = doc.resolve(to - 1);\n    }\n    if ($from.depth === 0) {\n        $from = doc.resolve(from - 1);\n        $to = $from;\n    }\n    return {\n        startFromOffset: $from.start(1),\n        endFromOffset: $to.start(1),\n        startToOffset: $from.end(1),\n        endToOffset: $to.end(1),\n        startIndex: $from.index(0),\n        endIndex: $to.index(0),\n        from: $from.pos,\n        to: $to.pos,\n    };\n}\nfunction getNodeContentOffsetRange(doc, targetIndex) {\n    var startOffset = 1;\n    var endOffset = 1;\n    for (var i = 0, offset = 0; i < doc.childCount; i += 1) {\n        var nodeSize = doc.child(i).nodeSize;\n        // calculate content start, end offset(not node offset)\n        startOffset = offset + 1;\n        endOffset = offset + nodeSize - 1;\n        if (i === targetIndex) {\n            break;\n        }\n        offset += nodeSize;\n    }\n    return { startOffset: startOffset, endOffset: endOffset };\n}\n\nvar HEADING = 'heading';\nvar BLOCK_QUOTE = 'blockQuote';\nvar LIST_ITEM = 'listItem';\nvar TABLE = 'table';\nvar TABLE_CELL = 'tableCell';\nvar CODE_BLOCK = 'codeBlock';\nvar THEMATIC_BREAK = 'thematicBreak';\nvar LINK = 'link';\nvar CODE = 'code';\nvar META = 'meta';\nvar DELIM = 'delimiter';\nvar TASK_DELIM = 'taskDelimiter';\nvar TEXT = 'markedText';\nvar HTML = 'html';\nvar CUSTOM_BLOCK = 'customBlock';\nvar delimSize = {\n    strong: 2,\n    emph: 1,\n    strike: 2,\n};\nfunction markInfo(start, end, type, attrs) {\n    return { start: start, end: end, spec: { type: type, attrs: attrs } };\n}\nfunction heading$1(_a, start, end) {\n    var level = _a.level, headingType = _a.headingType;\n    var marks = [markInfo(start, end, HEADING, { level: level })];\n    if (headingType === 'atx') {\n        marks.push(markInfo(start, addOffsetPos(start, level), DELIM));\n    }\n    else {\n        marks.push(markInfo(setOffsetPos(end, 0), end, HEADING, { seText: true }));\n    }\n    return marks;\n}\nfunction emphasisAndStrikethrough(_a, start, end) {\n    var type = _a.type;\n    var startDelimPos = addOffsetPos(start, delimSize[type]);\n    var endDelimPos = addOffsetPos(end, -delimSize[type]);\n    return [\n        markInfo(startDelimPos, endDelimPos, type),\n        markInfo(start, startDelimPos, DELIM),\n        markInfo(endDelimPos, end, DELIM),\n    ];\n}\nfunction markLink(start, end, linkTextStart, lastChildCh) {\n    return [\n        markInfo(start, end, LINK),\n        markInfo(setOffsetPos(start, linkTextStart[1] + 1), setOffsetPos(end, lastChildCh), LINK, {\n            desc: true,\n        }),\n        markInfo(setOffsetPos(end, lastChildCh + 2), addOffsetPos(end, -1), LINK, { url: true }),\n    ];\n}\nfunction image$1(_a, start, end) {\n    var lastChild = _a.lastChild;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 3; // 3: length of '![]'\n    var linkTextEnd = addOffsetPos(start, 1);\n    return __spreadArray$1([markInfo(start, linkTextEnd, META)], markLink(start, end, linkTextEnd, lastChildCh));\n}\nfunction link(_a, start, end) {\n    var lastChild = _a.lastChild, extendedAutolink = _a.extendedAutolink;\n    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 2; // 2: length of '[]'\n    return extendedAutolink\n        ? [markInfo(start, end, LINK, { desc: true })]\n        : markLink(start, end, start, lastChildCh);\n}\nfunction code(_a, start, end) {\n    var tickCount = _a.tickCount;\n    var openDelimEnd = addOffsetPos(start, tickCount);\n    var closeDelimStart = addOffsetPos(end, -tickCount);\n    return [\n        markInfo(start, end, CODE),\n        markInfo(start, openDelimEnd, CODE, { start: true }),\n        markInfo(openDelimEnd, closeDelimStart, CODE, { marked: true }),\n        markInfo(closeDelimStart, end, CODE, { end: true }),\n    ];\n}\nfunction lineBackground(parent, start, end, prefix) {\n    var defaultBackground = {\n        start: start,\n        end: end,\n        spec: {\n            attrs: { className: prefix + \"-line-background\", codeStart: start[0], codeEnd: end[0] },\n        },\n        lineBackground: true,\n    };\n    return parent.type !== 'item' && parent.type !== 'blockQuote'\n        ? [\n            __assign$1(__assign$1({}, defaultBackground), { end: start, spec: { attrs: { className: prefix + \"-line-background start\" } } }),\n            __assign$1(__assign$1({}, defaultBackground), { start: [Math.min(start[0] + 1, end[0]), start[1]] }),\n        ]\n        : null;\n}\nfunction codeBlock$1(node, start, end, endLine) {\n    var fenceOffset = node.fenceOffset, fenceLength = node.fenceLength, fenceChar = node.fenceChar, info = node.info, infoPadding = node.infoPadding, parent = node.parent;\n    var fenceEnd = fenceOffset + fenceLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CODE_BLOCK)];\n    if (fenceChar) {\n        marks.push(markInfo(start, addOffsetPos(start, fenceEnd), DELIM));\n    }\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, fenceLength), addOffsetPos(start, fenceLength + infoPadding + info.length), META));\n    }\n    var codeBlockEnd = \"^(\\\\s{0,4})(\" + fenceChar + \"{\" + fenceLength + \",})\";\n    var reCodeBlockEnd = new RegExp(codeBlockEnd);\n    if (reCodeBlockEnd.test(endLine)) {\n        marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    }\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'code-block');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction customBlock$2(node, start, end) {\n    var _a = node, offset = _a.offset, syntaxLength = _a.syntaxLength, info = _a.info, parent = _a.parent;\n    var syntaxEnd = offset + syntaxLength;\n    var marks = [markInfo(setOffsetPos(start, 1), end, CUSTOM_BLOCK)];\n    marks.push(markInfo(start, addOffsetPos(start, syntaxEnd), DELIM));\n    if (info) {\n        marks.push(markInfo(addOffsetPos(start, syntaxEnd), addOffsetPos(start, syntaxLength + info.length), META));\n    }\n    marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));\n    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'custom-block');\n    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;\n}\nfunction markListItemChildren(node, markType) {\n    var marks = [];\n    while (node) {\n        var type = node.type;\n        if (type === 'paragraph' || type === 'codeBlock') {\n            marks.push(markInfo([getMdStartLine(node), getMdStartCh(node) - 1], [getMdEndLine(node), getMdEndCh(node) + 1], markType));\n        }\n        node = node.next;\n    }\n    return marks;\n}\nfunction markParagraphInBlockQuote(node) {\n    var marks = [];\n    while (node) {\n        marks.push(markInfo([getMdStartLine(node), getMdStartCh(node)], [getMdEndLine(node), getMdEndCh(node) + 1], TEXT));\n        node = node.next;\n    }\n    return marks;\n}\nfunction blockQuote$2(node, start, end) {\n    var marks = node.parent && node.parent.type !== 'blockQuote' ? [markInfo(start, end, BLOCK_QUOTE)] : [];\n    if (node.firstChild) {\n        var childMarks = [];\n        if (node.firstChild.type === 'paragraph') {\n            childMarks = markParagraphInBlockQuote(node.firstChild.firstChild);\n        }\n        else if (node.firstChild.type === 'list') {\n            childMarks = markListItemChildren(node.firstChild, TEXT);\n        }\n        marks = __spreadArray$1(__spreadArray$1([], marks), childMarks);\n    }\n    return marks;\n}\nfunction getSpecOfListItemStyle(node) {\n    var depth = 0;\n    while (node.parent.parent && node.parent.parent.type === 'item') {\n        node = node.parent.parent;\n        depth += 1;\n    }\n    var attrs = [{ odd: true }, { even: true }][depth % 2];\n    return [LIST_ITEM, __assign$1(__assign$1({}, attrs), { listStyle: true })];\n}\nfunction item$1(node, start) {\n    var _a = node.listData, padding = _a.padding, task = _a.task;\n    var spec = getSpecOfListItemStyle(node);\n    var marks = [markInfo.apply(void 0, __spreadArray$1([start, addOffsetPos(start, padding)], spec))];\n    if (task) {\n        marks.push(markInfo(addOffsetPos(start, padding), addOffsetPos(start, padding + 3), TASK_DELIM));\n        marks.push(markInfo(addOffsetPos(start, padding + 1), addOffsetPos(start, padding + 2), META));\n    }\n    return marks.concat(markListItemChildren(node.firstChild, TEXT));\n}\nvar markNodeFuncMap = {\n    heading: heading$1,\n    strong: emphasisAndStrikethrough,\n    emph: emphasisAndStrikethrough,\n    strike: emphasisAndStrikethrough,\n    link: link,\n    image: image$1,\n    code: code,\n    codeBlock: codeBlock$1,\n    blockQuote: blockQuote$2,\n    item: item$1,\n    customBlock: customBlock$2,\n};\nvar simpleMarkClassNameMap = {\n    thematicBreak: THEMATIC_BREAK,\n    table: TABLE,\n    tableCell: TABLE_CELL,\n    htmlInline: HTML,\n};\nfunction getMarkInfo(node, start, end, endLine) {\n    var type = node.type;\n    if (isFunction_1(markNodeFuncMap[type])) {\n        // @ts-ignore\n        return markNodeFuncMap[type](node, start, end, endLine);\n    }\n    if (simpleMarkClassNameMap[type]) {\n        return [markInfo(start, end, simpleMarkClassNameMap[type])];\n    }\n    return null;\n}\n\nvar removingBackgroundIndexMap = {};\nfunction syntaxHighlight(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        appendTransaction: function (transactions, _, newState) {\n            var tr = transactions[0];\n            var newTr = newState.tr;\n            if (tr.docChanged) {\n                var markInfo_1 = [];\n                var editResult = tr.getMeta('editResult');\n                editResult.forEach(function (result) {\n                    var nodes = result.nodes, removedNodeRange = result.removedNodeRange;\n                    if (nodes.length) {\n                        markInfo_1 = markInfo_1.concat(getMarkForRemoving(newTr, nodes));\n                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                            var parent_1 = nodes_1[_i];\n                            var walker = parent_1.walker();\n                            var event_1 = walker.next();\n                            while (event_1) {\n                                var node = event_1.node, entering = event_1.entering;\n                                if (entering) {\n                                    markInfo_1 = markInfo_1.concat(getMarkForAdding(node, toastMark));\n                                }\n                                event_1 = walker.next();\n                            }\n                        }\n                    }\n                    else if (removedNodeRange) {\n                        var maxIndex = newTr.doc.childCount - 1;\n                        var _a = removedNodeRange.line, startLine = _a[0], endLine = _a[1];\n                        var startIndex = Math.min(startLine, maxIndex);\n                        var endIndex = Math.min(endLine, maxIndex);\n                        // cache the index to remove code block, custom block background when there are no adding nodes\n                        for (var i = startIndex; i <= endIndex; i += 1) {\n                            removingBackgroundIndexMap[i] = true;\n                        }\n                    }\n                });\n                appendMarkTr(newTr, schema, markInfo_1);\n            }\n            return newTr.setMeta('widget', tr.getMeta('widget'));\n        },\n    });\n}\nfunction isDifferentBlock(doc, index, attrs) {\n    return Object.keys(attrs).some(function (name) { return attrs[name] !== doc.child(index).attrs[name]; });\n}\nfunction addLineBackground(tr, doc, paragraph, blockPosInfo, attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var startIndex = blockPosInfo.startIndex, endIndex = blockPosInfo.endIndex, from = blockPosInfo.from, to = blockPosInfo.to;\n    var shouldChangeBlockType = false;\n    for (var i = startIndex; i <= endIndex; i += 1) {\n        // prevent to remove background of the node that need to have background\n        delete removingBackgroundIndexMap[i];\n        shouldChangeBlockType = isDifferentBlock(doc, i, attrs);\n    }\n    if (shouldChangeBlockType) {\n        tr.setBlockType(from, to, paragraph, attrs);\n    }\n}\nfunction appendMarkTr(tr, schema, marks) {\n    var doc = tr.doc;\n    var paragraph = schema.nodes.paragraph;\n    // get start position per line for lazy calculation\n    var startPosListPerLine = getStartPosListPerLine(doc, doc.childCount);\n    marks.forEach(function (_a) {\n        var start = _a.start, end = _a.end, spec = _a.spec, lineBackground = _a.lineBackground;\n        var startIndex = Math.min(start[0], doc.childCount) - 1;\n        var endIndex = Math.min(end[0], doc.childCount) - 1;\n        var startNode = doc.child(startIndex);\n        var endNode = doc.child(endIndex);\n        // calculate the position corresponding to the line\n        var from = startPosListPerLine[startIndex];\n        var to = startPosListPerLine[endIndex];\n        // calculate the position corresponding to the character offset of the line\n        from += start[1] + getWidgetNodePos(startNode, start[1] - 1);\n        to += end[1] + getWidgetNodePos(endNode, end[1] - 1);\n        if (spec) {\n            if (lineBackground) {\n                var posInfo = { from: from, to: to, startIndex: startIndex, endIndex: endIndex };\n                addLineBackground(tr, doc, paragraph, posInfo, spec.attrs);\n            }\n            else {\n                tr.addMark(from, to, schema.mark(spec.type, spec.attrs));\n            }\n        }\n        else {\n            tr.removeMark(from, to);\n        }\n    });\n    removeBlockBackground(tr, startPosListPerLine, paragraph);\n}\nfunction removeBlockBackground(tr, startPosListPerLine, paragraph) {\n    Object.keys(removingBackgroundIndexMap).forEach(function (index) {\n        var startIndex = Number(index);\n        // get the end position of the current line with the next node start position.\n        var endIndex = Math.min(Number(index) + 1, tr.doc.childCount - 1);\n        var from = startPosListPerLine[startIndex];\n        // subtract '1' for getting end position of the line\n        var to = startPosListPerLine[endIndex] - 1;\n        if (startIndex === endIndex) {\n            to += 2;\n        }\n        tr.setBlockType(from, to, paragraph);\n    });\n}\nfunction cacheIndexToRemoveBackground(doc, start, end) {\n    var skipLines = [];\n    removingBackgroundIndexMap = {};\n    for (var i = start[0] - 1; i < end[0]; i += 1) {\n        var node = doc.child(i);\n        var codeEnd = node.attrs.codeEnd;\n        var codeStart = node.attrs.codeStart;\n        if (codeStart && codeEnd && !includes(skipLines, codeStart)) {\n            skipLines.push(codeStart);\n            codeEnd = Math.min(codeEnd, doc.childCount);\n            // should subtract '1' to markdown line position\n            // because markdown parser has '1'(not zero) as the start number\n            var startIndex = codeStart - 1;\n            var endIndex = end[0];\n            for (var index = startIndex; index < endIndex; index += 1) {\n                removingBackgroundIndexMap[index] = true;\n            }\n        }\n    }\n}\nfunction getMarkForRemoving(_a, nodes) {\n    var doc = _a.doc;\n    var start = nodes[0].sourcepos[0];\n    var _b = last$1(nodes).sourcepos, end = _b[1];\n    var startPos = [start[0], start[1]];\n    var endPos = [end[0], end[1] + 1];\n    var marks = [];\n    cacheIndexToRemoveBackground(doc, start, end);\n    marks.push({ start: startPos, end: endPos });\n    return marks;\n}\nfunction getMarkForAdding(node, toastMark) {\n    var lineTexts = toastMark.getLineTexts();\n    var startPos = [getMdStartLine(node), getMdStartCh(node)];\n    var endPos = [getMdEndLine(node), getMdEndCh(node) + 1];\n    var markInfo = getMarkInfo(node, startPos, endPos, lineTexts[endPos[0] - 1]);\n    return markInfo !== null && markInfo !== void 0 ? markInfo : [];\n}\n\nvar defaultToolbarStateKeys = [\n    'taskList',\n    'orderedList',\n    'bulletList',\n    'table',\n    'strong',\n    'emph',\n    'strike',\n    'heading',\n    'thematicBreak',\n    'blockQuote',\n    'code',\n    'codeBlock',\n    'indent',\n    'outdent',\n];\nfunction getToolbarStateType$1(mdNode) {\n    var type = mdNode.type;\n    if (isListNode$1(mdNode)) {\n        if (mdNode.listData.task) {\n            return 'taskList';\n        }\n        return mdNode.listData.type === 'ordered' ? 'orderedList' : 'bulletList';\n    }\n    if (type.indexOf('table') !== -1) {\n        return 'table';\n    }\n    if (!includes(defaultToolbarStateKeys, type)) {\n        return null;\n    }\n    return type;\n}\nfunction getToolbarState$1(targetNode) {\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    var listEnabled = true;\n    traverseParentNodes(targetNode, function (mdNode) {\n        var type = getToolbarStateType$1(mdNode);\n        if (!type) {\n            return;\n        }\n        if (type === 'bulletList' || type === 'orderedList') {\n            // to apply the nearlist list state in the nested list\n            if (listEnabled) {\n                toolbarState[type] = { active: true };\n                toolbarState.indent.disabled = false;\n                toolbarState.outdent.disabled = false;\n                listEnabled = false;\n            }\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction previewHighlight(_a) {\n    var toastMark = _a.toastMark, eventEmitter = _a.eventEmitter;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view, prevState) {\n                    var state = view.state;\n                    var doc = state.doc, selection = state.selection;\n                    if (prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)) {\n                        return;\n                    }\n                    var from = selection.from;\n                    var startChOffset = state.doc.resolve(from).start();\n                    var line = state.doc.content.findIndex(from).index + 1;\n                    var ch = from - startChOffset;\n                    if (from === startChOffset) {\n                        ch += 1;\n                    }\n                    var cursorPos = [line, ch];\n                    var mdNode = toastMark.findNodeAtPosition(cursorPos);\n                    var toolbarState = getToolbarState$1(mdNode);\n                    eventEmitter.emit('changeToolbarState', {\n                        cursorPos: cursorPos,\n                        mdNode: mdNode,\n                        toolbarState: toolbarState,\n                    });\n                    eventEmitter.emit('setFocusedNode', mdNode);\n                },\n            };\n        },\n    });\n}\n\nvar Doc$1 = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, \"name\", {\n        get: function () {\n            return 'doc';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'block+',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Mark = /** @class */ (function () {\n    function Mark() {\n    }\n    Object.defineProperty(Mark.prototype, \"type\", {\n        get: function () {\n            return 'mark';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Mark.prototype.setContext = function (context) {\n        this.context = context;\n    };\n    return Mark;\n}());\n\nfunction getTextByMdLine(doc, mdLine) {\n    return getTextContent(doc, mdLine - 1);\n}\nfunction getTextContent(doc, index) {\n    return doc.child(index).textContent;\n}\n\nvar reBlockQuote = /^\\s*> ?/;\nvar BlockQuote$1 = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, \"name\", {\n        get: function () {\n            return 'blockQuote';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('block-quote') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.createBlockQuoteText = function (text, isBlockQuote) {\n        return isBlockQuote ? text.replace(reBlockQuote, '').trim() : \"> \" + text.trim();\n    };\n    BlockQuote.prototype.extendBlockQuote = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            var isBlockQuote = reBlockQuote.test(textContent);\n            if (isBlockQuote && to > endFromOffset && selection.empty) {\n                var isEmpty = !textContent.replace(reBlockQuote, '').trim();\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    var slicedText = textContent.slice(to - endFromOffset).trim();\n                    var node = createTextNode$1(schema, _this.createBlockQuoteText(slicedText));\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    BlockQuote.prototype.commands = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var isBlockQuote = reBlockQuote.test(getTextContent(doc, startIndex));\n            var tr = replaceTextNode({\n                state: state,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                from: startFromOffset,\n                createText: function (textContent) { return _this.createBlockQuoteText(textContent, isBlockQuote); },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQuoteCommand = this.commands()();\n        return {\n            'alt-q': blockQuoteCommand,\n            'alt-Q': blockQuoteCommand,\n            Enter: this.extendBlockQuote(),\n        };\n    };\n    return BlockQuote;\n}(Mark));\n\nvar reList = /(^\\s*)([-*+] |[\\d]+\\. )/;\nvar reOrderedList = /(^\\s*)([\\d])+\\.( \\[[ xX]])? /;\nvar reOrderedListGroup = /^(\\s*)((\\d+)([.)]\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reCanBeTaskList = /(^\\s*)([-*+]|[\\d]+\\.)( \\[[ xX]])? /;\nvar reBulletListGroup = /^(\\s*)([-*+]+(\\s(?:\\[(?:x|\\s)\\]\\s)?))(.*)/;\nvar reTaskList = /(^\\s*)([-*+] |[\\d]+\\. )(\\[[ xX]] )/;\nvar reBulletTaskList = /(^\\s*)([-*+])( \\[[ xX]]) /;\nfunction getListType(text) {\n    return reOrderedList.test(text) ? 'ordered' : 'bullet';\n}\nfunction getListDepth(mdNode) {\n    var depth = 0;\n    while (mdNode && mdNode.type !== 'document') {\n        if (mdNode.type === 'list') {\n            depth += 1;\n        }\n        mdNode = mdNode.parent;\n    }\n    return depth;\n}\nfunction findSameDepthList(toastMark, currentLine, depth, backward) {\n    var lineTexts = toastMark.getLineTexts();\n    var lineLen = lineTexts.length;\n    var result = [];\n    var line = currentLine;\n    while (backward ? line < lineLen : line > 1) {\n        line = backward ? line + 1 : line - 1;\n        var mdNode = toastMark.findFirstNodeAtLine(line);\n        var currentListDepth = getListDepth(mdNode);\n        if (currentListDepth === depth) {\n            result.push({ line: line, depth: depth, mdNode: mdNode });\n        }\n        else if (currentListDepth < depth) {\n            break;\n        }\n    }\n    return result;\n}\nfunction getSameDepthItems(_a) {\n    var toastMark = _a.toastMark, mdNode = _a.mdNode, line = _a.line;\n    var depth = getListDepth(mdNode);\n    var forwardList = findSameDepthList(toastMark, line, depth, false).reverse();\n    var backwardList = findSameDepthList(toastMark, line, depth, true);\n    return forwardList.concat([{ line: line, depth: depth, mdNode: mdNode }]).concat(backwardList);\n}\nfunction textToBullet(text) {\n    if (!reList.test(text)) {\n        return \"* \" + text;\n    }\n    var type = getListType(text);\n    if (type === 'bullet' && reCanBeTaskList.test(text)) {\n        text = text.replace(reBulletTaskList, '$1$2 ');\n    }\n    else if (type === 'ordered') {\n        text = text.replace(reOrderedList, '$1* ');\n    }\n    return text;\n}\nfunction textToOrdered(text, ordinalNum) {\n    if (!reList.test(text)) {\n        return ordinalNum + \". \" + text;\n    }\n    var type = getListType(text);\n    if (type === 'bullet' || (type === 'ordered' && reCanBeTaskList.test(text))) {\n        text = text.replace(reCanBeTaskList, \"$1\" + ordinalNum + \". \");\n    }\n    else if (type === 'ordered') {\n        // eslint-disable-next-line prefer-destructuring\n        var start = reOrderedListGroup.exec(text)[3];\n        if (Number(start) !== ordinalNum) {\n            text = text.replace(reOrderedList, \"$1\" + ordinalNum + \". \");\n        }\n    }\n    return text;\n}\nfunction getChangedInfo(doc, sameDepthItems, type, start) {\n    if (start === void 0) { start = 0; }\n    var firstIndex = Number.MAX_VALUE;\n    var lastIndex = 0;\n    var changedResults = sameDepthItems.map(function (_a, index) {\n        var line = _a.line;\n        firstIndex = Math.min(line - 1, firstIndex);\n        lastIndex = Math.max(line - 1, lastIndex);\n        var text = getTextByMdLine(doc, line);\n        text = type === 'bullet' ? textToBullet(text) : textToOrdered(text, index + 1 + start);\n        return { text: text, line: line };\n    });\n    return { changedResults: changedResults, firstIndex: firstIndex, lastIndex: lastIndex };\n}\nfunction getBulletOrOrdered(type, context) {\n    var sameDepthListInfo = getSameDepthItems(context);\n    return getChangedInfo(context.doc, sameDepthListInfo, type);\n}\nvar otherListToList = {\n    bullet: function (context) {\n        return getBulletOrOrdered('bullet', context);\n    },\n    ordered: function (context) {\n        return getBulletOrOrdered('ordered', context);\n    },\n    task: function (_a) {\n        var mdNode = _a.mdNode, doc = _a.doc, line = _a.line;\n        var text = getTextByMdLine(doc, line);\n        if (mdNode.listData.task) {\n            text = text.replace(reTaskList, '$1$2');\n        }\n        else if (isListNode$1(mdNode)) {\n            text = text.replace(reList, '$1$2[ ] ');\n        }\n        return { changedResults: [{ text: text, line: line }] };\n    },\n};\nvar otherNodeToList = {\n    bullet: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: \"* \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, doc = _a.doc, line = _a.line, startLine = _a.startLine;\n        var lineText = getTextByMdLine(doc, line);\n        var firstOrderedListNum = 1;\n        var firstOrderedListLine = startLine;\n        var skipped = 0;\n        for (var i = startLine - 1; i > 0; i -= 1) {\n            var mdNode = toastMark.findFirstNodeAtLine(i);\n            var text = getTextByMdLine(doc, i);\n            var canBeListNode = text && !!findClosestNode(mdNode, function (targetNode) { return isListNode$1(targetNode); });\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, i));\n            if (!searchResult && !canBeListNode) {\n                break;\n            }\n            if (!searchResult && canBeListNode) {\n                skipped += 1;\n                continue;\n            }\n            var _b = searchResult, indent = _b[1], start = _b[3];\n            // basis on one depth list\n            if (!indent) {\n                firstOrderedListNum = Number(start);\n                firstOrderedListLine = i;\n                break;\n            }\n        }\n        var ordinalNum = firstOrderedListNum + line - firstOrderedListLine - skipped;\n        var changedResults = [{ text: ordinalNum + \". \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n    task: function (_a) {\n        var doc = _a.doc, line = _a.line;\n        var lineText = getTextByMdLine(doc, line);\n        var changedResults = [{ text: \"* [ ] \" + lineText, line: line }];\n        return { changedResults: changedResults };\n    },\n};\nvar extendList = {\n    bullet: function (_a) {\n        var line = _a.line, doc = _a.doc;\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reBulletListGroup.exec(lineText), indent = _b[1], delimiter = _b[2];\n        return { listSyntax: \"\" + indent + delimiter };\n    },\n    ordered: function (_a) {\n        var toastMark = _a.toastMark, line = _a.line, mdNode = _a.mdNode, doc = _a.doc;\n        var depth = getListDepth(mdNode);\n        var lineText = getTextByMdLine(doc, line);\n        var _b = reOrderedListGroup.exec(lineText), indent = _b[1], start = _b[3], delimiter = _b[4];\n        var ordinalNum = Number(start) + 1;\n        var listSyntax = \"\" + indent + ordinalNum + delimiter;\n        var backwardList = findSameDepthList(toastMark, line, depth, true);\n        var filteredList = backwardList.filter(function (info) {\n            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, info.line));\n            return (searchResult &&\n                searchResult[1].length === indent.length &&\n                !!findClosestNode(info.mdNode, function (targetNode) { return isOrderedListNode(targetNode); }));\n        });\n        return __assign$1({ listSyntax: listSyntax }, getChangedInfo(doc, filteredList, 'ordered', ordinalNum));\n    },\n};\nfunction getReorderedListInfo(doc, schema, line, ordinalNum, prevIndentLength) {\n    var nodes = [];\n    var lineText = getTextByMdLine(doc, line);\n    var searchResult = reOrderedListGroup.exec(lineText);\n    while (searchResult) {\n        var indent = searchResult[1], delimiter = searchResult[4], text = searchResult[5];\n        var indentLength = indent.length;\n        if (indentLength === prevIndentLength) {\n            nodes.push(createTextNode$1(schema, \"\" + indent + ordinalNum + delimiter + text));\n            ordinalNum += 1;\n            line += 1;\n        }\n        else if (indentLength > prevIndentLength) {\n            var nestedListInfo = getReorderedListInfo(doc, schema, line, 1, indentLength);\n            line = nestedListInfo.line;\n            nodes = nodes.concat(nestedListInfo.nodes);\n        }\n        if (indentLength < prevIndentLength || line > doc.childCount) {\n            break;\n        }\n        lineText = getTextByMdLine(doc, line);\n        searchResult = reOrderedListGroup.exec(lineText);\n    }\n    return { nodes: nodes, line: line };\n}\n\nvar reStartSpace = /(^\\s{1,4})(.*)/;\nfunction isBlockUnit(from, to, text) {\n    return from < to || reList.test(text) || reBlockQuote.test(text);\n}\nfunction isInTableCellNode(doc, schema, selection) {\n    var $pos = selection.$from;\n    if ($pos.depth === 0) {\n        $pos = doc.resolve($pos.pos - 1);\n    }\n    var node = $pos.node(1);\n    var startOffset = $pos.start(1);\n    var contentSize = node.content.size;\n    return (node.rangeHasMark(0, contentSize, schema.marks.table) &&\n        $pos.pos - startOffset !== contentSize &&\n        $pos.pos !== startOffset);\n}\nfunction createSelection(tr, posInfo) {\n    var from = posInfo.from, to = posInfo.to;\n    if (posInfo.type === 'indent') {\n        var softTabLen = 4;\n        from += softTabLen;\n        to += (posInfo.lineLen + 1) * softTabLen;\n    }\n    else {\n        var spaceLenList = posInfo.spaceLenList;\n        from -= spaceLenList[0];\n        for (var i = 0; i < spaceLenList.length; i += 1) {\n            to -= spaceLenList[i];\n        }\n    }\n    return createTextSelection(tr, from, to);\n}\nvar Paragraph$1 = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, \"name\", {\n        get: function () {\n            return 'paragraph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'inline*',\n                attrs: {\n                    className: { default: null },\n                    codeStart: { default: null },\n                    codeEnd: { default: null },\n                },\n                selectable: false,\n                group: 'block',\n                parseDOM: [{ tag: 'div' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return attrs.className\n                        ? ['div', { class: clsWithMdPrefix(attrs.className) }, 0]\n                        : ['div', 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Paragraph.prototype.reorderList = function (startLine, endLine) {\n        var _a = this.context, view = _a.view, toastMark = _a.toastMark, schema = _a.schema;\n        var _b = view.state, tr = _b.tr, selection = _b.selection, doc = _b.doc;\n        var mdNode = toastMark.findFirstNodeAtLine(startLine);\n        var topListNode = mdNode;\n        while (mdNode && !isBulletListNode(mdNode) && mdNode.parent.type !== 'document') {\n            mdNode = mdNode.parent;\n            if (isOrderedListNode(mdNode)) {\n                topListNode = mdNode;\n                break;\n            }\n        }\n        if (topListNode) {\n            startLine = topListNode.sourcepos[0][0];\n        }\n        var _c = reOrderedListGroup.exec(getTextByMdLine(doc, startLine)), indent = _c[1], start = _c[3];\n        var indentLen = indent.length;\n        var _d = getReorderedListInfo(doc, schema, startLine, Number(start), indentLen), line = _d.line, nodes = _d.nodes;\n        endLine = Math.max(endLine, line - 1);\n        var startOffset = getNodeContentOffsetRange(doc, startLine - 1).startOffset;\n        for (var i = startLine - 1; i <= endLine - 1; i += 1) {\n            var _e = doc.child(i), nodeSize = _e.nodeSize, content = _e.content;\n            var mappedFrom = tr.mapping.map(startOffset);\n            var mappedTo = mappedFrom + content.size;\n            tr.replaceWith(mappedFrom, mappedTo, nodes[i - startLine + 1]);\n            startOffset += nodeSize;\n        }\n        var newSelection = createTextSelection(tr, selection.from, selection.to);\n        view.dispatch(tr.setSelection(newSelection));\n    };\n    Paragraph.prototype.indent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, doc = state.doc;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) { return \"    \" + textContent; },\n                });\n                var posInfo = {\n                    type: 'indent',\n                    from: from,\n                    to: to,\n                    lineLen: endIndex - startIndex,\n                };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                dispatch(state.tr.insert(to, createTextNode$1(schema, '    ')));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.outdent = function (tabKey) {\n        var _this = this;\n        if (tabKey === void 0) { tabKey = false; }\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, doc = state.doc, schema = state.schema;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            if (tabKey && isInTableCellNode(doc, schema, selection)) {\n                return false;\n            }\n            var startLineText = getTextContent(doc, startIndex);\n            if ((tabKey && isBlockUnit(from, to, startLineText)) ||\n                (!tabKey && reList.test(startLineText))) {\n                var spaceLenList_1 = [];\n                var tr = replaceTextNode({\n                    state: state,\n                    from: startFromOffset,\n                    startIndex: startIndex,\n                    endIndex: endIndex,\n                    createText: function (textContent) {\n                        var searchResult = reStartSpace.exec(textContent);\n                        spaceLenList_1.push(searchResult ? searchResult[1].length : 0);\n                        return textContent.replace(reStartSpace, '$2');\n                    },\n                });\n                var posInfo = { type: 'outdent', from: from, to: to, spaceLenList: spaceLenList_1 };\n                dispatch(tr.setSelection(createSelection(tr, posInfo)));\n                if (reOrderedListGroup.test(startLineText)) {\n                    _this.reorderList(startIndex + 1, endIndex + 1);\n                }\n            }\n            else if (tabKey) {\n                var startText = startLineText.slice(0, to - startFromOffset);\n                var startTextWithoutSpace = startText.replace(/\\s{1,4}$/, '');\n                var deletStart = to - (startText.length - startTextWithoutSpace.length);\n                dispatch(state.tr.delete(deletStart, to));\n            }\n            return true;\n        }; };\n    };\n    Paragraph.prototype.deleteLines = function () {\n        var _this = this;\n        return function (state, dispatch) {\n            var view = _this.context.view;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var deleteRange = function () {\n                dispatch(state.tr.deleteRange(startFromOffset, endToOffset));\n                return true;\n            };\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.chainCommands)(deleteRange, prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.joinForward)(state, dispatch, view);\n        };\n    };\n    Paragraph.prototype.moveDown = function () {\n        return function (state, dispatch) {\n            var doc = state.doc, tr = state.tr, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, endIndex = _a.endIndex;\n            if (endIndex < doc.content.childCount - 1) {\n                var _b = doc.child(endIndex + 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(endToOffset, endToOffset + nodeSize)\n                    .split(startFromOffset)\n                    // subtract 2(start, end tag length) to insert prev line\n                    .insert(tr.mapping.map(startFromOffset) - 2, createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.moveUp = function () {\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, selection = state.selection, schema = state.schema;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex;\n            if (startIndex > 0) {\n                var _b = doc.child(startIndex - 1), nodeSize = _b.nodeSize, textContent = _b.textContent;\n                tr.delete(startFromOffset - nodeSize, startFromOffset)\n                    .split(tr.mapping.map(endToOffset))\n                    .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, textContent));\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Paragraph.prototype.commands = function () {\n        return {\n            indent: this.indent(),\n            outdent: this.outdent(),\n        };\n    };\n    Paragraph.prototype.keymaps = function () {\n        return {\n            Tab: this.indent(true)(),\n            'Shift-Tab': this.outdent(true)(),\n            'Mod-d': this.deleteLines(),\n            'Mod-D': this.deleteLines(),\n            'Alt-ArrowUp': this.moveUp(),\n            'Alt-ArrowDown': this.moveDown(),\n        };\n    };\n    return Paragraph;\n}(Node$2));\n\nvar Text$1 = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, \"name\", {\n        get: function () {\n            return 'text';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"schema\", {\n        get: function () {\n            return {\n                group: 'inline',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Text;\n}(Node$2));\n\nvar reHeading = /^#{1,6}\\s/;\nvar Heading$1 = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, \"name\", {\n        get: function () {\n            return 'heading';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    level: { default: 1 },\n                    seText: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var level = attrs.level, seText = attrs.seText;\n                    var classNames = \"heading|heading\" + level;\n                    if (seText) {\n                        classNames += '|delimiter|setext';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.createHeadingText = function (level, text, curHeadingSyntax) {\n        var textContent = text.replace(curHeadingSyntax, '').trim();\n        var headingText = '';\n        while (level > 0) {\n            headingText += '#';\n            level -= 1;\n        }\n        return headingText + \" \" + textContent;\n    };\n    Heading.prototype.commands = function () {\n        var _this = this;\n        return function (payload) { return function (state, dispatch) {\n            var level = payload.level;\n            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;\n            var tr = replaceTextNode({\n                state: state,\n                from: startFromOffset,\n                startIndex: startIndex,\n                endIndex: endIndex,\n                createText: function (textContent) {\n                    var matchedHeading = textContent.match(reHeading);\n                    var curHeadingSyntax = matchedHeading ? matchedHeading[0] : '';\n                    return _this.createHeadingText(level, textContent, curHeadingSyntax);\n                },\n            });\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    return Heading;\n}(Mark));\n\nvar fencedCodeBlockSyntax = '```';\nvar CodeBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, \"name\", {\n        get: function () {\n            return 'codeBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('code-block') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            var fencedNode = createTextNode$1(schema, fencedCodeBlockSyntax);\n            // add fenced start block\n            tr.insert(startFromOffset, fencedNode).split(startFromOffset + fencedCodeBlockSyntax.length);\n            // add fenced end block\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), fencedNode);\n            dispatch(tr.setSelection(\n            // subtract fenced syntax length and open, close tag(2)\n            createTextSelection(tr, tr.mapping.map(endToOffset) - (fencedCodeBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    CodeBlock.prototype.keepIndentation = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startFromOffset = _b.startFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, from = _b.from, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            if (from === to && textContent.trim()) {\n                var matched = textContent.match(/^\\s+/);\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                if (isCodeBlockNode(mdNode) && matched) {\n                    var spaces = matched[0];\n                    var slicedText = textContent.slice(to - startFromOffset);\n                    var node = createTextNode$1(schema, spaces + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeBlockCommand = this.commands()();\n        return {\n            'Shift-Mod-p': codeBlockCommand,\n            'Shift-Mod-P': codeBlockCommand,\n            Enter: this.keepIndentation(),\n        };\n    };\n    return CodeBlock;\n}(Mark));\n\nvar reEmptyTable = /\\||\\s/g;\nfunction createTableHeader(columnCount) {\n    return [createTableRow(columnCount), createTableRow(columnCount, true)];\n}\nfunction createTableBody$1(columnCount, rowCount) {\n    var bodyRows = [];\n    for (var i = 0; i < rowCount; i += 1) {\n        bodyRows.push(createTableRow(columnCount));\n    }\n    return bodyRows;\n}\nfunction createTableRow(columnCount, delim) {\n    var row = '|';\n    for (var i = 0; i < columnCount; i += 1) {\n        row += delim ? ' --- |' : '  |';\n    }\n    return row;\n}\nfunction createTargetTypes(moveNext) {\n    return moveNext\n        ? { type: 'next', parentType: 'tableHead', childType: 'firstChild' }\n        : { type: 'prev', parentType: 'tableBody', childType: 'lastChild' };\n}\nvar Table$1 = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, \"name\", {\n        get: function () {\n            return 'table';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('table') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.extendTable = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;\n            if (!selection.empty) {\n                return false;\n            }\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;\n            var textContent = getTextContent(doc, endIndex);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var mdPos = [endIndex + 1, to - endFromOffset + 1];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) {\n                return isTableCellNode(node) &&\n                    (node.parent.type === 'tableDelimRow' || node.parent.parent.type === 'tableBody');\n            });\n            if (cellNode) {\n                var isEmpty = !textContent.replace(reEmptyTable, '').trim();\n                var parent_1 = cellNode.parent;\n                var columnCount = parent_1.parent.parent.columns.length;\n                var row = createTableRow(columnCount);\n                if (isEmpty) {\n                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n                }\n                else {\n                    tr\n                        .split(endToOffset)\n                        .insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row))\n                        // should subtract `2` to selection end position considering ` |` text\n                        .setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - 2));\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveTableCell = function (moveNext) {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, to = _b.to;\n            var mdPos = [endIndex + 1, to - endFromOffset];\n            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);\n            var cellNode = findClosestNode(mdNode, function (node) { return isTableCellNode(node); });\n            if (cellNode) {\n                var parent_2 = cellNode.parent;\n                var _c = createTargetTypes(moveNext), type = _c.type, parentType = _c.parentType, childType = _c.childType;\n                var chOffset = getMdEndCh(cellNode);\n                if (cellNode[type]) {\n                    chOffset = getMdEndCh(cellNode[type]) - 1;\n                }\n                else {\n                    var row = !parent_2[type] && parent_2.parent.type === parentType\n                        ? parent_2.parent[type][childType]\n                        : parent_2[type];\n                    if (type === 'next') {\n                        // if there is next row, the base offset would be end position of the next row's first child.\n                        // Otherwise, the base offset is zero.\n                        var baseOffset = row ? getMdEndCh(row[childType]) : 0;\n                        // calculate tag(open, close) position('2') for selection\n                        chOffset += baseOffset + 2;\n                    }\n                    else if (type === 'prev') {\n                        // if there is prev row, the target position would be '-4' for calculating ' |' characters and tag(open, close)\n                        // Otherwise, the target position is zero.\n                        chOffset = row ? -4 : 0;\n                    }\n                }\n                dispatch(tr.setSelection(createTextSelection(tr, endFromOffset + chOffset)));\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.addTable = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = payload, columnCount = _b.columnCount, rowCount = _b.rowCount;\n            var endToOffset = getRangeInfo(selection).endToOffset;\n            var headerRows = createTableHeader(columnCount);\n            var bodyRows = createTableBody$1(columnCount, rowCount - 1);\n            var rows = __spreadArray$1(__spreadArray$1([], headerRows), bodyRows);\n            rows.forEach(function (row) {\n                tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row));\n            });\n            // should add `4` to selection position considering `| ` text and start block tag length\n            dispatch(tr.setSelection(createTextSelection(tr, endToOffset + 4)));\n            return true;\n        }; };\n    };\n    Table.prototype.commands = function () {\n        return { addTable: this.addTable() };\n    };\n    Table.prototype.keymaps = function () {\n        return {\n            Enter: this.extendTable(),\n            Tab: this.moveTableCell(true),\n            'Shift-Tab': this.moveTableCell(false),\n        };\n    };\n    return Table;\n}(Mark));\n\nvar thematicBreakSyntax = '***';\nvar ThematicBreak$1 = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, \"name\", {\n        get: function () {\n            return 'thematicBreak';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('thematic-break') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, endToOffset = _a.endToOffset;\n            var node = createTextNode$1(schema, thematicBreakSyntax);\n            tr\n                .split(from)\n                .replaceWith(tr.mapping.map(from), tr.mapping.map(to), node)\n                .split(tr.mapping.map(to)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset)));\n            dispatch(tr);\n            return true;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var lineCommand = this.hr()();\n        return { 'Mod-l': lineCommand, 'Mod-L': lineCommand };\n    };\n    return ThematicBreak;\n}(Mark));\n\nfunction cannotBeListNode(_a, line) {\n    var type = _a.type, sourcepos = _a.sourcepos;\n    // eslint-disable-next-line prefer-destructuring\n    var startLine = sourcepos[0][0];\n    return line <= startLine && (type === 'codeBlock' || type === 'heading' || type.match('table'));\n}\nvar ListItem$1 = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, \"name\", {\n        get: function () {\n            return 'listItem';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    odd: { default: false },\n                    even: { default: false },\n                    listStyle: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var odd = attrs.odd, even = attrs.even, listStyle = attrs.listStyle;\n                    var classNames = 'list-item';\n                    if (listStyle) {\n                        classNames += '|list-item-style';\n                    }\n                    if (odd) {\n                        classNames += '|list-item-odd';\n                    }\n                    if (even) {\n                        classNames += '|list-item-even';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.extendList = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, doc = _a.doc, schema = _a.schema, tr = _a.tr;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), to = _b.to, startFromOffset = _b.startFromOffset, endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, endToOffset = _b.endToOffset;\n            var textContent = getTextContent(doc, endIndex);\n            var isList = reList.test(textContent);\n            if (!isList || selection.from === startFromOffset || !selection.empty) {\n                return false;\n            }\n            var isEmpty = !textContent.replace(reCanBeTaskList, '').trim();\n            if (isEmpty) {\n                tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));\n            }\n            else {\n                var commandType = getListType(textContent);\n                // should add `1` to line for the markdown parser\n                // because markdown parser has `1`(not zero) as the start number\n                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);\n                var slicedText = textContent.slice(to - endFromOffset);\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: endIndex + 1 };\n                var _c = extendList[commandType](context), listSyntax = _c.listSyntax, changedResults = _c.changedResults;\n                // change ordinal number of backward ordered list\n                if (changedResults === null || changedResults === void 0 ? void 0 : changedResults.length) {\n                    // split the block\n                    tr.split(to);\n                    // set first ordered list info\n                    changedResults.unshift({ text: listSyntax + slicedText, line: endIndex + 1 });\n                    _this.changeToListPerLine(tr, changedResults, {\n                        from: to,\n                        // don't subtract 1 because the line has increased through 'split' command.\n                        startLine: changedResults[0].line,\n                        endLine: last$1(changedResults).line,\n                    });\n                    var pos = tr.mapping.map(endToOffset) - slicedText.length;\n                    tr.setSelection(createTextSelection(tr, pos));\n                }\n                else {\n                    var node = createTextNode$1(schema, listSyntax + slicedText);\n                    splitAndExtendBlock(tr, endToOffset, slicedText, node);\n                }\n            }\n            dispatch(tr);\n            return true;\n        };\n    };\n    ListItem.prototype.toList = function (commandType) {\n        var _this = this;\n        return function () { return function (_a, dispatch) {\n            var doc = _a.doc, tr = _a.tr, selection = _a.selection;\n            var toastMark = _this.context.toastMark;\n            var rangeInfo = getRangeInfo(selection);\n            // should add `1` to line for the markdown parser\n            // because markdown parser has `1`(not zero) as the start number\n            var startLine = rangeInfo.startIndex + 1;\n            var endLine = rangeInfo.endIndex + 1;\n            var endToOffset = rangeInfo.endToOffset;\n            var skipLines = [];\n            for (var line = startLine; line <= endLine; line += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(line);\n                if (mdNode && cannotBeListNode(mdNode, line)) {\n                    break;\n                }\n                // to skip unnecessary processing\n                if (skipLines.indexOf(line) !== -1) {\n                    continue;\n                }\n                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: line, startLine: startLine };\n                var changedResults = (isListNode$1(mdNode)\n                    ? otherListToList[commandType](context)\n                    : otherNodeToList[commandType](context)).changedResults;\n                var endOffset = _this.changeToListPerLine(tr, changedResults, {\n                    from: getNodeContentOffsetRange(doc, changedResults[0].line - 1).startOffset,\n                    startLine: changedResults[0].line,\n                    endLine: last$1(changedResults).line,\n                    indexDiff: 1,\n                });\n                endToOffset = Math.max(endOffset, endToOffset);\n                if (changedResults) {\n                    skipLines = skipLines.concat(changedResults.map(function (info) { return info.line; }));\n                }\n            }\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));\n            return true;\n        }; };\n    };\n    ListItem.prototype.changeToListPerLine = function (tr, changedResults, _a) {\n        var from = _a.from, startLine = _a.startLine, endLine = _a.endLine, _b = _a.indexDiff, indexDiff = _b === void 0 ? 0 : _b;\n        var maxEndOffset = 0;\n        var _loop_1 = function (i) {\n            var _c = tr.doc.child(i), nodeSize = _c.nodeSize, content = _c.content;\n            var mappedFrom = tr.mapping.map(from);\n            var mappedTo = mappedFrom + content.size;\n            var changedResult = changedResults.filter(function (result) { return result.line - indexDiff === i; })[0];\n            if (changedResult) {\n                tr.replaceWith(mappedFrom, mappedTo, createTextNode$1(this_1.context.schema, changedResult.text));\n                maxEndOffset = Math.max(maxEndOffset, from + content.size);\n            }\n            from += nodeSize;\n        };\n        var this_1 = this;\n        for (var i = startLine - indexDiff; i <= endLine - indexDiff; i += 1) {\n            _loop_1(i);\n        }\n        return maxEndOffset;\n    };\n    ListItem.prototype.toggleTask = function () {\n        var _this = this;\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n            var toastMark = _this.context.toastMark;\n            var _b = getRangeInfo(selection), startIndex = _b.startIndex, endIndex = _b.endIndex;\n            var newTr = null;\n            for (var i = startIndex; i <= endIndex; i += 1) {\n                var mdNode = toastMark.findFirstNodeAtLine(i + 1);\n                if (isListNode$1(mdNode) && mdNode.listData.task) {\n                    var _c = mdNode.listData, checked = _c.checked, padding = _c.padding;\n                    var stateChar = checked ? ' ' : 'x';\n                    var mdPos = mdNode.sourcepos[0];\n                    var startOffset = getNodeContentOffsetRange(doc, mdPos[0] - 1).startOffset;\n                    startOffset += mdPos[1] + padding;\n                    newTr = tr.replaceWith(startOffset, startOffset + 1, schema.text(stateChar));\n                }\n            }\n            if (newTr) {\n                dispatch(newTr);\n                return true;\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.commands = function () {\n        return {\n            bulletList: this.toList('bullet'),\n            orderedList: this.toList('ordered'),\n            taskList: this.toList('task'),\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var bulletCommand = this.toList('bullet')();\n        var orderedCommand = this.toList('ordered')();\n        var taskCommand = this.toList('task')();\n        var togleTaskCommand = this.toggleTask();\n        return {\n            'Mod-u': bulletCommand,\n            'Mod-U': bulletCommand,\n            'Mod-o': orderedCommand,\n            'Mod-O': orderedCommand,\n            'alt-t': taskCommand,\n            'alt-T': taskCommand,\n            'Shift-Ctrl-x': togleTaskCommand,\n            'Shift-Ctrl-X': togleTaskCommand,\n            Enter: this.extendList(),\n        };\n    };\n    return ListItem;\n}(Mark));\n\nfunction toggleMark(condition, syntax) {\n    return function () { return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var conditionFn = !isFunction_1(condition)\n            ? function (text) { return condition.test(text); }\n            : condition;\n        var syntaxLen = syntax.length;\n        var doc = tr.doc;\n        var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n        var prevPos = Math.max(from - syntaxLen, 1);\n        var nextPos = Math.min(to + syntaxLen, doc.content.size - 1);\n        var slice = selection.content();\n        var textContent = slice.content.textBetween(0, slice.content.size, '\\n');\n        var prevText = doc.textBetween(prevPos, from, '\\n');\n        var nextText = doc.textBetween(to, nextPos, '\\n');\n        textContent = \"\" + prevText + textContent + nextText;\n        if (prevText && nextText && conditionFn(textContent)) {\n            tr.delete(nextPos - syntaxLen, nextPos).delete(prevPos, prevPos + syntaxLen);\n        }\n        else {\n            tr.insertText(syntax, to).insertText(syntax, from);\n            var newSelection = selection.empty\n                ? createTextSelection(tr, from + syntaxLen)\n                : createTextSelection(tr, from + syntaxLen, to + syntaxLen);\n            tr.setSelection(newSelection);\n        }\n        dispatch(tr);\n        return true;\n    }; };\n}\n\nvar reStrong = /^(\\*{2}|_{2}).*([\\s\\S]*)\\1$/m;\nvar strongSyntax = '**';\nvar Strong$1 = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, \"name\", {\n        get: function () {\n            return 'strong';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('strong') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return toggleMark(reStrong, strongSyntax);\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return { 'Mod-b': boldCommand, 'Mod-B': boldCommand };\n    };\n    return Strong;\n}(Mark));\n\nvar reStrike = /^(~{2}).*([\\s\\S]*)\\1$/m;\nvar strikeSyntax = '~~';\nvar Strike$1 = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, \"name\", {\n        get: function () {\n            return 'strike';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('strike') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return toggleMark(reStrike, strikeSyntax);\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return { 'Mod-s': strikeCommand, 'Mod-S': strikeCommand };\n    };\n    return Strike;\n}(Mark));\n\nvar reEmph = /^(\\*|_).*([\\s\\S]*)\\1$/m;\nvar emphSyntax = '*';\nvar Emph$1 = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, \"name\", {\n        get: function () {\n            return 'emph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('emph') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return toggleMark(reEmph, emphSyntax);\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return { 'Mod-i': italicCommand, 'Mod-I': italicCommand };\n    };\n    return Emph;\n}(Mark));\n\nvar reCode = /^(`).*([\\s\\S]*)\\1$/m;\nvar codeSyntax = '`';\nvar Code$1 = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, \"name\", {\n        get: function () {\n            return 'code';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    start: { default: false },\n                    end: { default: false },\n                    marked: { default: false },\n                },\n                toDOM: function (mark) {\n                    var _a = mark.attrs, start = _a.start, end = _a.end, marked = _a.marked;\n                    var classNames = 'code';\n                    if (start) {\n                        classNames += '|delimiter|start';\n                    }\n                    if (end) {\n                        classNames += '|delimiter|end';\n                    }\n                    if (marked) {\n                        classNames += '|marked-text';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return toggleMark(reCode, codeSyntax);\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return { 'Shift-Mod-c': codeCommand, 'Shift-Mod-C': codeCommand };\n    };\n    return Code;\n}(Mark));\n\nvar Link$1 = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Link.prototype, \"name\", {\n        get: function () {\n            return 'link';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: {\n                    url: { default: false },\n                    desc: { default: false },\n                },\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var url = attrs.url, desc = attrs.desc;\n                    var classNames = 'link';\n                    if (url) {\n                        classNames += '|link-url|marked-text';\n                    }\n                    if (desc) {\n                        classNames += '|link-desc|marked-text';\n                    }\n                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLinkOrImage = function (commandType) {\n        return function (payload) { return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n            var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];\n            var _c = payload, linkText = _c.linkText, altText = _c.altText, linkUrl = _c.linkUrl, imageUrl = _c.imageUrl;\n            var text = linkText;\n            var url = linkUrl;\n            var syntax = '';\n            if (commandType === 'image') {\n                text = altText;\n                url = imageUrl;\n                syntax = '!';\n            }\n            text = escapeTextForLink(text);\n            syntax += \"[\" + text + \"](\" + url + \")\";\n            dispatch(tr.replaceWith(from, to, createTextNode$1(schema, syntax)));\n            return true;\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addImage: this.addLinkOrImage('image'),\n            addLink: this.addLinkOrImage('link'),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar TaskDelimiter = /** @class */ (function (_super) {\n    __extends$1(TaskDelimiter, _super);\n    function TaskDelimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TaskDelimiter.prototype, \"name\", {\n        get: function () {\n            return 'taskDelimiter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TaskDelimiter.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('delimiter', 'list-item') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TaskDelimiter;\n}(Mark));\nvar Delimiter = /** @class */ (function (_super) {\n    __extends$1(Delimiter, _super);\n    function Delimiter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Delimiter.prototype, \"name\", {\n        get: function () {\n            return 'delimiter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Delimiter.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('delimiter') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Delimiter;\n}(Mark));\nvar Meta = /** @class */ (function (_super) {\n    __extends$1(Meta, _super);\n    function Meta() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Meta.prototype, \"name\", {\n        get: function () {\n            return 'meta';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Meta.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('meta') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Meta;\n}(Mark));\nvar MarkedText = /** @class */ (function (_super) {\n    __extends$1(MarkedText, _super);\n    function MarkedText() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(MarkedText.prototype, \"name\", {\n        get: function () {\n            return 'markedText';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(MarkedText.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('marked-text') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return MarkedText;\n}(Mark));\nvar TableCell = /** @class */ (function (_super) {\n    __extends$1(TableCell, _super);\n    function TableCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableCell.prototype, \"name\", {\n        get: function () {\n            return 'tableCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('table-cell') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableCell;\n}(Mark));\n\nvar Html = /** @class */ (function (_super) {\n    __extends$1(Html, _super);\n    function Html() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Html.prototype, \"name\", {\n        get: function () {\n            return 'html';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Html.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('html') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Html;\n}(Mark));\n\nvar customBlockSyntax = '$$';\nvar CustomBlock$1 = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, \"name\", {\n        get: function () {\n            return 'customBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                toDOM: function () {\n                    return ['span', { class: clsWithMdPrefix('custom-block') }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;\n            if (!(payload === null || payload === void 0 ? void 0 : payload.info)) {\n                return false;\n            }\n            var customBlock = \"\" + customBlockSyntax + payload.info;\n            var startNode = createTextNode$1(schema, customBlock);\n            var endNode = createTextNode$1(schema, customBlockSyntax);\n            tr.insert(startFromOffset, startNode).split(startFromOffset + customBlock.length);\n            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), endNode);\n            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - (customBlockSyntax.length + 2))));\n            return true;\n        }; };\n    };\n    return CustomBlock;\n}(Mark));\n\nvar reTaskMarkerKey = /x|backspace/i;\nvar reTaskMarker = /^\\[(\\s*)(x?)(\\s*)\\](?:\\s+)/i;\nfunction smartTask(_a) {\n    var schema = _a.schema, toastMark = _a.toastMark;\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                keyup: function (view, ev) {\n                    var _a;\n                    var _b = view.state, doc = _b.doc, tr = _b.tr, selection = _b.selection;\n                    if (selection.empty && reTaskMarkerKey.test(ev.key)) {\n                        var _c = getRangeInfo(selection), startIndex = _c.startIndex, startFromOffset = _c.startFromOffset, from = _c.from;\n                        // should add `1` to line for the markdown parser\n                        // because markdown parser has `1`(not zero) as the start number\n                        var mdPos = [startIndex + 1, from - startFromOffset + 1];\n                        var mdNode = toastMark.findNodeAtPosition(mdPos);\n                        var paraNode = findClosestNode(mdNode, function (node) { var _a; return node.type === 'paragraph' && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'item'; });\n                        if ((_a = paraNode === null || paraNode === void 0 ? void 0 : paraNode.firstChild) === null || _a === void 0 ? void 0 : _a.literal) {\n                            var firstChild = paraNode.firstChild;\n                            var matched = firstChild.literal.match(reTaskMarker);\n                            if (matched) {\n                                var startMdPos = firstChild.sourcepos[0];\n                                var startSpaces = matched[1], stateChar = matched[2], lastSpaces = matched[3];\n                                var spaces = startSpaces.length + lastSpaces.length;\n                                var startOffset = getNodeContentOffsetRange(doc, startMdPos[0] - 1).startOffset;\n                                var startPos = startMdPos[1] + startOffset;\n                                if (stateChar) {\n                                    var addedPos = spaces ? spaces + 1 : 0;\n                                    tr.replaceWith(startPos, addedPos + startPos, schema.text(stateChar));\n                                    view.dispatch(tr);\n                                }\n                                else if (!spaces) {\n                                    tr.insertText(' ', startPos);\n                                    view.dispatch(tr);\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EVENT_TYPE = 'cut';\nvar reLineEnding$2 = /\\r\\n|\\n|\\r/;\nvar MdEditor = /** @class */ (function (_super) {\n    __extends$1(MdEditor, _super);\n    function MdEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toastMark = options.toastMark, _a = options.useCommandShortcut, useCommandShortcut = _a === void 0 ? true : _a, _b = options.mdPlugins, mdPlugins = _b === void 0 ? [] : _b;\n        _this.editorType = 'markdown';\n        _this.el.classList.add('md-mode');\n        _this.toastMark = toastMark;\n        _this.extraPlugins = mdPlugins;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema();\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.createClipboard();\n        // To prevent unnecessary focus setting during initial rendering\n        _this.eventEmitter.listen('changePreviewTabWrite', function (isMarkdownTabMounted) {\n            return _this.toggleActive(true, isMarkdownTabMounted);\n        });\n        _this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(false); });\n        _this.initEvent();\n        return _this;\n    }\n    MdEditor.prototype.toggleActive = function (active, isMarkdownTabMounted) {\n        toggleClass(this.el, 'active', active);\n        if (active) {\n            if (!isMarkdownTabMounted) {\n                this.focus();\n            }\n        }\n        else {\n            this.blur();\n        }\n    };\n    MdEditor.prototype.createClipboard = function () {\n        var _this = this;\n        this.clipboard = document.createElement('textarea');\n        this.clipboard.className = cls('pseudo-clipboard');\n        this.clipboard.addEventListener('paste', function (ev) {\n            var clipboardData = ev.clipboardData || window.clipboardData;\n            var items = clipboardData && clipboardData.items;\n            if (items) {\n                var containRtfItem = toArray_1(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });\n                // if it contains rtf, it's most likely copy paste from office -> no image\n                if (!containRtfItem) {\n                    var imageBlob = pasteImageOnly(items);\n                    if (imageBlob) {\n                        ev.preventDefault();\n                        emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                    }\n                }\n            }\n        });\n        // process the pasted data in input event for IE11\n        this.clipboard.addEventListener('input', function (ev) {\n            var text = ev.target.value;\n            _this.replaceSelection(text);\n            ev.preventDefault();\n            ev.target.value = '';\n        });\n        this.el.insertBefore(this.clipboard, this.view.dom);\n    };\n    MdEditor.prototype.createContext = function () {\n        return {\n            toastMark: this.toastMark,\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    MdEditor.prototype.createSpecs = function () {\n        return new SpecManager([\n            new Doc$1(),\n            new Paragraph$1(),\n            new Widget(),\n            new Text$1(),\n            new Heading$1(),\n            new BlockQuote$1(),\n            new CodeBlock$1(),\n            new CustomBlock$1(),\n            new Table$1(),\n            new TableCell(),\n            new ThematicBreak$1(),\n            new ListItem$1(),\n            new Strong$1(),\n            new Strike$1(),\n            new Emph$1(),\n            new Code$1(),\n            new Link$1(),\n            new Delimiter(),\n            new TaskDelimiter(),\n            new MarkedText(),\n            new Meta(),\n            new Html(),\n        ]);\n    };\n    MdEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            syntaxHighlight(this.context),\n            previewHighlight(this.context),\n            smartTask(this.context)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    MdEditor.prototype.createView = function () {\n        var _this = this;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            dispatchTransaction: function (tr) {\n                _this.updateMarkdown(tr);\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr);\n            },\n            handleKeyDown: function (_, ev) {\n                if ((ev.metaKey || ev.ctrlKey) && ev.key.toUpperCase() === 'V') {\n                    _this.clipboard.focus();\n                }\n                _this.eventEmitter.emit('keydown', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                copy: function (_, ev) { return _this.captureCopy(ev); },\n                cut: function (_, ev) { return _this.captureCopy(ev, EVENT_TYPE); },\n                scroll: function () {\n                    _this.eventEmitter.emit('scroll', 'editor');\n                    return true;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit('keyup', _this.editorType, ev);\n                    return false;\n                },\n            },\n            nodeViews: {\n                widget: widgetNodeView,\n            },\n        });\n    };\n    MdEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view);\n    };\n    MdEditor.prototype.captureCopy = function (ev, type) {\n        ev.preventDefault();\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        if (selection.empty) {\n            return true;\n        }\n        var text = this.getChanged(selection.content());\n        if (ev.clipboardData) {\n            ev.clipboardData.setData('text/plain', text);\n        }\n        else {\n            window.clipboardData.setData('Text', text);\n        }\n        if (type === EVENT_TYPE) {\n            this.view.dispatch(tr.deleteSelection().scrollIntoView().setMeta('uiEvent', EVENT_TYPE));\n        }\n        return true;\n    };\n    MdEditor.prototype.updateMarkdown = function (tr) {\n        var _this = this;\n        if (tr.docChanged) {\n            tr.steps.forEach(function (step, index) {\n                if (step.slice && !(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep)) {\n                    var doc = tr.docs[index];\n                    var _a = [step.from, step.to], from = _a[0], to = _a[1];\n                    var _b = getEditorToMdPos(doc, from, to), startPos = _b[0], endPos = _b[1];\n                    var changed = _this.getChanged(step.slice);\n                    if (startPos[0] === endPos[0] && startPos[1] === endPos[1] && changed === '') {\n                        changed = '\\n';\n                    }\n                    var editResult = _this.toastMark.editMarkdown(startPos, endPos, changed);\n                    _this.eventEmitter.emit('updatePreview', editResult);\n                    tr.setMeta('editResult', editResult).scrollIntoView();\n                }\n            });\n        }\n    };\n    MdEditor.prototype.getChanged = function (slice) {\n        var changed = '';\n        var from = 0;\n        var to = slice.content.size;\n        slice.content.nodesBetween(from, to, function (node, pos) {\n            if (node.isText) {\n                changed += node.text.slice(Math.max(from, pos) - pos, to - pos);\n            }\n            else if (node.isBlock && pos > 0) {\n                changed += '\\n';\n            }\n        });\n        return changed;\n    };\n    MdEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var _a = getMdToEditorPos(tr.doc, start, end), from = _a[0], to = _a[1];\n        this.view.dispatch(tr.setSelection(createTextSelection(tr, from, to)).scrollIntoView());\n    };\n    MdEditor.prototype.replaceSelection = function (text, start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var lineTexts = text.split(reLineEnding$2);\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), 1, 1);\n        this.focus();\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.replaceRange(from, to, slice);\n        }\n        else {\n            newTr = tr.replaceSelection(slice);\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.deleteSelection = function (start, end) {\n        var newTr;\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        if (start && end) {\n            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];\n            newTr = tr.deleteRange(from, to);\n        }\n        else {\n            newTr = tr.deleteSelection();\n        }\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    MdEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (start && end) {\n            var pos = getMdToEditorPos(doc, start, end);\n            from = pos[0];\n            to = pos[1];\n        }\n        return doc.textBetween(from, to, '\\n');\n    };\n    MdEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return getEditorToMdPos(this.view.state.tr.doc, from, to);\n    };\n    MdEditor.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var lineTexts = markdown.split(reLineEnding$2);\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, schema = _a.schema;\n        var nodes = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, nodes));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    MdEditor.prototype.addWidget = function (node, style, mdPos) {\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc, selection = _a.selection;\n        var pos = mdPos ? getMdToEditorPos(doc, mdPos, mdPos)[0] : selection.to;\n        this.view.dispatch(tr.setMeta('widget', { pos: pos, node: node, style: style }));\n    };\n    MdEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;\n        var pos = getMdToEditorPos(doc, start, end);\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(pos[0], pos[1], nodes));\n    };\n    MdEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var mdPos = pos || getEditorToMdPos(doc, selection.from)[0];\n        var mdNode = this.toastMark.findNodeAtPosition(mdPos);\n        if (mdNode.type === 'text' && mdNode.parent.type !== 'paragraph') {\n            mdNode = mdNode.parent;\n        }\n        // add 1 sync for prosemirror position\n        mdNode.sourcepos[1][1] += 1;\n        return { range: mdNode.sourcepos, type: mdNode.type };\n    };\n    MdEditor.prototype.getMarkdown = function () {\n        return this.toastMark\n            .getLineTexts()\n            .map(function (lineText) { return unwrapWidgetSyntax(lineText); })\n            .join('\\n');\n    };\n    MdEditor.prototype.getToastMark = function () {\n        return this.toastMark;\n    };\n    return MdEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent$2(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nvar _safeEvent = safeEvent$2;\n\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString$1 = isString_1;\nvar forEach$1 = forEach_1;\n\nvar safeEvent$1 = _safeEvent;\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, 'click', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, 'mouseenter mouseleave', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, 'drag');\n */\nfunction off(element, types, handler) {\n  if (isString$1(types)) {\n    forEach$1(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach$1(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent$1(element, type);\n  var index;\n\n  if (!handler) {\n    forEach$1(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach$1(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if ('removeEventListener' in element) {\n    element.removeEventListener(type, handler);\n  } else if ('detachEvent' in element) {\n    element.detachEvent('on' + type, handler);\n  }\n}\n\nvar off_1 = off;\n\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isString = isString_1;\nvar forEach = forEach_1;\n\nvar safeEvent = _safeEvent;\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector('div');\n * \n * // Bind one event to an element.\n * on(div, 'click', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, 'mouseenter mouseleave', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = 'global';\n * const repository = {name: 'CodeSnippet'};\n * on(div, 'drag', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: \"CodeSnippet\"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if ('addEventListener' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if ('attachEvent' in element) {\n    element.attachEvent('on' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nvar on_1 = on;\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped  = exclude;\n    exclude = encode$1.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode$1.defaultChars   = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\n\n\nvar encode_1 = encode$1;\n\nvar lib = {};\n\nvar decode = {};\n\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element$1 = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$1 = {\n\tAacute: Aacute$1,\n\taacute: aacute$1,\n\tAbreve: Abreve,\n\tabreve: abreve,\n\tac: ac,\n\tacd: acd,\n\tacE: acE,\n\tAcirc: Acirc$1,\n\tacirc: acirc$1,\n\tacute: acute$1,\n\tAcy: Acy,\n\tacy: acy,\n\tAElig: AElig$1,\n\taelig: aelig$1,\n\taf: af,\n\tAfr: Afr,\n\tafr: afr,\n\tAgrave: Agrave$1,\n\tagrave: agrave$1,\n\talefsym: alefsym,\n\taleph: aleph,\n\tAlpha: Alpha,\n\talpha: alpha,\n\tAmacr: Amacr,\n\tamacr: amacr,\n\tamalg: amalg,\n\tamp: amp$2,\n\tAMP: AMP$1,\n\tandand: andand,\n\tAnd: And,\n\tand: and,\n\tandd: andd,\n\tandslope: andslope,\n\tandv: andv,\n\tang: ang,\n\tange: ange,\n\tangle: angle,\n\tangmsdaa: angmsdaa,\n\tangmsdab: angmsdab,\n\tangmsdac: angmsdac,\n\tangmsdad: angmsdad,\n\tangmsdae: angmsdae,\n\tangmsdaf: angmsdaf,\n\tangmsdag: angmsdag,\n\tangmsdah: angmsdah,\n\tangmsd: angmsd,\n\tangrt: angrt,\n\tangrtvb: angrtvb,\n\tangrtvbd: angrtvbd,\n\tangsph: angsph,\n\tangst: angst,\n\tangzarr: angzarr,\n\tAogon: Aogon,\n\taogon: aogon,\n\tAopf: Aopf,\n\taopf: aopf,\n\tapacir: apacir,\n\tap: ap,\n\tapE: apE,\n\tape: ape,\n\tapid: apid,\n\tapos: apos$1,\n\tApplyFunction: ApplyFunction,\n\tapprox: approx,\n\tapproxeq: approxeq,\n\tAring: Aring$1,\n\taring: aring$1,\n\tAscr: Ascr,\n\tascr: ascr,\n\tAssign: Assign,\n\tast: ast,\n\tasymp: asymp,\n\tasympeq: asympeq,\n\tAtilde: Atilde$1,\n\tatilde: atilde$1,\n\tAuml: Auml$1,\n\tauml: auml$1,\n\tawconint: awconint,\n\tawint: awint,\n\tbackcong: backcong,\n\tbackepsilon: backepsilon,\n\tbackprime: backprime,\n\tbacksim: backsim,\n\tbacksimeq: backsimeq,\n\tBackslash: Backslash,\n\tBarv: Barv,\n\tbarvee: barvee,\n\tbarwed: barwed,\n\tBarwed: Barwed,\n\tbarwedge: barwedge,\n\tbbrk: bbrk,\n\tbbrktbrk: bbrktbrk,\n\tbcong: bcong,\n\tBcy: Bcy,\n\tbcy: bcy,\n\tbdquo: bdquo,\n\tbecaus: becaus,\n\tbecause: because,\n\tBecause: Because,\n\tbemptyv: bemptyv,\n\tbepsi: bepsi,\n\tbernou: bernou,\n\tBernoullis: Bernoullis,\n\tBeta: Beta,\n\tbeta: beta,\n\tbeth: beth,\n\tbetween: between,\n\tBfr: Bfr,\n\tbfr: bfr,\n\tbigcap: bigcap,\n\tbigcirc: bigcirc,\n\tbigcup: bigcup,\n\tbigodot: bigodot,\n\tbigoplus: bigoplus,\n\tbigotimes: bigotimes,\n\tbigsqcup: bigsqcup,\n\tbigstar: bigstar,\n\tbigtriangledown: bigtriangledown,\n\tbigtriangleup: bigtriangleup,\n\tbiguplus: biguplus,\n\tbigvee: bigvee,\n\tbigwedge: bigwedge,\n\tbkarow: bkarow,\n\tblacklozenge: blacklozenge,\n\tblacksquare: blacksquare,\n\tblacktriangle: blacktriangle,\n\tblacktriangledown: blacktriangledown,\n\tblacktriangleleft: blacktriangleleft,\n\tblacktriangleright: blacktriangleright,\n\tblank: blank,\n\tblk12: blk12,\n\tblk14: blk14,\n\tblk34: blk34,\n\tblock: block,\n\tbne: bne,\n\tbnequiv: bnequiv,\n\tbNot: bNot,\n\tbnot: bnot,\n\tBopf: Bopf,\n\tbopf: bopf,\n\tbot: bot,\n\tbottom: bottom,\n\tbowtie: bowtie,\n\tboxbox: boxbox,\n\tboxdl: boxdl,\n\tboxdL: boxdL,\n\tboxDl: boxDl,\n\tboxDL: boxDL,\n\tboxdr: boxdr,\n\tboxdR: boxdR,\n\tboxDr: boxDr,\n\tboxDR: boxDR,\n\tboxh: boxh,\n\tboxH: boxH,\n\tboxhd: boxhd,\n\tboxHd: boxHd,\n\tboxhD: boxhD,\n\tboxHD: boxHD,\n\tboxhu: boxhu,\n\tboxHu: boxHu,\n\tboxhU: boxhU,\n\tboxHU: boxHU,\n\tboxminus: boxminus,\n\tboxplus: boxplus,\n\tboxtimes: boxtimes,\n\tboxul: boxul,\n\tboxuL: boxuL,\n\tboxUl: boxUl,\n\tboxUL: boxUL,\n\tboxur: boxur,\n\tboxuR: boxuR,\n\tboxUr: boxUr,\n\tboxUR: boxUR,\n\tboxv: boxv,\n\tboxV: boxV,\n\tboxvh: boxvh,\n\tboxvH: boxvH,\n\tboxVh: boxVh,\n\tboxVH: boxVH,\n\tboxvl: boxvl,\n\tboxvL: boxvL,\n\tboxVl: boxVl,\n\tboxVL: boxVL,\n\tboxvr: boxvr,\n\tboxvR: boxvR,\n\tboxVr: boxVr,\n\tboxVR: boxVR,\n\tbprime: bprime,\n\tbreve: breve,\n\tBreve: Breve,\n\tbrvbar: brvbar$1,\n\tbscr: bscr,\n\tBscr: Bscr,\n\tbsemi: bsemi,\n\tbsim: bsim,\n\tbsime: bsime,\n\tbsolb: bsolb,\n\tbsol: bsol,\n\tbsolhsub: bsolhsub,\n\tbull: bull,\n\tbullet: bullet,\n\tbump: bump,\n\tbumpE: bumpE,\n\tbumpe: bumpe,\n\tBumpeq: Bumpeq,\n\tbumpeq: bumpeq,\n\tCacute: Cacute,\n\tcacute: cacute,\n\tcapand: capand,\n\tcapbrcup: capbrcup,\n\tcapcap: capcap,\n\tcap: cap,\n\tCap: Cap,\n\tcapcup: capcup,\n\tcapdot: capdot,\n\tCapitalDifferentialD: CapitalDifferentialD,\n\tcaps: caps,\n\tcaret: caret,\n\tcaron: caron,\n\tCayleys: Cayleys,\n\tccaps: ccaps,\n\tCcaron: Ccaron,\n\tccaron: ccaron,\n\tCcedil: Ccedil$1,\n\tccedil: ccedil$1,\n\tCcirc: Ccirc,\n\tccirc: ccirc,\n\tCconint: Cconint,\n\tccups: ccups,\n\tccupssm: ccupssm,\n\tCdot: Cdot,\n\tcdot: cdot,\n\tcedil: cedil$1,\n\tCedilla: Cedilla,\n\tcemptyv: cemptyv,\n\tcent: cent$1,\n\tcenterdot: centerdot,\n\tCenterDot: CenterDot,\n\tcfr: cfr,\n\tCfr: Cfr,\n\tCHcy: CHcy,\n\tchcy: chcy,\n\tcheck: check,\n\tcheckmark: checkmark,\n\tChi: Chi,\n\tchi: chi,\n\tcirc: circ,\n\tcirceq: circeq,\n\tcirclearrowleft: circlearrowleft,\n\tcirclearrowright: circlearrowright,\n\tcircledast: circledast,\n\tcircledcirc: circledcirc,\n\tcircleddash: circleddash,\n\tCircleDot: CircleDot,\n\tcircledR: circledR,\n\tcircledS: circledS,\n\tCircleMinus: CircleMinus,\n\tCirclePlus: CirclePlus,\n\tCircleTimes: CircleTimes,\n\tcir: cir,\n\tcirE: cirE,\n\tcire: cire,\n\tcirfnint: cirfnint,\n\tcirmid: cirmid,\n\tcirscir: cirscir,\n\tClockwiseContourIntegral: ClockwiseContourIntegral,\n\tCloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n\tCloseCurlyQuote: CloseCurlyQuote,\n\tclubs: clubs,\n\tclubsuit: clubsuit,\n\tcolon: colon,\n\tColon: Colon,\n\tColone: Colone,\n\tcolone: colone,\n\tcoloneq: coloneq,\n\tcomma: comma,\n\tcommat: commat,\n\tcomp: comp,\n\tcompfn: compfn,\n\tcomplement: complement,\n\tcomplexes: complexes,\n\tcong: cong,\n\tcongdot: congdot,\n\tCongruent: Congruent,\n\tconint: conint,\n\tConint: Conint,\n\tContourIntegral: ContourIntegral,\n\tcopf: copf,\n\tCopf: Copf,\n\tcoprod: coprod,\n\tCoproduct: Coproduct,\n\tcopy: copy$1,\n\tCOPY: COPY$1,\n\tcopysr: copysr,\n\tCounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n\tcrarr: crarr,\n\tcross: cross,\n\tCross: Cross,\n\tCscr: Cscr,\n\tcscr: cscr,\n\tcsub: csub,\n\tcsube: csube,\n\tcsup: csup,\n\tcsupe: csupe,\n\tctdot: ctdot,\n\tcudarrl: cudarrl,\n\tcudarrr: cudarrr,\n\tcuepr: cuepr,\n\tcuesc: cuesc,\n\tcularr: cularr,\n\tcularrp: cularrp,\n\tcupbrcap: cupbrcap,\n\tcupcap: cupcap,\n\tCupCap: CupCap,\n\tcup: cup,\n\tCup: Cup,\n\tcupcup: cupcup,\n\tcupdot: cupdot,\n\tcupor: cupor,\n\tcups: cups,\n\tcurarr: curarr,\n\tcurarrm: curarrm,\n\tcurlyeqprec: curlyeqprec,\n\tcurlyeqsucc: curlyeqsucc,\n\tcurlyvee: curlyvee,\n\tcurlywedge: curlywedge,\n\tcurren: curren$1,\n\tcurvearrowleft: curvearrowleft,\n\tcurvearrowright: curvearrowright,\n\tcuvee: cuvee,\n\tcuwed: cuwed,\n\tcwconint: cwconint,\n\tcwint: cwint,\n\tcylcty: cylcty,\n\tdagger: dagger,\n\tDagger: Dagger,\n\tdaleth: daleth,\n\tdarr: darr,\n\tDarr: Darr,\n\tdArr: dArr,\n\tdash: dash,\n\tDashv: Dashv,\n\tdashv: dashv,\n\tdbkarow: dbkarow,\n\tdblac: dblac,\n\tDcaron: Dcaron,\n\tdcaron: dcaron,\n\tDcy: Dcy,\n\tdcy: dcy,\n\tddagger: ddagger,\n\tddarr: ddarr,\n\tDD: DD,\n\tdd: dd,\n\tDDotrahd: DDotrahd,\n\tddotseq: ddotseq,\n\tdeg: deg$1,\n\tDel: Del,\n\tDelta: Delta,\n\tdelta: delta,\n\tdemptyv: demptyv,\n\tdfisht: dfisht,\n\tDfr: Dfr,\n\tdfr: dfr,\n\tdHar: dHar,\n\tdharl: dharl,\n\tdharr: dharr,\n\tDiacriticalAcute: DiacriticalAcute,\n\tDiacriticalDot: DiacriticalDot,\n\tDiacriticalDoubleAcute: DiacriticalDoubleAcute,\n\tDiacriticalGrave: DiacriticalGrave,\n\tDiacriticalTilde: DiacriticalTilde,\n\tdiam: diam,\n\tdiamond: diamond,\n\tDiamond: Diamond,\n\tdiamondsuit: diamondsuit,\n\tdiams: diams,\n\tdie: die,\n\tDifferentialD: DifferentialD,\n\tdigamma: digamma,\n\tdisin: disin,\n\tdiv: div,\n\tdivide: divide$1,\n\tdivideontimes: divideontimes,\n\tdivonx: divonx,\n\tDJcy: DJcy,\n\tdjcy: djcy,\n\tdlcorn: dlcorn,\n\tdlcrop: dlcrop,\n\tdollar: dollar,\n\tDopf: Dopf,\n\tdopf: dopf,\n\tDot: Dot,\n\tdot: dot,\n\tDotDot: DotDot,\n\tdoteq: doteq,\n\tdoteqdot: doteqdot,\n\tDotEqual: DotEqual,\n\tdotminus: dotminus,\n\tdotplus: dotplus,\n\tdotsquare: dotsquare,\n\tdoublebarwedge: doublebarwedge,\n\tDoubleContourIntegral: DoubleContourIntegral,\n\tDoubleDot: DoubleDot,\n\tDoubleDownArrow: DoubleDownArrow,\n\tDoubleLeftArrow: DoubleLeftArrow,\n\tDoubleLeftRightArrow: DoubleLeftRightArrow,\n\tDoubleLeftTee: DoubleLeftTee,\n\tDoubleLongLeftArrow: DoubleLongLeftArrow,\n\tDoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n\tDoubleLongRightArrow: DoubleLongRightArrow,\n\tDoubleRightArrow: DoubleRightArrow,\n\tDoubleRightTee: DoubleRightTee,\n\tDoubleUpArrow: DoubleUpArrow,\n\tDoubleUpDownArrow: DoubleUpDownArrow,\n\tDoubleVerticalBar: DoubleVerticalBar,\n\tDownArrowBar: DownArrowBar,\n\tdownarrow: downarrow,\n\tDownArrow: DownArrow,\n\tDownarrow: Downarrow,\n\tDownArrowUpArrow: DownArrowUpArrow,\n\tDownBreve: DownBreve,\n\tdowndownarrows: downdownarrows,\n\tdownharpoonleft: downharpoonleft,\n\tdownharpoonright: downharpoonright,\n\tDownLeftRightVector: DownLeftRightVector,\n\tDownLeftTeeVector: DownLeftTeeVector,\n\tDownLeftVectorBar: DownLeftVectorBar,\n\tDownLeftVector: DownLeftVector,\n\tDownRightTeeVector: DownRightTeeVector,\n\tDownRightVectorBar: DownRightVectorBar,\n\tDownRightVector: DownRightVector,\n\tDownTeeArrow: DownTeeArrow,\n\tDownTee: DownTee,\n\tdrbkarow: drbkarow,\n\tdrcorn: drcorn,\n\tdrcrop: drcrop,\n\tDscr: Dscr,\n\tdscr: dscr,\n\tDScy: DScy,\n\tdscy: dscy,\n\tdsol: dsol,\n\tDstrok: Dstrok,\n\tdstrok: dstrok,\n\tdtdot: dtdot,\n\tdtri: dtri,\n\tdtrif: dtrif,\n\tduarr: duarr,\n\tduhar: duhar,\n\tdwangle: dwangle,\n\tDZcy: DZcy,\n\tdzcy: dzcy,\n\tdzigrarr: dzigrarr,\n\tEacute: Eacute$1,\n\teacute: eacute$1,\n\teaster: easter,\n\tEcaron: Ecaron,\n\tecaron: ecaron,\n\tEcirc: Ecirc$1,\n\tecirc: ecirc$1,\n\tecir: ecir,\n\tecolon: ecolon,\n\tEcy: Ecy,\n\tecy: ecy,\n\teDDot: eDDot,\n\tEdot: Edot,\n\tedot: edot,\n\teDot: eDot,\n\tee: ee,\n\tefDot: efDot,\n\tEfr: Efr,\n\tefr: efr,\n\teg: eg,\n\tEgrave: Egrave$1,\n\tegrave: egrave$1,\n\tegs: egs,\n\tegsdot: egsdot,\n\tel: el,\n\tElement: Element$1,\n\telinters: elinters,\n\tell: ell,\n\tels: els,\n\telsdot: elsdot,\n\tEmacr: Emacr,\n\temacr: emacr,\n\tempty: empty,\n\temptyset: emptyset,\n\tEmptySmallSquare: EmptySmallSquare,\n\temptyv: emptyv,\n\tEmptyVerySmallSquare: EmptyVerySmallSquare,\n\temsp13: emsp13,\n\temsp14: emsp14,\n\temsp: emsp,\n\tENG: ENG,\n\teng: eng,\n\tensp: ensp,\n\tEogon: Eogon,\n\teogon: eogon,\n\tEopf: Eopf,\n\teopf: eopf,\n\tepar: epar,\n\teparsl: eparsl,\n\teplus: eplus,\n\tepsi: epsi,\n\tEpsilon: Epsilon,\n\tepsilon: epsilon,\n\tepsiv: epsiv,\n\teqcirc: eqcirc,\n\teqcolon: eqcolon,\n\teqsim: eqsim,\n\teqslantgtr: eqslantgtr,\n\teqslantless: eqslantless,\n\tEqual: Equal,\n\tequals: equals,\n\tEqualTilde: EqualTilde,\n\tequest: equest,\n\tEquilibrium: Equilibrium,\n\tequiv: equiv,\n\tequivDD: equivDD,\n\teqvparsl: eqvparsl,\n\terarr: erarr,\n\terDot: erDot,\n\tescr: escr,\n\tEscr: Escr,\n\tesdot: esdot,\n\tEsim: Esim,\n\tesim: esim,\n\tEta: Eta,\n\teta: eta,\n\tETH: ETH$1,\n\teth: eth$1,\n\tEuml: Euml$1,\n\teuml: euml$1,\n\teuro: euro,\n\texcl: excl,\n\texist: exist,\n\tExists: Exists,\n\texpectation: expectation,\n\texponentiale: exponentiale,\n\tExponentialE: ExponentialE,\n\tfallingdotseq: fallingdotseq,\n\tFcy: Fcy,\n\tfcy: fcy,\n\tfemale: female,\n\tffilig: ffilig,\n\tfflig: fflig,\n\tffllig: ffllig,\n\tFfr: Ffr,\n\tffr: ffr,\n\tfilig: filig,\n\tFilledSmallSquare: FilledSmallSquare,\n\tFilledVerySmallSquare: FilledVerySmallSquare,\n\tfjlig: fjlig,\n\tflat: flat,\n\tfllig: fllig,\n\tfltns: fltns,\n\tfnof: fnof,\n\tFopf: Fopf,\n\tfopf: fopf,\n\tforall: forall,\n\tForAll: ForAll,\n\tfork: fork,\n\tforkv: forkv,\n\tFouriertrf: Fouriertrf,\n\tfpartint: fpartint,\n\tfrac12: frac12$1,\n\tfrac13: frac13,\n\tfrac14: frac14$1,\n\tfrac15: frac15,\n\tfrac16: frac16,\n\tfrac18: frac18,\n\tfrac23: frac23,\n\tfrac25: frac25,\n\tfrac34: frac34$1,\n\tfrac35: frac35,\n\tfrac38: frac38,\n\tfrac45: frac45,\n\tfrac56: frac56,\n\tfrac58: frac58,\n\tfrac78: frac78,\n\tfrasl: frasl,\n\tfrown: frown,\n\tfscr: fscr,\n\tFscr: Fscr,\n\tgacute: gacute,\n\tGamma: Gamma,\n\tgamma: gamma,\n\tGammad: Gammad,\n\tgammad: gammad,\n\tgap: gap,\n\tGbreve: Gbreve,\n\tgbreve: gbreve,\n\tGcedil: Gcedil,\n\tGcirc: Gcirc,\n\tgcirc: gcirc,\n\tGcy: Gcy,\n\tgcy: gcy,\n\tGdot: Gdot,\n\tgdot: gdot,\n\tge: ge,\n\tgE: gE,\n\tgEl: gEl,\n\tgel: gel,\n\tgeq: geq,\n\tgeqq: geqq,\n\tgeqslant: geqslant,\n\tgescc: gescc,\n\tges: ges,\n\tgesdot: gesdot,\n\tgesdoto: gesdoto,\n\tgesdotol: gesdotol,\n\tgesl: gesl,\n\tgesles: gesles,\n\tGfr: Gfr,\n\tgfr: gfr,\n\tgg: gg,\n\tGg: Gg,\n\tggg: ggg,\n\tgimel: gimel,\n\tGJcy: GJcy,\n\tgjcy: gjcy,\n\tgla: gla,\n\tgl: gl,\n\tglE: glE,\n\tglj: glj,\n\tgnap: gnap,\n\tgnapprox: gnapprox,\n\tgne: gne,\n\tgnE: gnE,\n\tgneq: gneq,\n\tgneqq: gneqq,\n\tgnsim: gnsim,\n\tGopf: Gopf,\n\tgopf: gopf,\n\tgrave: grave,\n\tGreaterEqual: GreaterEqual,\n\tGreaterEqualLess: GreaterEqualLess,\n\tGreaterFullEqual: GreaterFullEqual,\n\tGreaterGreater: GreaterGreater,\n\tGreaterLess: GreaterLess,\n\tGreaterSlantEqual: GreaterSlantEqual,\n\tGreaterTilde: GreaterTilde,\n\tGscr: Gscr,\n\tgscr: gscr,\n\tgsim: gsim,\n\tgsime: gsime,\n\tgsiml: gsiml,\n\tgtcc: gtcc,\n\tgtcir: gtcir,\n\tgt: gt$2,\n\tGT: GT$1,\n\tGt: Gt,\n\tgtdot: gtdot,\n\tgtlPar: gtlPar,\n\tgtquest: gtquest,\n\tgtrapprox: gtrapprox,\n\tgtrarr: gtrarr,\n\tgtrdot: gtrdot,\n\tgtreqless: gtreqless,\n\tgtreqqless: gtreqqless,\n\tgtrless: gtrless,\n\tgtrsim: gtrsim,\n\tgvertneqq: gvertneqq,\n\tgvnE: gvnE,\n\tHacek: Hacek,\n\thairsp: hairsp,\n\thalf: half,\n\thamilt: hamilt,\n\tHARDcy: HARDcy,\n\thardcy: hardcy,\n\tharrcir: harrcir,\n\tharr: harr,\n\thArr: hArr,\n\tharrw: harrw,\n\tHat: Hat,\n\thbar: hbar,\n\tHcirc: Hcirc,\n\thcirc: hcirc,\n\thearts: hearts,\n\theartsuit: heartsuit,\n\thellip: hellip,\n\thercon: hercon,\n\thfr: hfr,\n\tHfr: Hfr,\n\tHilbertSpace: HilbertSpace,\n\thksearow: hksearow,\n\thkswarow: hkswarow,\n\thoarr: hoarr,\n\thomtht: homtht,\n\thookleftarrow: hookleftarrow,\n\thookrightarrow: hookrightarrow,\n\thopf: hopf,\n\tHopf: Hopf,\n\thorbar: horbar,\n\tHorizontalLine: HorizontalLine,\n\thscr: hscr,\n\tHscr: Hscr,\n\thslash: hslash,\n\tHstrok: Hstrok,\n\thstrok: hstrok,\n\tHumpDownHump: HumpDownHump,\n\tHumpEqual: HumpEqual,\n\thybull: hybull,\n\thyphen: hyphen,\n\tIacute: Iacute$1,\n\tiacute: iacute$1,\n\tic: ic,\n\tIcirc: Icirc$1,\n\ticirc: icirc$1,\n\tIcy: Icy,\n\ticy: icy,\n\tIdot: Idot,\n\tIEcy: IEcy,\n\tiecy: iecy,\n\tiexcl: iexcl$1,\n\tiff: iff,\n\tifr: ifr,\n\tIfr: Ifr,\n\tIgrave: Igrave$1,\n\tigrave: igrave$1,\n\tii: ii,\n\tiiiint: iiiint,\n\tiiint: iiint,\n\tiinfin: iinfin,\n\tiiota: iiota,\n\tIJlig: IJlig,\n\tijlig: ijlig,\n\tImacr: Imacr,\n\timacr: imacr,\n\timage: image,\n\tImaginaryI: ImaginaryI,\n\timagline: imagline,\n\timagpart: imagpart,\n\timath: imath,\n\tIm: Im,\n\timof: imof,\n\timped: imped,\n\tImplies: Implies,\n\tincare: incare,\n\t\"in\": \"∈\",\n\tinfin: infin,\n\tinfintie: infintie,\n\tinodot: inodot,\n\tintcal: intcal,\n\tint: int,\n\tInt: Int,\n\tintegers: integers,\n\tIntegral: Integral,\n\tintercal: intercal,\n\tIntersection: Intersection,\n\tintlarhk: intlarhk,\n\tintprod: intprod,\n\tInvisibleComma: InvisibleComma,\n\tInvisibleTimes: InvisibleTimes,\n\tIOcy: IOcy,\n\tiocy: iocy,\n\tIogon: Iogon,\n\tiogon: iogon,\n\tIopf: Iopf,\n\tiopf: iopf,\n\tIota: Iota,\n\tiota: iota,\n\tiprod: iprod,\n\tiquest: iquest$1,\n\tiscr: iscr,\n\tIscr: Iscr,\n\tisin: isin,\n\tisindot: isindot,\n\tisinE: isinE,\n\tisins: isins,\n\tisinsv: isinsv,\n\tisinv: isinv,\n\tit: it,\n\tItilde: Itilde,\n\titilde: itilde,\n\tIukcy: Iukcy,\n\tiukcy: iukcy,\n\tIuml: Iuml$1,\n\tiuml: iuml$1,\n\tJcirc: Jcirc,\n\tjcirc: jcirc,\n\tJcy: Jcy,\n\tjcy: jcy,\n\tJfr: Jfr,\n\tjfr: jfr,\n\tjmath: jmath,\n\tJopf: Jopf,\n\tjopf: jopf,\n\tJscr: Jscr,\n\tjscr: jscr,\n\tJsercy: Jsercy,\n\tjsercy: jsercy,\n\tJukcy: Jukcy,\n\tjukcy: jukcy,\n\tKappa: Kappa,\n\tkappa: kappa,\n\tkappav: kappav,\n\tKcedil: Kcedil,\n\tkcedil: kcedil,\n\tKcy: Kcy,\n\tkcy: kcy,\n\tKfr: Kfr,\n\tkfr: kfr,\n\tkgreen: kgreen,\n\tKHcy: KHcy,\n\tkhcy: khcy,\n\tKJcy: KJcy,\n\tkjcy: kjcy,\n\tKopf: Kopf,\n\tkopf: kopf,\n\tKscr: Kscr,\n\tkscr: kscr,\n\tlAarr: lAarr,\n\tLacute: Lacute,\n\tlacute: lacute,\n\tlaemptyv: laemptyv,\n\tlagran: lagran,\n\tLambda: Lambda,\n\tlambda: lambda,\n\tlang: lang,\n\tLang: Lang,\n\tlangd: langd,\n\tlangle: langle,\n\tlap: lap,\n\tLaplacetrf: Laplacetrf,\n\tlaquo: laquo$1,\n\tlarrb: larrb,\n\tlarrbfs: larrbfs,\n\tlarr: larr,\n\tLarr: Larr,\n\tlArr: lArr,\n\tlarrfs: larrfs,\n\tlarrhk: larrhk,\n\tlarrlp: larrlp,\n\tlarrpl: larrpl,\n\tlarrsim: larrsim,\n\tlarrtl: larrtl,\n\tlatail: latail,\n\tlAtail: lAtail,\n\tlat: lat,\n\tlate: late,\n\tlates: lates,\n\tlbarr: lbarr,\n\tlBarr: lBarr,\n\tlbbrk: lbbrk,\n\tlbrace: lbrace,\n\tlbrack: lbrack,\n\tlbrke: lbrke,\n\tlbrksld: lbrksld,\n\tlbrkslu: lbrkslu,\n\tLcaron: Lcaron,\n\tlcaron: lcaron,\n\tLcedil: Lcedil,\n\tlcedil: lcedil,\n\tlceil: lceil,\n\tlcub: lcub,\n\tLcy: Lcy,\n\tlcy: lcy,\n\tldca: ldca,\n\tldquo: ldquo,\n\tldquor: ldquor,\n\tldrdhar: ldrdhar,\n\tldrushar: ldrushar,\n\tldsh: ldsh,\n\tle: le,\n\tlE: lE,\n\tLeftAngleBracket: LeftAngleBracket,\n\tLeftArrowBar: LeftArrowBar,\n\tleftarrow: leftarrow,\n\tLeftArrow: LeftArrow,\n\tLeftarrow: Leftarrow,\n\tLeftArrowRightArrow: LeftArrowRightArrow,\n\tleftarrowtail: leftarrowtail,\n\tLeftCeiling: LeftCeiling,\n\tLeftDoubleBracket: LeftDoubleBracket,\n\tLeftDownTeeVector: LeftDownTeeVector,\n\tLeftDownVectorBar: LeftDownVectorBar,\n\tLeftDownVector: LeftDownVector,\n\tLeftFloor: LeftFloor,\n\tleftharpoondown: leftharpoondown,\n\tleftharpoonup: leftharpoonup,\n\tleftleftarrows: leftleftarrows,\n\tleftrightarrow: leftrightarrow,\n\tLeftRightArrow: LeftRightArrow,\n\tLeftrightarrow: Leftrightarrow,\n\tleftrightarrows: leftrightarrows,\n\tleftrightharpoons: leftrightharpoons,\n\tleftrightsquigarrow: leftrightsquigarrow,\n\tLeftRightVector: LeftRightVector,\n\tLeftTeeArrow: LeftTeeArrow,\n\tLeftTee: LeftTee,\n\tLeftTeeVector: LeftTeeVector,\n\tleftthreetimes: leftthreetimes,\n\tLeftTriangleBar: LeftTriangleBar,\n\tLeftTriangle: LeftTriangle,\n\tLeftTriangleEqual: LeftTriangleEqual,\n\tLeftUpDownVector: LeftUpDownVector,\n\tLeftUpTeeVector: LeftUpTeeVector,\n\tLeftUpVectorBar: LeftUpVectorBar,\n\tLeftUpVector: LeftUpVector,\n\tLeftVectorBar: LeftVectorBar,\n\tLeftVector: LeftVector,\n\tlEg: lEg,\n\tleg: leg,\n\tleq: leq,\n\tleqq: leqq,\n\tleqslant: leqslant,\n\tlescc: lescc,\n\tles: les,\n\tlesdot: lesdot,\n\tlesdoto: lesdoto,\n\tlesdotor: lesdotor,\n\tlesg: lesg,\n\tlesges: lesges,\n\tlessapprox: lessapprox,\n\tlessdot: lessdot,\n\tlesseqgtr: lesseqgtr,\n\tlesseqqgtr: lesseqqgtr,\n\tLessEqualGreater: LessEqualGreater,\n\tLessFullEqual: LessFullEqual,\n\tLessGreater: LessGreater,\n\tlessgtr: lessgtr,\n\tLessLess: LessLess,\n\tlesssim: lesssim,\n\tLessSlantEqual: LessSlantEqual,\n\tLessTilde: LessTilde,\n\tlfisht: lfisht,\n\tlfloor: lfloor,\n\tLfr: Lfr,\n\tlfr: lfr,\n\tlg: lg,\n\tlgE: lgE,\n\tlHar: lHar,\n\tlhard: lhard,\n\tlharu: lharu,\n\tlharul: lharul,\n\tlhblk: lhblk,\n\tLJcy: LJcy,\n\tljcy: ljcy,\n\tllarr: llarr,\n\tll: ll,\n\tLl: Ll,\n\tllcorner: llcorner,\n\tLleftarrow: Lleftarrow,\n\tllhard: llhard,\n\tlltri: lltri,\n\tLmidot: Lmidot,\n\tlmidot: lmidot,\n\tlmoustache: lmoustache,\n\tlmoust: lmoust,\n\tlnap: lnap,\n\tlnapprox: lnapprox,\n\tlne: lne,\n\tlnE: lnE,\n\tlneq: lneq,\n\tlneqq: lneqq,\n\tlnsim: lnsim,\n\tloang: loang,\n\tloarr: loarr,\n\tlobrk: lobrk,\n\tlongleftarrow: longleftarrow,\n\tLongLeftArrow: LongLeftArrow,\n\tLongleftarrow: Longleftarrow,\n\tlongleftrightarrow: longleftrightarrow,\n\tLongLeftRightArrow: LongLeftRightArrow,\n\tLongleftrightarrow: Longleftrightarrow,\n\tlongmapsto: longmapsto,\n\tlongrightarrow: longrightarrow,\n\tLongRightArrow: LongRightArrow,\n\tLongrightarrow: Longrightarrow,\n\tlooparrowleft: looparrowleft,\n\tlooparrowright: looparrowright,\n\tlopar: lopar,\n\tLopf: Lopf,\n\tlopf: lopf,\n\tloplus: loplus,\n\tlotimes: lotimes,\n\tlowast: lowast,\n\tlowbar: lowbar,\n\tLowerLeftArrow: LowerLeftArrow,\n\tLowerRightArrow: LowerRightArrow,\n\tloz: loz,\n\tlozenge: lozenge,\n\tlozf: lozf,\n\tlpar: lpar,\n\tlparlt: lparlt,\n\tlrarr: lrarr,\n\tlrcorner: lrcorner,\n\tlrhar: lrhar,\n\tlrhard: lrhard,\n\tlrm: lrm,\n\tlrtri: lrtri,\n\tlsaquo: lsaquo,\n\tlscr: lscr,\n\tLscr: Lscr,\n\tlsh: lsh,\n\tLsh: Lsh,\n\tlsim: lsim,\n\tlsime: lsime,\n\tlsimg: lsimg,\n\tlsqb: lsqb,\n\tlsquo: lsquo,\n\tlsquor: lsquor,\n\tLstrok: Lstrok,\n\tlstrok: lstrok,\n\tltcc: ltcc,\n\tltcir: ltcir,\n\tlt: lt$2,\n\tLT: LT$1,\n\tLt: Lt,\n\tltdot: ltdot,\n\tlthree: lthree,\n\tltimes: ltimes,\n\tltlarr: ltlarr,\n\tltquest: ltquest,\n\tltri: ltri,\n\tltrie: ltrie,\n\tltrif: ltrif,\n\tltrPar: ltrPar,\n\tlurdshar: lurdshar,\n\tluruhar: luruhar,\n\tlvertneqq: lvertneqq,\n\tlvnE: lvnE,\n\tmacr: macr$1,\n\tmale: male,\n\tmalt: malt,\n\tmaltese: maltese,\n\t\"Map\": \"⤅\",\n\tmap: map,\n\tmapsto: mapsto,\n\tmapstodown: mapstodown,\n\tmapstoleft: mapstoleft,\n\tmapstoup: mapstoup,\n\tmarker: marker,\n\tmcomma: mcomma,\n\tMcy: Mcy,\n\tmcy: mcy,\n\tmdash: mdash,\n\tmDDot: mDDot,\n\tmeasuredangle: measuredangle,\n\tMediumSpace: MediumSpace,\n\tMellintrf: Mellintrf,\n\tMfr: Mfr,\n\tmfr: mfr,\n\tmho: mho,\n\tmicro: micro$1,\n\tmidast: midast,\n\tmidcir: midcir,\n\tmid: mid,\n\tmiddot: middot$1,\n\tminusb: minusb,\n\tminus: minus,\n\tminusd: minusd,\n\tminusdu: minusdu,\n\tMinusPlus: MinusPlus,\n\tmlcp: mlcp,\n\tmldr: mldr,\n\tmnplus: mnplus,\n\tmodels: models,\n\tMopf: Mopf,\n\tmopf: mopf,\n\tmp: mp,\n\tmscr: mscr,\n\tMscr: Mscr,\n\tmstpos: mstpos,\n\tMu: Mu,\n\tmu: mu,\n\tmultimap: multimap,\n\tmumap: mumap,\n\tnabla: nabla,\n\tNacute: Nacute,\n\tnacute: nacute,\n\tnang: nang,\n\tnap: nap,\n\tnapE: napE,\n\tnapid: napid,\n\tnapos: napos,\n\tnapprox: napprox,\n\tnatural: natural,\n\tnaturals: naturals,\n\tnatur: natur,\n\tnbsp: nbsp$1,\n\tnbump: nbump,\n\tnbumpe: nbumpe,\n\tncap: ncap,\n\tNcaron: Ncaron,\n\tncaron: ncaron,\n\tNcedil: Ncedil,\n\tncedil: ncedil,\n\tncong: ncong,\n\tncongdot: ncongdot,\n\tncup: ncup,\n\tNcy: Ncy,\n\tncy: ncy,\n\tndash: ndash,\n\tnearhk: nearhk,\n\tnearr: nearr,\n\tneArr: neArr,\n\tnearrow: nearrow,\n\tne: ne,\n\tnedot: nedot,\n\tNegativeMediumSpace: NegativeMediumSpace,\n\tNegativeThickSpace: NegativeThickSpace,\n\tNegativeThinSpace: NegativeThinSpace,\n\tNegativeVeryThinSpace: NegativeVeryThinSpace,\n\tnequiv: nequiv,\n\tnesear: nesear,\n\tnesim: nesim,\n\tNestedGreaterGreater: NestedGreaterGreater,\n\tNestedLessLess: NestedLessLess,\n\tNewLine: NewLine,\n\tnexist: nexist,\n\tnexists: nexists,\n\tNfr: Nfr,\n\tnfr: nfr,\n\tngE: ngE,\n\tnge: nge,\n\tngeq: ngeq,\n\tngeqq: ngeqq,\n\tngeqslant: ngeqslant,\n\tnges: nges,\n\tnGg: nGg,\n\tngsim: ngsim,\n\tnGt: nGt,\n\tngt: ngt,\n\tngtr: ngtr,\n\tnGtv: nGtv,\n\tnharr: nharr,\n\tnhArr: nhArr,\n\tnhpar: nhpar,\n\tni: ni,\n\tnis: nis,\n\tnisd: nisd,\n\tniv: niv,\n\tNJcy: NJcy,\n\tnjcy: njcy,\n\tnlarr: nlarr,\n\tnlArr: nlArr,\n\tnldr: nldr,\n\tnlE: nlE,\n\tnle: nle,\n\tnleftarrow: nleftarrow,\n\tnLeftarrow: nLeftarrow,\n\tnleftrightarrow: nleftrightarrow,\n\tnLeftrightarrow: nLeftrightarrow,\n\tnleq: nleq,\n\tnleqq: nleqq,\n\tnleqslant: nleqslant,\n\tnles: nles,\n\tnless: nless,\n\tnLl: nLl,\n\tnlsim: nlsim,\n\tnLt: nLt,\n\tnlt: nlt,\n\tnltri: nltri,\n\tnltrie: nltrie,\n\tnLtv: nLtv,\n\tnmid: nmid,\n\tNoBreak: NoBreak,\n\tNonBreakingSpace: NonBreakingSpace,\n\tnopf: nopf,\n\tNopf: Nopf,\n\tNot: Not,\n\tnot: not$1,\n\tNotCongruent: NotCongruent,\n\tNotCupCap: NotCupCap,\n\tNotDoubleVerticalBar: NotDoubleVerticalBar,\n\tNotElement: NotElement,\n\tNotEqual: NotEqual,\n\tNotEqualTilde: NotEqualTilde,\n\tNotExists: NotExists,\n\tNotGreater: NotGreater,\n\tNotGreaterEqual: NotGreaterEqual,\n\tNotGreaterFullEqual: NotGreaterFullEqual,\n\tNotGreaterGreater: NotGreaterGreater,\n\tNotGreaterLess: NotGreaterLess,\n\tNotGreaterSlantEqual: NotGreaterSlantEqual,\n\tNotGreaterTilde: NotGreaterTilde,\n\tNotHumpDownHump: NotHumpDownHump,\n\tNotHumpEqual: NotHumpEqual,\n\tnotin: notin,\n\tnotindot: notindot,\n\tnotinE: notinE,\n\tnotinva: notinva,\n\tnotinvb: notinvb,\n\tnotinvc: notinvc,\n\tNotLeftTriangleBar: NotLeftTriangleBar,\n\tNotLeftTriangle: NotLeftTriangle,\n\tNotLeftTriangleEqual: NotLeftTriangleEqual,\n\tNotLess: NotLess,\n\tNotLessEqual: NotLessEqual,\n\tNotLessGreater: NotLessGreater,\n\tNotLessLess: NotLessLess,\n\tNotLessSlantEqual: NotLessSlantEqual,\n\tNotLessTilde: NotLessTilde,\n\tNotNestedGreaterGreater: NotNestedGreaterGreater,\n\tNotNestedLessLess: NotNestedLessLess,\n\tnotni: notni,\n\tnotniva: notniva,\n\tnotnivb: notnivb,\n\tnotnivc: notnivc,\n\tNotPrecedes: NotPrecedes,\n\tNotPrecedesEqual: NotPrecedesEqual,\n\tNotPrecedesSlantEqual: NotPrecedesSlantEqual,\n\tNotReverseElement: NotReverseElement,\n\tNotRightTriangleBar: NotRightTriangleBar,\n\tNotRightTriangle: NotRightTriangle,\n\tNotRightTriangleEqual: NotRightTriangleEqual,\n\tNotSquareSubset: NotSquareSubset,\n\tNotSquareSubsetEqual: NotSquareSubsetEqual,\n\tNotSquareSuperset: NotSquareSuperset,\n\tNotSquareSupersetEqual: NotSquareSupersetEqual,\n\tNotSubset: NotSubset,\n\tNotSubsetEqual: NotSubsetEqual,\n\tNotSucceeds: NotSucceeds,\n\tNotSucceedsEqual: NotSucceedsEqual,\n\tNotSucceedsSlantEqual: NotSucceedsSlantEqual,\n\tNotSucceedsTilde: NotSucceedsTilde,\n\tNotSuperset: NotSuperset,\n\tNotSupersetEqual: NotSupersetEqual,\n\tNotTilde: NotTilde,\n\tNotTildeEqual: NotTildeEqual,\n\tNotTildeFullEqual: NotTildeFullEqual,\n\tNotTildeTilde: NotTildeTilde,\n\tNotVerticalBar: NotVerticalBar,\n\tnparallel: nparallel,\n\tnpar: npar,\n\tnparsl: nparsl,\n\tnpart: npart,\n\tnpolint: npolint,\n\tnpr: npr,\n\tnprcue: nprcue,\n\tnprec: nprec,\n\tnpreceq: npreceq,\n\tnpre: npre,\n\tnrarrc: nrarrc,\n\tnrarr: nrarr,\n\tnrArr: nrArr,\n\tnrarrw: nrarrw,\n\tnrightarrow: nrightarrow,\n\tnRightarrow: nRightarrow,\n\tnrtri: nrtri,\n\tnrtrie: nrtrie,\n\tnsc: nsc,\n\tnsccue: nsccue,\n\tnsce: nsce,\n\tNscr: Nscr,\n\tnscr: nscr,\n\tnshortmid: nshortmid,\n\tnshortparallel: nshortparallel,\n\tnsim: nsim,\n\tnsime: nsime,\n\tnsimeq: nsimeq,\n\tnsmid: nsmid,\n\tnspar: nspar,\n\tnsqsube: nsqsube,\n\tnsqsupe: nsqsupe,\n\tnsub: nsub,\n\tnsubE: nsubE,\n\tnsube: nsube,\n\tnsubset: nsubset,\n\tnsubseteq: nsubseteq,\n\tnsubseteqq: nsubseteqq,\n\tnsucc: nsucc,\n\tnsucceq: nsucceq,\n\tnsup: nsup,\n\tnsupE: nsupE,\n\tnsupe: nsupe,\n\tnsupset: nsupset,\n\tnsupseteq: nsupseteq,\n\tnsupseteqq: nsupseteqq,\n\tntgl: ntgl,\n\tNtilde: Ntilde$1,\n\tntilde: ntilde$1,\n\tntlg: ntlg,\n\tntriangleleft: ntriangleleft,\n\tntrianglelefteq: ntrianglelefteq,\n\tntriangleright: ntriangleright,\n\tntrianglerighteq: ntrianglerighteq,\n\tNu: Nu,\n\tnu: nu,\n\tnum: num,\n\tnumero: numero,\n\tnumsp: numsp,\n\tnvap: nvap,\n\tnvdash: nvdash,\n\tnvDash: nvDash,\n\tnVdash: nVdash,\n\tnVDash: nVDash,\n\tnvge: nvge,\n\tnvgt: nvgt,\n\tnvHarr: nvHarr,\n\tnvinfin: nvinfin,\n\tnvlArr: nvlArr,\n\tnvle: nvle,\n\tnvlt: nvlt,\n\tnvltrie: nvltrie,\n\tnvrArr: nvrArr,\n\tnvrtrie: nvrtrie,\n\tnvsim: nvsim,\n\tnwarhk: nwarhk,\n\tnwarr: nwarr,\n\tnwArr: nwArr,\n\tnwarrow: nwarrow,\n\tnwnear: nwnear,\n\tOacute: Oacute$1,\n\toacute: oacute$1,\n\toast: oast,\n\tOcirc: Ocirc$1,\n\tocirc: ocirc$1,\n\tocir: ocir,\n\tOcy: Ocy,\n\tocy: ocy,\n\todash: odash,\n\tOdblac: Odblac,\n\todblac: odblac,\n\todiv: odiv,\n\todot: odot,\n\todsold: odsold,\n\tOElig: OElig,\n\toelig: oelig,\n\tofcir: ofcir,\n\tOfr: Ofr,\n\tofr: ofr,\n\togon: ogon,\n\tOgrave: Ograve$1,\n\tograve: ograve$1,\n\togt: ogt,\n\tohbar: ohbar,\n\tohm: ohm,\n\toint: oint,\n\tolarr: olarr,\n\tolcir: olcir,\n\tolcross: olcross,\n\toline: oline,\n\tolt: olt,\n\tOmacr: Omacr,\n\tomacr: omacr,\n\tOmega: Omega,\n\tomega: omega,\n\tOmicron: Omicron,\n\tomicron: omicron,\n\tomid: omid,\n\tominus: ominus,\n\tOopf: Oopf,\n\toopf: oopf,\n\topar: opar,\n\tOpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n\tOpenCurlyQuote: OpenCurlyQuote,\n\toperp: operp,\n\toplus: oplus,\n\torarr: orarr,\n\tOr: Or,\n\tor: or,\n\tord: ord,\n\torder: order,\n\torderof: orderof,\n\tordf: ordf$1,\n\tordm: ordm$1,\n\torigof: origof,\n\toror: oror,\n\torslope: orslope,\n\torv: orv,\n\toS: oS,\n\tOscr: Oscr,\n\toscr: oscr,\n\tOslash: Oslash$1,\n\toslash: oslash$1,\n\tosol: osol,\n\tOtilde: Otilde$1,\n\totilde: otilde$1,\n\totimesas: otimesas,\n\tOtimes: Otimes,\n\totimes: otimes,\n\tOuml: Ouml$1,\n\touml: ouml$1,\n\tovbar: ovbar,\n\tOverBar: OverBar,\n\tOverBrace: OverBrace,\n\tOverBracket: OverBracket,\n\tOverParenthesis: OverParenthesis,\n\tpara: para$1,\n\tparallel: parallel,\n\tpar: par,\n\tparsim: parsim,\n\tparsl: parsl,\n\tpart: part,\n\tPartialD: PartialD,\n\tPcy: Pcy,\n\tpcy: pcy,\n\tpercnt: percnt,\n\tperiod: period,\n\tpermil: permil,\n\tperp: perp,\n\tpertenk: pertenk,\n\tPfr: Pfr,\n\tpfr: pfr,\n\tPhi: Phi,\n\tphi: phi,\n\tphiv: phiv,\n\tphmmat: phmmat,\n\tphone: phone,\n\tPi: Pi,\n\tpi: pi,\n\tpitchfork: pitchfork,\n\tpiv: piv,\n\tplanck: planck,\n\tplanckh: planckh,\n\tplankv: plankv,\n\tplusacir: plusacir,\n\tplusb: plusb,\n\tpluscir: pluscir,\n\tplus: plus,\n\tplusdo: plusdo,\n\tplusdu: plusdu,\n\tpluse: pluse,\n\tPlusMinus: PlusMinus,\n\tplusmn: plusmn$1,\n\tplussim: plussim,\n\tplustwo: plustwo,\n\tpm: pm,\n\tPoincareplane: Poincareplane,\n\tpointint: pointint,\n\tpopf: popf,\n\tPopf: Popf,\n\tpound: pound$1,\n\tprap: prap,\n\tPr: Pr,\n\tpr: pr,\n\tprcue: prcue,\n\tprecapprox: precapprox,\n\tprec: prec,\n\tpreccurlyeq: preccurlyeq,\n\tPrecedes: Precedes,\n\tPrecedesEqual: PrecedesEqual,\n\tPrecedesSlantEqual: PrecedesSlantEqual,\n\tPrecedesTilde: PrecedesTilde,\n\tpreceq: preceq,\n\tprecnapprox: precnapprox,\n\tprecneqq: precneqq,\n\tprecnsim: precnsim,\n\tpre: pre,\n\tprE: prE,\n\tprecsim: precsim,\n\tprime: prime,\n\tPrime: Prime,\n\tprimes: primes,\n\tprnap: prnap,\n\tprnE: prnE,\n\tprnsim: prnsim,\n\tprod: prod,\n\tProduct: Product,\n\tprofalar: profalar,\n\tprofline: profline,\n\tprofsurf: profsurf,\n\tprop: prop,\n\tProportional: Proportional,\n\tProportion: Proportion,\n\tpropto: propto,\n\tprsim: prsim,\n\tprurel: prurel,\n\tPscr: Pscr,\n\tpscr: pscr,\n\tPsi: Psi,\n\tpsi: psi,\n\tpuncsp: puncsp,\n\tQfr: Qfr,\n\tqfr: qfr,\n\tqint: qint,\n\tqopf: qopf,\n\tQopf: Qopf,\n\tqprime: qprime,\n\tQscr: Qscr,\n\tqscr: qscr,\n\tquaternions: quaternions,\n\tquatint: quatint,\n\tquest: quest,\n\tquesteq: questeq,\n\tquot: quot$2,\n\tQUOT: QUOT$1,\n\trAarr: rAarr,\n\trace: race,\n\tRacute: Racute,\n\tracute: racute,\n\tradic: radic,\n\traemptyv: raemptyv,\n\trang: rang,\n\tRang: Rang,\n\trangd: rangd,\n\trange: range,\n\trangle: rangle,\n\traquo: raquo$1,\n\trarrap: rarrap,\n\trarrb: rarrb,\n\trarrbfs: rarrbfs,\n\trarrc: rarrc,\n\trarr: rarr,\n\tRarr: Rarr,\n\trArr: rArr,\n\trarrfs: rarrfs,\n\trarrhk: rarrhk,\n\trarrlp: rarrlp,\n\trarrpl: rarrpl,\n\trarrsim: rarrsim,\n\tRarrtl: Rarrtl,\n\trarrtl: rarrtl,\n\trarrw: rarrw,\n\tratail: ratail,\n\trAtail: rAtail,\n\tratio: ratio,\n\trationals: rationals,\n\trbarr: rbarr,\n\trBarr: rBarr,\n\tRBarr: RBarr,\n\trbbrk: rbbrk,\n\trbrace: rbrace,\n\trbrack: rbrack,\n\trbrke: rbrke,\n\trbrksld: rbrksld,\n\trbrkslu: rbrkslu,\n\tRcaron: Rcaron,\n\trcaron: rcaron,\n\tRcedil: Rcedil,\n\trcedil: rcedil,\n\trceil: rceil,\n\trcub: rcub,\n\tRcy: Rcy,\n\trcy: rcy,\n\trdca: rdca,\n\trdldhar: rdldhar,\n\trdquo: rdquo,\n\trdquor: rdquor,\n\trdsh: rdsh,\n\treal: real,\n\trealine: realine,\n\trealpart: realpart,\n\treals: reals,\n\tRe: Re,\n\trect: rect,\n\treg: reg$1,\n\tREG: REG$1,\n\tReverseElement: ReverseElement,\n\tReverseEquilibrium: ReverseEquilibrium,\n\tReverseUpEquilibrium: ReverseUpEquilibrium,\n\trfisht: rfisht,\n\trfloor: rfloor,\n\trfr: rfr,\n\tRfr: Rfr,\n\trHar: rHar,\n\trhard: rhard,\n\trharu: rharu,\n\trharul: rharul,\n\tRho: Rho,\n\trho: rho,\n\trhov: rhov,\n\tRightAngleBracket: RightAngleBracket,\n\tRightArrowBar: RightArrowBar,\n\trightarrow: rightarrow,\n\tRightArrow: RightArrow,\n\tRightarrow: Rightarrow,\n\tRightArrowLeftArrow: RightArrowLeftArrow,\n\trightarrowtail: rightarrowtail,\n\tRightCeiling: RightCeiling,\n\tRightDoubleBracket: RightDoubleBracket,\n\tRightDownTeeVector: RightDownTeeVector,\n\tRightDownVectorBar: RightDownVectorBar,\n\tRightDownVector: RightDownVector,\n\tRightFloor: RightFloor,\n\trightharpoondown: rightharpoondown,\n\trightharpoonup: rightharpoonup,\n\trightleftarrows: rightleftarrows,\n\trightleftharpoons: rightleftharpoons,\n\trightrightarrows: rightrightarrows,\n\trightsquigarrow: rightsquigarrow,\n\tRightTeeArrow: RightTeeArrow,\n\tRightTee: RightTee,\n\tRightTeeVector: RightTeeVector,\n\trightthreetimes: rightthreetimes,\n\tRightTriangleBar: RightTriangleBar,\n\tRightTriangle: RightTriangle,\n\tRightTriangleEqual: RightTriangleEqual,\n\tRightUpDownVector: RightUpDownVector,\n\tRightUpTeeVector: RightUpTeeVector,\n\tRightUpVectorBar: RightUpVectorBar,\n\tRightUpVector: RightUpVector,\n\tRightVectorBar: RightVectorBar,\n\tRightVector: RightVector,\n\tring: ring,\n\trisingdotseq: risingdotseq,\n\trlarr: rlarr,\n\trlhar: rlhar,\n\trlm: rlm,\n\trmoustache: rmoustache,\n\trmoust: rmoust,\n\trnmid: rnmid,\n\troang: roang,\n\troarr: roarr,\n\trobrk: robrk,\n\tropar: ropar,\n\tropf: ropf,\n\tRopf: Ropf,\n\troplus: roplus,\n\trotimes: rotimes,\n\tRoundImplies: RoundImplies,\n\trpar: rpar,\n\trpargt: rpargt,\n\trppolint: rppolint,\n\trrarr: rrarr,\n\tRrightarrow: Rrightarrow,\n\trsaquo: rsaquo,\n\trscr: rscr,\n\tRscr: Rscr,\n\trsh: rsh,\n\tRsh: Rsh,\n\trsqb: rsqb,\n\trsquo: rsquo,\n\trsquor: rsquor,\n\trthree: rthree,\n\trtimes: rtimes,\n\trtri: rtri,\n\trtrie: rtrie,\n\trtrif: rtrif,\n\trtriltri: rtriltri,\n\tRuleDelayed: RuleDelayed,\n\truluhar: ruluhar,\n\trx: rx,\n\tSacute: Sacute,\n\tsacute: sacute,\n\tsbquo: sbquo,\n\tscap: scap,\n\tScaron: Scaron,\n\tscaron: scaron,\n\tSc: Sc,\n\tsc: sc,\n\tsccue: sccue,\n\tsce: sce,\n\tscE: scE,\n\tScedil: Scedil,\n\tscedil: scedil,\n\tScirc: Scirc,\n\tscirc: scirc,\n\tscnap: scnap,\n\tscnE: scnE,\n\tscnsim: scnsim,\n\tscpolint: scpolint,\n\tscsim: scsim,\n\tScy: Scy,\n\tscy: scy,\n\tsdotb: sdotb,\n\tsdot: sdot,\n\tsdote: sdote,\n\tsearhk: searhk,\n\tsearr: searr,\n\tseArr: seArr,\n\tsearrow: searrow,\n\tsect: sect$1,\n\tsemi: semi,\n\tseswar: seswar,\n\tsetminus: setminus,\n\tsetmn: setmn,\n\tsext: sext,\n\tSfr: Sfr,\n\tsfr: sfr,\n\tsfrown: sfrown,\n\tsharp: sharp,\n\tSHCHcy: SHCHcy,\n\tshchcy: shchcy,\n\tSHcy: SHcy,\n\tshcy: shcy,\n\tShortDownArrow: ShortDownArrow,\n\tShortLeftArrow: ShortLeftArrow,\n\tshortmid: shortmid,\n\tshortparallel: shortparallel,\n\tShortRightArrow: ShortRightArrow,\n\tShortUpArrow: ShortUpArrow,\n\tshy: shy$1,\n\tSigma: Sigma,\n\tsigma: sigma,\n\tsigmaf: sigmaf,\n\tsigmav: sigmav,\n\tsim: sim,\n\tsimdot: simdot,\n\tsime: sime,\n\tsimeq: simeq,\n\tsimg: simg,\n\tsimgE: simgE,\n\tsiml: siml,\n\tsimlE: simlE,\n\tsimne: simne,\n\tsimplus: simplus,\n\tsimrarr: simrarr,\n\tslarr: slarr,\n\tSmallCircle: SmallCircle,\n\tsmallsetminus: smallsetminus,\n\tsmashp: smashp,\n\tsmeparsl: smeparsl,\n\tsmid: smid,\n\tsmile: smile,\n\tsmt: smt,\n\tsmte: smte,\n\tsmtes: smtes,\n\tSOFTcy: SOFTcy,\n\tsoftcy: softcy,\n\tsolbar: solbar,\n\tsolb: solb,\n\tsol: sol,\n\tSopf: Sopf,\n\tsopf: sopf,\n\tspades: spades,\n\tspadesuit: spadesuit,\n\tspar: spar,\n\tsqcap: sqcap,\n\tsqcaps: sqcaps,\n\tsqcup: sqcup,\n\tsqcups: sqcups,\n\tSqrt: Sqrt,\n\tsqsub: sqsub,\n\tsqsube: sqsube,\n\tsqsubset: sqsubset,\n\tsqsubseteq: sqsubseteq,\n\tsqsup: sqsup,\n\tsqsupe: sqsupe,\n\tsqsupset: sqsupset,\n\tsqsupseteq: sqsupseteq,\n\tsquare: square,\n\tSquare: Square,\n\tSquareIntersection: SquareIntersection,\n\tSquareSubset: SquareSubset,\n\tSquareSubsetEqual: SquareSubsetEqual,\n\tSquareSuperset: SquareSuperset,\n\tSquareSupersetEqual: SquareSupersetEqual,\n\tSquareUnion: SquareUnion,\n\tsquarf: squarf,\n\tsqu: squ,\n\tsquf: squf,\n\tsrarr: srarr,\n\tSscr: Sscr,\n\tsscr: sscr,\n\tssetmn: ssetmn,\n\tssmile: ssmile,\n\tsstarf: sstarf,\n\tStar: Star,\n\tstar: star,\n\tstarf: starf,\n\tstraightepsilon: straightepsilon,\n\tstraightphi: straightphi,\n\tstrns: strns,\n\tsub: sub,\n\tSub: Sub,\n\tsubdot: subdot,\n\tsubE: subE,\n\tsube: sube,\n\tsubedot: subedot,\n\tsubmult: submult,\n\tsubnE: subnE,\n\tsubne: subne,\n\tsubplus: subplus,\n\tsubrarr: subrarr,\n\tsubset: subset,\n\tSubset: Subset,\n\tsubseteq: subseteq,\n\tsubseteqq: subseteqq,\n\tSubsetEqual: SubsetEqual,\n\tsubsetneq: subsetneq,\n\tsubsetneqq: subsetneqq,\n\tsubsim: subsim,\n\tsubsub: subsub,\n\tsubsup: subsup,\n\tsuccapprox: succapprox,\n\tsucc: succ,\n\tsucccurlyeq: succcurlyeq,\n\tSucceeds: Succeeds,\n\tSucceedsEqual: SucceedsEqual,\n\tSucceedsSlantEqual: SucceedsSlantEqual,\n\tSucceedsTilde: SucceedsTilde,\n\tsucceq: succeq,\n\tsuccnapprox: succnapprox,\n\tsuccneqq: succneqq,\n\tsuccnsim: succnsim,\n\tsuccsim: succsim,\n\tSuchThat: SuchThat,\n\tsum: sum,\n\tSum: Sum,\n\tsung: sung,\n\tsup1: sup1$1,\n\tsup2: sup2$1,\n\tsup3: sup3$1,\n\tsup: sup,\n\tSup: Sup,\n\tsupdot: supdot,\n\tsupdsub: supdsub,\n\tsupE: supE,\n\tsupe: supe,\n\tsupedot: supedot,\n\tSuperset: Superset,\n\tSupersetEqual: SupersetEqual,\n\tsuphsol: suphsol,\n\tsuphsub: suphsub,\n\tsuplarr: suplarr,\n\tsupmult: supmult,\n\tsupnE: supnE,\n\tsupne: supne,\n\tsupplus: supplus,\n\tsupset: supset,\n\tSupset: Supset,\n\tsupseteq: supseteq,\n\tsupseteqq: supseteqq,\n\tsupsetneq: supsetneq,\n\tsupsetneqq: supsetneqq,\n\tsupsim: supsim,\n\tsupsub: supsub,\n\tsupsup: supsup,\n\tswarhk: swarhk,\n\tswarr: swarr,\n\tswArr: swArr,\n\tswarrow: swarrow,\n\tswnwar: swnwar,\n\tszlig: szlig$1,\n\tTab: Tab,\n\ttarget: target,\n\tTau: Tau,\n\ttau: tau,\n\ttbrk: tbrk,\n\tTcaron: Tcaron,\n\ttcaron: tcaron,\n\tTcedil: Tcedil,\n\ttcedil: tcedil,\n\tTcy: Tcy,\n\ttcy: tcy,\n\ttdot: tdot,\n\ttelrec: telrec,\n\tTfr: Tfr,\n\ttfr: tfr,\n\tthere4: there4,\n\ttherefore: therefore,\n\tTherefore: Therefore,\n\tTheta: Theta,\n\ttheta: theta,\n\tthetasym: thetasym,\n\tthetav: thetav,\n\tthickapprox: thickapprox,\n\tthicksim: thicksim,\n\tThickSpace: ThickSpace,\n\tThinSpace: ThinSpace,\n\tthinsp: thinsp,\n\tthkap: thkap,\n\tthksim: thksim,\n\tTHORN: THORN$1,\n\tthorn: thorn$1,\n\ttilde: tilde,\n\tTilde: Tilde,\n\tTildeEqual: TildeEqual,\n\tTildeFullEqual: TildeFullEqual,\n\tTildeTilde: TildeTilde,\n\ttimesbar: timesbar,\n\ttimesb: timesb,\n\ttimes: times$1,\n\ttimesd: timesd,\n\ttint: tint,\n\ttoea: toea,\n\ttopbot: topbot,\n\ttopcir: topcir,\n\ttop: top,\n\tTopf: Topf,\n\ttopf: topf,\n\ttopfork: topfork,\n\ttosa: tosa,\n\ttprime: tprime,\n\ttrade: trade,\n\tTRADE: TRADE,\n\ttriangle: triangle,\n\ttriangledown: triangledown,\n\ttriangleleft: triangleleft,\n\ttrianglelefteq: trianglelefteq,\n\ttriangleq: triangleq,\n\ttriangleright: triangleright,\n\ttrianglerighteq: trianglerighteq,\n\ttridot: tridot,\n\ttrie: trie,\n\ttriminus: triminus,\n\tTripleDot: TripleDot,\n\ttriplus: triplus,\n\ttrisb: trisb,\n\ttritime: tritime,\n\ttrpezium: trpezium,\n\tTscr: Tscr,\n\ttscr: tscr,\n\tTScy: TScy,\n\ttscy: tscy,\n\tTSHcy: TSHcy,\n\ttshcy: tshcy,\n\tTstrok: Tstrok,\n\ttstrok: tstrok,\n\ttwixt: twixt,\n\ttwoheadleftarrow: twoheadleftarrow,\n\ttwoheadrightarrow: twoheadrightarrow,\n\tUacute: Uacute$1,\n\tuacute: uacute$1,\n\tuarr: uarr,\n\tUarr: Uarr,\n\tuArr: uArr,\n\tUarrocir: Uarrocir,\n\tUbrcy: Ubrcy,\n\tubrcy: ubrcy,\n\tUbreve: Ubreve,\n\tubreve: ubreve,\n\tUcirc: Ucirc$1,\n\tucirc: ucirc$1,\n\tUcy: Ucy,\n\tucy: ucy,\n\tudarr: udarr,\n\tUdblac: Udblac,\n\tudblac: udblac,\n\tudhar: udhar,\n\tufisht: ufisht,\n\tUfr: Ufr,\n\tufr: ufr,\n\tUgrave: Ugrave$1,\n\tugrave: ugrave$1,\n\tuHar: uHar,\n\tuharl: uharl,\n\tuharr: uharr,\n\tuhblk: uhblk,\n\tulcorn: ulcorn,\n\tulcorner: ulcorner,\n\tulcrop: ulcrop,\n\tultri: ultri,\n\tUmacr: Umacr,\n\tumacr: umacr,\n\tuml: uml$1,\n\tUnderBar: UnderBar,\n\tUnderBrace: UnderBrace,\n\tUnderBracket: UnderBracket,\n\tUnderParenthesis: UnderParenthesis,\n\tUnion: Union,\n\tUnionPlus: UnionPlus,\n\tUogon: Uogon,\n\tuogon: uogon,\n\tUopf: Uopf,\n\tuopf: uopf,\n\tUpArrowBar: UpArrowBar,\n\tuparrow: uparrow,\n\tUpArrow: UpArrow,\n\tUparrow: Uparrow,\n\tUpArrowDownArrow: UpArrowDownArrow,\n\tupdownarrow: updownarrow,\n\tUpDownArrow: UpDownArrow,\n\tUpdownarrow: Updownarrow,\n\tUpEquilibrium: UpEquilibrium,\n\tupharpoonleft: upharpoonleft,\n\tupharpoonright: upharpoonright,\n\tuplus: uplus,\n\tUpperLeftArrow: UpperLeftArrow,\n\tUpperRightArrow: UpperRightArrow,\n\tupsi: upsi,\n\tUpsi: Upsi,\n\tupsih: upsih,\n\tUpsilon: Upsilon,\n\tupsilon: upsilon,\n\tUpTeeArrow: UpTeeArrow,\n\tUpTee: UpTee,\n\tupuparrows: upuparrows,\n\turcorn: urcorn,\n\turcorner: urcorner,\n\turcrop: urcrop,\n\tUring: Uring,\n\turing: uring,\n\turtri: urtri,\n\tUscr: Uscr,\n\tuscr: uscr,\n\tutdot: utdot,\n\tUtilde: Utilde,\n\tutilde: utilde,\n\tutri: utri,\n\tutrif: utrif,\n\tuuarr: uuarr,\n\tUuml: Uuml$1,\n\tuuml: uuml$1,\n\tuwangle: uwangle,\n\tvangrt: vangrt,\n\tvarepsilon: varepsilon,\n\tvarkappa: varkappa,\n\tvarnothing: varnothing,\n\tvarphi: varphi,\n\tvarpi: varpi,\n\tvarpropto: varpropto,\n\tvarr: varr,\n\tvArr: vArr,\n\tvarrho: varrho,\n\tvarsigma: varsigma,\n\tvarsubsetneq: varsubsetneq,\n\tvarsubsetneqq: varsubsetneqq,\n\tvarsupsetneq: varsupsetneq,\n\tvarsupsetneqq: varsupsetneqq,\n\tvartheta: vartheta,\n\tvartriangleleft: vartriangleleft,\n\tvartriangleright: vartriangleright,\n\tvBar: vBar,\n\tVbar: Vbar,\n\tvBarv: vBarv,\n\tVcy: Vcy,\n\tvcy: vcy,\n\tvdash: vdash,\n\tvDash: vDash,\n\tVdash: Vdash,\n\tVDash: VDash,\n\tVdashl: Vdashl,\n\tveebar: veebar,\n\tvee: vee,\n\tVee: Vee,\n\tveeeq: veeeq,\n\tvellip: vellip,\n\tverbar: verbar,\n\tVerbar: Verbar,\n\tvert: vert,\n\tVert: Vert,\n\tVerticalBar: VerticalBar,\n\tVerticalLine: VerticalLine,\n\tVerticalSeparator: VerticalSeparator,\n\tVerticalTilde: VerticalTilde,\n\tVeryThinSpace: VeryThinSpace,\n\tVfr: Vfr,\n\tvfr: vfr,\n\tvltri: vltri,\n\tvnsub: vnsub,\n\tvnsup: vnsup,\n\tVopf: Vopf,\n\tvopf: vopf,\n\tvprop: vprop,\n\tvrtri: vrtri,\n\tVscr: Vscr,\n\tvscr: vscr,\n\tvsubnE: vsubnE,\n\tvsubne: vsubne,\n\tvsupnE: vsupnE,\n\tvsupne: vsupne,\n\tVvdash: Vvdash,\n\tvzigzag: vzigzag,\n\tWcirc: Wcirc,\n\twcirc: wcirc,\n\twedbar: wedbar,\n\twedge: wedge,\n\tWedge: Wedge,\n\twedgeq: wedgeq,\n\tweierp: weierp,\n\tWfr: Wfr,\n\twfr: wfr,\n\tWopf: Wopf,\n\twopf: wopf,\n\twp: wp,\n\twr: wr,\n\twreath: wreath,\n\tWscr: Wscr,\n\twscr: wscr,\n\txcap: xcap,\n\txcirc: xcirc,\n\txcup: xcup,\n\txdtri: xdtri,\n\tXfr: Xfr,\n\txfr: xfr,\n\txharr: xharr,\n\txhArr: xhArr,\n\tXi: Xi,\n\txi: xi,\n\txlarr: xlarr,\n\txlArr: xlArr,\n\txmap: xmap,\n\txnis: xnis,\n\txodot: xodot,\n\tXopf: Xopf,\n\txopf: xopf,\n\txoplus: xoplus,\n\txotime: xotime,\n\txrarr: xrarr,\n\txrArr: xrArr,\n\tXscr: Xscr,\n\txscr: xscr,\n\txsqcup: xsqcup,\n\txuplus: xuplus,\n\txutri: xutri,\n\txvee: xvee,\n\txwedge: xwedge,\n\tYacute: Yacute$1,\n\tyacute: yacute$1,\n\tYAcy: YAcy,\n\tyacy: yacy,\n\tYcirc: Ycirc,\n\tycirc: ycirc,\n\tYcy: Ycy,\n\tycy: ycy,\n\tyen: yen$1,\n\tYfr: Yfr,\n\tyfr: yfr,\n\tYIcy: YIcy,\n\tyicy: yicy,\n\tYopf: Yopf,\n\tyopf: yopf,\n\tYscr: Yscr,\n\tyscr: yscr,\n\tYUcy: YUcy,\n\tyucy: yucy,\n\tyuml: yuml$1,\n\tYuml: Yuml,\n\tZacute: Zacute,\n\tzacute: zacute,\n\tZcaron: Zcaron,\n\tzcaron: zcaron,\n\tZcy: Zcy,\n\tzcy: zcy,\n\tZdot: Zdot,\n\tzdot: zdot,\n\tzeetrf: zeetrf,\n\tZeroWidthSpace: ZeroWidthSpace,\n\tZeta: Zeta,\n\tzeta: zeta,\n\tzfr: zfr,\n\tZfr: Zfr,\n\tZHcy: ZHcy,\n\tzhcy: zhcy,\n\tzigrarr: zigrarr,\n\tzopf: zopf,\n\tZopf: Zopf,\n\tZscr: Zscr,\n\tzscr: zscr,\n\tzwj: zwj,\n\tzwnj: zwnj\n};\n\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1 = {\n\tAacute: Aacute,\n\taacute: aacute,\n\tAcirc: Acirc,\n\tacirc: acirc,\n\tacute: acute,\n\tAElig: AElig,\n\taelig: aelig,\n\tAgrave: Agrave,\n\tagrave: agrave,\n\tamp: amp$1,\n\tAMP: AMP,\n\tAring: Aring,\n\taring: aring,\n\tAtilde: Atilde,\n\tatilde: atilde,\n\tAuml: Auml,\n\tauml: auml,\n\tbrvbar: brvbar,\n\tCcedil: Ccedil,\n\tccedil: ccedil,\n\tcedil: cedil,\n\tcent: cent,\n\tcopy: copy,\n\tCOPY: COPY,\n\tcurren: curren,\n\tdeg: deg,\n\tdivide: divide,\n\tEacute: Eacute,\n\teacute: eacute,\n\tEcirc: Ecirc,\n\tecirc: ecirc,\n\tEgrave: Egrave,\n\tegrave: egrave,\n\tETH: ETH,\n\teth: eth,\n\tEuml: Euml,\n\teuml: euml,\n\tfrac12: frac12,\n\tfrac14: frac14,\n\tfrac34: frac34,\n\tgt: gt$1,\n\tGT: GT,\n\tIacute: Iacute,\n\tiacute: iacute,\n\tIcirc: Icirc,\n\ticirc: icirc,\n\tiexcl: iexcl,\n\tIgrave: Igrave,\n\tigrave: igrave,\n\tiquest: iquest,\n\tIuml: Iuml,\n\tiuml: iuml,\n\tlaquo: laquo,\n\tlt: lt$1,\n\tLT: LT,\n\tmacr: macr,\n\tmicro: micro,\n\tmiddot: middot,\n\tnbsp: nbsp,\n\tnot: not,\n\tNtilde: Ntilde,\n\tntilde: ntilde,\n\tOacute: Oacute,\n\toacute: oacute,\n\tOcirc: Ocirc,\n\tocirc: ocirc,\n\tOgrave: Ograve,\n\tograve: ograve,\n\tordf: ordf,\n\tordm: ordm,\n\tOslash: Oslash,\n\toslash: oslash,\n\tOtilde: Otilde,\n\totilde: otilde,\n\tOuml: Ouml,\n\touml: ouml,\n\tpara: para,\n\tplusmn: plusmn,\n\tpound: pound,\n\tquot: quot$1,\n\tQUOT: QUOT,\n\traquo: raquo,\n\treg: reg,\n\tREG: REG,\n\tsect: sect,\n\tshy: shy,\n\tsup1: sup1,\n\tsup2: sup2,\n\tsup3: sup3,\n\tszlig: szlig,\n\tTHORN: THORN,\n\tthorn: thorn,\n\ttimes: times,\n\tUacute: Uacute,\n\tuacute: uacute,\n\tUcirc: Ucirc,\n\tucirc: ucirc,\n\tUgrave: Ugrave,\n\tugrave: ugrave,\n\tuml: uml,\n\tUuml: Uuml,\n\tuuml: uuml,\n\tYacute: Yacute,\n\tyacute: yacute,\n\tyen: yen,\n\tyuml: yuml\n};\n\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n\tamp: amp,\n\tapos: apos,\n\tgt: gt,\n\tlt: lt,\n\tquot: quot\n};\n\nvar decode_codepoint = {};\n\nvar require$$0 = {\n\t\"0\": 65533,\n\t\"128\": 8364,\n\t\"130\": 8218,\n\t\"131\": 402,\n\t\"132\": 8222,\n\t\"133\": 8230,\n\t\"134\": 8224,\n\t\"135\": 8225,\n\t\"136\": 710,\n\t\"137\": 8240,\n\t\"138\": 352,\n\t\"139\": 8249,\n\t\"140\": 338,\n\t\"142\": 381,\n\t\"145\": 8216,\n\t\"146\": 8217,\n\t\"147\": 8220,\n\t\"148\": 8221,\n\t\"149\": 8226,\n\t\"150\": 8211,\n\t\"151\": 8212,\n\t\"152\": 732,\n\t\"153\": 8482,\n\t\"154\": 353,\n\t\"155\": 8250,\n\t\"156\": 339,\n\t\"158\": 382,\n\t\"159\": 376\n};\n\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode_codepoint, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\n\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode, \"__esModule\", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n\nvar encode = {};\n\nvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(encode, \"__esModule\", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = __importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n\n(function (exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = decode;\nvar encode_1 = encode;\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode$1(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode$1;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode$1(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode$1;\nvar encode_2 = encode;\nObject.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\nObject.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\nObject.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nvar decode_2 = decode;\nObject.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\nObject.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\n\nvar ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\nvar reEntityOrEscapedChar = new RegExp(\"\\\\\\\\\" + ESCAPABLE + \"|\" + ENTITY, 'gi');\nvar XMLSPECIAL = '[&<>\"]';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join('');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\n\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer$1(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\n\nfunction isContainer$1(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar Node$1 = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === 'document') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer$1(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    __extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(Node$1));\nvar ListNode = /** @class */ (function (_super) {\n    __extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    __extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = 'atx';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    __extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    __extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    __extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    __extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = '';\n        _this.dest = '';\n        _this.label = '';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    __extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = '';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    __extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    __extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(Node$1));\nvar CodeNode = /** @class */ (function (_super) {\n    __extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(Node$1));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    __extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = '';\n        return _this;\n    }\n    return CustomInlineNode;\n}(Node$1));\nfunction createNode$1(type, sourcepos) {\n    switch (type) {\n        case 'heading':\n            return new HeadingNode(type, sourcepos);\n        case 'list':\n        case 'item':\n            return new ListNode(type, sourcepos);\n        case 'link':\n        case 'image':\n            return new LinkNode(type, sourcepos);\n        case 'codeBlock':\n            return new CodeBlockNode(type, sourcepos);\n        case 'htmlBlock':\n            return new HtmlBlockNode(type, sourcepos);\n        case 'table':\n            return new TableNode(type, sourcepos);\n        case 'tableCell':\n            return new TableCellNode(type, sourcepos);\n        case 'document':\n        case 'paragraph':\n        case 'blockQuote':\n        case 'thematicBreak':\n        case 'tableRow':\n        case 'tableBody':\n        case 'tableHead':\n        case 'frontMatter':\n            return new BlockNode(type, sourcepos);\n        case 'code':\n            return new CodeNode(type, sourcepos);\n        case 'refDef':\n            return new RefDefNode(type, sourcepos);\n        case 'customBlock':\n            return new CustomBlockNode(type, sourcepos);\n        case 'customInline':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new Node$1(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === 'codeBlock';\n}\nfunction isHtmlBlock(node) {\n    return node.type === 'htmlBlock';\n}\nfunction isHeading(node) {\n    return node.type === 'heading';\n}\nfunction isList(node) {\n    return node.type === 'list';\n}\nfunction isTable(node) {\n    return node.type === 'table';\n}\nfunction isRefDef(node) {\n    return node.type === 'refDef';\n}\nfunction isCustomBlock(node) {\n    return node.type === 'customBlock';\n}\nfunction isCustomInline(node) {\n    return node.type === 'customInline';\n}\nfunction text$1(s, sourcepos) {\n    var node = createNode$1('text', sourcepos);\n    node.literal = s;\n    return node;\n}\n\nvar TAGNAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';\nvar DECLARATION = '<![A-Z]+\\\\s+[^>]*>';\nvar CDATA = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" + PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar reHtmlTag = new RegExp(\"^\" + HTMLTAG, 'i');\n\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return '';\n        }\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\n\nvar DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';\nvar PATH = '[^<\\\\s]*[^<?!.,:*_?~\\\\s]';\nvar EMAIL = '[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === '(') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === ')') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, '');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, 'g');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: \"mailto:\" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp(\"(www|https?://).\" + DOMAIN + PATH, 'g');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === 'www' ? 'http://' : '';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: \"\" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return __spreadArray(__spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === 'boolean') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === 'text' && node.parent.type !== 'link') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return \"continue\";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) { return [\n                [lineNum_1, chPos_1 + startIdx],\n                [lineNum_1, chPos_1 + endIdx],\n            ]; };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(text$1(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode$1('link', sourcepos.apply(void 0, range));\n                linkNode.appendChild(text$1(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(text$1(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\n\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, ' ')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = __assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\n\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = \"\\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp(\"^(?:\\\"(\" + ESCAPED_CHAR + \"|[^\\\"\\\\x00])*\\\"\" +\n    \"|\" +\n    (\"'(\" + ESCAPED_CHAR + \"|[^'\\\\x00])*'\") +\n    \"|\" +\n    (\"\\\\((\" + ESCAPED_CHAR + \"|[^()\\\\x00])*\\\\))\"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp(\"^\" + ESCAPABLE);\nvar reEntityHere = new RegExp(\"^\" + ENTITY, 'i');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = '';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === 'number') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split('\\n');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(' ');\n                }\n                var node = createNode$1('code', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == ' ' &&\n                    contents[contents.length - 1] == ' ') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn't match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(text$1(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block's children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode$1('linebreak', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(text$1(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(text$1('\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(\"mailto:\" + dest);\n            node.title = '';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode$1('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = '';\n            node.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode$1('htmlInline', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = '\\n';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = '\\u2019';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = '\\u201C';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = text$1(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? 'emph'\n                                : 'strong'\n                            : 'strike';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = 'customInline';\n                        }\n                        var newNode = createNode$1(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || '';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + \" \", '');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = '\\u2019';\n                    if (openerFound) {\n                        opener.node.literal = '\\u2018';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = '\\u201D';\n                    if (openerFound) {\n                        opener.node.literal = '\\u201C';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can't be an opener,\n                        // once we've seen there's no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block's children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = text$1('[', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block's children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = text$1('![', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = text$1('!', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block's children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there's a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = '';\n        if (!matched) {\n            // Next, see if there's a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode$1(isImage ? 'image' : 'link');\n            node.destination = dest;\n            node.title = title || '';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(text$1(']', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(text$1(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, '\\u2026').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat('\\u2014', emCount) + repeat('\\u2013', enCount);\n                });\n                block.appendChild(text$1(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = text$1(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we're at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, '');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode$1(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode$1('softbreak', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = '';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we're at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === '') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = '';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === '') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode$1('refDef', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === 'text') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/'|\"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block's children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(text$1(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\n\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === 'paragraph') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\n\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableHead' || t === 'tableBody';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow' || t === 'tableDelimRow';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableDelimCell';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableCell';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\n\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\n\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === 'item';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we're at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf('\\n');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '\\n');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\n\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === '|' && content[i - 1] !== '\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = '';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode$1(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, '|'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === ':') {\n        align = firstCh === ':' ? 'center' : 'right';\n    }\n    else if (firstCh === ':') {\n        align = 'left';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf('\\n', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option\n            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode$1('table', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf('\\n', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode$1('tableHead', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode$1('tableRow', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode$1('tableDelimRow', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== 'table' && container.type !== 'tableBody') ||\n        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === 'tableBody') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === 'table') {\n        tableBody = parser.addChild('tableBody', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode$1('tableRow', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\n\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('customBlock', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^<!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp(\"^(?:\" + OPENTAG + \"|\" + CLOSETAG + \")\\\\s*$\", 'i'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: 'bullet',\n        tight: true,\n        bulletChar: '',\n        start: 0,\n        delimiter: '',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = 'bullet';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== 'paragraph' || match[1] === '1')) {\n        data.type = 'ordered';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn't blank\n    if (container.type === 'paragraph' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we've got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild('blockQuote', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild('heading', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = 'atx';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, '')\n            .replace(/[ \\t]+#+[ \\t]*$/, '');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('codeBlock', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === 'paragraph') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp(\"</?(?:\" + disallowedTags.join('|') + \")\", 'i');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don't adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild('htmlBlock', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === 'paragraph' &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode$1('heading', container.sourcepos);\n            heading.level = match[0][0] === '=' ? 1 : 2;\n            heading.headingType = 'setext';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild('thematicBreak', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === 'list') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild('list', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild('item', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild('codeBlock', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === 'document' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\n\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === 'frontMatter' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\n\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /-->/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction document$2() {\n    return createNode$1('document', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = __assign(__assign({}, defaultOptions$1), options);\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = '';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) { columns = false; }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === '\\t') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== '') {\n            if (c === ' ') {\n                i++;\n                cols++;\n            }\n            else if (c === '\\t') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === '\\n' || c === '\\r' || c === '';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(' ', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + \"\\n\";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can't\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode$1(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = '';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the 'tight'\n    // or 'loose' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === 'paragraph' ||\n                    t === 'heading' ||\n                    (t === 'tableCell' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf('\\u0000') !== -1) {\n            ln = ln.replace(/\\0/g, '\\uFFFD');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type]['continue'](this, container)) {\n                case 0 /* Go */: // we've matched, keep going\n                    break;\n                case 1 /* Stop */: // we've failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we've hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error('continue returned illegal value, must be 0, 1, or 2');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== 'table' &&\n                container.type !== 'tableBody' &&\n                container.type !== 'paragraph' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don't count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don't set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === 'blockQuote' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild('paragraph', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = document$2();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\n\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== 'document' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) { end = null; }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== 'document') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\n\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf('|') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || '';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, __spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === '') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn't have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === '') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) { lineDiff = 0; }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, 'nextNode');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger('change', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\n\nvar disallowedTags = [\n    'title',\n    'textarea',\n    'style',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'script',\n    'plaintext',\n];\nvar reDisallowedTag = new RegExp(\"<(/?(?:\" + disallowedTags.join('|') + \")[^>]*>)\", 'ig');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return \"&lt;\" + group; });\n    }\n    return str;\n}\n\nvar baseConvertors$1 = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: \"h\" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: 'text',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: 'html',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: 'html',\n            content: '<br />\\n',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'em',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'strong',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === 'list') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'p',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: 'openTag',\n            tagName: 'hr',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'blockquote',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === 'bullet' ? 'ul' : 'ol';\n        var attributes = {};\n        if (tagName === 'ol' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: 'html', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: 'openTag', tagName: 'div', outerNewLine: true },\n                { type: 'html', content: content },\n                { type: 'closeTag', tagName: 'div', outerNewLine: true },\n            ];\n        }\n        return { type: 'html', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: 'openTag', tagName: 'code' },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push(\"language-\" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', outerNewLine: true },\n            { type: 'openTag', tagName: 'code', classNames: codeClassNames },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: 'openTag',\n                tagName: 'a',\n                attributes: __assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: 'closeTag', tagName: 'a' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: 'openTag',\n            tagName: 'img',\n            selfClose: true,\n            attributes: __assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + info + \" block node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return [\n            { type: 'openTag', tagName: 'div', outerNewLine: true },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: 'openTag',\n                tagName: 'div',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: 'white-space: pre; display: none;' },\n            },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + nomalizedInfo + \" inline node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return entering\n            ? [\n                { type: 'openTag', tagName: 'span' },\n                { type: 'text', content: \"$$\" + info + (firstChild ? ' ' : '') },\n            ]\n            : [\n                { type: 'text', content: '$$' },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n    },\n};\n\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'del',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: 'openTag',\n                tagName: 'li',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: 'openTag',\n                        tagName: 'input',\n                        selfClose: true,\n                        attributes: __assign(__assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),\n                    },\n                    {\n                        type: 'text',\n                        content: ' ',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'table',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'thead',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'tbody',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: 'openTag',\n                tagName: 'tr',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: 'openTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                }, {\n                    type: 'closeTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: 'closeTag',\n            tagName: 'tr',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: 'text',\n                content: '',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return __assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: 'closeTag',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\n\nvar defaultOptions = {\n    softbreak: '\\n',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === 'text') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join('');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = __assign(__assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = __assign({}, baseConvertors$1);\n        if (this.options.gfm) {\n            convertors = __assign(__assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = __assign(__assign({}, baseConvertors$1), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return \"continue\";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer$1(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes['data-nodeid'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join('');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case 'openTag':\n            case 'closeTag':\n                this.renderElementNode(node);\n                break;\n            case 'text':\n                this.renderTextNode(node);\n                break;\n            case 'html':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push(\"<\" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(\" class=\\\"\" + classNames.join(' ') + \"\\\"\");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(' /');\n        }\n        this.buffer.push('>');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push(\"</\" + tagName + \">\");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== '\\n') {\n            this.buffer.push('\\n');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === 'openTag') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar hasOwnProperty = Object.hasOwnProperty,\n    setPrototypeOf = Object.setPrototypeOf,\n    isFrozen = Object.isFrozen,\n    getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar freeze = Object.freeze,\n    seal = Object.seal,\n    create = Object.create; // eslint-disable-line import/no-mutable-exports\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect,\n    apply = _ref.apply,\n    construct = _ref.construct;\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!freeze) {\n  freeze = function freeze(x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function seal(x) {\n    return x;\n  };\n}\n\nif (!construct) {\n  construct = function construct(Func, args) {\n    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n  };\n}\n\nvar arrayForEach = unapply(Array.prototype.forEach);\nvar arrayPop = unapply(Array.prototype.pop);\nvar arrayPush = unapply(Array.prototype.push);\n\nvar stringToLowerCase = unapply(String.prototype.toLowerCase);\nvar stringMatch = unapply(String.prototype.match);\nvar stringReplace = unapply(String.prototype.replace);\nvar stringIndexOf = unapply(String.prototype.indexOf);\nvar stringTrim = unapply(String.prototype.trim);\n\nvar regExpTest = unapply(RegExp.prototype.test);\n\nvar typeErrorCreate = unconstruct(TypeError);\n\nfunction unapply(func) {\n  return function (thisArg) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\nfunction unconstruct(func) {\n  return function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return construct(func, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = stringToLowerCase(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = create(null);\n\n  var property = void 0;\n  for (property in object) {\n    if (apply(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\n/* IE10 doesn't support __lookupGetter__ so lets'\n * simulate it. It also automatically checks\n * if the prop is function or getter and behaves\n * accordingly. */\nfunction lookupGetter(object, prop) {\n  while (object !== null) {\n    var desc = getOwnPropertyDescriptor(object, prop);\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(element) {\n    console.warn('fallback value for', element);\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nvar html$2 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\nvar svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nvar svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\nvar mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nvar mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\nvar text = freeze(['#text']);\n\nvar html$1$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\nvar svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n// eslint-disable-next-line unicorn/better-regex\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.3.3';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      Element = window.Element,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      trustedTypes = window.trustedTypes;\n\n\n  var ElementPrototype = Element.prototype;\n\n  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      createDocumentFragment = _document.createDocumentFragment,\n      getElementsByTagName = _document.getElementsByTagName;\n  var importNode = originalDocument.importNode;\n\n\n  var documentMode = {};\n  try {\n    documentMode = clone(document).documentMode ? document.documentMode : {};\n  } catch (_) {}\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html$2), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify.\n   *\n   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n   * might cause XSS from attacks hidden in closed shadowroots in case the browser\n   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n   */\n  var RETURN_DOM_IMPORT = true;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = null;\n  var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = null;\n  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  var NAMESPACE = HTML_NAMESPACE;\n  var IS_EMPTY_INPUT = false;\n\n  /* Parsing of strict XHTML documents */\n  var PARSER_MEDIA_TYPE = void 0;\n  var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  var transformCaseFunc = void 0;\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n    PARSER_MEDIA_TYPE =\n    // eslint-disable-next-line unicorn/prefer-includes\n    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n      return x;\n    } : stringToLowerCase;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html$2);\n        addToSet(ALLOWED_ATTR, html$1$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  var ALL_SVG_TAGS = addToSet({}, svg);\n  addToSet(ALL_SVG_TAGS, svgFilters);\n  addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n  var ALL_MATHML_TAGS = addToSet({}, mathMl);\n  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n  /**\n   *\n   *\n   * @param  {Element} element a DOM element whose namespace is being checked\n   * @returns {boolean} Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  var _checkValidNamespace = function _checkValidNamespace(element) {\n    var parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: HTML_NAMESPACE,\n        tagName: 'template'\n      };\n    }\n\n    var tagName = stringToLowerCase(element.tagName);\n    var parentTagName = stringToLowerCase(parent.tagName);\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n        return false;\n      }\n\n      // Certain elements are allowed in both SVG and HTML\n      // namespace. We need to specify them explicitly\n      // so that they don't get erronously deleted from\n      // HTML namespace.\n      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG or MathML). Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    arrayPush(DOMPurify.removed, { element: node });\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      node.parentNode.removeChild(node);\n    } catch (_) {\n      try {\n        node.outerHTML = emptyHTML;\n      } catch (_) {\n        node.remove();\n      }\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\"\" attributes\n    if (name === 'is' && !ALLOWED_ATTR[name]) {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(node);\n        } catch (_) {}\n      } else {\n        try {\n          node.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n    }\n\n    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    var body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(object) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    arrayForEach(hooks[entryPoint], function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check if tagname contains Unicode */\n    if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Mitigate a problem with templates inside select */\n    if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          var childCount = childNodes.length;\n\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n      content = stringReplace(content, ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = stringTrim(attr.value);\n      lcName = transformCaseFunc(name);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Remove attribute */\n      _removeAttribute(name, currentNode);\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n        value = stringReplace(value, ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        arrayPop(DOMPurify.removed);\n      } catch (_) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw typeErrorCreate('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) ; else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n      // eslint-disable-next-line unicorn/prefer-includes\n      dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = transformCaseFunc(tag);\n    var lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      arrayPop(hooks[entryPoint]);\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nvar CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];\nvar whiteTagList = [];\nfunction registerTagWhitelistIfPossible(tagName) {\n    if (includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify.sanitize(html, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [\n            'input',\n            'script',\n            'textarea',\n            'form',\n            'button',\n            'select',\n            'meta',\n            'style',\n            'link',\n            'title',\n            'object',\n            'base',\n        ] }, options));\n}\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp(\"(<\\\\s*\" + typeName + \"[^>]*>)|(</\" + typeName + \"\\\\s*[>])\", 'ig'), '')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(ATTRIBUTE$1, 'g'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join('=').replace(/'|\"/g, '').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_1(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: 'block+',\n            group: 'block',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: '' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + \" html-block\" : 'html-block';\n                return __spreadArray$1([typeName, htmlAttrs], toArray_1(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? 'openTag' : 'closeTag',\n                outerNewLine: true,\n                tagName: 'p',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? '\\n' : '<br>\\n';\n        return { type: 'html', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes['data-task'] = '';\n                classNames.push('task-list-item');\n                if (node.listData.checked) {\n                    classNames.push('checked');\n                    attributes['data-task-checked'] = '';\n                }\n            }\n            return {\n                type: 'openTag',\n                tagName: 'li',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { 'data-backticks': String(node.tickCount) };\n        return [\n            { type: 'openTag', tagName: 'code', attributes: attributes },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs['data-backticks'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push(\"lang-\" + lang);\n            codeAttrs['data-language'] = lang;\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', classNames: preClasses },\n            { type: 'openTag', tagName: 'code', attributes: codeAttrs },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf('widget') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },\n                { type: 'html', content: htmlInline },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = __assign$1({}, baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = __assign$1(__assign$1({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = __assign$1({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_1(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = __assign$1({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\nvar nestableTypes = ['list', 'item', 'blockQuote'];\nvar nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];\n        toArray_1(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\nvar CLASS_HIGHLIGHT = cls('md-preview-highlight');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement('div');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls('md-preview');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = 'break-word';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith(\"<div class=\\\"\" + cls('contents') + \"\\\"></div>\");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, 'active', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen('updatePreview', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen('changeToolbarState', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen('blur', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_1(this.el, 'scroll', function (event) {\n            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_1(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode$1(mdNode); });\n            if (cursorNode.type === 'tableRow') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === 'tableBody') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_1(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_1(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector(\"[data-nodeid=\\\"\" + nodeId + \"\\\"]\")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit('afterPreviewRender', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML('afterbegin', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML('beforebegin', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode$1(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_1(this.el, 'scroll');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_1(this.el, { height: height + \"px\" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_1(this.el, { minHeight: minHeight + \"px\" });\n    };\n    return MarkdownPreview;\n}());\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute('data-raw-html');\n            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== 'rawHTML' && attrs[attrName]) {\n            attrName = attrName === 'className' ? 'class' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes(['rawHTML', 'extended'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign$1(__assign$1({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });\n}\n\nfunction findWrappingOutside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (around) {\n        var outer = around.length ? around[0] : type;\n        return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n    }\n    return null;\n}\nfunction findWrappingInside(range, type) {\n    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;\n    var inner = parent.child(startIndex);\n    var inside = type.contentMatch.findWrapping(inner.type);\n    if (inside) {\n        var lastType = inside.length ? inside[inside.length - 1] : type;\n        var innerMatch = lastType.contentMatch;\n        for (var i = startIndex; innerMatch && i < endIndex; i += 1) {\n            innerMatch = innerMatch.matchType(parent.child(i).type);\n        }\n        if (innerMatch && innerMatch.validEnd) {\n            return inside;\n        }\n    }\n    return null;\n}\nfunction findWrappers(range, innerRange, nodeType, attrs) {\n    var around = findWrappingOutside(range, nodeType);\n    var inner = findWrappingInside(innerRange, nodeType);\n    if (around && inner) {\n        var aroundNodes = around.map(function (type) {\n            return { type: type };\n        });\n        var innerNodes = inner.map(function (type) {\n            return { type: type, attrs: attrs };\n        });\n        return aroundNodes.concat({ type: nodeType }).concat(innerNodes);\n    }\n    return null;\n}\nfunction wrapInList(tr, _a, wrappers, joinBefore, list) {\n    var start = _a.start, end = _a.end, startIndex = _a.startIndex, endIndex = _a.endIndex, parent = _a.parent;\n    var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (var i = wrappers.length - 1; i >= 0; i -= 1) {\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (joinBefore ? 2 : 0), end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, 0, 0), wrappers.length, true));\n    var foundListIndex = 0;\n    for (var i = 0; i < wrappers.length; i += 1) {\n        if (wrappers[i].type === list) {\n            foundListIndex = i + 1;\n            break;\n        }\n    }\n    var splitDepth = wrappers.length - foundListIndex;\n    var splitPos = start + wrappers.length - (joinBefore ? 2 : 0);\n    for (var i = startIndex, len = endIndex; i < len; i += 1) {\n        var first = i === startIndex;\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += splitDepth * 2;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\nfunction changeToList(tr, range, list, attrs) {\n    var $from = range.$from, $to = range.$to, depth = range.depth;\n    var outerRange = range;\n    var joinBefore = false;\n    if (depth >= 2 &&\n        $from.node(depth - 1).type.compatibleContent(list) &&\n        range.startIndex === 0 &&\n        $from.index(depth - 1)) {\n        var start = tr.doc.resolve(range.start - 2);\n        outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(start, start, depth);\n        if (range.endIndex < range.parent.childCount) {\n            range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange($from, tr.doc.resolve($to.end(depth)), depth);\n        }\n        joinBefore = true;\n    }\n    var wrappers = findWrappers(outerRange, range, list, attrs);\n    if (wrappers) {\n        return wrapInList(tr, range, wrappers, joinBefore, list);\n    }\n    return tr;\n}\nfunction getBeforeLineListItem(doc, offset) {\n    var endListItemPos = doc.resolve(offset);\n    while (endListItemPos.node().type.name !== 'paragraph') {\n        offset -= 2; // The position value of </li></ul>\n        endListItemPos = doc.resolve(offset);\n    }\n    return findListItem(endListItemPos);\n}\nfunction toggleTaskListItems(tr, _a) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node;\n            var attrs = { task: !node.attrs.task, checked: false };\n            tr.setNodeMarkup(offset, null, attrs);\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeListType(tr, _a, list) {\n    var $from = _a.$from, $to = _a.$to;\n    var startListItem = findListItem($from);\n    var endListItem = findListItem($to);\n    if (startListItem && endListItem) {\n        while (endListItem) {\n            var offset = endListItem.offset, node = endListItem.node, depth = endListItem.depth;\n            if (node.attrs.task) {\n                tr.setNodeMarkup(offset, null, { task: false, checked: false });\n            }\n            var resolvedPos = tr.doc.resolve(offset);\n            if (resolvedPos.parent.type !== list) {\n                var parentOffset = resolvedPos.before(depth - 1);\n                tr.setNodeMarkup(parentOffset, list);\n            }\n            if (offset === startListItem.offset) {\n                break;\n            }\n            endListItem = getBeforeLineListItem(tr.doc, offset);\n        }\n    }\n    return tr;\n}\nfunction changeList(list) {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? changeListType(tr, range, list)\n                : changeToList(tr, range, list);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction toggleTask() {\n    return function (_a, dispatch) {\n        var selection = _a.selection, tr = _a.tr, schema = _a.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range) {\n            var newTr = isInListNode($from)\n                ? toggleTaskListItems(tr, range)\n                : changeToList(tr, range, schema.nodes.bulletList, { task: true });\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction sinkListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range && range.startIndex > 0) {\n            var parent_1 = range.parent;\n            var nodeBefore = parent_1.child(range.startIndex - 1);\n            if (nodeBefore.type !== listItem) {\n                return false;\n            }\n            var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type === parent_1.type;\n            var inner = nestedBefore ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create()) : null;\n            var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(parent_1.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            var before = range.start;\n            var after = range.end;\n            tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true));\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction liftToOuterList(tr, range, listItem) {\n    var $from = range.$from, $to = range.$to, end = range.end, depth = range.depth, parent = range.parent;\n    var endOfList = $to.end(depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.create(null, parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), depth);\n    }\n    tr.lift(range, (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.liftTarget)(range));\n    return tr;\n}\nfunction liftOutOfList(tr, range) {\n    var list = range.parent;\n    var pos = range.end;\n    // Merge the list items into a single big item\n    for (var i = range.endIndex - 1, len = range.startIndex; i > len; i -= 1) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    var startPos = tr.doc.resolve(range.start);\n    var listItem = startPos.nodeAfter;\n    var atStart = range.startIndex === 0;\n    var atEnd = range.endIndex === list.childCount;\n    var parent = startPos.node(-1);\n    var indexBefore = startPos.index(-1);\n    var canReplaceParent = parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, listItem === null || listItem === void 0 ? void 0 : listItem.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list)));\n    if (listItem && canReplaceParent) {\n        var start = startPos.pos;\n        var end = start + listItem.nodeSize;\n        // Strip off the surrounding list. At the sides where we're not at\n        // the end of the list, the existing list is closed. At sides where\n        // this is the end, it is overwritten to its end.\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    }\n    return tr;\n}\nfunction liftListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to, function (_a) {\n            var childCount = _a.childCount, firstChild = _a.firstChild;\n            return !!childCount && firstChild.type === listItem;\n        });\n        if (range) {\n            var topListItem = $from.node(range.depth - 1).type === listItem;\n            var newTr = topListItem ? liftToOuterList(tr, range, listItem) : liftOutOfList(tr, range);\n            dispatch(newTr);\n            return true;\n        }\n        return false;\n    };\n}\nfunction splitListItem(listItem) {\n    return function (_a, dispatch) {\n        var tr = _a.tr, selection = _a.selection;\n        var $from = selection.$from, $to = selection.$to;\n        if ($from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        var grandParent = $from.node(-1);\n        if (grandParent.type !== listItem) {\n            return false;\n        }\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 ||\n                $from.node(-3).type !== listItem ||\n                $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            var keepItem = $from.index(-1) > 0;\n            var wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n            // Build a fragment containing empty versions of the structure\n            // from the outer list item to the parent node of the cursor\n            for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth -= 1) {\n                wrapper = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from($from.node(depth).copy(wrapper));\n            }\n            // Add a second list item with an empty default start node\n            wrapper = wrapper.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(listItem.createAndFill()));\n            tr.replace(keepItem ? $from.before() : $from.before(-1), $from.after(-3), new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrapper, keepItem ? 3 : 2, 2));\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));\n            dispatch(tr);\n            return true;\n        }\n        var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        var types = nextType && [null, { type: nextType }];\n        tr.delete($from.pos, $to.pos);\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.canSplit)(tr.doc, $from.pos, 2, types)) {\n            tr.split($from.pos, 2, types);\n            dispatch(tr);\n            return true;\n        }\n        return false;\n    };\n}\n\nfunction indent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return sinkListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction outdent() {\n    return function () { return function (state, dispatch) {\n        var selection = state.selection, schema = state.schema;\n        var $from = selection.$from, $to = selection.$to;\n        var range = $from.blockRange($to);\n        if (range && isInListNode($from)) {\n            return liftListItem(schema.nodes.listItem)(state, dispatch);\n        }\n        return false;\n    }; };\n}\nfunction getWwCommands() {\n    return {\n        indent: indent(),\n        outdent: outdent(),\n    };\n}\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === 'table';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, \"totalRowCount\", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"totalColumnCount\", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableStartOffset\", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableEndOffset\", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\nfunction getSelectionRanges(doc, map, _a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var ranges = [];\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n            var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n            ranges.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange(doc.resolve(offset + 1), doc.resolve(offset + nodeSize - 1)));\n        }\n    }\n    return ranges;\n}\nfunction createTableFragment(tableHead, tableBody) {\n    var fragment = [];\n    if (tableHead.childCount) {\n        fragment.push(tableHead);\n    }\n    if (tableBody.childCount) {\n        fragment.push(tableBody);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(fragment);\n}\nvar CellSelection = /** @class */ (function (_super) {\n    __extends$1(CellSelection, _super);\n    function CellSelection(startCellPos, endCellPos) {\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        var _this = this;\n        var doc = startCellPos.node(0);\n        var map = TableOffsetMap.create(startCellPos);\n        var selectionInfo = map.getRectOffsets(startCellPos, endCellPos);\n        var ranges = getSelectionRanges(doc, map, selectionInfo);\n        _this = _super.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;\n        _this.startCell = startCellPos;\n        _this.endCell = endCellPos;\n        _this.offsetMap = map;\n        _this.isCellSelection = true;\n        // This property is the api of the 'Selection' in prosemirror,\n        // and is used to disable the text selection.\n        _this.visible = false;\n        return _this;\n    }\n    CellSelection.prototype.map = function (doc, mapping) {\n        var startPos = this.startCell.pos;\n        var endPos = this.endCell.pos;\n        var startCell = doc.resolve(mapping.map(startPos));\n        var endCell = doc.resolve(mapping.map(endPos));\n        var map = TableOffsetMap.create(startCell);\n        // text selection when rows or columns are deleted\n        if (this.offsetMap.totalColumnCount > map.totalColumnCount ||\n            this.offsetMap.totalRowCount > map.totalRowCount) {\n            var depthMap = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 };\n            var depthFromTable = depthMap[endCell.parent.type.name];\n            var tableEndPos = endCell.end(endCell.depth - depthFromTable);\n            // subtract 4(</td></tr></tbody></table> tag length)\n            var from = Math.min(tableEndPos - 4, endCell.pos);\n            return prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, from);\n        }\n        return new CellSelection(startCell, endCell);\n    };\n    CellSelection.prototype.eq = function (cell) {\n        return (cell instanceof CellSelection &&\n            cell.startCell.pos === this.startCell.pos &&\n            cell.endCell.pos === this.endCell.pos);\n    };\n    CellSelection.prototype.content = function () {\n        var table = this.startCell.node(-2);\n        var tableOffset = this.startCell.start(-2);\n        var row = table.child(1).firstChild;\n        var tableHead = table.child(0).type.create();\n        var tableBody = table.child(1).type.create();\n        var map = TableOffsetMap.create(this.startCell);\n        var selectionInfo = map.getRectOffsets(this.startCell, this.endCell);\n        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;\n        var isTableHeadCell = false;\n        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n            var cells = [];\n            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                var offset = map.getCellInfo(rowIdx, colIdx).offset;\n                var cell = table.nodeAt(offset - tableOffset);\n                if (cell) {\n                    isTableHeadCell = cell.type.name === 'tableHeadCell';\n                    // mark the extended cell for pasting\n                    if (map.extendedRowspan(rowIdx, colIdx) || map.extendedColspan(rowIdx, colIdx)) {\n                        cells.push(cell.type.create({ extended: true }));\n                    }\n                    else {\n                        cells.push(cell.copy(cell.content));\n                    }\n                }\n            }\n            var copiedRow = row.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(cells));\n            var targetNode = isTableHeadCell ? tableHead : tableBody;\n            // @ts-ignore\n            targetNode.content = targetNode.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(copiedRow));\n        }\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(createTableFragment(tableHead, tableBody), 1, 1);\n    };\n    CellSelection.prototype.toJSON = function () {\n        return JSON.stringify(this);\n    };\n    return CellSelection;\n}(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection));\n\nfunction createTableHeadRow(columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell, paragraph = _a.paragraph;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        var text = data && data[index];\n        var para = paragraph.create(null, text ? schema.text(text) : []);\n        cells.push(tableHeadCell.create(null, para));\n    }\n    return [tableRow.create(null, cells)];\n}\nfunction createTableBodyRows(rowCount, columnCount, schema, data) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var tableRows = [];\n    for (var rowIdx = 0; rowIdx < rowCount; rowIdx += 1) {\n        var cells = [];\n        for (var colIdx = 0; colIdx < columnCount; colIdx += 1) {\n            var text = data && data[rowIdx * columnCount + colIdx];\n            var para = paragraph.create(null, text ? schema.text(text) : []);\n            cells.push(tableBodyCell.create(null, para));\n        }\n        tableRows.push(tableRow.create(null, cells));\n    }\n    return tableRows;\n}\nfunction createDummyCells(columnCount, rowIdx, schema, attrs) {\n    if (attrs === void 0) { attrs = null; }\n    var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;\n    var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;\n    var cells = [];\n    for (var index = 0; index < columnCount; index += 1) {\n        cells.push(cell.create(attrs, paragraph.create()));\n    }\n    return cells;\n}\nfunction findCellElement(node, root) {\n    while (node && node !== root) {\n        if (node.nodeName === 'TD' || node.nodeName === 'TH') {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction findCell(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction getResolvedSelection(selection) {\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n        var $anchor = selection.$anchor;\n        var foundCell = findCell($anchor);\n        if (foundCell) {\n            var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));\n            return { anchor: anchor, head: anchor };\n        }\n    }\n    var _a = selection, startCell = _a.startCell, endCell = _a.endCell;\n    return { anchor: startCell, head: endCell };\n}\nfunction getTableContentFromSlice(slice) {\n    var _a;\n    if (slice.size) {\n        var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n        if (content.childCount !== 1) {\n            return null;\n        }\n        while (content.childCount === 1 &&\n            ((openStart > 0 && openEnd > 0) || ((_a = content.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === 'table')) {\n            openStart -= 1;\n            openEnd -= 1;\n            content = content.firstChild.content;\n        }\n        if (content.firstChild.type.name === 'tableHead' ||\n            content.firstChild.type.name === 'tableBody') {\n            return content;\n        }\n    }\n    return null;\n}\nfunction getRowAndColumnCount(_a) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;\n    var rowCount = endRowIdx - startRowIdx + 1;\n    var columnCount = endColIdx - startColIdx + 1;\n    return { rowCount: rowCount, columnCount: columnCount };\n}\nfunction setAttrs(cell, attrs) {\n    return __assign$1(__assign$1({}, cell.attrs), attrs);\n}\n\nvar pluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('cellSelection');\nvar MOUSE_RIGHT_BUTTON = 2;\nvar TableSelection = /** @class */ (function () {\n    function TableSelection(view) {\n        this.view = view;\n        this.handlers = {\n            mousedown: this.handleMousedown.bind(this),\n            mousemove: this.handleMousemove.bind(this),\n            mouseup: this.handleMouseup.bind(this),\n        };\n        this.startCellPos = null;\n        this.init();\n    }\n    TableSelection.prototype.init = function () {\n        this.view.dom.addEventListener('mousedown', this.handlers.mousedown);\n    };\n    TableSelection.prototype.handleMousedown = function (ev) {\n        var foundCell = findCellElement(ev.target, this.view.dom);\n        if (ev.button === MOUSE_RIGHT_BUTTON) {\n            ev.preventDefault();\n            return;\n        }\n        if (foundCell) {\n            var startCellPos = this.getCellPos(ev);\n            if (startCellPos) {\n                this.startCellPos = startCellPos;\n            }\n            this.bindEvent();\n        }\n    };\n    TableSelection.prototype.handleMousemove = function (ev) {\n        var prevEndCellOffset = pluginKey.getState(this.view.state);\n        var endCellPos = this.getCellPos(ev);\n        var startCellPos = this.startCellPos;\n        var prevEndCellPos;\n        if (prevEndCellOffset) {\n            prevEndCellPos = this.view.state.doc.resolve(prevEndCellOffset);\n        }\n        else if (startCellPos !== endCellPos) {\n            prevEndCellPos = startCellPos;\n        }\n        if (prevEndCellPos && startCellPos && endCellPos) {\n            this.setCellSelection(startCellPos, endCellPos);\n        }\n    };\n    TableSelection.prototype.handleMouseup = function () {\n        this.startCellPos = null;\n        this.unbindEvent();\n        if (pluginKey.getState(this.view.state) !== null) {\n            this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));\n        }\n    };\n    TableSelection.prototype.bindEvent = function () {\n        var dom = this.view.dom;\n        dom.addEventListener('mousemove', this.handlers.mousemove);\n        dom.addEventListener('mouseup', this.handlers.mouseup);\n    };\n    TableSelection.prototype.unbindEvent = function () {\n        var dom = this.view.dom;\n        dom.removeEventListener('mousemove', this.handlers.mousemove);\n        dom.removeEventListener('mouseup', this.handlers.mouseup);\n    };\n    TableSelection.prototype.getCellPos = function (_a) {\n        var clientX = _a.clientX, clientY = _a.clientY;\n        var mousePos = this.view.posAtCoords({ left: clientX, top: clientY });\n        if (mousePos) {\n            var doc = this.view.state.doc;\n            var currentPos = doc.resolve(mousePos.pos);\n            var foundCell = findCell(currentPos);\n            if (foundCell) {\n                var cellOffset = currentPos.before(foundCell.depth);\n                return doc.resolve(cellOffset);\n            }\n        }\n        return null;\n    };\n    TableSelection.prototype.setCellSelection = function (startCellPos, endCellPos) {\n        var _a = this.view.state, selection = _a.selection, tr = _a.tr;\n        var starting = pluginKey.getState(this.view.state) === null;\n        var cellSelection = new CellSelection(startCellPos, endCellPos);\n        if (starting || !selection.eq(cellSelection)) {\n            var newTr = tr.setSelection(cellSelection);\n            if (starting) {\n                newTr.setMeta(pluginKey, endCellPos.pos);\n            }\n            this.view.dispatch(newTr);\n        }\n    };\n    TableSelection.prototype.destroy = function () {\n        this.view.dom.removeEventListener('mousedown', this.handlers.mousedown);\n    };\n    return TableSelection;\n}());\n\nvar SELECTED_CELL_CLASS_NAME = cls('cell-selected');\nfunction drawCellSelection(_a) {\n    var selection = _a.selection, doc = _a.doc;\n    if (selection instanceof CellSelection) {\n        var cells_1 = [];\n        var ranges = selection.ranges;\n        ranges.forEach(function (_a) {\n            var $from = _a.$from, $to = _a.$to;\n            cells_1.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.node($from.pos - 1, $to.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));\n        });\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet.create(doc, cells_1);\n    }\n    return null;\n}\nfunction tableSelection() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: pluginKey,\n        state: {\n            init: function () {\n                return null;\n            },\n            apply: function (tr, value) {\n                var cellOffset = tr.getMeta(pluginKey);\n                if (cellOffset) {\n                    return cellOffset === -1 ? null : cellOffset;\n                }\n                if (isNull_1(value) || !tr.docChanged) {\n                    return value;\n                }\n                var _a = tr.mapping.mapResult(value), deleted = _a.deleted, pos = _a.pos;\n                return deleted ? null : pos;\n            },\n        },\n        props: {\n            decorations: drawCellSelection,\n            createSelectionBetween: function (_a) {\n                var state = _a.state;\n                if (!isNull_1(pluginKey.getState(state))) {\n                    return state.selection;\n                }\n                return null;\n            },\n        },\n        view: function (editorView) {\n            return new TableSelection(editorView);\n        },\n    });\n}\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar Map$1 = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_1(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nvar DEFAULT_CODE = 'en-US';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new Map$1();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_1(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error(\"There is no text key \\\"\" + key + \"\\\" in \" + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\nvar i18n = new I18n();\n\nvar contextMenuGroups = [\n    [\n        {\n            action: 'Add row to up',\n            command: 'addRowToUp',\n            disableInThead: true,\n            className: 'add-row-up',\n        },\n        {\n            action: 'Add row to down',\n            command: 'addRowToDown',\n            disableInThead: true,\n            className: 'add-row-down',\n        },\n        { action: 'Remove row', command: 'removeRow', disableInThead: true, className: 'remove-row' },\n    ],\n    [\n        { action: 'Add column to left', command: 'addColumnToLeft', className: 'add-column-left' },\n        { action: 'Add column to right', command: 'addColumnToRight', className: 'add-column-right' },\n        { action: 'Remove column', command: 'removeColumn', className: 'remove-column' },\n    ],\n    [\n        {\n            action: 'Align column to left',\n            command: 'alignColumn',\n            payload: { align: 'left' },\n            className: 'align-column-left',\n        },\n        {\n            action: 'Align column to center',\n            command: 'alignColumn',\n            payload: { align: 'center' },\n            className: 'align-column-center',\n        },\n        {\n            action: 'Align column to right',\n            command: 'alignColumn',\n            payload: { align: 'right' },\n            className: 'align-column-right',\n        },\n    ],\n    [{ action: 'Remove table', command: 'removeTable', className: 'remove-table' }],\n];\nfunction getContextMenuGroups(eventEmitter, inTableHead) {\n    return contextMenuGroups\n        .map(function (contextMenuGroup) {\n        return contextMenuGroup.map(function (_a) {\n            var action = _a.action, command = _a.command, payload = _a.payload, disableInThead = _a.disableInThead, className = _a.className;\n            return {\n                label: i18n.get(action),\n                onClick: function () {\n                    eventEmitter.emit('command', command, payload);\n                },\n                disabled: inTableHead && !!disableInThead,\n                className: className,\n            };\n        });\n    })\n        .concat();\n}\nfunction tableContextMenu(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                contextmenu: function (view, ev) {\n                    var tableCell = findCellElement(ev.target, view.dom);\n                    if (tableCell) {\n                        ev.preventDefault();\n                        var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                        var _b = view.dom.parentNode.getBoundingClientRect(), left = _b.left, top_1 = _b.top;\n                        var inTableHead = tableCell.nodeName === 'TH';\n                        eventEmitter.emit('contextmenu', {\n                            pos: { left: clientX - left + 10 + \"px\", top: clientY - top_1 + 30 + \"px\" },\n                            menuGroups: getContextMenuGroups(eventEmitter, inTableHead),\n                            tableCell: tableCell,\n                        });\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nfunction task() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            handleDOMEvents: {\n                mousedown: function (view, ev) {\n                    var _a = ev, clientX = _a.clientX, clientY = _a.clientY;\n                    var mousePos = view.posAtCoords({ left: clientX, top: clientY });\n                    if (mousePos) {\n                        var _b = view.state, doc = _b.doc, tr = _b.tr;\n                        var currentPos = doc.resolve(mousePos.pos);\n                        var listItem = findListItem(currentPos);\n                        var target = ev.target;\n                        var style = getComputedStyle(target, ':before');\n                        var _c = ev, offsetX = _c.offsetX, offsetY = _c.offsetY;\n                        if (!listItem || !isPositionInBox(style, offsetX, offsetY)) {\n                            return false;\n                        }\n                        ev.preventDefault();\n                        var offset = currentPos.before(listItem.depth);\n                        var attrs = listItem.node.attrs;\n                        tr.setNodeMarkup(offset, null, __assign$1(__assign$1({}, attrs), { checked: !attrs.checked }));\n                        view.dispatch(tr);\n                        return true;\n                    }\n                    return false;\n                },\n            },\n        },\n    });\n}\n\nvar EXCEPT_TYPES = ['image', 'link', 'customBlock', 'frontMatter'];\nvar MARK_TYPES = ['strong', 'strike', 'emph', 'code'];\nvar LIST_TYPES = ['bulletList', 'orderedList', 'taskList'];\nfunction getToolbarStateType(node, parentNode) {\n    var type = node.type.name;\n    if (type === 'listItem') {\n        return node.attrs.task ? 'taskList' : parentNode.type.name;\n    }\n    if (type.indexOf('table') !== -1) {\n        return 'table';\n    }\n    return type;\n}\nfunction setListNodeToolbarState(type, nodeTypeState) {\n    nodeTypeState[type] = { active: true };\n    LIST_TYPES.filter(function (listName) { return listName !== type; }).forEach(function (listType) {\n        if (nodeTypeState[listType]) {\n            delete nodeTypeState[listType];\n        }\n    });\n}\nfunction setMarkTypeStates(from, to, schema, toolbarState) {\n    MARK_TYPES.forEach(function (type) {\n        var mark = schema.marks[type];\n        var marksAtPos = from.marksAcross(to) || [];\n        var foundMark = !!mark.isInSet(marksAtPos);\n        if (foundMark) {\n            toolbarState[type] = { active: true };\n        }\n    });\n}\nfunction getToolbarState(selection, doc, schema) {\n    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;\n    var toolbarState = {\n        indent: { active: false, disabled: true },\n        outdent: { active: false, disabled: true },\n    };\n    doc.nodesBetween(from, to, function (node, _, parentNode) {\n        var type = getToolbarStateType(node, parentNode);\n        if (includes(EXCEPT_TYPES, type)) {\n            return;\n        }\n        if (includes(LIST_TYPES, type)) {\n            setListNodeToolbarState(type, toolbarState);\n            toolbarState.indent.disabled = false;\n            toolbarState.outdent.disabled = false;\n        }\n        else if (type === 'paragraph' || type === 'text') {\n            setMarkTypeStates($from, $to, schema, toolbarState);\n        }\n        else {\n            toolbarState[type] = { active: true };\n        }\n    });\n    return toolbarState;\n}\nfunction toolbarStateHighlight(eventEmitter) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view: function () {\n            return {\n                update: function (view) {\n                    var _a = view.state, selection = _a.selection, doc = _a.doc, schema = _a.schema;\n                    eventEmitter.emit('changeToolbarState', {\n                        toolbarState: getToolbarState(selection, doc, schema),\n                    });\n                },\n            };\n        },\n    });\n}\n\nvar CustomBlockView = /** @class */ (function () {\n    function CustomBlockView(node, view, getPos, toDOMAdaptor) {\n        var _this = this;\n        this.openEditor = function () {\n            if (_this.innerEditorView) {\n                throw new Error('The editor is already opened.');\n            }\n            _this.dom.draggable = false;\n            _this.wrapper.style.display = 'none';\n            _this.innerViewContainer.style.display = 'block';\n            _this.innerEditorView = new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(_this.innerViewContainer, {\n                state: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                    doc: _this.node,\n                    plugins: [\n                        (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap)({\n                            'Mod-z': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            'Shift-Mod-z': function () { return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.redo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },\n                            Tab: function (state, dispatch) {\n                                dispatch(state.tr.insertText('\\t'));\n                                return true;\n                            },\n                            Enter: prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.newlineInCode,\n                            Escape: function () {\n                                _this.cancelEditing();\n                                return true;\n                            },\n                            'Ctrl-Enter': function () {\n                                _this.saveAndFinishEditing();\n                                return true;\n                            },\n                        }),\n                        (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.history)(),\n                    ],\n                }),\n                dispatchTransaction: function (tr) { return _this.dispatchInner(tr); },\n                handleDOMEvents: {\n                    mousedown: function () {\n                        if (_this.editorView.hasFocus()) {\n                            _this.innerEditorView.focus();\n                        }\n                        return true;\n                    },\n                    blur: function () {\n                        _this.saveAndFinishEditing();\n                        return true;\n                    },\n                },\n            });\n            _this.innerEditorView.focus();\n        };\n        this.node = node;\n        this.editorView = view;\n        this.getPos = getPos;\n        this.toDOMAdaptor = toDOMAdaptor;\n        this.innerEditorView = null;\n        this.canceled = false;\n        this.dom = document.createElement('div');\n        this.dom.className = cls('custom-block');\n        this.wrapper = document.createElement('div');\n        this.wrapper.className = cls('custom-block-view');\n        this.createInnerViewContainer();\n        this.renderCustomBlock();\n        this.dom.appendChild(this.innerViewContainer);\n        this.dom.appendChild(this.wrapper);\n    }\n    CustomBlockView.prototype.renderToolArea = function () {\n        var _this = this;\n        var tool = document.createElement('div');\n        var span = document.createElement('span');\n        var button = document.createElement('button');\n        tool.className = 'tool';\n        span.textContent = this.node.attrs.info;\n        span.className = 'info';\n        button.type = 'button';\n        button.addEventListener('click', function () { return _this.openEditor(); });\n        tool.appendChild(span);\n        tool.appendChild(button);\n        this.wrapper.appendChild(tool);\n    };\n    CustomBlockView.prototype.renderCustomBlock = function () {\n        var toDOMNode = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);\n        if (toDOMNode) {\n            var node = toDOMNode(this.node);\n            while (this.wrapper.hasChildNodes()) {\n                this.wrapper.removeChild(this.wrapper.lastChild);\n            }\n            if (node) {\n                this.wrapper.appendChild(node);\n            }\n            this.renderToolArea();\n        }\n    };\n    CustomBlockView.prototype.createInnerViewContainer = function () {\n        this.innerViewContainer = document.createElement('div');\n        this.innerViewContainer.className = cls('custom-block-editor');\n        this.innerViewContainer.style.display = 'none';\n    };\n    CustomBlockView.prototype.closeEditor = function () {\n        if (this.innerEditorView) {\n            this.innerEditorView.destroy();\n            this.innerEditorView = null;\n            this.innerViewContainer.style.display = 'none';\n        }\n        this.wrapper.style.display = 'block';\n    };\n    CustomBlockView.prototype.saveAndFinishEditing = function () {\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(createTextSelection(outerState.tr, to)));\n        this.editorView.focus();\n        this.renderCustomBlock();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.cancelEditing = function () {\n        var undoableCount = (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undoDepth)(this.innerEditorView.state);\n        this.canceled = true;\n        // should undo editing result\n        // eslint-disable-next-line no-plusplus\n        while (undoableCount--) {\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.innerEditorView.state, this.innerEditorView.dispatch);\n            (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_3__.undo)(this.editorView.state, this.editorView.dispatch);\n        }\n        this.canceled = false;\n        var to = this.editorView.state.selection.to;\n        var outerState = this.editorView.state;\n        this.editorView.dispatch(outerState.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(outerState.doc, to)));\n        this.editorView.focus();\n        this.closeEditor();\n    };\n    CustomBlockView.prototype.dispatchInner = function (tr) {\n        var _a = this.innerEditorView.state.applyTransaction(tr), state = _a.state, transactions = _a.transactions;\n        this.innerEditorView.updateState(state);\n        if (!this.canceled && isFunction_1(this.getPos)) {\n            var outerTr = this.editorView.state.tr;\n            var offsetMap = prosemirror_transform__WEBPACK_IMPORTED_MODULE_7__.StepMap.offset(this.getPos() + 1);\n            for (var i = 0; i < transactions.length; i += 1) {\n                var steps = transactions[i].steps;\n                for (var j = 0; j < steps.length; j += 1) {\n                    outerTr.step(steps[j].map(offsetMap));\n                }\n            }\n            if (outerTr.docChanged) {\n                this.editorView.dispatch(outerTr);\n            }\n        }\n    };\n    CustomBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        if (!this.innerEditorView) {\n            this.renderCustomBlock();\n        }\n        return true;\n    };\n    CustomBlockView.prototype.stopEvent = function (event) {\n        return (!!this.innerEditorView &&\n            !!event.target &&\n            this.innerEditorView.dom.contains(event.target));\n    };\n    CustomBlockView.prototype.ignoreMutation = function () {\n        return true;\n    };\n    CustomBlockView.prototype.destroy = function () {\n        this.dom.removeEventListener('dblclick', this.openEditor);\n        this.closeEditor();\n    };\n    return CustomBlockView;\n}());\n\nvar IMAGE_LINK_CLASS_NAME = 'image-link';\nvar ImageView = /** @class */ (function () {\n    function ImageView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        var _a;\n        this.handleMousedown = function (ev) {\n            ev.preventDefault();\n            var target = ev.target, offsetX = ev.offsetX, offsetY = ev.offsetY;\n            if (_this.imageLink &&\n                isFunction_1(_this.getPos) &&\n                hasClass_1(target, IMAGE_LINK_CLASS_NAME)) {\n                var style = getComputedStyle(target, ':before');\n                ev.stopPropagation();\n                if (isPositionInBox(style, offsetX, offsetY)) {\n                    var tr = _this.view.state.tr;\n                    var pos = _this.getPos();\n                    tr.setSelection(createTextSelection(tr, pos, pos + 1));\n                    _this.view.dispatch(tr);\n                    _this.eventEmitter.emit('openPopup', 'link', _this.imageLink.attrs);\n                }\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.imageLink = (_a = node.marks.filter(function (_a) {\n            var type = _a.type;\n            return type.name === 'link';\n        })[0]) !== null && _a !== void 0 ? _a : null;\n        this.dom = this.createElement();\n        this.bindEvent();\n    }\n    ImageView.prototype.createElement = function () {\n        var image = this.createImageElement(this.node);\n        if (this.imageLink) {\n            var wrapper = document.createElement('span');\n            wrapper.className = IMAGE_LINK_CLASS_NAME;\n            wrapper.appendChild(image);\n            return wrapper;\n        }\n        return image;\n    };\n    ImageView.prototype.createImageElement = function (node) {\n        var image = document.createElement('img');\n        var _a = node.attrs, imageUrl = _a.imageUrl, altText = _a.altText;\n        var attrs = getCustomAttrs(node.attrs);\n        image.src = imageUrl;\n        if (altText) {\n            image.alt = altText;\n        }\n        setAttributes(attrs, image);\n        return image;\n    };\n    ImageView.prototype.bindEvent = function () {\n        if (this.imageLink) {\n            this.dom.addEventListener('mousedown', this.handleMousedown);\n        }\n    };\n    ImageView.prototype.stopEvent = function () {\n        return true;\n    };\n    ImageView.prototype.destroy = function () {\n        if (this.imageLink) {\n            this.dom.removeEventListener('mousedown', this.handleMousedown);\n        }\n    };\n    return ImageView;\n}());\n\nvar WRAPPER_CLASS_NAME = 'toastui-editor-ww-code-block';\nvar CODE_BLOCK_LANG_CLASS_NAME = 'toastui-editor-ww-code-block-language';\nvar CodeBlockView = /** @class */ (function () {\n    function CodeBlockView(node, view, getPos, eventEmitter) {\n        var _this = this;\n        this.contentDOM = null;\n        this.input = null;\n        this.timer = null;\n        this.handleMousedown = function (ev) {\n            var target = ev.target;\n            var style = getComputedStyle(target, ':after');\n            // judge to click pseudo element with background image for IE11\n            if (style.backgroundImage !== 'none' && isFunction_1(_this.getPos)) {\n                var _a = _this.view.coordsAtPos(_this.getPos()), top_1 = _a.top, right = _a.right;\n                _this.createLanguageEditor({ top: top_1, right: right });\n            }\n        };\n        this.handleKeydown = function (ev) {\n            if (ev.key === 'Enter' && _this.input) {\n                ev.preventDefault();\n                _this.changeLanguage();\n            }\n        };\n        this.node = node;\n        this.view = view;\n        this.getPos = getPos;\n        this.eventEmitter = eventEmitter;\n        this.createElement();\n        this.bindDOMEvent();\n        this.bindEvent();\n    }\n    CodeBlockView.prototype.createElement = function () {\n        var language = this.node.attrs.language;\n        var wrapper = document.createElement('div');\n        wrapper.setAttribute('data-language', language || 'text');\n        wrapper.className = WRAPPER_CLASS_NAME;\n        var pre = this.createCodeBlockElement();\n        var code = pre.firstChild;\n        wrapper.appendChild(pre);\n        this.dom = wrapper;\n        this.contentDOM = code;\n    };\n    CodeBlockView.prototype.createCodeBlockElement = function () {\n        var pre = document.createElement('pre');\n        var code = document.createElement('code');\n        var language = this.node.attrs.language;\n        var attrs = getCustomAttrs(this.node.attrs);\n        if (language) {\n            code.setAttribute('data-language', language);\n        }\n        setAttributes(attrs, pre);\n        pre.appendChild(code);\n        return pre;\n    };\n    CodeBlockView.prototype.createLanguageEditor = function (_a) {\n        var _this = this;\n        var top = _a.top, right = _a.right;\n        var wrapper = document.createElement('span');\n        wrapper.className = CODE_BLOCK_LANG_CLASS_NAME;\n        var input = document.createElement('input');\n        input.type = 'text';\n        input.value = this.node.attrs.language;\n        wrapper.appendChild(input);\n        this.view.dom.parentElement.appendChild(wrapper);\n        var wrpperWidth = wrapper.clientWidth;\n        css_1(wrapper, {\n            top: top + 10 + \"px\",\n            left: right - wrpperWidth - 10 + \"px\",\n            width: wrpperWidth + \"px\",\n        });\n        this.input = input;\n        this.input.addEventListener('blur', function () { return _this.changeLanguage(); });\n        this.input.addEventListener('keydown', this.handleKeydown);\n        this.clearTimer();\n        this.timer = setTimeout(function () {\n            _this.input.focus();\n        });\n    };\n    CodeBlockView.prototype.bindDOMEvent = function () {\n        if (this.dom) {\n            this.dom.addEventListener('click', this.handleMousedown);\n        }\n    };\n    CodeBlockView.prototype.bindEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('scroll', function () {\n            if (_this.input) {\n                _this.reset();\n            }\n        });\n    };\n    CodeBlockView.prototype.changeLanguage = function () {\n        if (this.input && isFunction_1(this.getPos)) {\n            var value = this.input.value;\n            this.reset();\n            var pos = this.getPos();\n            var tr = this.view.state.tr;\n            tr.setNodeMarkup(pos, null, { language: value });\n            this.view.dispatch(tr);\n        }\n    };\n    CodeBlockView.prototype.reset = function () {\n        var _a;\n        if ((_a = this.input) === null || _a === void 0 ? void 0 : _a.parentElement) {\n            var parent_1 = this.input.parentElement;\n            this.input = null;\n            removeNode$1(parent_1);\n        }\n    };\n    CodeBlockView.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    CodeBlockView.prototype.stopEvent = function () {\n        return true;\n    };\n    CodeBlockView.prototype.update = function (node) {\n        if (!node.sameMarkup(this.node)) {\n            return false;\n        }\n        this.node = node;\n        return true;\n    };\n    CodeBlockView.prototype.destroy = function () {\n        this.reset();\n        this.clearTimer();\n        if (this.dom) {\n            this.dom.removeEventListener('click', this.handleMousedown);\n        }\n    };\n    return CodeBlockView;\n}());\n\nvar reMSOListClassName = /MsoListParagraph/;\nvar reMSOStylePrefix = /style=(.|\\n)*mso-/;\nvar reMSOListStyle = /mso-list:(.*)/;\nvar reMSOTagName = /O:P/;\nvar reMSOListBullet = /^(n|u|l)/;\nvar MSO_CLASS_NAME_LIST_PARA = 'p.MsoListParagraph';\nfunction isFromMso(html) {\n    return reMSOStylePrefix.test(html);\n}\nfunction getListItemContents(para) {\n    var removedNodes = [];\n    var walker = document.createTreeWalker(para, 1, null, false);\n    while (walker.nextNode()) {\n        var node = walker.currentNode;\n        if (isElemNode(node)) {\n            var _a = node, outerHTML = _a.outerHTML, textContent = _a.textContent;\n            var msoSpan = reMSOStylePrefix.test(outerHTML);\n            var bulletSpan = reMSOListStyle.test(outerHTML);\n            if (msoSpan && !bulletSpan && textContent) {\n                removedNodes.push([node, true]);\n            }\n            else if (reMSOTagName.test(node.nodeName) || (msoSpan && !textContent) || bulletSpan) {\n                removedNodes.push([node, false]);\n            }\n        }\n    }\n    removedNodes.forEach(function (_a) {\n        var node = _a[0], isUnwrap = _a[1];\n        if (isUnwrap) {\n            unwrapNode(node);\n        }\n        else {\n            removeNode$1(node);\n        }\n    });\n    return para.innerHTML.trim();\n}\nfunction createListItemDataFromParagraph(para, index) {\n    var styleAttr = para.getAttribute('style');\n    if (styleAttr) {\n        var _a = styleAttr.match(reMSOListStyle), listItemInfo = _a[1];\n        var _b = listItemInfo.trim().split(' '), levelStr = _b[1];\n        var level = parseInt(levelStr.replace('level', ''), 10);\n        var unordered = reMSOListBullet.test(para.textContent || '');\n        return {\n            id: index,\n            level: level,\n            prev: null,\n            parent: null,\n            children: [],\n            unordered: unordered,\n            contents: getListItemContents(para),\n        };\n    }\n    return null;\n}\nfunction addListItemDetailData(data, prevData) {\n    if (prevData.level < data.level) {\n        prevData.children.push(data);\n        data.parent = prevData;\n    }\n    else {\n        while (prevData) {\n            if (prevData.level === data.level) {\n                break;\n            }\n            prevData = prevData.parent;\n        }\n        if (prevData) {\n            data.prev = prevData;\n            data.parent = prevData.parent;\n            if (data.parent) {\n                data.parent.children.push(data);\n            }\n        }\n    }\n}\nfunction createListData(paras) {\n    var listData = [];\n    paras.forEach(function (para, index) {\n        var prevListItemData = listData[index - 1];\n        var listItemData = createListItemDataFromParagraph(para, index);\n        if (listItemData) {\n            if (prevListItemData) {\n                addListItemDetailData(listItemData, prevListItemData);\n            }\n            listData.push(listItemData);\n        }\n    });\n    return listData;\n}\nfunction makeList(listData) {\n    var listTagName = listData[0].unordered ? 'ul' : 'ol';\n    var list = document.createElement(listTagName);\n    listData.forEach(function (data) {\n        var children = data.children, contents = data.contents;\n        var listItem = document.createElement('li');\n        listItem.innerHTML = contents;\n        list.appendChild(listItem);\n        if (children.length) {\n            list.appendChild(makeList(children));\n        }\n    });\n    return list;\n}\nfunction makeListFromParagraphs(paras) {\n    var listData = createListData(paras);\n    var rootChildren = listData.filter(function (_a) {\n        var parent = _a.parent;\n        return !parent;\n    });\n    return makeList(rootChildren);\n}\nfunction isMsoListParagraphEnd(node) {\n    while (node) {\n        if (isElemNode(node)) {\n            break;\n        }\n        node = node.nextSibling;\n    }\n    return node ? !reMSOListClassName.test(node.className) : true;\n}\nfunction convertMsoParagraphsToList(html) {\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    var paras = [];\n    var foundParas = findNodes(container, MSO_CLASS_NAME_LIST_PARA);\n    foundParas.forEach(function (para) {\n        var msoListParaEnd = isMsoListParagraphEnd(para.nextSibling);\n        paras.push(para);\n        if (msoListParaEnd) {\n            var list = makeListFromParagraphs(paras);\n            var nextSibling = para.nextSibling;\n            if (nextSibling) {\n                insertBeforeNode(list, nextSibling);\n            }\n            else {\n                appendNodes(container, list);\n            }\n            paras = [];\n        }\n        removeNode$1(para);\n    });\n    // without `<p></p>`, the list string was parsed as a paragraph node and added\n    var extraHTML = foundParas.length ? '<p></p>' : '';\n    return \"\" + extraHTML + container.innerHTML;\n}\n\nvar START_FRAGMENT_COMMENT = '<!--StartFragment-->';\nvar END_FRAGMENT_COMMENT = '<!--EndFragment-->';\nfunction getContentBetweenFragmentComments(html) {\n    var startFragmentIndex = html.indexOf(START_FRAGMENT_COMMENT);\n    var endFragmentIndex = html.lastIndexOf(END_FRAGMENT_COMMENT);\n    if (startFragmentIndex > -1 && endFragmentIndex > -1) {\n        html = html.slice(startFragmentIndex + START_FRAGMENT_COMMENT.length, endFragmentIndex);\n    }\n    return html.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);\n}\nfunction convertMsoTableToCompletedTable(html) {\n    // wrap with <tr> if html contains dangling <td> tags\n    // dangling <td> tag is that tag does not have <tr> as parent node\n    if (/<\\/td>((?!<\\/tr>)[\\s\\S])*$/i.test(html)) {\n        html = \"<tr>\" + html + \"</tr>\";\n    }\n    // wrap with <table> if html contains dangling <tr> tags\n    // dangling <tr> tag is that tag does not have <table> as parent node\n    if (/<\\/tr>((?!<\\/table>)[\\s\\S])*$/i.test(html)) {\n        html = \"<table>\" + html + \"</table>\";\n    }\n    return html;\n}\nfunction changePastedHTML(html) {\n    html = getContentBetweenFragmentComments(html);\n    html = convertMsoTableToCompletedTable(html);\n    if (isFromMso(html)) {\n        html = convertMsoParagraphsToList(html);\n    }\n    return html;\n}\nfunction getMaxColumnCount(rows) {\n    var row = rows.reduce(function (prevRow, currentRow) {\n        return prevRow.childCount > currentRow.childCount ? prevRow : currentRow;\n    });\n    return row.childCount;\n}\nfunction createCells(orgRow, maxColumnCount, cell) {\n    var cells = [];\n    var cellCount = orgRow.childCount;\n    for (var colIdx = 0; colIdx < cellCount; colIdx += 1) {\n        if (!orgRow.child(colIdx).attrs.extended) {\n            var copiedCell = colIdx < cellCount\n                ? cell.create(orgRow.child(colIdx).attrs, orgRow.child(colIdx).content)\n                : cell.createAndFill();\n            cells.push(copiedCell);\n        }\n    }\n    return cells;\n}\nfunction copyTableHeadRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell;\n    var cells = createCells(orgRow, maxColumnCount, tableHeadCell);\n    return tableRow.create(null, cells);\n}\nfunction copyTableBodyRow(orgRow, maxColumnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = createCells(orgRow, maxColumnCount, tableBodyCell);\n    return tableRow.create(null, cells);\n}\nfunction creatTableBodyDummyRow(columnCount, schema) {\n    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;\n    var cells = [];\n    for (var columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {\n        var dummyCell = tableBodyCell.createAndFill();\n        cells.push(dummyCell);\n    }\n    return tableRow.create({ dummyRowForPasting: true }, cells);\n}\nfunction createRowsFromPastingTable(tableContent) {\n    var tableHeadRows = [];\n    var tableBodyRows = [];\n    if (tableContent.firstChild.type.name === 'tableHead') {\n        var tableHead = tableContent.firstChild;\n        tableHead.forEach(function (row) { return tableHeadRows.push(row); });\n    }\n    if (tableContent.lastChild.type.name === 'tableBody') {\n        var tableBody = tableContent.lastChild;\n        tableBody.forEach(function (row) { return tableBodyRows.push(row); });\n    }\n    return __spreadArray$1(__spreadArray$1([], tableHeadRows), tableBodyRows);\n}\nfunction createTableHead(tableHeadRow, maxColumnCount, schema) {\n    var copiedRow = copyTableHeadRow(tableHeadRow, maxColumnCount, schema);\n    return schema.nodes.tableHead.create(null, copiedRow);\n}\nfunction createTableBody(tableBodyRows, maxColumnCount, schema) {\n    var copiedRows = tableBodyRows.map(function (tableBodyRow) {\n        return copyTableBodyRow(tableBodyRow, maxColumnCount, schema);\n    });\n    if (!tableBodyRows.length) {\n        var dummyTableRow = creatTableBodyDummyRow(maxColumnCount, schema);\n        copiedRows.push(dummyTableRow);\n    }\n    return schema.nodes.tableBody.create(null, copiedRows);\n}\nfunction createTableFromPastingTable(rows, schema, startFromBody, isInTable) {\n    var columnCount = getMaxColumnCount(rows);\n    if (startFromBody && isInTable) {\n        return schema.nodes.table.create(null, [createTableBody(rows, columnCount, schema)]);\n    }\n    var tableHeadRow = rows[0];\n    var tableBodyRows = rows.slice(1);\n    var nodes = [createTableHead(tableHeadRow, columnCount, schema)];\n    if (tableBodyRows.length) {\n        nodes.push(createTableBody(tableBodyRows, columnCount, schema));\n    }\n    return schema.nodes.table.create(null, nodes);\n}\nfunction changePastedSlice(slice, schema, isInTable) {\n    var nodes = [];\n    var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;\n    content.forEach(function (node) {\n        if (node.type.name === 'table') {\n            var tableContent = getTableContentFromSlice(new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node), 0, 0));\n            if (tableContent) {\n                var rows = createRowsFromPastingTable(tableContent);\n                var startFromBody = tableContent.firstChild.type.name === 'tableBody';\n                var table = createTableFromPastingTable(rows, schema, startFromBody, isInTable);\n                nodes.push(table);\n            }\n        }\n        else {\n            nodes.push(node);\n        }\n    });\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(nodes), openStart, openEnd);\n}\n\nvar DUMMY_CELL_SIZE = 4;\nvar TR_NODES_SIZE = 2;\nfunction getDummyCellSize(dummyCellCount) {\n    return dummyCellCount * DUMMY_CELL_SIZE;\n}\nfunction createPastingCells(tableContent, curSelectionInfo, schema) {\n    var pastingRows = [];\n    var pastingTableRows = createRowsFromPastingTable(tableContent);\n    var columnCount = pastingTableRows[0].childCount;\n    var rowCount = pastingTableRows.length;\n    var startToTableHead = curSelectionInfo.startRowIdx === 0;\n    var slicedRows = pastingTableRows.slice(0, rowCount);\n    if (startToTableHead) {\n        var tableHeadRow = slicedRows.shift();\n        if (tableHeadRow) {\n            var content = copyTableHeadRow(tableHeadRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    }\n    slicedRows.forEach(function (tableBodyRow) {\n        if (!tableBodyRow.attrs.dummyRowForPasting) {\n            var content = copyTableBodyRow(tableBodyRow, columnCount, schema).content;\n            pastingRows.push(content);\n        }\n    });\n    return pastingRows;\n}\nfunction getPastingRangeInfo(map, _a, pastingCells) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx;\n    var pastingRowCount = pastingCells.length;\n    var pastingColumnCount = 0;\n    var _loop_1 = function (i) {\n        var columnCount = pastingCells[i].childCount;\n        pastingCells[i].forEach(function (_a) {\n            var attrs = _a.attrs;\n            var colspan = attrs.colspan;\n            if (colspan > 1) {\n                columnCount += colspan - 1;\n            }\n        });\n        pastingColumnCount = Math.max(pastingColumnCount, columnCount);\n    };\n    for (var i = 0; i < pastingRowCount; i += 1) {\n        _loop_1(i);\n    }\n    var endRowIdx = startRowIdx + pastingRowCount - 1;\n    var endColIdx = startColIdx + pastingColumnCount - 1;\n    var addedRowCount = Math.max(endRowIdx + 1 - map.totalRowCount, 0);\n    var addedColumnCount = Math.max(endColIdx + 1 - map.totalColumnCount, 0);\n    return {\n        startRowIdx: startRowIdx,\n        startColIdx: startColIdx,\n        endRowIdx: endRowIdx,\n        endColIdx: endColIdx,\n        addedRowCount: addedRowCount,\n        addedColumnCount: addedColumnCount,\n    };\n}\nfunction addReplacedOffsets(_a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx - addedRowCount; rowIdx += 1) {\n        cellsOffsets.push({\n            rowIdx: rowIdx,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx - addedColumnCount,\n        });\n    }\n}\nfunction expandColumns(tr, schema, map, _a, cellsOffsets) {\n    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;\n    var totalRowCount = map.totalRowCount;\n    var index = 0;\n    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n        var _b = map.getCellInfo(rowIdx, endColIdx - addedColumnCount), offset = _b.offset, nodeSize = _b.nodeSize;\n        var insertOffset = tr.mapping.map(offset + nodeSize);\n        var cells = createDummyCells(addedColumnCount, rowIdx, schema);\n        tr.insert(insertOffset, cells);\n        if (rowIdx >= startRowIdx && rowIdx <= endRowIdx - addedRowCount) {\n            var cellInfo = map.getCellInfo(rowIdx, endColIdx - addedColumnCount);\n            var startCellOffset = tr.mapping.map(cellInfo.offset);\n            var endCellOffset = insertOffset + getDummyCellSize(addedColumnCount);\n            cellsOffsets[index] = {\n                rowIdx: rowIdx,\n                startColIdx: startColIdx,\n                endColIdx: endColIdx,\n                dummyOffsets: [startCellOffset, endCellOffset],\n            };\n            index += 1;\n        }\n    }\n}\nfunction expandRows(tr, schema, map, _a, cellsOffsets) {\n    var addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount, startColIdx = _a.startColIdx, endColIdx = _a.endColIdx;\n    var mapStart = tr.mapping.maps.length;\n    var tableEndPos = map.tableEndOffset - 2;\n    var rows = createTableBodyRows(addedRowCount, map.totalColumnCount + addedColumnCount, schema);\n    var startOffset = tableEndPos;\n    tr.insert(tr.mapping.slice(mapStart).map(startOffset), rows);\n    for (var rowIndex = 0; rowIndex < addedRowCount; rowIndex += 1) {\n        var startCellOffset = startOffset + getDummyCellSize(startColIdx) + 1;\n        var endCellOffset = startOffset + getDummyCellSize(endColIdx + 1) + 1;\n        var nextCellOffset = startOffset + getDummyCellSize(map.totalColumnCount + addedColumnCount) + TR_NODES_SIZE;\n        cellsOffsets.push({\n            rowIdx: rowIndex + map.totalRowCount,\n            startColIdx: startColIdx,\n            endColIdx: endColIdx,\n            dummyOffsets: [startCellOffset, endCellOffset],\n        });\n        startOffset = nextCellOffset;\n    }\n}\nfunction replaceCells(tr, pastingRows, cellsOffsets, map) {\n    var mapStart = tr.mapping.maps.length;\n    cellsOffsets.forEach(function (offsets, index) {\n        var rowIdx = offsets.rowIdx, startColIdx = offsets.startColIdx, endColIdx = offsets.endColIdx, dummyOffsets = offsets.dummyOffsets;\n        var mapping = tr.mapping.slice(mapStart);\n        var cells = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(pastingRows[index], 0, 0);\n        var from = dummyOffsets ? dummyOffsets[0] : map.getCellStartOffset(rowIdx, startColIdx);\n        var to = dummyOffsets ? dummyOffsets[1] : map.getCellEndOffset(rowIdx, endColIdx);\n        tr.replace(mapping.map(from), mapping.map(to), cells);\n    });\n}\nfunction pasteToTable(view, slice) {\n    var _a = view.state, selection = _a.selection, schema = _a.schema, tr = _a.tr;\n    var _b = getResolvedSelection(selection), anchor = _b.anchor, head = _b.head;\n    if (anchor && head) {\n        var tableContent = getTableContentFromSlice(slice);\n        if (!tableContent) {\n            return false;\n        }\n        var map = TableOffsetMap.create(anchor);\n        var curSelectionInfo = map.getRectOffsets(anchor, head);\n        var pastingCells = createPastingCells(tableContent, curSelectionInfo, schema);\n        var pastingInfo = getPastingRangeInfo(map, curSelectionInfo, pastingCells);\n        var cellsOffsets = [];\n        // @TODO: unmerge the span and paste the cell\n        if (canMerge(map, pastingInfo)) {\n            addReplacedOffsets(pastingInfo, cellsOffsets);\n            if (pastingInfo.addedColumnCount) {\n                expandColumns(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            if (pastingInfo.addedRowCount) {\n                expandRows(tr, schema, map, pastingInfo, cellsOffsets);\n            }\n            replaceCells(tr, pastingCells, cellsOffsets, map);\n            view.dispatch(tr);\n            setSelection(view, cellsOffsets, map.getCellInfo(0, 0).offset);\n        }\n        return true;\n    }\n    return false;\n}\nfunction setSelection(view, cellsOffsets, pos) {\n    var _a = view.state, tr = _a.tr, doc = _a.doc;\n    // get changed cell offsets\n    var map = TableOffsetMap.create(doc.resolve(pos));\n    // eslint-disable-next-line prefer-destructuring\n    var _b = cellsOffsets[0], startRowIdx = _b.rowIdx, startColIdx = _b.startColIdx;\n    var _c = last$1(cellsOffsets), endRowIdx = _c.rowIdx, endColIdx = _c.endColIdx;\n    var startOffset = map.getCellInfo(startRowIdx, startColIdx).offset;\n    var endOffset = map.getCellInfo(endRowIdx, endColIdx).offset;\n    view.dispatch(tr.setSelection(new CellSelection(doc.resolve(startOffset), doc.resolve(endOffset))));\n}\nfunction canMerge(map, pastingInfo) {\n    var ranges = map.getSpannedOffsets(pastingInfo);\n    var _a = getRowAndColumnCount(ranges), rowCount = _a.rowCount, columnCount = _a.columnCount;\n    var _b = getRowAndColumnCount(pastingInfo), pastingRowCount = _b.rowCount, pastingColumnCount = _b.columnCount;\n    return rowCount === pastingRowCount && columnCount === pastingColumnCount;\n}\n\nvar Doc = /** @class */ (function (_super) {\n    __extends$1(Doc, _super);\n    function Doc() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Doc.prototype, \"name\", {\n        get: function () {\n            return 'doc';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Doc.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'block+',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Doc;\n}(Node$2));\n\nvar Paragraph = /** @class */ (function (_super) {\n    __extends$1(Paragraph, _super);\n    function Paragraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Paragraph.prototype, \"name\", {\n        get: function () {\n            return 'paragraph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Paragraph.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'inline*',\n                group: 'block',\n                attrs: __assign$1({}, getDefaultCustomAttrs()),\n                parseDOM: [{ tag: 'p' }],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['p', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Paragraph;\n}(Node$2));\n\nvar reSoftTabLen = /\\s{1,4}$/;\nvar Text = /** @class */ (function (_super) {\n    __extends$1(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Text.prototype, \"name\", {\n        get: function () {\n            return 'text';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Text.prototype, \"schema\", {\n        get: function () {\n            return {\n                group: 'inline',\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Text.prototype.addSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                dispatch(tr.insertText('    ', $from.pos, $to.pos));\n                return true;\n            }\n            return false;\n        };\n    };\n    Text.prototype.removeSpaces = function () {\n        return function (_a, dispatch) {\n            var selection = _a.selection, tr = _a.tr;\n            var $from = selection.$from, $to = selection.$to, from = selection.from;\n            var range = $from.blockRange($to);\n            if (range && !isInListNode($from) && !isInTableNode($from)) {\n                var nodeBefore = $from.nodeBefore;\n                if (nodeBefore && nodeBefore.isText) {\n                    var text = nodeBefore.text;\n                    var removedSpaceText = text.replace(reSoftTabLen, '');\n                    var spaces = text.length - removedSpaceText.length;\n                    dispatch(tr.delete(from - spaces, from));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Text.prototype.keymaps = function () {\n        return {\n            Tab: this.addSpaces(),\n            'Shift-Tab': this.removeSpaces(),\n        };\n    };\n    return Text;\n}(Node$2));\n\nvar Heading = /** @class */ (function (_super) {\n    __extends$1(Heading, _super);\n    function Heading() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Heading.prototype, \"name\", {\n        get: function () {\n            return 'heading';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"levels\", {\n        get: function () {\n            return [1, 2, 3, 4, 5, 6];\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heading.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = this.levels.map(function (level) {\n                return {\n                    tag: \"h\" + level,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({ level: level }, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ level: { default: 1 }, headingType: { default: 'atx' }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: 'inline*',\n                group: 'block',\n                defining: true,\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\"h\" + attrs.level, getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Heading.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            var nodeType = state.schema.nodes[payload.level ? 'heading' : 'paragraph'];\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(nodeType, payload)(state, dispatch);\n        }; };\n    };\n    return Heading;\n}(Node$2));\n\nvar CodeBlock = /** @class */ (function (_super) {\n    __extends$1(CodeBlock, _super);\n    function CodeBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CodeBlock.prototype, \"name\", {\n        get: function () {\n            return 'codeBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CodeBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                code: true,\n                defining: true,\n                marks: '',\n                parseDOM: [\n                    {\n                        tag: 'pre',\n                        preserveWhitespace: 'full',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            var child = dom.firstElementChild;\n                            return __assign$1({ language: (child === null || child === void 0 ? void 0 : child.getAttribute('data-language')) || null }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'pre',\n                        ['code', __assign$1({ 'data-language': attrs.language }, getCustomAttrs(attrs)), 0],\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CodeBlock.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.codeBlock)(state, dispatch); }; };\n    };\n    CodeBlock.prototype.moveCursor = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = state.selection.$from;\n            var view = _this.context.view;\n            if (view.endOfTextblock(direction) && $from.node().type.name === 'codeBlock') {\n                var lines = $from.parent.textContent.split('\\n');\n                var offset = direction === 'up' ? $from.start() : $from.end();\n                var range = direction === 'up'\n                    ? [offset, lines[0].length + offset]\n                    : [offset - last$1(lines).length, offset];\n                var pos = doc.resolve(direction === 'up' ? $from.before() : $from.after());\n                var node = direction === 'up' ? pos.nodeBefore : pos.nodeAfter;\n                if (between$1($from.pos, range[0], range[1]) && !node) {\n                    var newTr = addParagraph(tr, pos, schema);\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    CodeBlock.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            'Shift-Mod-p': codeCommand,\n            'Shift-Mod-P': codeCommand,\n            ArrowUp: this.moveCursor('up'),\n            ArrowDown: this.moveCursor('down'),\n        };\n    };\n    return CodeBlock;\n}(Node$2));\n\nvar BulletList = /** @class */ (function (_super) {\n    __extends$1(BulletList, _super);\n    function BulletList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BulletList.prototype, \"name\", {\n        get: function () {\n            return 'bulletList';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BulletList.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'listItem+',\n                group: 'block',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('ul')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['ul', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BulletList.prototype.changeList = function () {\n        return function (state, dispatch) { return changeList(state.schema.nodes.bulletList)(state, dispatch); };\n    };\n    BulletList.prototype.commands = function () {\n        return {\n            bulletList: this.changeList,\n            taskList: toggleTask,\n        };\n    };\n    BulletList.prototype.keymaps = function () {\n        var bulletListCommand = this.changeList();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            'Mod-u': bulletListCommand,\n            'Mod-U': bulletListCommand,\n            Tab: indent(),\n            'Shift-Tab': outdent(),\n        };\n    };\n    return BulletList;\n}(Node$2));\n\nvar OrderedList = /** @class */ (function (_super) {\n    __extends$1(OrderedList, _super);\n    function OrderedList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(OrderedList.prototype, \"name\", {\n        get: function () {\n            return 'orderedList';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OrderedList.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'listItem+',\n                group: 'block',\n                attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'ol',\n                        getAttrs: function (dom) {\n                            var start = dom.getAttribute('start');\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({ order: dom.hasAttribute('start') ? Number(start) : 1 }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'ol',\n                        __assign$1({ start: attrs.order === 1 ? null : attrs.order }, getCustomAttrs(attrs)),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    OrderedList.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return changeList(state.schema.nodes.orderedList)(state, dispatch); }; };\n    };\n    OrderedList.prototype.keymaps = function () {\n        var orderedListCommand = this.commands()();\n        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;\n        return {\n            'Mod-o': orderedListCommand,\n            'Mod-O': orderedListCommand,\n            Tab: indent(),\n            'Shift-Tab': outdent(),\n        };\n    };\n    return OrderedList;\n}(Node$2));\n\nvar ListItem = /** @class */ (function (_super) {\n    __extends$1(ListItem, _super);\n    function ListItem() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ListItem.prototype, \"name\", {\n        get: function () {\n            return 'listItem';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ListItem.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'paragraph block*',\n                selectable: false,\n                attrs: {\n                    task: { default: false },\n                    checked: { default: false },\n                    rawHTML: { default: null },\n                },\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: 'li',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({ task: dom.hasAttribute('data-task'), checked: dom.hasAttribute('data-task-checked') }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var task = attrs.task, checked = attrs.checked;\n                    if (!task) {\n                        return [attrs.rawHTML || 'li', 0];\n                    }\n                    var classNames = ['task-list-item'];\n                    if (checked) {\n                        classNames.push('checked');\n                    }\n                    return [\n                        attrs.rawHTML || 'li',\n                        __assign$1({ class: classNames.join(' '), 'data-task': task }, (checked && { 'data-task-checked': checked })),\n                        0,\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ListItem.prototype.liftToPrevListItem = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from, empty = selection.empty;\n            var listItem = schema.nodes.listItem;\n            var parent = $from.parent;\n            var listItemParent = $from.node(-1);\n            if (empty && !parent.childCount && listItemParent.type === listItem) {\n                // move to previous sibling list item when the current list item is not top list item\n                if ($from.index(-2) >= 1) {\n                    // should subtract '1' for considering tag length(<li>)\n                    tr.delete($from.start(-1) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n                var grandParentListItem = $from.node(-3);\n                // move to parent list item when the current list item is top list item\n                if (grandParentListItem.type === listItem) {\n                    // should subtract '1' for considering tag length(<ul>)\n                    tr.delete($from.start(-2) - 1, $from.end(-1));\n                    dispatch(tr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    ListItem.prototype.keymaps = function () {\n        var split = function (state, dispatch) {\n            return splitListItem(state.schema.nodes.listItem)(state, dispatch);\n        };\n        return {\n            Backspace: this.liftToPrevListItem(),\n            Enter: split,\n        };\n    };\n    return ListItem;\n}(Node$2));\n\nvar BlockQuote = /** @class */ (function (_super) {\n    __extends$1(BlockQuote, _super);\n    function BlockQuote() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(BlockQuote.prototype, \"name\", {\n        get: function () {\n            return 'blockQuote';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BlockQuote.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                content: 'block+',\n                group: 'block',\n                parseDOM: [createDOMInfoParsedRawHTML('blockquote')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['blockquote', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BlockQuote.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.wrapIn)(state.schema.nodes.blockQuote)(state, dispatch); }; };\n    };\n    BlockQuote.prototype.keymaps = function () {\n        var blockQutoeCommand = this.commands()();\n        return {\n            'Alt-q': blockQutoeCommand,\n            'Alt-Q': blockQutoeCommand,\n        };\n    };\n    return BlockQuote;\n}(Node$2));\n\nvar cellOffsetFnMap = {\n    left: getLeftCellOffset,\n    right: getRightCellOffset,\n    up: getUpCellOffset,\n    down: getDownCellOffset,\n};\nfunction isInFirstListItem(pos, doc, _a) {\n    var paraDepth = _a[0], listDepth = _a[1];\n    var listItemNode = doc.resolve(pos.before(paraDepth - 1));\n    return listDepth === paraDepth && !listItemNode.nodeBefore;\n}\nfunction isInLastListItem(pos) {\n    var _a;\n    var depth = pos.depth;\n    var parentNode;\n    while (depth) {\n        parentNode = pos.node(depth);\n        if (parentNode.type.name === 'tableBodyCell') {\n            break;\n        }\n        if (parentNode.type.name === 'listItem') {\n            var grandParent = pos.node(depth - 1);\n            var lastListItem = grandParent.lastChild === parentNode;\n            var hasChildren = ((_a = parentNode.lastChild) === null || _a === void 0 ? void 0 : _a.type.name) !== 'paragraph';\n            if (!lastListItem) {\n                return false;\n            }\n            return !hasChildren;\n        }\n        depth -= 1;\n    }\n    return false;\n}\nfunction canMoveToBeforeCell(direction, _a, from, doc, inList) {\n    var paraDepth = _a[0], listDepth = _a[1], curDepth = _a[2];\n    if (direction === \"left\" /* LEFT */ || direction === \"up\" /* UP */) {\n        if (inList && !isInFirstListItem(from, doc, [paraDepth, listDepth])) {\n            return false;\n        }\n        var endOffset = from.before(curDepth);\n        var nodeBefore = doc.resolve(endOffset).nodeBefore;\n        if (nodeBefore) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveToAfterCell(direction, curDepth, from, doc, inList) {\n    if (direction === \"right\" /* RIGHT */ || direction === \"down\" /* DOWN */) {\n        if (inList && !isInLastListItem(from)) {\n            return false;\n        }\n        var endOffset = from.after(curDepth);\n        var nodeAfter = doc.resolve(endOffset).nodeAfter;\n        if (nodeAfter) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction canMoveBetweenCells(direction, _a, from, doc) {\n    var cellDepth = _a[0], paraDepth = _a[1];\n    var listDepth = cellDepth + 3; // 3 is position of <ul><li><p>\n    var inList = paraDepth >= listDepth;\n    var curDepth = inList ? cellDepth + 1 : paraDepth;\n    var moveBeforeCell = canMoveToBeforeCell(direction, [paraDepth, listDepth, curDepth], from, doc, inList);\n    var moveAfterCell = canMoveToAfterCell(direction, curDepth, from, doc, inList);\n    return moveBeforeCell && moveAfterCell;\n}\nfunction canBeOutOfTable(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n    var inFirstRow = direction === \"up\" /* UP */ && rowIdx === 0;\n    var inLastRow = direction === \"down\" /* DOWN */ &&\n        ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 ? rowIdx + rowspanInfo.count - 1 : rowIdx) === map.totalRowCount - 1;\n    return inFirstRow || inLastRow;\n}\nfunction addParagraphBeforeTable(tr, map, schema) {\n    var tableStartPos = tr.doc.resolve(map.tableStartOffset - 1);\n    if (!tableStartPos.nodeBefore) {\n        return addParagraph(tr, tableStartPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableStartPos, -1));\n}\nfunction addParagraphAfterTable(tr, map, schema, forcedAddtion) {\n    if (forcedAddtion === void 0) { forcedAddtion = false; }\n    var tableEndPos = tr.doc.resolve(map.tableEndOffset);\n    if (forcedAddtion || !tableEndPos.nodeAfter) {\n        return addParagraph(tr, tableEndPos, schema);\n    }\n    return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tableEndPos, 1));\n}\nfunction getRightCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n    var lastCellInRow = colIdx === totalColumnCount - 1;\n    var lastCellInTable = rowIdx === totalRowCount - 1 && lastCellInRow;\n    if (!lastCellInTable) {\n        var nextColIdx = colIdx + 1;\n        var colspanInfo = map.getColspanStartInfo(rowIdx, colIdx);\n        if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {\n            nextColIdx += colspanInfo.count - 1;\n        }\n        if (lastCellInRow || nextColIdx === totalColumnCount) {\n            rowIdx += 1;\n            nextColIdx = 0;\n        }\n        var offset = map.getCellInfo(rowIdx, nextColIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction getLeftCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalColumnCount = map.totalColumnCount;\n    var firstCellInRow = colIdx === 0;\n    var firstCellInTable = rowIdx === 0 && firstCellInRow;\n    if (!firstCellInTable) {\n        colIdx -= 1;\n        if (firstCellInRow) {\n            rowIdx -= 1;\n            colIdx = totalColumnCount - 1;\n        }\n        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getUpCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (rowIdx > 0) {\n        var _b = map.getCellInfo(rowIdx - 1, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n        return offset + nodeSize - 2;\n    }\n    return null;\n}\nfunction getDownCellOffset(_a, map) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    var totalRowCount = map.totalRowCount;\n    if (rowIdx < totalRowCount - 1) {\n        var nextRowIdx = rowIdx + 1;\n        var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);\n        if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1) {\n            nextRowIdx += rowspanInfo.count - 1;\n        }\n        var offset = map.getCellInfo(nextRowIdx, colIdx).offset;\n        return offset + 2;\n    }\n    return null;\n}\nfunction moveToCell(direction, tr, cellIndex, map) {\n    var cellOffsetFn = cellOffsetFnMap[direction];\n    var offset = cellOffsetFn(cellIndex, map);\n    if (offset) {\n        var dir = direction === \"right\" /* RIGHT */ || direction === \"down\" /* DOWN */ ? 1 : -1;\n        return tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(offset), dir));\n    }\n    return null;\n}\nfunction canSelectTableNode(direction, map, _a) {\n    var rowIdx = _a[0], colIdx = _a[1];\n    if (direction === \"up\" /* UP */ || direction === \"down\" /* DOWN */) {\n        return false;\n    }\n    var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n    var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n    var pos = direction === \"left\" /* LEFT */ ? tableStartOffset : tableEndOffset;\n    var curPos = direction === \"left\" /* LEFT */ ? offset - 2 : offset + nodeSize + 3;\n    return pos === curPos;\n}\nfunction selectNode(tr, pos, depth) {\n    var tablePos = tr.doc.resolve(pos.before(depth - 3));\n    return tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(tablePos));\n}\n\nfunction getTargetRowInfo(direction, map, selectionInfo) {\n    var targetRowIdx;\n    var insertColIdx;\n    var nodeSize;\n    if (direction === \"up\" /* UP */) {\n        targetRowIdx = selectionInfo.startRowIdx;\n        insertColIdx = 0;\n        nodeSize = -1;\n    }\n    else {\n        targetRowIdx = selectionInfo.endRowIdx;\n        insertColIdx = map.totalColumnCount - 1;\n        nodeSize = map.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1;\n    }\n    return { targetRowIdx: targetRowIdx, insertColIdx: insertColIdx, nodeSize: nodeSize };\n}\nfunction getRowRanges(map, rowIdx, totalColumnCount) {\n    var startOffset = map.getCellInfo(rowIdx, 0).offset;\n    var _a = map.getCellInfo(rowIdx, totalColumnCount - 1), offset = _a.offset, nodeSize = _a.nodeSize;\n    return { from: startOffset, to: offset + nodeSize };\n}\nvar Table = /** @class */ (function (_super) {\n    __extends$1(Table, _super);\n    function Table() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Table.prototype, \"name\", {\n        get: function () {\n            return 'table';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Table.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableHead{1} tableBody{1}',\n                group: 'block',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('table')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['table', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Table.prototype.addTable = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { rowCount: 2, columnCount: 1, data: [] }; }\n            return function (state, dispatch) {\n                var rowCount = payload.rowCount, columnCount = payload.columnCount, data = payload.data;\n                var schema = state.schema, selection = state.selection, tr = state.tr;\n                var from = selection.from, to = selection.to, $from = selection.$from;\n                var collapsed = from === to;\n                if (collapsed && !isInTableNode($from)) {\n                    var _a = schema.nodes, tableHead = _a.tableHead, tableBody = _a.tableBody;\n                    var theadData = data === null || data === void 0 ? void 0 : data.slice(0, columnCount);\n                    var tbodyData = data === null || data === void 0 ? void 0 : data.slice(columnCount, data.length);\n                    var tableHeadRow = createTableHeadRow(columnCount, schema, theadData);\n                    var tableBodyRows = createTableBodyRows(rowCount - 1, columnCount, schema, tbodyData);\n                    var table = schema.nodes.table.create(null, [\n                        tableHead.create(null, tableHeadRow),\n                        tableBody.create(null, tableBodyRows),\n                    ]);\n                    dispatch(tr.replaceSelectionWith(table));\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.removeTable = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var map = TableOffsetMap.create(selection.$anchor);\n            if (map) {\n                var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;\n                var startOffset = tableStartOffset - 1;\n                var cursorPos = createTextSelection(tr.delete(startOffset, tableEndOffset), startOffset);\n                dispatch(tr.setSelection(cursorPos));\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addColumn = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var targetColIdx = direction === \"left\" /* LEFT */ ? selectionInfo.startColIdx : selectionInfo.endColIdx + 1;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var totalRowCount = map.totalRowCount;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    var cells = createDummyCells(columnCount, rowIdx, schema);\n                    tr.insert(tr.mapping.map(map.posAt(rowIdx, targetColIdx)), cells);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeColumn = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var totalColumnCount = map.totalColumnCount, totalRowCount = map.totalRowCount;\n                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;\n                var selectedAllColumn = columnCount === totalColumnCount;\n                if (selectedAllColumn) {\n                    return false;\n                }\n                var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                var mapStart = tr.mapping.maps.length;\n                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                    for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {\n                        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;\n                        var from = tr.mapping.slice(mapStart).map(offset);\n                        var to = from + nodeSize;\n                        tr.delete(from, to);\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.addRow = function (direction) {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, schema = state.schema, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var _b = getTargetRowInfo(direction, map, selectionInfo), targetRowIdx = _b.targetRowIdx, insertColIdx = _b.insertColIdx, nodeSize = _b.nodeSize;\n                var selectedThead = targetRowIdx === 0;\n                if (!selectedThead) {\n                    var rows = [];\n                    var from = tr.mapping.map(map.posAt(targetRowIdx, insertColIdx)) + nodeSize;\n                    var cells = [];\n                    for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {\n                        cells = cells.concat(createDummyCells(1, targetRowIdx, schema));\n                    }\n                    for (var i = 0; i < rowCount; i += 1) {\n                        rows.push(schema.nodes.tableRow.create(null, cells));\n                    }\n                    dispatch(tr.insert(from, rows));\n                    return true;\n                }\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.removeRow = function () {\n        return function () { return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;\n                var selectionInfo = map.getRectOffsets(anchor, head);\n                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;\n                var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;\n                var selectedThead = startRowIdx === 0;\n                var selectedAllTbodyRow = rowCount === totalRowCount - 1;\n                if (selectedAllTbodyRow || selectedThead) {\n                    return false;\n                }\n                for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {\n                    var _b = getRowRanges(map, rowIdx, totalColumnCount), from = _b.from, to = _b.to;\n                    // delete table row\n                    tr.delete(from - 1, to + 1);\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Table.prototype.alignColumn = function () {\n        return function (payload) {\n            if (payload === void 0) { payload = { align: 'center' }; }\n            return function (state, dispatch) {\n                var align = payload.align;\n                var selection = state.selection, tr = state.tr;\n                var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n                if (anchor && head) {\n                    var map = TableOffsetMap.create(anchor);\n                    var totalRowCount = map.totalRowCount;\n                    var selectionInfo = map.getRectOffsets(anchor, head);\n                    var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;\n                    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {\n                        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                            if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                                var _b = map.getNodeAndPos(rowIdx, colIdx), node = _b.node, pos = _b.pos;\n                                var attrs = setAttrs(node, { align: align });\n                                tr.setNodeMarkup(pos, null, attrs);\n                            }\n                        }\n                    }\n                    dispatch(tr);\n                    return true;\n                }\n                return false;\n            };\n        };\n    };\n    Table.prototype.moveToCell = function (direction) {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            if (anchor && head) {\n                var map = TableOffsetMap.create(anchor);\n                var cellIndex = map.getCellIndex(anchor);\n                var newTr = void 0;\n                if (canBeOutOfTable(direction, map, cellIndex)) {\n                    // When there is no content before or after the table,\n                    // an empty line('paragraph') is created by pressing the arrow keys.\n                    newTr = addParagraphAfterTable(tr, map, schema);\n                }\n                else {\n                    newTr = moveToCell(direction, tr, cellIndex, map);\n                }\n                if (newTr) {\n                    dispatch(newTr);\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.moveInCell = function (direction) {\n        var _this = this;\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, doc = state.doc, schema = state.schema;\n            var $from = selection.$from;\n            var view = _this.context.view;\n            if (!view.endOfTextblock(direction)) {\n                return false;\n            }\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === 'paragraph';\n                });\n                var cellDepth = cell.depth;\n                if (para && canMoveBetweenCells(direction, [cellDepth, para.depth], $from, doc)) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    var cellIndex = map.getCellIndex(anchor);\n                    var newTr = void 0;\n                    if (canSelectTableNode(direction, map, cellIndex)) {\n                        // When the cursor position is at the end of the cell,\n                        // the table is selected when the left / right arrow keys are pressed.\n                        newTr = selectNode(tr, $from, cellDepth);\n                    }\n                    else if (canBeOutOfTable(direction, map, cellIndex)) {\n                        // When there is no content before or after the table,\n                        // an empty line('paragraph') is created by pressing the arrow keys.\n                        if (direction === \"up\" /* UP */) {\n                            newTr = addParagraphBeforeTable(tr, map, schema);\n                        }\n                        else if (direction === \"down\" /* DOWN */) {\n                            newTr = addParagraphAfterTable(tr, map, schema);\n                        }\n                    }\n                    else {\n                        newTr = moveToCell(direction, tr, cellIndex, map);\n                    }\n                    if (newTr) {\n                        dispatch(newTr);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.deleteCells = function () {\n        return function (state, dispatch) {\n            var schema = state.schema, selection = state.selection, tr = state.tr;\n            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;\n            var textSelection = selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n            if (anchor && head && !textSelection) {\n                var map = TableOffsetMap.create(anchor);\n                var _b = map.getRectOffsets(anchor, head), startRowIdx = _b.startRowIdx, startColIdx = _b.startColIdx, endRowIdx = _b.endRowIdx, endColIdx = _b.endColIdx;\n                for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {\n                    for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {\n                        if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {\n                            var _c = map.getNodeAndPos(rowIdx, colIdx), node = _c.node, pos = _c.pos;\n                            var cells = createDummyCells(1, rowIdx, schema, node.attrs);\n                            tr.replaceWith(tr.mapping.map(pos), tr.mapping.map(pos + node.nodeSize), cells);\n                        }\n                    }\n                }\n                dispatch(tr);\n                return true;\n            }\n            return false;\n        };\n    };\n    Table.prototype.exitTable = function () {\n        return function (state, dispatch) {\n            var selection = state.selection, tr = state.tr, schema = state.schema;\n            var $from = selection.$from;\n            var cell = findNodeBy($from, function (_a) {\n                var type = _a.type;\n                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n            });\n            if (cell) {\n                var para = findNodeBy($from, function (_a) {\n                    var type = _a.type;\n                    return type.name === 'paragraph';\n                });\n                if (para) {\n                    var anchor = getResolvedSelection(selection).anchor;\n                    var map = TableOffsetMap.create(anchor);\n                    dispatch(addParagraphAfterTable(tr, map, schema, true));\n                    return true;\n                }\n            }\n            return false;\n        };\n    };\n    Table.prototype.commands = function () {\n        return {\n            addTable: this.addTable(),\n            removeTable: this.removeTable(),\n            addColumnToLeft: this.addColumn(\"left\" /* LEFT */),\n            addColumnToRight: this.addColumn(\"right\" /* RIGHT */),\n            removeColumn: this.removeColumn(),\n            addRowToUp: this.addRow(\"up\" /* UP */),\n            addRowToDown: this.addRow(\"down\" /* DOWN */),\n            removeRow: this.removeRow(),\n            alignColumn: this.alignColumn(),\n        };\n    };\n    Table.prototype.keymaps = function () {\n        var deleteCellContent = this.deleteCells();\n        return {\n            Tab: this.moveToCell(\"right\" /* RIGHT */),\n            'Shift-Tab': this.moveToCell(\"left\" /* LEFT */),\n            ArrowUp: this.moveInCell(\"up\" /* UP */),\n            ArrowDown: this.moveInCell(\"down\" /* DOWN */),\n            ArrowLeft: this.moveInCell(\"left\" /* LEFT */),\n            ArrowRight: this.moveInCell(\"right\" /* RIGHT */),\n            Backspace: deleteCellContent,\n            'Mod-Backspace': deleteCellContent,\n            Delete: deleteCellContent,\n            'Mod-Delete': deleteCellContent,\n            'Mod-Enter': this.exitTable(),\n        };\n    };\n    return Table;\n}(Node$2));\n\nvar TableHead = /** @class */ (function (_super) {\n    __extends$1(TableHead, _super);\n    function TableHead() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHead.prototype, \"name\", {\n        get: function () {\n            return 'tableHead';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHead.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableRow{1}',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [createDOMInfoParsedRawHTML('thead')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['thead', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHead;\n}(Node$2));\n\nvar TableBody = /** @class */ (function (_super) {\n    __extends$1(TableBody, _super);\n    function TableBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBody.prototype, \"name\", {\n        get: function () {\n            return 'tableBody';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBody.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'tableRow+',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'tbody',\n                        getAttrs: function (dom) {\n                            var rows = dom.querySelectorAll('tr');\n                            var columns = rows[0].children.length;\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['tbody', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBody;\n}(Node$2));\n\nvar TableRow = /** @class */ (function (_super) {\n    __extends$1(TableRow, _super);\n    function TableRow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableRow.prototype, \"name\", {\n        get: function () {\n            return 'tableRow';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableRow.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: '(tableHeadCell | tableBodyCell)*',\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'tr',\n                        getAttrs: function (dom) {\n                            var columns = dom.children.length;\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            if (!columns) {\n                                return false;\n                            }\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['tr', getCustomAttrs(attrs), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableRow;\n}(Node$2));\n\nvar TableHeadCell = /** @class */ (function (_super) {\n    __extends$1(TableHeadCell, _super);\n    function TableHeadCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableHeadCell.prototype, \"name\", {\n        get: function () {\n            return 'tableHeadCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableHeadCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'paragraph+',\n                attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),\n                isolating: true,\n                parseDOM: [createParsedCellDOM('th')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return ['th', __assign$1(__assign$1({}, cellAttrs), getCustomAttrs(attrs)), 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableHeadCell;\n}(Node$2));\n\nvar TableBodyCell = /** @class */ (function (_super) {\n    __extends$1(TableBodyCell, _super);\n    function TableBodyCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TableBodyCell.prototype, \"name\", {\n        get: function () {\n            return 'tableBodyCell';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableBodyCell.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: '(paragraph | bulletList | orderedList)+',\n                attrs: {\n                    align: { default: null },\n                    className: { default: null },\n                    rawHTML: { default: null },\n                    colspan: { default: null },\n                    rowspan: { default: null },\n                    extended: { default: null },\n                },\n                isolating: true,\n                parseDOM: [createParsedCellDOM('td')],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    var cellAttrs = createCellAttrs(attrs);\n                    return ['td', cellAttrs, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TableBodyCell;\n}(Node$2));\n\nvar Image = /** @class */ (function (_super) {\n    __extends$1(Image, _super);\n    function Image() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Image.prototype, \"name\", {\n        get: function () {\n            return 'image';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Image.prototype, \"schema\", {\n        get: function () {\n            return {\n                inline: true,\n                attrs: __assign$1({ imageUrl: { default: '' }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: 'inline',\n                selectable: false,\n                parseDOM: [\n                    {\n                        tag: 'img[src]',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var imageUrl = sanitizedDOM.getAttribute('src') || '';\n                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');\n                            var altText = sanitizedDOM.getAttribute('alt');\n                            return __assign$1({ imageUrl: imageUrl,\n                                altText: altText }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'img',\n                        __assign$1(__assign$1({ src: escapeXml$1(attrs.imageUrl) }, (attrs.altText && { alt: attrs.altText })), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Image.prototype.addImage = function () {\n        return function (payload) { return function (_a, dispatch) {\n            var schema = _a.schema, tr = _a.tr;\n            var _b = payload, imageUrl = _b.imageUrl, altText = _b.altText;\n            if (!imageUrl) {\n                return false;\n            }\n            var node = schema.nodes.image.createAndFill(__assign$1({ imageUrl: imageUrl }, (altText && { altText: altText })));\n            dispatch(tr.replaceSelectionWith(node).scrollIntoView());\n            return true;\n        }; };\n    };\n    Image.prototype.commands = function () {\n        return {\n            addImage: this.addImage(),\n        };\n    };\n    return Image;\n}(Node$2));\n\nvar ROOT_BLOCK_DEPTH = 1;\nvar ThematicBreak = /** @class */ (function (_super) {\n    __extends$1(ThematicBreak, _super);\n    function ThematicBreak() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(ThematicBreak.prototype, \"name\", {\n        get: function () {\n            return 'thematicBreak';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ThematicBreak.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                group: 'block',\n                parseDOM: [{ tag: 'hr' }],\n                selectable: false,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['div', getCustomAttrs(attrs), [attrs.rawHTML || 'hr']];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ThematicBreak.prototype.hr = function () {\n        var _this = this;\n        return function () { return function (state, dispatch) {\n            var _a;\n            var _b = state.selection, $from = _b.$from, $to = _b.$to;\n            if ($from === $to) {\n                var doc = state.doc;\n                var _c = state.schema.nodes, thematicBreak = _c.thematicBreak, paragraph = _c.paragraph;\n                var nodes = [thematicBreak.create()];\n                var rootBlock = $from.node(ROOT_BLOCK_DEPTH);\n                var lastBlock = doc.child(doc.childCount - 1) === rootBlock;\n                var blockEnd = doc.resolve($from.after(ROOT_BLOCK_DEPTH));\n                var nextHr = ((_a = $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.type.name) === _this.name;\n                if (lastBlock || nextHr) {\n                    nodes.push(paragraph.create());\n                }\n                dispatch(state.tr.insert(blockEnd.pos, nodes).scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    ThematicBreak.prototype.commands = function () {\n        return { hr: this.hr() };\n    };\n    ThematicBreak.prototype.keymaps = function () {\n        var hrCommand = this.hr()();\n        return {\n            'Mod-l': hrCommand,\n            'Mod-L': hrCommand,\n        };\n    };\n    return ThematicBreak;\n}(Node$2));\n\nvar Strong = /** @class */ (function (_super) {\n    __extends$1(Strong, _super);\n    function Strong() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strong.prototype, \"name\", {\n        get: function () {\n            return 'strong';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strong.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['b', 'strong'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'strong', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strong.prototype.bold = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strong)(state, dispatch); }; };\n    };\n    Strong.prototype.commands = function () {\n        return { bold: this.bold() };\n    };\n    Strong.prototype.keymaps = function () {\n        var boldCommand = this.bold()();\n        return {\n            'Mod-b': boldCommand,\n            'Mod-B': boldCommand,\n        };\n    };\n    return Strong;\n}(Mark));\n\nvar Emph = /** @class */ (function (_super) {\n    __extends$1(Emph, _super);\n    function Emph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Emph.prototype, \"name\", {\n        get: function () {\n            return 'emph';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Emph.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['i', 'em'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'em', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Emph.prototype.italic = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.emph)(state, dispatch); }; };\n    };\n    Emph.prototype.commands = function () {\n        return { italic: this.italic() };\n    };\n    Emph.prototype.keymaps = function () {\n        var italicCommand = this.italic()();\n        return {\n            'Mod-i': italicCommand,\n            'Mod-I': italicCommand,\n        };\n    };\n    return Emph;\n}(Mark));\n\nvar Strike = /** @class */ (function (_super) {\n    __extends$1(Strike, _super);\n    function Strike() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Strike.prototype, \"name\", {\n        get: function () {\n            return 'strike';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Strike.prototype, \"schema\", {\n        get: function () {\n            var parseDOM = ['s', 'del'].map(function (tag) {\n                return {\n                    tag: tag,\n                    getAttrs: function (dom) {\n                        var rawHTML = dom.getAttribute('data-raw-html');\n                        return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                    },\n                };\n            });\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: parseDOM,\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'del', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Strike.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.strike)(state, dispatch); }; };\n    };\n    Strike.prototype.keymaps = function () {\n        var strikeCommand = this.commands()();\n        return {\n            'Mod-s': strikeCommand,\n            'Mod-S': strikeCommand,\n        };\n    };\n    return Strike;\n}(Mark));\n\nvar Link = /** @class */ (function (_super) {\n    __extends$1(Link, _super);\n    function Link(linkAttributes) {\n        var _this = _super.call(this) || this;\n        _this.linkAttributes = linkAttributes;\n        return _this;\n    }\n    Object.defineProperty(Link.prototype, \"name\", {\n        get: function () {\n            return 'link';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Link.prototype, \"schema\", {\n        get: function () {\n            var _this = this;\n            return {\n                attrs: __assign$1({ linkUrl: { default: '' }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                inclusive: false,\n                parseDOM: [\n                    {\n                        tag: 'a[href]',\n                        getAttrs: function (dom) {\n                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })\n                                .firstChild;\n                            var href = sanitizedDOM.getAttribute('href') || '';\n                            var title = sanitizedDOM.getAttribute('title') || '';\n                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');\n                            return __assign$1({ linkUrl: href, title: title }, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [\n                        attrs.rawHTML || 'a',\n                        __assign$1(__assign$1({ href: escapeXml$1(attrs.linkUrl) }, _this.linkAttributes), getCustomAttrs(attrs)),\n                    ];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Link.prototype.addLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            var _a = payload, linkUrl = _a.linkUrl, _b = _a.linkText, linkText = _b === void 0 ? '' : _b;\n            var schema = state.schema, tr = state.tr, selection = state.selection;\n            var empty = selection.empty, from = selection.from, to = selection.to;\n            if (from && to && linkUrl) {\n                var attrs = { linkUrl: linkUrl };\n                var mark = schema.mark('link', attrs);\n                if (empty && linkText) {\n                    var node = createTextNode$1(schema, linkText, mark);\n                    tr.replaceRangeWith(from, to, node);\n                }\n                else {\n                    tr.addMark(from, to, mark);\n                }\n                dispatch(tr.scrollIntoView());\n                return true;\n            }\n            return false;\n        }; };\n    };\n    Link.prototype.toggleLink = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.link, payload)(state, dispatch);\n        }; };\n    };\n    Link.prototype.commands = function () {\n        return {\n            addLink: this.addLink(),\n            toggleLink: this.toggleLink(),\n        };\n    };\n    return Link;\n}(Mark));\n\nvar Code = /** @class */ (function (_super) {\n    __extends$1(Code, _super);\n    function Code() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(Code.prototype, \"name\", {\n        get: function () {\n            return 'code';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Code.prototype, \"schema\", {\n        get: function () {\n            return {\n                attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),\n                parseDOM: [\n                    {\n                        tag: 'code',\n                        getAttrs: function (dom) {\n                            var rawHTML = dom.getAttribute('data-raw-html');\n                            return __assign$1({}, (rawHTML && { rawHTML: rawHTML }));\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return [attrs.rawHTML || 'code', getCustomAttrs(attrs)];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Code.prototype.commands = function () {\n        return function () { return function (state, dispatch) { return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.toggleMark)(state.schema.marks.code)(state, dispatch); }; };\n    };\n    Code.prototype.keymaps = function () {\n        var codeCommand = this.commands()();\n        return {\n            'Shift-Mod-c': codeCommand,\n            'Shift-Mod-C': codeCommand,\n        };\n    };\n    return Code;\n}(Mark));\n\nvar CustomBlock = /** @class */ (function (_super) {\n    __extends$1(CustomBlock, _super);\n    function CustomBlock() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(CustomBlock.prototype, \"name\", {\n        get: function () {\n            return 'customBlock';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CustomBlock.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                attrs: {\n                    info: { default: null },\n                },\n                atom: true,\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        tag: 'div[data-custom-info]',\n                        getAttrs: function (dom) {\n                            var info = dom.getAttribute('data-custom-info');\n                            return { info: info };\n                        },\n                    },\n                ],\n                toDOM: function (_a) {\n                    var attrs = _a.attrs;\n                    return ['div', { 'data-custom-info': attrs.info || null }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    CustomBlock.prototype.commands = function () {\n        return function (payload) { return function (state, dispatch) {\n            return (payload === null || payload === void 0 ? void 0 : payload.info)\n                ? (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.setBlockType)(state.schema.nodes.customBlock, payload)(state, dispatch)\n                : false;\n        }; };\n    };\n    return CustomBlock;\n}(Node$2));\n\nvar FrontMatter = /** @class */ (function (_super) {\n    __extends$1(FrontMatter, _super);\n    function FrontMatter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(FrontMatter.prototype, \"name\", {\n        get: function () {\n            return 'frontMatter';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FrontMatter.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                code: true,\n                defining: true,\n                parseDOM: [\n                    {\n                        preserveWhitespace: 'full',\n                        tag: 'div[data-front-matter]',\n                    },\n                ],\n                toDOM: function () {\n                    return ['div', { 'data-front-matter': 'true' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FrontMatter.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock('down') && $from.node().type.name === 'frontMatter') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    FrontMatter.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return FrontMatter;\n}(Node$2));\n\nvar HTMLComment = /** @class */ (function (_super) {\n    __extends$1(HTMLComment, _super);\n    function HTMLComment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(HTMLComment.prototype, \"name\", {\n        get: function () {\n            return 'htmlComment';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(HTMLComment.prototype, \"schema\", {\n        get: function () {\n            return {\n                content: 'text*',\n                group: 'block',\n                code: true,\n                defining: true,\n                parseDOM: [{ preserveWhitespace: 'full', tag: 'div[data-html-comment]' }],\n                toDOM: function () {\n                    return ['div', { 'data-html-comment': 'true' }, 0];\n                },\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    HTMLComment.prototype.commands = function () {\n        return function () { return function (state, dispatch, view) {\n            var $from = state.selection.$from;\n            if (view.endOfTextblock('down') && $from.node().type.name === 'htmlComment') {\n                return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_2__.exitCode)(state, dispatch);\n            }\n            return false;\n        }; };\n    };\n    HTMLComment.prototype.keymaps = function () {\n        return {\n            Enter: this.commands()(),\n        };\n    };\n    return HTMLComment;\n}(Node$2));\n\nfunction createSpecs(linkAttributes) {\n    return new SpecManager([\n        new Doc(),\n        new Paragraph(),\n        new Text(),\n        new Heading(),\n        new CodeBlock(),\n        new BulletList(),\n        new OrderedList(),\n        new ListItem(),\n        new BlockQuote(),\n        new Table(),\n        new TableHead(),\n        new TableBody(),\n        new TableRow(),\n        new TableHeadCell(),\n        new TableBodyCell(),\n        new Image(),\n        new ThematicBreak(),\n        new Strong(),\n        new Emph(),\n        new Strike(),\n        new Link(linkAttributes),\n        new Code(),\n        new CustomBlock(),\n        new FrontMatter(),\n        new Widget(),\n        new HTMLComment(),\n    ]);\n}\n\nvar CONTENTS_CLASS_NAME = cls('contents');\nvar WysiwygEditor = /** @class */ (function (_super) {\n    __extends$1(WysiwygEditor, _super);\n    function WysiwygEditor(eventEmitter, options) {\n        var _this = _super.call(this, eventEmitter) || this;\n        var toDOMAdaptor = options.toDOMAdaptor, _a = options.htmlSchemaMap, htmlSchemaMap = _a === void 0 ? {} : _a, _b = options.linkAttributes, linkAttributes = _b === void 0 ? {} : _b, _c = options.useCommandShortcut, useCommandShortcut = _c === void 0 ? true : _c, _d = options.wwPlugins, wwPlugins = _d === void 0 ? [] : _d, _e = options.wwNodeViews, wwNodeViews = _e === void 0 ? {} : _e;\n        _this.editorType = 'wysiwyg';\n        _this.el.classList.add('ww-mode');\n        _this.toDOMAdaptor = toDOMAdaptor;\n        _this.linkAttributes = linkAttributes;\n        _this.extraPlugins = wwPlugins;\n        _this.pluginNodeViews = wwNodeViews;\n        _this.specs = _this.createSpecs();\n        _this.schema = _this.createSchema(htmlSchemaMap);\n        _this.context = _this.createContext();\n        _this.keymaps = _this.createKeymaps(useCommandShortcut);\n        _this.view = _this.createView();\n        _this.commands = _this.createCommands();\n        _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));\n        _this.initEvent();\n        return _this;\n    }\n    WysiwygEditor.prototype.createSpecs = function () {\n        return createSpecs(this.linkAttributes);\n    };\n    WysiwygEditor.prototype.createContext = function () {\n        return {\n            schema: this.schema,\n            eventEmitter: this.eventEmitter,\n        };\n    };\n    WysiwygEditor.prototype.createSchema = function (htmlSchemaMap) {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Schema({\n            nodes: __assign$1(__assign$1({}, this.specs.nodes), htmlSchemaMap.nodes),\n            marks: __assign$1(__assign$1({}, this.specs.marks), htmlSchemaMap.marks),\n        });\n    };\n    WysiwygEditor.prototype.createPlugins = function () {\n        return __spreadArray$1([\n            tableSelection(),\n            tableContextMenu(this.eventEmitter),\n            task(),\n            toolbarStateHighlight(this.eventEmitter)\n        ], this.createPluginProps()).concat(this.defaultPlugins);\n    };\n    WysiwygEditor.prototype.createPluginNodeViews = function () {\n        var _a = this, eventEmitter = _a.eventEmitter, pluginNodeViews = _a.pluginNodeViews;\n        var pluginNodeViewMap = {};\n        if (pluginNodeViews) {\n            Object.keys(pluginNodeViews).forEach(function (key) {\n                pluginNodeViewMap[key] = function (node, view, getPos) {\n                    return pluginNodeViews[key](node, view, getPos, eventEmitter);\n                };\n            });\n        }\n        return pluginNodeViewMap;\n    };\n    WysiwygEditor.prototype.createView = function () {\n        var _this = this;\n        var _a = this, toDOMAdaptor = _a.toDOMAdaptor, eventEmitter = _a.eventEmitter;\n        return new prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView(this.el, {\n            state: this.createState(),\n            attributes: {\n                class: CONTENTS_CLASS_NAME,\n            },\n            nodeViews: __assign$1({ customBlock: function (node, view, getPos) {\n                    return new CustomBlockView(node, view, getPos, toDOMAdaptor);\n                },\n                image: function (node, view, getPos) {\n                    return new ImageView(node, view, getPos, eventEmitter);\n                },\n                codeBlock: function (node, view, getPos) {\n                    return new CodeBlockView(node, view, getPos, eventEmitter);\n                }, widget: widgetNodeView }, this.createPluginNodeViews()),\n            dispatchTransaction: function (tr) {\n                var state = _this.view.state.applyTransaction(tr).state;\n                _this.view.updateState(state);\n                _this.emitChangeEvent(tr.scrollIntoView());\n                _this.eventEmitter.emit('setFocusedNode', state.selection.$from.node(1));\n            },\n            transformPastedHTML: changePastedHTML,\n            transformPasted: function (slice) {\n                return changePastedSlice(slice, _this.schema, isInTableNode(_this.view.state.selection.$from));\n            },\n            handlePaste: function (view, _, slice) { return pasteToTable(view, slice); },\n            handleKeyDown: function (_, ev) {\n                _this.eventEmitter.emit('keydown', _this.editorType, ev);\n                return false;\n            },\n            handleDOMEvents: {\n                paste: function (_, ev) {\n                    var clipboardData = ev.clipboardData || window.clipboardData;\n                    var items = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.items;\n                    if (items) {\n                        var containRtfItem = toArray_1(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });\n                        // if it contains rtf, it's most likely copy paste from office -> no image\n                        if (!containRtfItem) {\n                            var imageBlob = pasteImageOnly(items);\n                            if (imageBlob) {\n                                ev.preventDefault();\n                                emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);\n                            }\n                        }\n                    }\n                    return false;\n                },\n                keyup: function (_, ev) {\n                    _this.eventEmitter.emit('keyup', _this.editorType, ev);\n                    return false;\n                },\n                scroll: function () {\n                    _this.eventEmitter.emit('scroll', 'editor');\n                    return true;\n                },\n            },\n        });\n    };\n    WysiwygEditor.prototype.createCommands = function () {\n        return this.specs.commands(this.view, getWwCommands());\n    };\n    WysiwygEditor.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.view.dom.innerHTML);\n    };\n    WysiwygEditor.prototype.getModel = function () {\n        return this.view.state.doc;\n    };\n    WysiwygEditor.prototype.getSelection = function () {\n        var _a = this.view.state.selection, from = _a.from, to = _a.to;\n        return [from, to];\n    };\n    WysiwygEditor.prototype.getSchema = function () {\n        return this.view.state.schema;\n    };\n    WysiwygEditor.prototype.replaceSelection = function (text, start, end) {\n        var _a = this.view.state, schema = _a.schema, tr = _a.tr;\n        var lineTexts = text.split('\\n');\n        var paras = lineTexts.map(function (lineText) {\n            return createParagraph(schema, createNodesWithWidget(lineText, schema));\n        });\n        var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(paras), 1, 1);\n        var newTr = isNumber_1(start) && isNumber_1(end)\n            ? tr.replaceRange(start, end, slice)\n            : tr.replaceSelection(slice);\n        this.view.dispatch(newTr);\n        this.focus();\n    };\n    WysiwygEditor.prototype.deleteSelection = function (start, end) {\n        var tr = this.view.state.tr;\n        var newTr = isNumber_1(start) && isNumber_1(end) ? tr.deleteRange(start, end) : tr.deleteSelection();\n        this.view.dispatch(newTr.scrollIntoView());\n    };\n    WysiwygEditor.prototype.getSelectedText = function (start, end) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var from = selection.from, to = selection.to;\n        if (isNumber_1(start) && isNumber_1(end)) {\n            from = start;\n            to = end;\n        }\n        return doc.textBetween(from, to, '\\n');\n    };\n    WysiwygEditor.prototype.setModel = function (newDoc, cursorToEnd) {\n        if (cursorToEnd === void 0) { cursorToEnd = false; }\n        var _a = this.view.state, tr = _a.tr, doc = _a.doc;\n        this.view.dispatch(tr.replaceWith(0, doc.content.size, newDoc));\n        if (cursorToEnd) {\n            this.moveCursorToEnd(true);\n        }\n    };\n    WysiwygEditor.prototype.setSelection = function (start, end) {\n        if (end === void 0) { end = start; }\n        var tr = this.view.state.tr;\n        var selection = createTextSelection(tr, start, end);\n        this.view.dispatch(tr.setSelection(selection).scrollIntoView());\n    };\n    WysiwygEditor.prototype.addWidget = function (node, style, pos) {\n        var _a = this.view, dispatch = _a.dispatch, state = _a.state;\n        dispatch(state.tr.setMeta('widget', { pos: pos !== null && pos !== void 0 ? pos : state.selection.to, node: node, style: style }));\n    };\n    WysiwygEditor.prototype.replaceWithWidget = function (start, end, text) {\n        var _a = this.view.state, tr = _a.tr, schema = _a.schema;\n        var nodes = createNodesWithWidget(text, schema);\n        this.view.dispatch(tr.replaceWith(start, end, nodes));\n    };\n    WysiwygEditor.prototype.getRangeInfoOfNode = function (pos) {\n        var _a = this.view.state, doc = _a.doc, selection = _a.selection;\n        var $pos = pos ? doc.resolve(pos) : selection.$from;\n        var marks = $pos.marks();\n        var node = $pos.node();\n        var start = $pos.start();\n        var end = $pos.end();\n        var type = node.type.name;\n        if (marks.length || type === 'paragraph') {\n            var mark_1 = marks[marks.length - 1];\n            var maybeHasMark_1 = function (nodeMarks) {\n                return nodeMarks.length ? includes(nodeMarks, mark_1) : true;\n            };\n            type = mark_1 ? mark_1.type.name : 'text';\n            node.forEach(function (child, offset) {\n                var isText = child.isText, nodeSize = child.nodeSize, nodeMarks = child.marks;\n                var startOffset = $pos.pos - start;\n                if (isText &&\n                    offset <= startOffset &&\n                    offset + nodeSize >= startOffset &&\n                    maybeHasMark_1(nodeMarks)) {\n                    start = start + offset;\n                    end = start + nodeSize;\n                }\n            });\n        }\n        return { range: [start, end], type: type };\n    };\n    return WysiwygEditor;\n}(EditorBase));\n\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isUndefined = isUndefined_1;\nvar isNull = isNull_1;\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from 'tui-code-snippet/type/isExisty');\n * \n * // CommonJS\n * const isExisty = require('tui-code-snippet/type/isExisty');\n *\n * isExisty(''); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty$1(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nvar isExisty_1 = isExisty$1;\n\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isExisty = isExisty_1;\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy$1(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nvar isTruthy_1 = isTruthy$1;\n\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\nvar isTruthy = isTruthy_1;\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nvar isFalsy_1 = isFalsy;\n\nvar eventTypeList = [\n    'afterPreviewRender',\n    'updatePreview',\n    'changeMode',\n    'needChangeMode',\n    'command',\n    'changePreviewStyle',\n    'changePreviewTabPreview',\n    'changePreviewTabWrite',\n    'scroll',\n    'contextmenu',\n    'show',\n    'hide',\n    'changeLanguage',\n    'changeToolbarState',\n    'toggleScrollSync',\n    'mixinTableOffsetMapPrototype',\n    'setFocusedNode',\n    'removePopupWidget',\n    'query',\n    // provide event for user\n    'openPopup',\n    'closePopup',\n    'addImageBlobHook',\n    'beforePreviewRender',\n    'beforeConvertWysiwygToMarkdown',\n    'load',\n    'loadUI',\n    'change',\n    'caretChange',\n    'destroy',\n    'focus',\n    'blur',\n    'keydown',\n    'keyup',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new Map$1();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return __assign$1(__assign$1({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error(\"There is no event type \" + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_1(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray$1([source], args));\n                if (!isFalsy_1(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split('.');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_1(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error(\"There is already have event type \" + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n\nvar CommandManager = /** @class */ (function () {\n    function CommandManager(eventEmitter, mdCommands, wwCommands, getEditorType) {\n        this.eventEmitter = eventEmitter;\n        this.mdCommands = mdCommands;\n        this.wwCommands = wwCommands;\n        this.getEditorType = getEditorType;\n        this.initEvent();\n    }\n    CommandManager.prototype.initEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('command', function (command, payload) {\n            _this.exec(command, payload);\n        });\n    };\n    CommandManager.prototype.addCommand = function (type, name, command) {\n        if (type === 'markdown') {\n            this.mdCommands[name] = command;\n        }\n        else {\n            this.wwCommands[name] = command;\n        }\n    };\n    CommandManager.prototype.deleteCommand = function (type, name) {\n        if (type === 'markdown') {\n            delete this.mdCommands[name];\n        }\n        else {\n            delete this.wwCommands[name];\n        }\n    };\n    CommandManager.prototype.exec = function (name, payload) {\n        var type = this.getEditorType();\n        if (type === 'markdown') {\n            this.mdCommands[name](payload);\n        }\n        else {\n            this.wwCommands[name](payload);\n        }\n    };\n    return CommandManager;\n}());\n\nfunction getTextWithoutTrailingNewline(text) {\n    return text[text.length - 1] === '\\n' ? text.slice(0, text.length - 1) : text;\n}\nfunction isCustomHTMLInlineNode(_a, node) {\n    var schema = _a.schema;\n    var html = node.literal;\n    var matched = html.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        return node.type === 'htmlInline' && !!(schema.marks[typeName] || schema.nodes[typeName]);\n    }\n    return false;\n}\nfunction isInlineNode(_a) {\n    var type = _a.type;\n    return includes(['text', 'strong', 'emph', 'strike', 'image', 'link', 'code'], type);\n}\nfunction isSoftbreak(mdNode) {\n    return (mdNode === null || mdNode === void 0 ? void 0 : mdNode.type) === 'softbreak';\n}\nfunction isListNode(_a) {\n    var type = _a.type, literal = _a.literal;\n    var matched = type === 'htmlInline' && literal.match(reHTMLTag);\n    if (matched) {\n        var openTagName = matched[1], closeTagName = matched[3];\n        var tagName = openTagName || closeTagName;\n        if (tagName) {\n            return includes(['ul', 'ol', 'li'], tagName.toLowerCase());\n        }\n    }\n    return false;\n}\nfunction getListItemAttrs(_a) {\n    var literal = _a.literal;\n    var task = /data-task/.test(literal);\n    var checked = /data-task-checked/.test(literal);\n    return { task: task, checked: checked };\n}\nfunction getMatchedAttributeValue(rawHTML) {\n    var attrNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        attrNames[_i - 1] = arguments[_i];\n    }\n    var wrapper = document.createElement('div');\n    wrapper.innerHTML = sanitizeHTML(rawHTML);\n    var el = wrapper.firstChild;\n    return attrNames.map(function (attrName) { return el.getAttribute(attrName) || ''; });\n}\nfunction createConvertors(convertors) {\n    var convertorMap = {};\n    Object.keys(convertors).forEach(function (key) {\n        var tagNames = key.split(', ');\n        tagNames.forEach(function (tagName) {\n            var name = tagName.toLowerCase();\n            convertorMap[name] = convertors[key];\n        });\n    });\n    return convertorMap;\n}\nvar convertors = {\n    'b, strong': function (state, _, openTagName) {\n        var strong = state.schema.marks.strong;\n        if (openTagName) {\n            state.openMark(strong.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    'i, em': function (state, _, openTagName) {\n        var emph = state.schema.marks.emph;\n        if (openTagName) {\n            state.openMark(emph.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    's, del': function (state, _, openTagName) {\n        var strike = state.schema.marks.strike;\n        if (openTagName) {\n            state.openMark(strike.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, _, openTagName) {\n        var code = state.schema.marks.code;\n        if (openTagName) {\n            state.openMark(code.create({ rawHTML: openTagName }));\n        }\n        else {\n            state.closeMark(code);\n        }\n    },\n    a: function (state, node, openTagName) {\n        var tag = node.literal;\n        var link = state.schema.marks.link;\n        if (openTagName) {\n            var linkUrl = getMatchedAttributeValue(tag, 'href')[0];\n            state.openMark(link.create({\n                linkUrl: linkUrl,\n                rawHTML: openTagName,\n            }));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    img: function (state, node, openTagName) {\n        var tag = node.literal;\n        if (openTagName) {\n            var _a = getMatchedAttributeValue(tag, 'src', 'alt'), imageUrl = _a[0], altText = _a[1];\n            var image = state.schema.nodes.image;\n            state.addNode(image, __assign$1({ rawHTML: openTagName, imageUrl: imageUrl }, (altText && { altText: altText })));\n        }\n    },\n    hr: function (state, _, openTagName) {\n        state.addNode(state.schema.nodes.thematicBreak, { rawHTML: openTagName });\n    },\n    br: function (state, node) {\n        var paragraph = state.schema.nodes.paragraph;\n        var parent = node.parent, prev = node.prev, next = node.next;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'paragraph') {\n            // should open a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(prev)) {\n                state.openNode(paragraph);\n            }\n            // should close a paragraph node when line text has only <br> tag\n            // ex) first line\\n\\n<br>\\nfourth line\n            if (isSoftbreak(next)) {\n                state.closeNode();\n                // should close a paragraph node and open a paragraph node to separate between blocks\n                // when <br> tag is in the middle of the paragraph\n                // ex) first <br>line\\nthird line\n            }\n            else if (next) {\n                state.closeNode();\n                state.openNode(paragraph);\n            }\n        }\n        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'tableCell') {\n            if (prev && (isInlineNode(prev) || isCustomHTMLInlineNode(state, prev))) {\n                state.closeNode();\n            }\n            if (next && (isInlineNode(next) || isCustomHTMLInlineNode(state, next))) {\n                state.openNode(paragraph);\n            }\n        }\n    },\n    pre: function (state, node, openTagName) {\n        var _a, _b;\n        var container = document.createElement('div');\n        container.innerHTML = node.literal;\n        var literal = (_b = (_a = container.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.textContent;\n        state.openNode(state.schema.nodes.codeBlock, { rawHTML: openTagName });\n        state.addText(getTextWithoutTrailingNewline(literal));\n        state.closeNode();\n    },\n    'ul, ol': function (state, node, openTagName) {\n        // in the table cell, '<ul>', '<ol>' is parsed as 'htmlInline' node\n        if (node.parent.type === 'tableCell') {\n            var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, paragraph = _a.paragraph;\n            var list = openTagName === 'ul' ? bulletList : orderedList;\n            if (openTagName) {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(list, { rawHTML: openTagName });\n            }\n            else {\n                state.closeNode();\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n        }\n    },\n    li: function (state, node, openTagName) {\n        var _a;\n        // in the table cell, '<li>' is parsed as 'htmlInline' node\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'tableCell') {\n            var _b = state.schema.nodes, listItem = _b.listItem, paragraph = _b.paragraph;\n            if (openTagName) {\n                var attrs = getListItemAttrs(node);\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.openNode(listItem, __assign$1({ rawHTML: openTagName }, attrs));\n                if (node.next && !isListNode(node.next)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (node.prev && !isListNode(node.prev)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n};\nvar htmlToWwConvertors = createConvertors(convertors);\n\nfunction isBRTag(node) {\n    return node.type === 'htmlInline' && reBR.test(node.literal);\n}\nfunction addRawHTMLAttributeToDOM(parent) {\n    toArray_1(parent.childNodes).forEach(function (child) {\n        if (isElemNode(child)) {\n            var openTagName = child.nodeName.toLowerCase();\n            child.setAttribute('data-raw-html', openTagName);\n            if (child.childNodes) {\n                addRawHTMLAttributeToDOM(child);\n            }\n        }\n    });\n}\nvar toWwConvertors = {\n    text: function (state, node) {\n        state.addText(node.literal || '');\n    },\n    paragraph: function (state, node, _a, customAttrs) {\n        var _b;\n        var entering = _a.entering;\n        if (entering) {\n            var paragraph = state.schema.nodes.paragraph;\n            // The `\\n\\n` entered in markdown separates the paragraph.\n            // When changing to wysiwyg, a newline is added between the two paragraphs.\n            if (((_b = node.prev) === null || _b === void 0 ? void 0 : _b.type) === 'paragraph') {\n                state.openNode(paragraph, customAttrs);\n                state.closeNode();\n            }\n            state.openNode(paragraph, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    heading: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, level = _b.level, headingType = _b.headingType;\n            state.openNode(state.schema.nodes.heading, __assign$1({ level: level, headingType: headingType }, customAttrs));\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    codeBlock: function (state, node, customAttrs) {\n        var codeBlock = state.schema.nodes.codeBlock;\n        var _a = node, info = _a.info, literal = _a.literal;\n        state.openNode(codeBlock, __assign$1({ language: info }, customAttrs));\n        state.addText(getTextWithoutTrailingNewline(literal || ''));\n        state.closeNode();\n    },\n    list: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = state.schema.nodes, bulletList = _b.bulletList, orderedList = _b.orderedList;\n            var _c = node.listData, type = _c.type, start = _c.start;\n            if (type === 'bullet') {\n                state.openNode(bulletList, customAttrs);\n            }\n            else {\n                state.openNode(orderedList, __assign$1({ order: start }, customAttrs));\n            }\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    item: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var listItem = state.schema.nodes.listItem;\n        var _b = node.listData, task = _b.task, checked = _b.checked;\n        if (entering) {\n            var attrs = __assign$1(__assign$1(__assign$1({}, (task && { task: task })), (checked && { checked: checked })), customAttrs);\n            state.openNode(listItem, attrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    blockQuote: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.blockQuote, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    image: function (state, node, _a, customAttrs) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var image = state.schema.nodes.image;\n        var _b = node, destination = _b.destination, firstChild = _b.firstChild;\n        if (entering && skipChildren) {\n            skipChildren();\n        }\n        state.addNode(image, __assign$1(__assign$1({ imageUrl: destination }, (firstChild && { altText: firstChild.literal })), customAttrs));\n    },\n    thematicBreak: function (state, node, _, customAttrs) {\n        state.addNode(state.schema.nodes.thematicBreak, customAttrs);\n    },\n    strong: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strong = state.schema.marks.strong;\n        if (entering) {\n            state.openMark(strong.create(customAttrs));\n        }\n        else {\n            state.closeMark(strong);\n        }\n    },\n    emph: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var emph = state.schema.marks.emph;\n        if (entering) {\n            state.openMark(emph.create(customAttrs));\n        }\n        else {\n            state.closeMark(emph);\n        }\n    },\n    link: function (state, node, _a, customAttrs) {\n        var entering = _a.entering;\n        var link = state.schema.marks.link;\n        var _b = node, destination = _b.destination, title = _b.title;\n        if (entering) {\n            var attrs = __assign$1({ linkUrl: destination, title: title }, customAttrs);\n            state.openMark(link.create(attrs));\n        }\n        else {\n            state.closeMark(link);\n        }\n    },\n    softbreak: function (state, node) {\n        if (node.parent.type === 'paragraph') {\n            var prev = node.prev, next = node.next;\n            if (prev && !isBRTag(prev)) {\n                state.closeNode();\n            }\n            if (next && !isBRTag(next)) {\n                state.openNode(state.schema.nodes.paragraph);\n            }\n        }\n    },\n    // GFM specifications node\n    table: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.table, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableHead: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableHead, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableBody: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableBody, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableRow: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        if (entering) {\n            state.openNode(state.schema.nodes.tableRow, customAttrs);\n        }\n        else {\n            state.closeNode();\n        }\n    },\n    tableCell: function (state, node, _a) {\n        var entering = _a.entering;\n        if (!node.ignored) {\n            var hasParaNode = function (childNode) {\n                return childNode && (isInlineNode(childNode) || isCustomHTMLInlineNode(state, childNode));\n            };\n            if (entering) {\n                var _b = state.schema.nodes, tableHeadCell = _b.tableHeadCell, tableBodyCell = _b.tableBodyCell, paragraph = _b.paragraph;\n                var tablePart = node.parent.parent;\n                var cell = tablePart.type === 'tableHead' ? tableHeadCell : tableBodyCell;\n                var table = tablePart.parent;\n                var align = (table.columns[node.startIdx] || {}).align;\n                var attrs = __assign$1({}, node.attrs);\n                if (align) {\n                    attrs.align = align;\n                }\n                state.openNode(cell, attrs);\n                if (hasParaNode(node.firstChild)) {\n                    state.openNode(paragraph);\n                }\n            }\n            else {\n                if (hasParaNode(node.lastChild)) {\n                    state.closeNode();\n                }\n                state.closeNode();\n            }\n        }\n    },\n    strike: function (state, _, _a, customAttrs) {\n        var entering = _a.entering;\n        var strike = state.schema.marks.strike;\n        if (entering) {\n            state.openMark(strike.create(customAttrs));\n        }\n        else {\n            state.closeMark(strike);\n        }\n    },\n    code: function (state, node, _, customAttrs) {\n        var code = state.schema.marks.code;\n        state.openMark(code.create(customAttrs));\n        state.addText(getTextWithoutTrailingNewline(node.literal || ''));\n        state.closeMark(code);\n    },\n    customBlock: function (state, node) {\n        var _a = state.schema.nodes, customBlock = _a.customBlock, paragraph = _a.paragraph;\n        var _b = node, info = _b.info, literal = _b.literal;\n        state.openNode(customBlock, { info: info });\n        state.addText(getTextWithoutTrailingNewline(literal || ''));\n        state.closeNode();\n        // add empty line to edit the content in next line\n        if (!node.next) {\n            state.openNode(paragraph);\n            state.closeNode();\n        }\n    },\n    frontMatter: function (state, node) {\n        state.openNode(state.schema.nodes.frontMatter);\n        state.addText(node.literal);\n        state.closeNode();\n    },\n    htmlInline: function (state, node) {\n        var html = node.literal;\n        var matched = html.match(reHTMLTag);\n        var openTagName = matched[1], closeTagName = matched[3];\n        var typeName = (openTagName || closeTagName).toLowerCase();\n        var markType = state.schema.marks[typeName];\n        var sanitizedHTML = sanitizeHTML(html);\n        // for user defined html schema\n        if (markType === null || markType === void 0 ? void 0 : markType.spec.attrs.htmlInline) {\n            if (openTagName) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                state.openMark(markType.create({ htmlAttrs: htmlAttrs }));\n            }\n            else {\n                state.closeMark(markType);\n            }\n        }\n        else {\n            var htmlToWwConvertor = htmlToWwConvertors[typeName];\n            if (htmlToWwConvertor) {\n                htmlToWwConvertor(state, node, openTagName);\n            }\n        }\n    },\n    htmlBlock: function (state, node) {\n        var html = node.literal;\n        var container = document.createElement('div');\n        var isHTMLComment = reHTMLComment.test(html);\n        if (isHTMLComment) {\n            state.openNode(state.schema.nodes.htmlComment);\n            state.addText(node.literal);\n            state.closeNode();\n        }\n        else {\n            var matched = html.match(reHTMLTag);\n            var openTagName = matched[1], closeTagName = matched[3];\n            var typeName = (openTagName || closeTagName).toLowerCase();\n            var nodeType = state.schema.nodes[typeName];\n            var sanitizedHTML = sanitizeHTML(html);\n            // for user defined html schema\n            if (nodeType === null || nodeType === void 0 ? void 0 : nodeType.spec.attrs.htmlBlock) {\n                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);\n                var childrenHTML = getChildrenHTML(node, typeName);\n                state.addNode(nodeType, { htmlAttrs: htmlAttrs, childrenHTML: childrenHTML });\n            }\n            else {\n                container.innerHTML = sanitizedHTML;\n                addRawHTMLAttributeToDOM(container);\n                state.convertByDOMParser(container);\n            }\n        }\n    },\n    customInline: function (state, node, _a) {\n        var entering = _a.entering, skipChildren = _a.skipChildren;\n        var _b = node, info = _b.info, firstChild = _b.firstChild;\n        var schema = state.schema;\n        if (info.indexOf('widget') !== -1 && entering) {\n            var content = getWidgetContent(node);\n            skipChildren();\n            state.addNode(schema.nodes.widget, { info: info }, [\n                schema.text(createWidgetContent(info, content)),\n            ]);\n        }\n        else {\n            var text = '$$';\n            if (entering) {\n                text += firstChild ? info + \" \" : info;\n            }\n            state.addText(text);\n        }\n    },\n};\nfunction createWwConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    var convertors = __assign$1({}, toWwConvertors);\n    var renderer = new Renderer({\n        gfm: true,\n        nodeId: true,\n        convertors: customConvertors,\n    });\n    var orgConvertors = renderer.getConvertors();\n    customConvertorTypes.forEach(function (type) {\n        var wwConvertor = toWwConvertors[type];\n        if (wwConvertor && !includes(['htmlBlock', 'htmlInline'], type)) {\n            convertors[type] = function (state, node, context) {\n                context.origin = function () { return orgConvertors[type](node, context, orgConvertors); };\n                var tokens = customConvertors[type](node, context);\n                var attrs;\n                if (tokens) {\n                    var _a = Array.isArray(tokens) ? tokens[0] : tokens, htmlAttrs = _a.attributes, classNames = _a.classNames;\n                    attrs = { htmlAttrs: htmlAttrs, classNames: classNames };\n                }\n                wwConvertor(state, node, context, attrs);\n            };\n        }\n    });\n    return convertors;\n}\n\nfunction mergeMarkText(a, b) {\n    if (a.isText && b.isText && prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.sameSet(a.marks, b.marks)) {\n        // @ts-ignore\n        // type is not defined for \"withText\" in prosemirror-model\n        return a.withText(a.text + b.text);\n    }\n    return false;\n}\nvar ToWwConvertorState = /** @class */ (function () {\n    function ToWwConvertorState(schema, convertors) {\n        this.schema = schema;\n        this.convertors = convertors;\n        this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }];\n        this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n    }\n    ToWwConvertorState.prototype.top = function () {\n        return last$1(this.stack);\n    };\n    ToWwConvertorState.prototype.push = function (node) {\n        if (this.stack.length) {\n            this.top().content.push(node);\n        }\n    };\n    ToWwConvertorState.prototype.addText = function (text) {\n        if (text) {\n            var nodes = this.top().content;\n            var lastNode = last$1(nodes);\n            var node = this.schema.text(text, this.marks);\n            var merged = lastNode && mergeMarkText(lastNode, node);\n            if (merged) {\n                nodes[nodes.length - 1] = merged;\n            }\n            else {\n                nodes.push(node);\n            }\n        }\n    };\n    ToWwConvertorState.prototype.openMark = function (mark) {\n        this.marks = mark.addToSet(this.marks);\n    };\n    ToWwConvertorState.prototype.closeMark = function (mark) {\n        this.marks = mark.removeFromSet(this.marks);\n    };\n    ToWwConvertorState.prototype.addNode = function (type, attrs, content) {\n        var node = type.createAndFill(attrs, content, this.marks);\n        if (node) {\n            this.push(node);\n            return node;\n        }\n        return null;\n    };\n    ToWwConvertorState.prototype.openNode = function (type, attrs) {\n        this.stack.push({ type: type, attrs: attrs, content: [] });\n    };\n    ToWwConvertorState.prototype.closeNode = function () {\n        if (this.marks.length) {\n            this.marks = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none;\n        }\n        var _a = this.stack.pop(), type = _a.type, attrs = _a.attrs, content = _a.content;\n        return this.addNode(type, attrs, content);\n    };\n    ToWwConvertorState.prototype.convertByDOMParser = function (root) {\n        var _this = this;\n        var doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.schema).parse(root);\n        doc.content.forEach(function (node) { return _this.push(node); });\n    };\n    ToWwConvertorState.prototype.closeUnmatchedHTMLInline = function (node, entering) {\n        var _a;\n        if (!entering && node.type !== 'htmlInline') {\n            var length_1 = this.stack.length - 1;\n            for (var i = length_1; i >= 0; i -= 1) {\n                var nodeInfo = this.stack[i];\n                if ((_a = nodeInfo.attrs) === null || _a === void 0 ? void 0 : _a.rawHTML) {\n                    if (nodeInfo.content.length) {\n                        this.closeNode();\n                    }\n                    else {\n                        // just pop useless unmatched html inline node\n                        this.stack.pop();\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n    };\n    ToWwConvertorState.prototype.convert = function (mdNode, infoForPosSync) {\n        var walker = mdNode.walker();\n        var event = walker.next();\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            var skipped = false;\n            if (convertor) {\n                var context = {\n                    entering: entering,\n                    leaf: !isContainer$2(node),\n                    getChildrenText: getChildrenText$1,\n                    options: { gfm: true, nodeId: false, tagFilter: false, softbreak: '\\n' },\n                    skipChildren: function () {\n                        skipped = true;\n                    },\n                };\n                this_1.closeUnmatchedHTMLInline(node, entering);\n                convertor(this_1, node, context);\n                if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                    var pos = this_1.stack.reduce(function (nodeSize, stackItem) {\n                        return nodeSize +\n                            stackItem.content.reduce(function (contentSize, pmNode) { return contentSize + pmNode.nodeSize; }, 0);\n                    }, 0) + 1;\n                    infoForPosSync.setMappedPos(pos);\n                }\n            }\n            if (skipped) {\n                walker.resumeAt(node, false);\n                walker.next();\n            }\n            event = walker.next();\n        };\n        var this_1 = this;\n        while (event) {\n            _loop_1();\n        }\n    };\n    ToWwConvertorState.prototype.convertNode = function (mdNode, infoForPosSync) {\n        this.convert(mdNode, infoForPosSync);\n        if (this.stack.length) {\n            return this.closeNode();\n        }\n        return null;\n    };\n    return ToWwConvertorState;\n}());\n\nfunction convertToRawHTMLHavingInlines(state, node, _a) {\n    var openTag = _a[0], closeTag = _a[1];\n    state.write(openTag);\n    state.convertInline(node);\n    state.write(closeTag);\n}\nfunction convertToRawHTMLHavingBlocks(state, _a, _b) {\n    var node = _a.node, parent = _a.parent;\n    var openTag = _b[0], closeTag = _b[1];\n    state.stopNewline = true;\n    state.write(openTag);\n    state.convertNode(node);\n    state.write(closeTag);\n    if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'doc') {\n        state.closeBlock(node);\n        state.stopNewline = false;\n    }\n}\nfunction createTableHeadDelim(textContent, columnAlign) {\n    var textLen = textContent.length;\n    var leftDelim = '';\n    var rightDelim = '';\n    if (columnAlign === 'left') {\n        leftDelim = ':';\n        textLen -= 1;\n    }\n    else if (columnAlign === 'right') {\n        rightDelim = ':';\n        textLen -= 1;\n    }\n    else if (columnAlign === 'center') {\n        leftDelim = ':';\n        rightDelim = ':';\n        textLen -= 2;\n    }\n    return \"\" + leftDelim + repeat$1('-', Math.max(textLen, 3)) + rightDelim;\n}\nvar nodeTypeWriters = {\n    text: function (state, _a) {\n        var _b;\n        var node = _a.node;\n        var text = (_b = node.text) !== null && _b !== void 0 ? _b : '';\n        if ((node.marks || []).some(function (mark) { return mark.type.name === 'link'; })) {\n            state.text(escapeTextForLink(text), false);\n        }\n        else {\n            state.text(text);\n        }\n    },\n    paragraph: function (state, _a) {\n        var node = _a.node, parent = _a.parent, _b = _a.index, index = _b === void 0 ? 0 : _b;\n        if (state.stopNewline) {\n            state.convertInline(node);\n        }\n        else {\n            var firstChildNode = index === 0;\n            var prevNode = !firstChildNode && parent.child(index - 1);\n            var prevEmptyNode = prevNode && prevNode.childCount === 0;\n            var nextNode = index < parent.childCount - 1 && parent.child(index + 1);\n            var nextParaNode = nextNode && nextNode.type.name === 'paragraph';\n            var emptyNode = node.childCount === 0;\n            if (emptyNode && prevEmptyNode) {\n                state.write('<br>\\n');\n            }\n            else if (emptyNode && !prevEmptyNode && !firstChildNode) {\n                if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'listItem') {\n                    var prevDelim = state.getDelim();\n                    state.setDelim('');\n                    state.write('<br>');\n                    state.setDelim(prevDelim);\n                }\n                state.write('\\n');\n            }\n            else {\n                state.convertInline(node);\n                if (nextParaNode) {\n                    state.write('\\n');\n                }\n                else {\n                    state.closeBlock(node);\n                }\n            }\n        }\n    },\n    heading: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var headingType = node.attrs.headingType;\n        if (headingType === 'atx') {\n            state.write(delim + \" \");\n            state.convertInline(node);\n            state.closeBlock(node);\n        }\n        else {\n            state.convertInline(node);\n            state.ensureNewLine();\n            state.write(delim);\n            state.closeBlock(node);\n        }\n    },\n    codeBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    blockQuote: function (state, _a, _b) {\n        var node = _a.node, parent = _a.parent;\n        var delim = _b.delim;\n        if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === node.type.name) {\n            state.flushClose(1);\n        }\n        state.wrapBlock(delim, null, node, function () { return state.convertNode(node); });\n    },\n    bulletList: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(' ', 4), function () { return delim + \" \"; });\n    },\n    orderedList: function (state, _a) {\n        var node = _a.node;\n        var start = node.attrs.order || 1;\n        // soft-tab(4)\n        state.convertList(node, repeat$1(' ', 4), function (index) {\n            var orderedNum = String(start + index);\n            return orderedNum + \". \";\n        });\n    },\n    listItem: function (state, _a) {\n        var node = _a.node;\n        var _b = node.attrs, task = _b.task, checked = _b.checked;\n        if (task) {\n            state.write(\"[\" + (checked ? 'x' : ' ') + \"] \");\n        }\n        state.convertNode(node);\n    },\n    image: function (state, _, _a) {\n        var attrs = _a.attrs;\n        state.write(\"![\" + (attrs === null || attrs === void 0 ? void 0 : attrs.altText) + \"](\" + (attrs === null || attrs === void 0 ? void 0 : attrs.imageUrl) + \")\");\n    },\n    thematicBreak: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        state.write(delim);\n        state.closeBlock(node);\n    },\n    table: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.closeBlock(node);\n    },\n    tableHead: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim;\n        var row = node.firstChild;\n        state.convertNode(node);\n        var result = delim !== null && delim !== void 0 ? delim : '';\n        if (!delim && row) {\n            row.forEach(function (_a) {\n                var textContent = _a.textContent, attrs = _a.attrs;\n                var headDelim = createTableHeadDelim(textContent, attrs.align);\n                result += \"| \" + headDelim + \" \";\n            });\n        }\n        state.write(result + \"|\");\n        state.ensureNewLine();\n    },\n    tableBody: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n    },\n    tableRow: function (state, _a) {\n        var node = _a.node;\n        state.convertNode(node);\n        state.write('|');\n        state.ensureNewLine();\n    },\n    tableHeadCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(' ');\n    },\n    tableBodyCell: function (state, _a, _b) {\n        var node = _a.node;\n        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;\n        state.write(delim);\n        state.convertTableCell(node);\n        state.write(' ');\n    },\n    customBlock: function (state, _a, _b) {\n        var node = _a.node;\n        var delim = _b.delim, text = _b.text;\n        var _c = delim, openDelim = _c[0], closeDelim = _c[1];\n        state.write(openDelim);\n        state.ensureNewLine();\n        state.text(text, false);\n        state.ensureNewLine();\n        state.write(closeDelim);\n        state.closeBlock(node);\n    },\n    frontMatter: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.text(text, false);\n        state.closeBlock(node);\n    },\n    widget: function (state, _, _a) {\n        var text = _a.text;\n        state.write(text);\n    },\n    html: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        if (node.attrs.htmlBlock) {\n            state.closeBlock(node);\n        }\n    },\n    htmlComment: function (state, _a, _b) {\n        var node = _a.node;\n        var text = _b.text;\n        state.write(text);\n        state.closeBlock(node);\n    },\n};\nfunction write(type, _a) {\n    var state = _a.state, nodeInfo = _a.nodeInfo, params = _a.params;\n    var rawHTML = params.rawHTML;\n    if (rawHTML) {\n        if (inArray_1(type, ['heading', 'codeBlock']) > -1) {\n            convertToRawHTMLHavingInlines(state, nodeInfo.node, rawHTML);\n        }\n        else if (inArray_1(type, ['image', 'thematicBreak']) > -1) {\n            state.write(rawHTML);\n        }\n        else {\n            convertToRawHTMLHavingBlocks(state, nodeInfo, rawHTML);\n        }\n    }\n    else {\n        nodeTypeWriters[type](state, nodeInfo, params);\n    }\n}\n\nfunction addBackticks(node, side) {\n    var text = node.text;\n    var ticks = /`+/g;\n    var len = 0;\n    if (node.isText && text) {\n        var matched = ticks.exec(text);\n        while (matched) {\n            len = Math.max(len, matched[0].length);\n            matched = ticks.exec(text);\n        }\n    }\n    var result = len > 0 && side > 0 ? ' `' : '`';\n    for (var i = 0; i < len; i += 1) {\n        result += '`';\n    }\n    if (len > 0 && side < 0) {\n        result += ' ';\n    }\n    return result;\n}\nfunction getPairRawHTML(rawHTML) {\n    return rawHTML ? [\"<\" + rawHTML + \">\", \"</\" + rawHTML + \">\"] : null;\n}\nfunction getOpenRawHTML(rawHTML) {\n    return rawHTML ? \"<\" + rawHTML + \">\" : null;\n}\nfunction getCloseRawHTML(rawHTML) {\n    return rawHTML ? \"</\" + rawHTML + \">\" : null;\n}\nvar toMdConvertors = {\n    heading: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var level = attrs.level;\n        var delim = repeat$1('#', level);\n        if (attrs.headingType === 'setext') {\n            delim = level === 1 ? '===' : '---';\n        }\n        return {\n            delim: delim,\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n        };\n    },\n    codeBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: [\"```\" + (attrs.language || ''), '```'],\n            rawHTML: getPairRawHTML(attrs.rawHTML),\n            text: textContent,\n        };\n    },\n    blockQuote: function (_a) {\n        var node = _a.node;\n        return {\n            delim: '> ',\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    bulletList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'ul';\n        }\n        return {\n            delim: '*',\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    orderedList: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'ol';\n        }\n        return {\n            rawHTML: getPairRawHTML(rawHTML),\n        };\n    },\n    listItem: function (_a, _b) {\n        var node = _a.node;\n        var inTable = _b.inTable;\n        var _c = node.attrs, task = _c.task, checked = _c.checked;\n        var rawHTML = node.attrs.rawHTML;\n        if (inTable) {\n            rawHTML = rawHTML || 'li';\n        }\n        var className = task ? \" class=\\\"task-list-item\" + (checked ? ' checked' : '') + \"\\\"\" : '';\n        var dataset = task ? \" data-task\" + (checked ? \" data-task-checked\" : '') : '';\n        return {\n            rawHTML: rawHTML ? [\"<\" + rawHTML + className + dataset + \">\", \"</\" + rawHTML + \">\"] : null,\n        };\n    },\n    table: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHead: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBody: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableRow: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableHeadCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    tableBodyCell: function (_a) {\n        var node = _a.node;\n        return {\n            rawHTML: getPairRawHTML(node.attrs.rawHTML),\n        };\n    },\n    image: function (_a) {\n        var node = _a.node;\n        var attrs = node.attrs;\n        var rawHTML = attrs.rawHTML, altText = attrs.altText;\n        var imageUrl = attrs.imageUrl.replace(/&amp;/g, '&');\n        var altAttr = altText ? \" alt=\\\"\" + escapeXml$1(altText) + \"\\\"\" : '';\n        return {\n            rawHTML: rawHTML ? \"<\" + rawHTML + \" src=\\\"\" + escapeXml$1(imageUrl) + \"\\\"\" + altAttr + \">\" : null,\n            attrs: {\n                altText: escapeTextForLink(altText || ''),\n                imageUrl: imageUrl,\n            },\n        };\n    },\n    thematicBreak: function (_a) {\n        var node = _a.node;\n        return {\n            delim: '***',\n            rawHTML: getOpenRawHTML(node.attrs.rawHTML),\n        };\n    },\n    customBlock: function (_a) {\n        var node = _a.node;\n        var _b = node, attrs = _b.attrs, textContent = _b.textContent;\n        return {\n            delim: [\"$$\" + attrs.info, '$$'],\n            text: textContent,\n        };\n    },\n    frontMatter: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    widget: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    strong: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '**',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    emph: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '*',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    strike: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var rawHTML = node.attrs.rawHTML;\n        return {\n            delim: '~~',\n            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),\n        };\n    },\n    link: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var attrs = node.attrs;\n        var title = attrs.title, rawHTML = attrs.rawHTML;\n        var linkUrl = attrs.linkUrl.replace(/&amp;/g, '&');\n        var titleAttr = title ? \" title=\\\"\" + escapeXml$1(title) + \"\\\"\" : '';\n        if (entering) {\n            return {\n                delim: '[',\n                rawHTML: rawHTML ? \"<\" + rawHTML + \" href=\\\"\" + escapeXml$1(linkUrl) + \"\\\"\" + titleAttr + \">\" : null,\n            };\n        }\n        return {\n            delim: \"](\" + linkUrl + (title ? \" \" + quote(escapeTextForLink(title)) : '') + \")\",\n            rawHTML: getCloseRawHTML(rawHTML),\n        };\n    },\n    code: function (_a, _b) {\n        var node = _a.node, parent = _a.parent, _c = _a.index, index = _c === void 0 ? 0 : _c;\n        var entering = _b.entering;\n        var delim = entering\n            ? addBackticks(parent.child(index), -1)\n            : addBackticks(parent.child(index - 1), 1);\n        var rawHTML = entering\n            ? getOpenRawHTML(node.attrs.rawHTML)\n            : getCloseRawHTML(node.attrs.rawHTML);\n        return {\n            delim: delim,\n            rawHTML: rawHTML,\n        };\n    },\n    htmlComment: function (_a) {\n        var node = _a.node;\n        return {\n            text: node.textContent,\n        };\n    },\n    // html inline node, html block node\n    html: function (_a, _b) {\n        var node = _a.node;\n        var entering = _b.entering;\n        var tagName = node.type.name;\n        var attrs = node.attrs.htmlAttrs;\n        var openTag = \"<\" + tagName;\n        var closeTag = \"</\" + tagName + \">\";\n        Object.keys(attrs).forEach(function (attrName) {\n            // To prevent broken converting when attributes has double quote string\n            openTag += \" \" + attrName + \"=\\\"\" + attrs[attrName].replace(/\"/g, \"'\") + \"\\\"\";\n        });\n        openTag += '>';\n        if (node.attrs.htmlInline) {\n            return {\n                rawHTML: entering ? openTag : closeTag,\n            };\n        }\n        return {\n            text: \"\" + openTag + node.attrs.childrenHTML + closeTag,\n        };\n    },\n};\nvar markTypeOptions = {\n    strong: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    emph: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    strike: {\n        mixable: true,\n        removedEnclosingWhitespace: true,\n    },\n    code: {\n        escape: false,\n    },\n    link: null,\n    html: null,\n};\nfunction createNodeTypeConvertors(convertors) {\n    var nodeTypeConvertors = {};\n    var nodeTypes = Object.keys(nodeTypeWriters);\n    nodeTypes.forEach(function (type) {\n        nodeTypeConvertors[type] = function (state, nodeInfo) {\n            var writer = nodeTypeWriters[type];\n            if (writer) {\n                var convertor = convertors[type];\n                var params = convertor\n                    ? convertor(nodeInfo, {\n                        inTable: state.inTable,\n                    })\n                    : {};\n                write(type, { state: state, nodeInfo: nodeInfo, params: params });\n            }\n        };\n    });\n    return nodeTypeConvertors;\n}\nfunction createMarkTypeConvertors(convertors) {\n    var markTypeConvertors = {};\n    var markTypes = Object.keys(markTypeOptions);\n    markTypes.forEach(function (type) {\n        markTypeConvertors[type] = function (nodeInfo, entering) {\n            var markOption = markTypeOptions[type];\n            var convertor = convertors[type];\n            // There are two ways to call the mark type converter\n            // in the `toMdConvertorState` module.\n            // When calling the converter without using `delim` and `rawHTML` values,\n            // the converter is called without parameters.\n            var runConvertor = convertor && nodeInfo && !isUndefined_1(entering);\n            var params = runConvertor ? convertor(nodeInfo, { entering: entering }) : {};\n            return __assign$1(__assign$1({}, params), markOption);\n        };\n    });\n    return markTypeConvertors;\n}\n// Step 1: Create the converter by overriding the custom converter\n//         to the original converter defined in the `toMdConvertors` module.\n//         If the node type is defined in the original converter,\n//         the `origin()` function is exported to the paramter of the converter.\n// Step 2: Create a converter for the node type of ProseMirror by combining the converter\n//         created in Step 1 with the writers defined in the`toMdNodeTypeWriters` module.\n//         Each writer converts the ProseMirror's node to a string with the value returned\n//         by the converter, and then stores the state in the`toMdConverterState` class.\n// Step 3: Create a converter for the mark type of ProseMirror by combining the converter\n//         created in Step 1 with `markTypeOptions`.\n// Step 4: The created node type converter and mark type converter are injected\n//         when creating an instance of the`toMdConverterState` class.\nfunction createMdConvertors(customConvertors) {\n    var customConvertorTypes = Object.keys(customConvertors);\n    customConvertorTypes.forEach(function (type) {\n        var baseConvertor = toMdConvertors[type];\n        var customConvertor = customConvertors[type];\n        if (baseConvertor) {\n            toMdConvertors[type] = function (nodeInfo, context) {\n                context.origin = function () { return baseConvertor(nodeInfo, context); };\n                return customConvertor(nodeInfo, context);\n            };\n        }\n        else {\n            toMdConvertors[type] = customConvertor;\n        }\n        delete customConvertors[type];\n    });\n    var nodeTypeConvertors = createNodeTypeConvertors(toMdConvertors);\n    var markTypeConvertors = createMarkTypeConvertors(toMdConvertors);\n    return {\n        nodeTypeConvertors: nodeTypeConvertors,\n        markTypeConvertors: markTypeConvertors,\n    };\n}\n\nvar ToMdConvertorState = /** @class */ (function () {\n    function ToMdConvertorState(_a) {\n        var nodeTypeConvertors = _a.nodeTypeConvertors, markTypeConvertors = _a.markTypeConvertors;\n        this.nodeTypeConvertors = nodeTypeConvertors;\n        this.markTypeConvertors = markTypeConvertors;\n        this.delim = '';\n        this.result = '';\n        this.closed = false;\n        this.tightList = false;\n        this.stopNewline = false;\n        this.inTable = false;\n    }\n    ToMdConvertorState.prototype.getMarkConvertor = function (mark) {\n        var type = mark.attrs.htmlInline ? 'html' : mark.type.name;\n        return this.markTypeConvertors[type];\n    };\n    ToMdConvertorState.prototype.isInBlank = function () {\n        return /(^|\\n)$/.test(this.result);\n    };\n    ToMdConvertorState.prototype.markText = function (mark, entering, parent, index) {\n        var convertor = this.getMarkConvertor(mark);\n        if (convertor) {\n            var _a = convertor({ node: mark, parent: parent, index: index }, entering), delim = _a.delim, rawHTML = _a.rawHTML;\n            return rawHTML || delim;\n        }\n        return '';\n    };\n    ToMdConvertorState.prototype.setDelim = function (delim) {\n        this.delim = delim;\n    };\n    ToMdConvertorState.prototype.getDelim = function () {\n        return this.delim;\n    };\n    ToMdConvertorState.prototype.flushClose = function (size) {\n        if (!this.stopNewline && this.closed) {\n            if (!this.isInBlank()) {\n                this.result += '\\n';\n            }\n            if (!size) {\n                size = 2;\n            }\n            if (size > 1) {\n                var delimMin = this.delim;\n                var trim = /\\s+$/.exec(delimMin);\n                if (trim) {\n                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n                }\n                for (var i = 1; i < size; i += 1) {\n                    this.result += delimMin + \"\\n\";\n                }\n            }\n            this.closed = false;\n        }\n    };\n    ToMdConvertorState.prototype.wrapBlock = function (delim, firstDelim, node, fn) {\n        var old = this.getDelim();\n        this.write(firstDelim || delim);\n        this.setDelim(this.getDelim() + delim);\n        fn();\n        this.setDelim(old);\n        this.closeBlock(node);\n    };\n    ToMdConvertorState.prototype.ensureNewLine = function () {\n        if (!this.isInBlank()) {\n            this.result += '\\n';\n        }\n    };\n    ToMdConvertorState.prototype.write = function (content) {\n        if (content === void 0) { content = ''; }\n        this.flushClose();\n        if (this.delim && this.isInBlank()) {\n            this.result += this.delim;\n        }\n        if (content) {\n            this.result += content;\n        }\n    };\n    ToMdConvertorState.prototype.closeBlock = function (node) {\n        this.closed = node;\n    };\n    ToMdConvertorState.prototype.text = function (text, escaped) {\n        if (escaped === void 0) { escaped = true; }\n        var lines = text.split('\\n');\n        for (var i = 0; i < lines.length; i += 1) {\n            this.write();\n            this.result += escaped ? escape$1(lines[i]) : lines[i];\n            if (i !== lines.length - 1) {\n                this.result += '\\n';\n            }\n        }\n    };\n    ToMdConvertorState.prototype.convertBlock = function (node, parent, index) {\n        var type = node.type.name;\n        var convertor = this.nodeTypeConvertors[type];\n        var nodeInfo = { node: node, parent: parent, index: index };\n        if (node.attrs.htmlBlock) {\n            this.nodeTypeConvertors.html(this, nodeInfo);\n        }\n        else if (convertor) {\n            convertor(this, nodeInfo);\n        }\n    };\n    ToMdConvertorState.prototype.convertInline = function (parent) {\n        var _this = this;\n        var active = [];\n        var trailing = '';\n        var progress = function (node, _, index) {\n            var marks = node ? node.marks : [];\n            var leading = trailing;\n            trailing = '';\n            // If whitespace has to be expelled from the node, adjust\n            // leading and trailing accordingly.\n            var removedWhitespace = node &&\n                node.isText &&\n                marks.some(function (mark) {\n                    var markConvertor = _this.getMarkConvertor(mark);\n                    var info = markConvertor && markConvertor();\n                    return info && info.removedEnclosingWhitespace;\n                });\n            if (removedWhitespace && node && node.text) {\n                var _a = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text), lead = _a[1], mark = _a[2], trail = _a[3];\n                leading += lead;\n                trailing = trail;\n                if (lead || trail) {\n                    // @ts-ignore\n                    // type is not defined for \"withText\" in prosemirror-model\n                    node = mark ? node.withText(mark) : null;\n                    if (!node) {\n                        marks = active;\n                    }\n                }\n            }\n            var lastMark = marks.length && last$1(marks);\n            var markConvertor = lastMark && _this.getMarkConvertor(lastMark);\n            var markType = markConvertor && markConvertor();\n            var noEscape = markType && markType.escape === false;\n            var len = marks.length - (noEscape ? 1 : 0);\n            // Try to reorder 'mixable' marks, such as em and strong, which\n            // in Markdown may be opened and closed in different order, so\n            // that order of the marks for the token matches the order in\n            // active.\n            for (var i = 0; i < len; i += 1) {\n                var mark = marks[i];\n                if (markType && !markType.mixable) {\n                    break;\n                }\n                for (var j = 0; j < active.length; j += 1) {\n                    var other = active[j];\n                    if (markType && !markType.mixable) {\n                        break;\n                    }\n                    if (mark.eq(other)) {\n                        // eslint-disable-next-line max-depth\n                        if (i > j) {\n                            marks = marks\n                                .slice(0, j)\n                                .concat(mark)\n                                .concat(marks.slice(j, i))\n                                .concat(marks.slice(i + 1, len));\n                        }\n                        else if (j > i) {\n                            marks = marks\n                                .slice(0, i)\n                                .concat(marks.slice(i + 1, j))\n                                .concat(mark)\n                                .concat(marks.slice(j, len));\n                        }\n                        break;\n                    }\n                }\n            }\n            // Find the prefix of the mark set that didn't change\n            var keep = 0;\n            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {\n                keep += 1;\n            }\n            // Close the marks that need to be closed\n            while (keep < active.length) {\n                var activedMark = active.pop();\n                if (activedMark) {\n                    _this.text(_this.markText(activedMark, false, parent, index), false);\n                }\n            }\n            // Output any previously expelled trailing whitespace outside the marks\n            if (leading) {\n                _this.text(leading);\n            }\n            // Open the marks that need to be opened\n            if (node) {\n                while (active.length < len) {\n                    var mark = marks[active.length];\n                    active.push(mark);\n                    _this.text(_this.markText(mark, true, parent, index), false);\n                }\n                // Render the node. Special case code marks, since their content\n                // may not be escaped.\n                if (noEscape && node.isText) {\n                    _this.text(_this.markText(lastMark, true, parent, index) +\n                        node.text +\n                        _this.markText(lastMark, false, parent, index + 1), false);\n                }\n                else {\n                    _this.convertBlock(node, parent, index);\n                }\n            }\n        };\n        parent.forEach(progress);\n        progress(null, null, parent.childCount);\n    };\n    // Render a node's content as a list. `delim` should be the extra\n    // indentation added to all lines except the first in an item,\n    // `firstDelimFn` is a function going from an item index to a\n    // delimiter for the first line of the item.\n    ToMdConvertorState.prototype.convertList = function (node, delim, firstDelimFn) {\n        var _this = this;\n        var _a;\n        if (this.closed && this.closed.type === node.type) {\n            this.flushClose(3);\n        }\n        else if (this.tightList) {\n            this.flushClose(1);\n        }\n        var tight = (_a = node.attrs.tight) !== null && _a !== void 0 ? _a : true;\n        var prevTight = this.tightList;\n        this.tightList = tight;\n        node.forEach(function (child, _, index) {\n            if (index && tight) {\n                _this.flushClose(1);\n            }\n            _this.wrapBlock(delim, firstDelimFn(index), node, function () { return _this.convertBlock(child, node, index); });\n        });\n        this.tightList = prevTight;\n    };\n    ToMdConvertorState.prototype.convertTableCell = function (node) {\n        var _this = this;\n        this.stopNewline = true;\n        this.inTable = true;\n        node.forEach(function (child, _, index) {\n            if (includes(['bulletList', 'orderedList'], child.type.name)) {\n                _this.convertBlock(child, node, index);\n                _this.closed = false;\n            }\n            else {\n                _this.convertInline(child);\n                if (index < node.childCount - 1) {\n                    var nextChild = node.child(index + 1);\n                    if (nextChild.type.name === 'paragraph') {\n                        _this.write('<br>');\n                    }\n                }\n            }\n        });\n        this.stopNewline = false;\n        this.inTable = false;\n    };\n    ToMdConvertorState.prototype.convertNode = function (parent, infoForPosSync) {\n        var _this = this;\n        parent.forEach(function (node, _, index) {\n            _this.convertBlock(node, parent, index);\n            if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {\n                var lineTexts = _this.result.split('\\n');\n                infoForPosSync.setMappedPos([lineTexts.length, last$1(lineTexts).length + 1]);\n            }\n        });\n        return this.result;\n    };\n    return ToMdConvertorState;\n}());\n\nvar Convertor = /** @class */ (function () {\n    function Convertor(schema, toMdConvertors, toHTMLConvertors, eventEmitter) {\n        var _this = this;\n        this.setMappedPos = function (pos) {\n            _this.mappedPosWhenConverting = pos;\n        };\n        this.schema = schema;\n        this.eventEmitter = eventEmitter;\n        this.focusedNode = null;\n        this.mappedPosWhenConverting = null;\n        this.toWwConvertors = createWwConvertors(toHTMLConvertors);\n        this.toMdConvertors = createMdConvertors(toMdConvertors || {});\n        this.eventEmitter.listen('setFocusedNode', function (node) { return (_this.focusedNode = node); });\n    }\n    Convertor.prototype.getMappedPos = function () {\n        return this.mappedPosWhenConverting;\n    };\n    Convertor.prototype.getInfoForPosSync = function () {\n        return { node: this.focusedNode, setMappedPos: this.setMappedPos };\n    };\n    Convertor.prototype.toWysiwygModel = function (mdNode) {\n        var state = new ToWwConvertorState(this.schema, this.toWwConvertors);\n        return state.convertNode(mdNode, this.getInfoForPosSync());\n    };\n    Convertor.prototype.toMarkdownText = function (wwNode) {\n        var state = new ToMdConvertorState(this.toMdConvertors);\n        var markdownText = state.convertNode(wwNode, this.getInfoForPosSync());\n        markdownText = this.eventEmitter.emitReduce('beforeConvertWysiwygToMarkdown', markdownText);\n        return markdownText;\n    };\n    return Convertor;\n}());\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin, PluginKey: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey, Selection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection, TextSelection: prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection };\n    var pmView = { Decoration: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration, DecorationSet: prosemirror_view__WEBPACK_IMPORTED_MODULE_4__.DecorationSet };\n    var pmModel = { Fragment: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment };\n    var pmRules = { InputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.InputRule, inputRules: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.inputRules, undoInputRule: prosemirror_inputrules__WEBPACK_IMPORTED_MODULE_6__.undoInputRule };\n    var pmKeymap = { keymap: prosemirror_keymap__WEBPACK_IMPORTED_MODULE_5__.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_1(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error('The return value of the executed plugin is empty.');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = __assign$1(__assign$1({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = __assign$1(__assign$1({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = __assign$1(__assign$1({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = __assign$1(__assign$1({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\nvar TASK_ATTR_NAME = 'data-task';\nvar DISABLED_TASK_ATTR_NAME = 'data-task-disabled';\nvar TASK_CHECKED_CLASS_NAME = 'checked';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor's initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_1({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: 'light',\n        }, options);\n        this.eventEmitter = new EventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: __assign$1(__assign$1({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== 'light') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = '';\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: true }));\n        on_1(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit('load', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, ':before');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit('change', {\n                source: 'viewer',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = last$1(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');\n        this.eventEmitter.emit('updatePreview', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_1(this.preview.el, 'mousedown', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit('destroy');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n\nfunction isPmNode(node) {\n    return node instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Node;\n}\nfunction isContainer(type) {\n    var containerTypes = [\n        'document',\n        'blockQuote',\n        'bulletList',\n        'orderedList',\n        'listItem',\n        'paragraph',\n        'heading',\n        'emph',\n        'strong',\n        'strike',\n        'link',\n        'image',\n        'table',\n        'tableHead',\n        'tableBody',\n        'tableRow',\n        'tableHeadCell',\n        'tableBodyCell',\n    ];\n    return includes(containerTypes, type);\n}\nfunction createMdLikeNode(node) {\n    var attrs = node.attrs, type = node.type;\n    var nodeType = type.name;\n    var mdLikeNode = {\n        type: nodeType,\n        wysiwygNode: true,\n        literal: !isContainer(nodeType) && isPmNode(node) ? node.textContent : null,\n    };\n    var nodeTypeMap = {\n        heading: { level: attrs.level },\n        link: { destination: attrs.linkUrl, title: attrs.title },\n        image: { destination: attrs.imageUrl },\n        codeBlock: { info: attrs.language },\n        bulletList: { type: 'list', listData: { type: 'bullet' } },\n        orderedList: { type: 'list', listData: { type: 'ordered', start: attrs.order } },\n        listItem: { type: 'item', listData: { task: attrs.task, checked: attrs.checked } },\n        tableHeadCell: { type: 'tableCell', cellType: 'head', align: attrs.align },\n        tableBodyCell: { type: 'tableCell', cellType: 'body', align: attrs.align },\n        customBlock: { info: attrs.info },\n    };\n    var nodeInfo = nodeTypeMap[nodeType];\n    var attributes = __assign$1(__assign$1({}, mdLikeNode), nodeInfo);\n    // html block, inline node\n    var _a = node.attrs, htmlAttrs = _a.htmlAttrs, childrenHTML = _a.childrenHTML;\n    if (htmlAttrs) {\n        return __assign$1(__assign$1({}, attributes), { attrs: htmlAttrs, childrenHTML: childrenHTML });\n    }\n    return attributes;\n}\n\nvar tokenToDOMNode = {\n    openTag: function (token, stack) {\n        var _a = token, tagName = _a.tagName, classNames = _a.classNames, attributes = _a.attributes;\n        var el = document.createElement(tagName);\n        var attrs = {};\n        if (classNames) {\n            el.className = classNames.join(' ');\n        }\n        if (attributes) {\n            attrs = __assign$1(__assign$1({}, attrs), attributes);\n        }\n        setAttributes(attrs, el);\n        stack.push(el);\n    },\n    closeTag: function (_, stack) {\n        if (stack.length > 1) {\n            var el = stack.pop();\n            last$1(stack).appendChild(el);\n        }\n    },\n    html: function (token, stack) {\n        last$1(stack).insertAdjacentHTML('beforeend', token.content);\n    },\n    text: function (token, stack) {\n        var textNode = document.createTextNode(token.content);\n        last$1(stack).appendChild(textNode);\n    },\n};\nvar WwToDOMAdaptor = /** @class */ (function () {\n    function WwToDOMAdaptor(linkAttributes, customRenderer) {\n        var convertors = getHTMLRenderConvertors(linkAttributes, customRenderer);\n        var customHTMLConvertor = __assign$1(__assign$1({}, customRenderer.htmlBlock), customRenderer.htmlInline);\n        // flatten the html block, inline convertor to other custom convertors\n        this.customConvertorKeys = Object.keys(customRenderer).concat(Object.keys(customHTMLConvertor));\n        this.renderer = new Renderer({\n            gfm: true,\n            convertors: __assign$1(__assign$1({}, convertors), customHTMLConvertor),\n        });\n        this.convertors = this.renderer.getConvertors();\n    }\n    WwToDOMAdaptor.prototype.generateTokens = function (node) {\n        var mdLikeNode = createMdLikeNode(node);\n        var context = {\n            entering: true,\n            leaf: isPmNode(node) ? node.isLeaf : false,\n            options: this.renderer.getOptions(),\n            getChildrenText: function () { return (isPmNode(node) ? node.textContent : ''); },\n            skipChildren: function () { return false; },\n        };\n        var convertor = this.convertors[node.type.name];\n        var converted = convertor(mdLikeNode, context, this.convertors);\n        var tokens = isArray_1(converted) ? converted : [converted];\n        if (isContainer(node.type.name) || node.attrs.htmlInline) {\n            context.entering = false;\n            tokens.push({ type: 'text', content: isPmNode(node) ? node.textContent : '' });\n            tokens = tokens.concat(convertor(mdLikeNode, context, this.convertors));\n        }\n        return tokens;\n    };\n    WwToDOMAdaptor.prototype.toDOMNode = function (node) {\n        var tokens = this.generateTokens(node);\n        var stack = [];\n        tokens.forEach(function (token) { return tokenToDOMNode[token.type](token, stack); });\n        return stack[0];\n    };\n    WwToDOMAdaptor.prototype.getToDOMNode = function (name) {\n        if (includes(this.customConvertorKeys, name)) {\n            return this.toDOMNode.bind(this);\n        }\n        return null;\n    };\n    return WwToDOMAdaptor;\n}());\n\nvar ANIMATION_TIME = 100;\nvar SCROLL_BLOCKING_RESET_DELAY = 15;\nvar currentTimeoutId = null;\nvar releaseTimer = null;\nfunction run(deltaScrollTop, _a) {\n    var syncScrollTop = _a.syncScrollTop, releaseEventBlock = _a.releaseEventBlock;\n    if (releaseTimer) {\n        clearTimeout(releaseTimer);\n    }\n    syncScrollTop(deltaScrollTop);\n    releaseTimer = setTimeout(function () {\n        releaseEventBlock();\n    }, SCROLL_BLOCKING_RESET_DELAY);\n}\nfunction animate(curScrollTop, targetScrollTop, syncCallbacks) {\n    var diff = targetScrollTop - curScrollTop;\n    var startTime = Date.now();\n    var step = function () {\n        var stepTime = Date.now();\n        var progress = (stepTime - startTime) / ANIMATION_TIME;\n        var deltaValue;\n        if (currentTimeoutId) {\n            clearTimeout(currentTimeoutId);\n        }\n        if (progress < 1) {\n            deltaValue = curScrollTop + diff * Math.cos(((1 - progress) * Math.PI) / 2);\n            run(Math.ceil(deltaValue), syncCallbacks);\n            currentTimeoutId = setTimeout(step, 1);\n        }\n        else {\n            run(targetScrollTop, syncCallbacks);\n            currentTimeoutId = null;\n        }\n    };\n    step();\n}\n\nvar EDITOR_BOTTOM_PADDING = 18;\nvar ScrollSync = /** @class */ (function () {\n    function ScrollSync(mdEditor, preview, eventEmitter) {\n        this.latestEditorScrollTop = null;\n        this.latestPreviewScrollTop = null;\n        this.blockedScroll = null;\n        this.active = true;\n        this.timer = null;\n        var previewRoot = preview.previewContent, previewEl = preview.el;\n        this.previewRoot = previewRoot;\n        this.previewEl = previewEl;\n        this.mdEditor = mdEditor;\n        this.editorView = mdEditor.view;\n        this.toastMark = mdEditor.getToastMark();\n        this.eventEmitter = eventEmitter;\n        this.addScrollSyncEvent();\n    }\n    ScrollSync.prototype.addScrollSyncEvent = function () {\n        var _this = this;\n        this.eventEmitter.listen('afterPreviewRender', function () {\n            _this.clearTimer();\n            // Immediately after the 'afterPreviewRender' event has occurred,\n            // browser rendering is not yet complete.\n            // So the size of elements can not be accurately measured.\n            _this.timer = setTimeout(function () {\n                _this.syncPreviewScrollTop(true);\n            }, 200);\n        });\n        this.eventEmitter.listen('scroll', function (type, data) {\n            if (_this.active) {\n                if (type === 'editor' && _this.blockedScroll !== 'editor') {\n                    _this.syncPreviewScrollTop();\n                }\n                else if (type === 'preview' && _this.blockedScroll !== 'preview') {\n                    _this.syncEditorScrollTop(data);\n                }\n            }\n        });\n        this.eventEmitter.listen('toggleScrollSync', function (active) {\n            _this.active = active;\n        });\n    };\n    ScrollSync.prototype.getMdNodeAtPos = function (doc, posInfo) {\n        var indexInfo = doc.content.findIndex(posInfo.pos);\n        var line = indexInfo.index;\n        return this.toastMark.findFirstNodeAtLine(line + 1);\n    };\n    ScrollSync.prototype.getScrollTopByCaretPos = function () {\n        var pos = this.mdEditor.getSelection();\n        var firstMdNode = this.toastMark.findFirstNodeAtLine(pos[0][0]);\n        var previewHeight = this.previewEl.clientHeight;\n        var el = getParentNodeObj(this.previewRoot, firstMdNode).el;\n        var totalOffsetTop = getTotalOffsetTop(el, this.previewRoot) || el.offsetTop;\n        var nodeHeight = el.clientHeight;\n        // multiply 0.5 for calculating the position in the middle of preview area\n        var targetScrollTop = totalOffsetTop + nodeHeight - previewHeight * 0.5;\n        this.latestEditorScrollTop = null;\n        var diff = el.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;\n        return diff < previewHeight ? null : targetScrollTop;\n    };\n    ScrollSync.prototype.syncPreviewScrollTop = function (editing) {\n        if (editing === void 0) { editing = false; }\n        var _a = this, editorView = _a.editorView, previewEl = _a.previewEl, previewRoot = _a.previewRoot;\n        var _b = editorView.dom.getBoundingClientRect(), left = _b.left, top = _b.top;\n        var posInfo = editorView.posAtCoords({ left: left, top: top });\n        var doc = editorView.state.doc;\n        var firstMdNode = this.getMdNodeAtPos(doc, posInfo);\n        if (!firstMdNode || isHTMLNode(firstMdNode)) {\n            return;\n        }\n        var curScrollTop = previewEl.scrollTop;\n        var _c = editorView.dom, scrollTop = _c.scrollTop, scrollHeight = _c.scrollHeight, clientHeight = _c.clientHeight, children = _c.children;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight + EDITOR_BOTTOM_PADDING;\n        var targetScrollTop = isBottomPos ? previewEl.scrollHeight : 0;\n        if (scrollTop && !isBottomPos) {\n            if (editing) {\n                var scrollTopByEditing = this.getScrollTopByCaretPos();\n                if (!scrollTopByEditing) {\n                    return;\n                }\n                targetScrollTop = scrollTopByEditing;\n            }\n            else {\n                var _d = getParentNodeObj(this.previewRoot, firstMdNode), el = _d.el, mdNode = _d.mdNode;\n                var _e = getEditorRangeHeightInfo(doc, mdNode, children), height = _e.height, rect = _e.rect;\n                var totalOffsetTop = getTotalOffsetTop(el, previewRoot) || el.offsetTop;\n                var nodeHeight = el.clientHeight;\n                var ratio = top > rect.top ? Math.min((top - rect.top) / height, 1) : 0;\n                targetScrollTop = totalOffsetTop + nodeHeight * ratio;\n            }\n            targetScrollTop = this.getResolvedScrollTop('editor', scrollTop, targetScrollTop, curScrollTop);\n            this.latestEditorScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run('editor', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.syncEditorScrollTop = function (targetNode) {\n        var _a = this, toastMark = _a.toastMark, editorView = _a.editorView, previewRoot = _a.previewRoot, previewEl = _a.previewEl;\n        var dom = editorView.dom, state = editorView.state;\n        var scrollTop = previewEl.scrollTop, clientHeight = previewEl.clientHeight, scrollHeight = previewEl.scrollHeight;\n        var isBottomPos = scrollHeight - scrollTop <= clientHeight;\n        var curScrollTop = dom.scrollTop;\n        var targetScrollTop = isBottomPos ? dom.scrollHeight : 0;\n        if (scrollTop && targetNode && !isBottomPos) {\n            targetNode = findAncestorHavingId(targetNode, previewRoot);\n            if (!targetNode.getAttribute('data-nodeid')) {\n                return;\n            }\n            var children = dom.children;\n            var mdNodeId = Number(targetNode.getAttribute('data-nodeid'));\n            var _b = getParentNodeObj(this.previewRoot, toastMark.findNodeById(mdNodeId)), mdNode = _b.mdNode, el = _b.el;\n            var mdNodeStartLine = getMdStartLine(mdNode);\n            targetScrollTop = children[mdNodeStartLine - 1].offsetTop;\n            var height = getEditorRangeHeightInfo(state.doc, mdNode, children).height;\n            var _c = getAndSaveOffsetInfo(el, previewRoot, mdNodeId), nodeHeight = _c.nodeHeight, offsetTop = _c.offsetTop;\n            targetScrollTop += getAdditionalPos(scrollTop, offsetTop, nodeHeight, height);\n            targetScrollTop = this.getResolvedScrollTop('preview', scrollTop, targetScrollTop, curScrollTop);\n            this.latestPreviewScrollTop = scrollTop;\n        }\n        if (targetScrollTop !== curScrollTop) {\n            this.run('preview', targetScrollTop, curScrollTop);\n        }\n    };\n    ScrollSync.prototype.getResolvedScrollTop = function (from, scrollTop, targetScrollTop, curScrollTop) {\n        var latestScrollTop = from === 'editor' ? this.latestEditorScrollTop : this.latestPreviewScrollTop;\n        if (latestScrollTop === null) {\n            return targetScrollTop;\n        }\n        return latestScrollTop < scrollTop\n            ? Math.max(targetScrollTop, curScrollTop)\n            : Math.min(targetScrollTop, curScrollTop);\n    };\n    ScrollSync.prototype.run = function (from, targetScrollTop, curScrollTop) {\n        var _this = this;\n        var scrollTarget;\n        if (from === 'editor') {\n            scrollTarget = this.previewEl;\n            this.blockedScroll = 'preview';\n        }\n        else {\n            scrollTarget = this.editorView.dom;\n            this.blockedScroll = 'editor';\n        }\n        var syncCallbacks = {\n            syncScrollTop: function (scrollTop) { return (scrollTarget.scrollTop = scrollTop); },\n            releaseEventBlock: function () { return (_this.blockedScroll = null); },\n        };\n        animate(curScrollTop, targetScrollTop, syncCallbacks);\n    };\n    ScrollSync.prototype.clearTimer = function () {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    };\n    ScrollSync.prototype.destroy = function () {\n        this.clearTimer();\n        this.eventEmitter.removeEventHandler('scroll');\n        this.eventEmitter.removeEventHandler('afterPreviewRender');\n    };\n    return ScrollSync;\n}());\n\nvar queryMap = {\n    getPopupInitialValues: function (editor, payload) {\n        var popupName = payload.popupName;\n        return popupName === 'link' ? { linkText: editor.getSelectedText() } : {};\n    },\n};\nfunction buildQuery(editor) {\n    editor.eventEmitter.listen('query', function (query, payload) {\n        return queryMap[query](editor, payload);\n    });\n}\n\n/**\n * ToastUIEditorCore\n * @param {Object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.height='300px'] - Editor's height style value. Height is applied as border-box ex) '300px', '100%', 'auto'\n *     @param {string} [options.minHeight='200px'] - Editor's min-height style value in pixel ex) '300px'\n *     @param {string} [options.initialValue] - Editor's initial value\n *     @param {string} [options.previewStyle] - Markdown editor's preview style (tab, vertical)\n *     @param {boolean} [options.previewHighlight = true] - Highlight a preview element corresponds to the cursor position in the markdown editor\n *     @param {string} [options.initialEditType] - Initial editor type (markdown, wysiwyg)\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *         @param {function} [options.events.keydown] - It would be emitted when the key is pressed in editor\n *         @param {function} [options.events.keyup] - It would be emitted when the key is released in editor\n *         @param {function} [options.events.beforePreviewRender] - It would be emitted before rendering the markdown preview with html string\n *         @param {function} [options.events.beforeConvertWysiwygToMarkdown] - It would be emitted before converting wysiwyg to markdown with markdown text\n *     @param {Object} [options.hooks] - Hooks\n *         @param {addImageBlobHook} [options.hooks.addImageBlobHook] - hook for image upload\n *     @param {string} [options.language='en-US'] - language\n *     @param {boolean} [options.useCommandShortcut=true] - whether use keyboard shortcuts to perform commands\n *     @param {boolean} [options.usageStatistics=true] - send hostname to google analytics\n *     @param {Array.<string|toolbarItemsValue>} [options.toolbarItems] - toolbar items.\n *     @param {boolean} [options.hideModeSwitch=false] - hide mode switch tab bar\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {string} [options.placeholder] - The placeholder text of the editable element.\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {Object} [options.customMarkdownRenderer=null] - Object containing custom renderer functions correspond to change wysiwyg node to markdown text\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.previewHighlight=false] - whether highlight preview area\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {Array.<object>} [options.widgetRules=[]] - The rules for replacing the text with widget node\n *     @param {string} [options.theme] - The theme to style the editor with. The default is included in toastui-editor.css.\n *     @param {autofocus} [options.autofocus=true] - automatically focus the editor on creation.\n */\nvar ToastUIEditorCore = /** @class */ (function () {\n    function ToastUIEditorCore(options) {\n        var _this = this;\n        this.initialHTML = options.el.innerHTML;\n        options.el.innerHTML = '';\n        this.options = extend_1({\n            previewStyle: 'tab',\n            previewHighlight: true,\n            initialEditType: 'markdown',\n            height: '300px',\n            minHeight: '200px',\n            language: 'en-US',\n            useCommandShortcut: true,\n            usageStatistics: true,\n            toolbarItems: [\n                ['heading', 'bold', 'italic', 'strike'],\n                ['hr', 'quote'],\n                ['ul', 'ol', 'task', 'indent', 'outdent'],\n                ['table', 'image', 'link'],\n                ['code', 'codeblock'],\n                ['scrollSync'],\n            ],\n            hideModeSwitch: false,\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            customMarkdownRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            widgetRules: [],\n            theme: 'light',\n            autofocus: true,\n        }, options);\n        var _a = this.options, customHTMLRenderer = _a.customHTMLRenderer, extendedAutolinks = _a.extendedAutolinks, referenceDefinition = _a.referenceDefinition, frontMatter = _a.frontMatter, customMarkdownRenderer = _a.customMarkdownRenderer, useCommandShortcut = _a.useCommandShortcut, initialEditType = _a.initialEditType, widgetRules = _a.widgetRules, customHTMLSanitizer = _a.customHTMLSanitizer;\n        this.mode = initialEditType || 'markdown';\n        this.mdPreviewStyle = this.options.previewStyle;\n        this.i18n = i18n;\n        this.i18n.setCode(this.options.language);\n        this.eventEmitter = new EventEmitter();\n        setWidgetRules(widgetRules);\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        this.pluginInfo = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        });\n        var _b = this.pluginInfo, toHTMLRenderers = _b.toHTMLRenderers, toMarkdownRenderers = _b.toMarkdownRenderers, mdPlugins = _b.mdPlugins, wwPlugins = _b.wwPlugins, wwNodeViews = _b.wwNodeViews, mdCommands = _b.mdCommands, wwCommands = _b.wwCommands, markdownParsers = _b.markdownParsers;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: deepMergedCopy(toHTMLRenderers, customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        var wwToDOMAdaptor = new WwToDOMAdaptor(linkAttributes, rendererOptions.customHTMLRenderer);\n        var htmlSchemaMap = createHTMLSchemaMap(rendererOptions.customHTMLRenderer, rendererOptions.sanitizer, wwToDOMAdaptor);\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.mdEditor = new MdEditor(this.eventEmitter, {\n            toastMark: this.toastMark,\n            useCommandShortcut: useCommandShortcut,\n            mdPlugins: mdPlugins,\n        });\n        this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: false, highlight: this.options.previewHighlight }));\n        this.wwEditor = new WysiwygEditor(this.eventEmitter, {\n            toDOMAdaptor: wwToDOMAdaptor,\n            useCommandShortcut: useCommandShortcut,\n            htmlSchemaMap: htmlSchemaMap,\n            linkAttributes: linkAttributes,\n            wwPlugins: wwPlugins,\n            wwNodeViews: wwNodeViews,\n        });\n        this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, toMarkdownRenderers), customMarkdownRenderer), getHTMLRenderConvertors(linkAttributes, rendererOptions.customHTMLRenderer), this.eventEmitter);\n        this.setMinHeight(this.options.minHeight);\n        this.setHeight(this.options.height);\n        this.setMarkdown(this.options.initialValue, false);\n        if (this.options.placeholder) {\n            this.setPlaceholder(this.options.placeholder);\n        }\n        if (!this.options.initialValue) {\n            this.setHTML(this.initialHTML, false);\n        }\n        this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function () { return _this.mode; });\n        if (this.options.usageStatistics) {\n            sendHostName();\n        }\n        this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter);\n        this.addInitEvent();\n        this.addInitCommand(mdCommands, wwCommands);\n        buildQuery(this);\n        if (this.options.hooks) {\n            forEachOwnProperties_1(this.options.hooks, function (fn, key) { return _this.addHook(key, fn); });\n        }\n        if (this.options.events) {\n            forEachOwnProperties_1(this.options.events, function (fn, key) { return _this.on(key, fn); });\n        }\n        this.eventEmitter.emit('load', this);\n        this.moveCursorToStart(this.options.autofocus);\n    }\n    ToastUIEditorCore.prototype.addInitEvent = function () {\n        var _this = this;\n        this.on('needChangeMode', this.changeMode.bind(this));\n        this.on('loadUI', function () {\n            if (_this.height !== 'auto') {\n                // 75px equals default editor ui height - the editing area height\n                var minHeight = Math.min(parseInt(_this.minHeight, 10), parseInt(_this.height, 10) - 75) + \"px\";\n                _this.setMinHeight(minHeight);\n            }\n        });\n        addDefaultImageBlobHook(this.eventEmitter);\n    };\n    ToastUIEditorCore.prototype.addInitCommand = function (mdCommands, wwCommands) {\n        var _this = this;\n        var addPluginCommands = function (type, commandMap) {\n            Object.keys(commandMap).forEach(function (name) {\n                _this.addCommand(type, name, commandMap[name]);\n            });\n        };\n        this.addCommand('markdown', 'toggleScrollSync', function (payload) {\n            _this.eventEmitter.emit('toggleScrollSync', payload.active);\n            return true;\n        });\n        addPluginCommands('markdown', mdCommands);\n        addPluginCommands('wysiwyg', wwCommands);\n    };\n    ToastUIEditorCore.prototype.getCurrentModeEditor = function () {\n        return (this.isMarkdownMode() ? this.mdEditor : this.wwEditor);\n    };\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditorCore or ToastUIEditorViewer\n     */\n    ToastUIEditorCore.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditorCore(options);\n    };\n    /**\n     * Set language\n     * @param {string|string[]} code - code for I18N language\n     * @param {object} data - language set\n     */\n    ToastUIEditorCore.setLanguage = function (code, data) {\n        i18n.setLanguage(code, data);\n    };\n    /**\n     * change preview style\n     * @param {string} style - 'tab'|'vertical'\n     */\n    ToastUIEditorCore.prototype.changePreviewStyle = function (style) {\n        if (this.mdPreviewStyle !== style) {\n            this.mdPreviewStyle = style;\n            this.eventEmitter.emit('changePreviewStyle', style);\n        }\n    };\n    /**\n     * execute editor command\n     * @param {string} name - command name\n     * @param {object} [payload] - payload for command\n     */\n    ToastUIEditorCore.prototype.exec = function (name, payload) {\n        this.commandManager.exec(name, payload);\n    };\n    /**\n     * @param {string} type - editor type\n     * @param {string} name - command name\n     * @param {function} command - command handler\n     */\n    ToastUIEditorCore.prototype.addCommand = function (type, name, command) {\n        var _this = this;\n        var commandHoc = function (paylaod) {\n            if (paylaod === void 0) { paylaod = {}; }\n            var view = (type === 'markdown' ? _this.mdEditor : _this.wwEditor).view;\n            command(paylaod, view.state, view.dispatch, view);\n        };\n        this.commandManager.addCommand(type, name, commandHoc);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorCore.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove hook from TUIEditor event\n     * @param {string} type Event type\n     */\n    ToastUIEditorCore.prototype.removeHook = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Set focus to current Editor\n     */\n    ToastUIEditorCore.prototype.focus = function () {\n        this.getCurrentModeEditor().focus();\n    };\n    /**\n     * Remove focus of current Editor\n     */\n    ToastUIEditorCore.prototype.blur = function () {\n        this.getCurrentModeEditor().blur();\n    };\n    /**\n     * Set cursor position to end\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToEnd = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToEnd(focus);\n    };\n    /**\n     * Set cursor position to start\n     * @param {boolean} [focus] - automatically focus the editor\n     */\n    ToastUIEditorCore.prototype.moveCursorToStart = function (focus) {\n        if (focus === void 0) { focus = true; }\n        this.getCurrentModeEditor().moveCursorToStart(focus);\n    };\n    /**\n     * Set markdown syntax text.\n     * @param {string} markdown - markdown syntax text.\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setMarkdown = function (markdown, cursorToEnd) {\n        if (markdown === void 0) { markdown = ''; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        this.mdEditor.setMarkdown(markdown, cursorToEnd);\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Set html value.\n     * @param {string} html - html syntax text\n     * @param {boolean} [cursorToEnd=true] - move cursor to contents end\n     */\n    ToastUIEditorCore.prototype.setHTML = function (html, cursorToEnd) {\n        if (html === void 0) { html = ''; }\n        if (cursorToEnd === void 0) { cursorToEnd = true; }\n        var container = document.createElement('div');\n        // the `br` tag should be replaced with empty block to separate between blocks\n        container.innerHTML = replaceBRWithEmptyBlock(html);\n        var wwNode = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(this.wwEditor.schema).parse(container);\n        if (this.isMarkdownMode()) {\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), cursorToEnd);\n        }\n        else {\n            this.wwEditor.setModel(wwNode, cursorToEnd);\n        }\n    };\n    /**\n     * Get content to markdown\n     * @returns {string} markdown text\n     */\n    ToastUIEditorCore.prototype.getMarkdown = function () {\n        if (this.isMarkdownMode()) {\n            return this.mdEditor.getMarkdown();\n        }\n        return this.convertor.toMarkdownText(this.wwEditor.getModel());\n    };\n    /**\n     * Get content to html\n     * @returns {string} html string\n     */\n    ToastUIEditorCore.prototype.getHTML = function () {\n        var _this = this;\n        this.eventEmitter.holdEventInvoke(function () {\n            if (_this.isMarkdownMode()) {\n                var mdNode = _this.toastMark.getRootNode();\n                var wwNode = _this.convertor.toWysiwygModel(mdNode);\n                _this.wwEditor.setModel(wwNode);\n            }\n        });\n        var html = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);\n        if (this.placeholder) {\n            var rePlaceholder = new RegExp(\"<span class=\\\"placeholder[^>]+>\" + this.placeholder + \"</span>\", 'i');\n            return html.replace(rePlaceholder, '');\n        }\n        return html;\n    };\n    /**\n     * Insert text\n     * @param {string} text - text content\n     */\n    ToastUIEditorCore.prototype.insertText = function (text) {\n        this.getCurrentModeEditor().replaceSelection(text);\n    };\n    /**\n     * Set selection range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     */\n    ToastUIEditorCore.prototype.setSelection = function (start, end) {\n        this.getCurrentModeEditor().setSelection(start, end);\n    };\n    /**\n     * Replace selection range with given text content\n     * @param {string} text - text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.replaceSelection = function (text, start, end) {\n        this.getCurrentModeEditor().replaceSelection(text, start, end);\n    };\n    /**\n     * Delete the content of selection range\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     */\n    ToastUIEditorCore.prototype.deleteSelection = function (start, end) {\n        this.getCurrentModeEditor().deleteSelection(start, end);\n    };\n    /**\n     * Get selected text content\n     * @param {number|Array.<number>} [start] - start position\n     * @param {number|Array.<number>} [end] - end position\n     * @returns {string} - selected text content\n     */\n    ToastUIEditorCore.prototype.getSelectedText = function (start, end) {\n        return this.getCurrentModeEditor().getSelectedText(start, end);\n    };\n    /**\n     * Get range of the node\n     * @param {number|Array.<number>} [pos] - position\n     * @returns {Array.<number[]>|Array.<number>} - node [start, end] range\n     * @example\n     * // Markdown mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]], type: 'emph' }\n     *\n     * // WYSIWYG mode\n     * const rangeInfo = editor.getRangeInfoOfNode();\n     *\n     * console.log(rangeInfo); // { range: [startCursorOffset, endCursorOffset], type: 'emph' }\n     */\n    ToastUIEditorCore.prototype.getRangeInfoOfNode = function (pos) {\n        return this.getCurrentModeEditor().getRangeInfoOfNode(pos);\n    };\n    /**\n     * Add widget to selection\n     * @param {Node} node - widget node\n     * @param {string} style - Adding style \"top\" or \"bottom\"\n     * @param {number|Array.<number>} [pos] - position\n     */\n    ToastUIEditorCore.prototype.addWidget = function (node, style, pos) {\n        this.getCurrentModeEditor().addWidget(node, style, pos);\n    };\n    /**\n     * Replace node with widget to range\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} text - widget text content\n     */\n    ToastUIEditorCore.prototype.replaceWithWidget = function (start, end, text) {\n        this.getCurrentModeEditor().replaceWithWidget(start, end, text);\n    };\n    /**\n     * Set editor height\n     * @param {string} height - editor height in pixel\n     */\n    ToastUIEditorCore.prototype.setHeight = function (height) {\n        var el = this.options.el;\n        if (isString_1(height)) {\n            if (height === 'auto') {\n                addClass_1(el, 'auto-height');\n            }\n            else {\n                removeClass_1(el, 'auto-height');\n            }\n            this.setMinHeight(this.getMinHeight());\n        }\n        css_1(el, { height: height });\n        this.height = height;\n    };\n    /**\n     * Get editor height\n     * @returns {string} editor height in pixel\n     */\n    ToastUIEditorCore.prototype.getHeight = function () {\n        return this.height;\n    };\n    /**\n     * Set minimum height to editor content\n     * @param {string} minHeight - min content height in pixel\n     */\n    ToastUIEditorCore.prototype.setMinHeight = function (minHeight) {\n        if (minHeight !== this.minHeight) {\n            var height = this.height || this.options.height;\n            if (height !== 'auto' && this.options.el.querySelector(\".\" + cls('main'))) {\n                // 75px equals default editor ui height - the editing area height\n                minHeight = Math.min(parseInt(minHeight, 10), parseInt(height, 10) - 75) + \"px\";\n            }\n            var minHeightNum = parseInt(minHeight, 10);\n            this.minHeight = minHeight;\n            this.wwEditor.setMinHeight(minHeightNum);\n            this.mdEditor.setMinHeight(minHeightNum);\n            this.preview.setMinHeight(minHeightNum);\n        }\n    };\n    /**\n     * Get minimum height of editor content\n     * @returns {string} min height in pixel\n     */\n    ToastUIEditorCore.prototype.getMinHeight = function () {\n        return this.minHeight;\n    };\n    /**\n     * Return true if current editor mode is Markdown\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isMarkdownMode = function () {\n        return this.mode === 'markdown';\n    };\n    /**\n     * Return true if current editor mode is WYSIWYG\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isWysiwygMode = function () {\n        return this.mode === 'wysiwyg';\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorCore.prototype.isViewer = function () {\n        return false;\n    };\n    /**\n     * Get current Markdown editor's preview style\n     * @returns {string}\n     */\n    ToastUIEditorCore.prototype.getCurrentPreviewStyle = function () {\n        return this.mdPreviewStyle;\n    };\n    /**\n     * Change editor's mode to given mode string\n     * @param {string} mode - Editor mode name of want to change\n     * @param {boolean} [withoutFocus] - Change mode without focus\n     */\n    ToastUIEditorCore.prototype.changeMode = function (mode, withoutFocus) {\n        if (this.mode === mode) {\n            return;\n        }\n        this.mode = mode;\n        if (this.isWysiwygMode()) {\n            var mdNode = this.toastMark.getRootNode();\n            var wwNode = this.convertor.toWysiwygModel(mdNode);\n            this.wwEditor.setModel(wwNode);\n        }\n        else {\n            var wwNode = this.wwEditor.getModel();\n            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), !withoutFocus);\n        }\n        this.eventEmitter.emit('removePopupWidget');\n        this.eventEmitter.emit('changeMode', mode);\n        if (!withoutFocus) {\n            var pos = this.convertor.getMappedPos();\n            this.focus();\n            if (this.isWysiwygMode() && isNumber_1(pos)) {\n                this.wwEditor.setSelection(pos);\n            }\n            else if (Array.isArray(pos)) {\n                this.mdEditor.setSelection(pos);\n            }\n        }\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditorCore.prototype.destroy = function () {\n        var _this = this;\n        this.wwEditor.destroy();\n        this.mdEditor.destroy();\n        this.preview.destroy();\n        this.scrollSync.destroy();\n        this.eventEmitter.emit('destroy');\n        this.eventEmitter.getEvents().forEach(function (_, type) { return _this.off(type); });\n    };\n    /**\n     * Hide TUIEditor\n     */\n    ToastUIEditorCore.prototype.hide = function () {\n        this.eventEmitter.emit('hide');\n    };\n    /**\n     * Show TUIEditor\n     */\n    ToastUIEditorCore.prototype.show = function () {\n        this.eventEmitter.emit('show');\n    };\n    /**\n     * Move on scroll position of the editor container\n     * @param {number} value scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.setScrollTop = function (value) {\n        this.getCurrentModeEditor().setScrollTop(value);\n    };\n    /**\n     * Get scroll position value of editor container\n     * @returns {number} scrollTop value of editor container\n     */\n    ToastUIEditorCore.prototype.getScrollTop = function () {\n        return this.getCurrentModeEditor().getScrollTop();\n    };\n    /**\n     * Reset TUIEditor\n     */\n    ToastUIEditorCore.prototype.reset = function () {\n        this.wwEditor.setModel([]);\n        this.mdEditor.setMarkdown('');\n    };\n    /**\n     * Get current selection range\n     * @returns {Array.<number[]>|Array.<number>} Returns the range of the selection depending on the editor mode\n     * @example\n     * // Markdown mode\n     * const mdSelection = editor.getSelection();\n     *\n     * console.log(mdSelection); // [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]]\n     *\n     * // WYSIWYG mode\n     * const wwSelection = editor.getSelection();\n     *\n     * console.log(wwSelection); // [startCursorOffset, endCursorOffset]\n     */\n    ToastUIEditorCore.prototype.getSelection = function () {\n        return this.getCurrentModeEditor().getSelection();\n    };\n    /**\n     * Set the placeholder on all editors\n     * @param {string} placeholder - placeholder to set\n     */\n    ToastUIEditorCore.prototype.setPlaceholder = function (placeholder) {\n        this.placeholder = placeholder;\n        this.mdEditor.setPlaceholder(placeholder);\n        this.wwEditor.setPlaceholder(placeholder);\n    };\n    /**\n     * Get markdown editor, preview, wysiwyg editor DOM elements\n     */\n    ToastUIEditorCore.prototype.getEditorElements = function () {\n        return {\n            mdEditor: this.mdEditor.getElement(),\n            mdPreview: this.preview.getElement(),\n            wwEditor: this.wwEditor.getElement(),\n        };\n    };\n    /**\n     * Convert position to match editor mode\n     * @param {number|Array.<number>} start - start position\n     * @param {number|Array.<number>} end - end position\n     * @param {string} mode - Editor mode name of want to match converted position to\n     */\n    ToastUIEditorCore.prototype.convertPosToMatchEditorMode = function (start, end, mode) {\n        var _a, _b;\n        if (end === void 0) { end = start; }\n        if (mode === void 0) { mode = this.mode; }\n        var doc = this.mdEditor.view.state.doc;\n        var isFromArray = Array.isArray(start);\n        var isToArray = Array.isArray(end);\n        var convertedFrom = start;\n        var convertedTo = end;\n        if (isFromArray !== isToArray) {\n            throw new Error('Types of arguments must be same');\n        }\n        if (mode === 'markdown' && !isFromArray && !isToArray) {\n            _a = getEditorToMdPos(doc, start, end), convertedFrom = _a[0], convertedTo = _a[1];\n        }\n        else if (mode === 'wysiwyg' && isFromArray && isToArray) {\n            _b = getMdToEditorPos(doc, start, end), convertedFrom = _b[0], convertedTo = _b[1];\n        }\n        return [convertedFrom, convertedTo];\n    };\n    return ToastUIEditorCore;\n}());\n\n// @TODO: change syntax with our convention\n/* eslint-disable */\nfunction html$1 (n) {\n  for (\n    var l,\n      e,\n      s = arguments,\n      t = 1,\n      r = '',\n      u = '',\n      a = [0],\n      c = function (n) {\n        t === 1 && (n || (r = r.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g, '')))\n          ? a.push(n ? s[n] : r)\n          : t === 3 && (n || r)\n          ? ((a[1] = n ? s[n] : r), (t = 2))\n          : t === 2 && r === '...' && n\n          ? (a[2] = assign(a[2] || {}, s[n]))\n          : t === 2 && r && !n\n          ? ((a[2] = a[2] || {})[r] = !0)\n          : t >= 5 &&\n            (t === 5\n              ? (((a[2] = a[2] || {})[e] = n ? (r ? r + s[n] : s[n]) : r), (t = 6))\n              : (n || r) && (a[2][e] += n ? r + s[n] : r)),\n          (r = '');\n      },\n      h = 0;\n    h < n.length;\n    h++\n  ) {\n    h && (t === 1 && c(), c(h));\n    for (let i = 0; i < n[h].length; i++)\n      (l = n[h][i]),\n        t === 1\n          ? l === '<'\n            ? (c(), (a = [a, '', null]), (t = 3))\n            : (r += l)\n          : t === 4\n          ? r === '--' && l === '>'\n            ? ((t = 1), (r = ''))\n            : (r = l + r[0])\n          : u\n          ? l === u\n            ? (u = '')\n            : (r += l)\n          : l === '\"' || l === \"'\"\n          ? (u = l)\n          : l === '>'\n          ? (c(), (t = 1))\n          : t &&\n            (l === '='\n              ? ((t = 5), (e = r), (r = ''))\n              : l === '/' && (t < 5 || n[h][i + 1] === '>')\n              ? (c(),\n                t === 3 && (a = a[0]),\n                (t = a),\n                (a = a[0]).push(this.apply(null, t.slice(1))),\n                (t = 0))\n              : l === ' ' || l === '\\t' || l === '\\n' || l === '\\r'\n              ? (c(), (t = 2))\n              : (r += l)),\n        t === 3 && r === '!--' && ((t = 4), (a = a[0]));\n  }\n  return c(), a.length > 2 ? a.slice(1) : a[1];\n}\n\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is a boolean or not.\n *  If the given variable is a boolean, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is boolean?\n * @memberof module:type\n */\nfunction isBoolean(obj) {\n  return typeof obj === 'boolean' || obj instanceof Boolean;\n}\n\nvar isBoolean_1 = isBoolean;\n\nvar VNodeWalker = /** @class */ (function () {\n    function VNodeWalker(current) {\n        this.current = current;\n        this.root = current;\n        this.entering = true;\n    }\n    VNodeWalker.prototype.walk = function () {\n        var _a = this, entering = _a.entering, cur = _a.current;\n        if (!cur) {\n            return null;\n        }\n        if (entering) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next) {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        else {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        return { vnode: cur, entering: entering };\n    };\n    return VNodeWalker;\n}());\nvar VNode = /** @class */ (function () {\n    function VNode(type, props, children) {\n        this.parent = null;\n        this.old = null;\n        this.firstChild = null;\n        this.next = null;\n        this.skip = false;\n        this.type = type;\n        this.props = props;\n        this.children = children;\n        this.props.children = children;\n        if (props.ref) {\n            this.ref = props.ref;\n            delete props.ref;\n        }\n        if (props.key) {\n            this.key = props.key;\n            delete props.key;\n        }\n    }\n    VNode.prototype.walker = function () {\n        return new VNodeWalker(this);\n    };\n    VNode.removalNodes = [];\n    return VNode;\n}());\n\nfunction createTextNode(text) {\n    return new VNode('TEXT_NODE', { nodeValue: text }, []);\n}\nfunction excludeUnnecessaryChild(child, flatted) {\n    var vnode = child;\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    if (isBoolean_1(child) || child == null) {\n        vnode = null;\n    }\n    else if (isString_1(child) || isNumber_1(child)) {\n        vnode = createTextNode(String(child));\n    }\n    if (vnode) {\n        flatted.push(vnode);\n    }\n}\nfunction h(type, props) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    var flatted = [];\n    children.forEach(function (child) {\n        if (Array.isArray(child)) {\n            child.forEach(function (vnode) {\n                excludeUnnecessaryChild(vnode, flatted);\n            });\n        }\n        else {\n            excludeUnnecessaryChild(child, flatted);\n        }\n    });\n    return new VNode(type, props || {}, flatted);\n}\n// @ts-ignore\nvar html = html$1.bind(h);\n\n/**\n * @fileoverview Check whether the given variable is an object or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n/**\n * Check whether the given variable is an object or not.\n * If the given variable is an object, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is object?\n * @memberof module:type\n */\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\nvar isObject_1 = isObject;\n\n// @TODO: clearfy the type definition for CSSDeclaration\nfunction createNode(vnode) {\n    var node;\n    if (vnode.type === 'TEXT_NODE') {\n        node = document.createTextNode(vnode.props.nodeValue);\n    }\n    else {\n        node = document.createElement(vnode.type);\n        setProps(node, {}, vnode.props);\n    }\n    return node;\n}\nfunction removeNode(vnode, parentNode) {\n    if (vnode.node) {\n        parentNode.removeChild(vnode.node);\n    }\n    else {\n        removeNode(vnode.firstChild, parentNode);\n    }\n}\nfunction innerDiff(node, prevProps, nextProps) {\n    Object.keys(prevProps).forEach(function (propName) {\n        if (/^on/.test(propName)) {\n            if (!nextProps[propName] || prevProps[propName] !== nextProps[propName]) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.removeEventListener(eventName, prevProps[propName]);\n            }\n        }\n        else if (propName !== 'children' && !nextProps[propName] && !isTextNode(node)) {\n            node.removeAttribute(propName);\n        }\n    });\n    setProps(node, prevProps, nextProps, function (propName) { return !shallowEqual(prevProps[propName], nextProps[propName]); });\n}\nvar reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\nfunction setProps(node, prevProps, props, condition) {\n    Object.keys(props).forEach(function (propName) {\n        if (!condition || condition(propName)) {\n            if (/^on/.test(propName)) {\n                var eventName = propName.slice(2).toLowerCase();\n                node.addEventListener(eventName, props[propName]);\n            }\n            else if (propName === 'nodeValue') {\n                node[propName] = props[propName];\n            }\n            else if (propName === 'style' && isObject_1(props[propName])) {\n                setStyleProps(node, prevProps[propName], props[propName]);\n            }\n            else if (propName !== 'children') {\n                if (props[propName] === false) {\n                    node.removeAttribute(propName);\n                }\n                else {\n                    node.setAttribute(propName, props[propName]);\n                }\n            }\n        }\n    });\n}\nfunction setStyleProps(node, prevStyleProps, styleProps) {\n    if (prevStyleProps) {\n        Object.keys(prevStyleProps).forEach(function (styleProp) {\n            // @ts-ignore\n            node.style[styleProp] = '';\n        });\n    }\n    Object.keys(styleProps).forEach(function (styleProp) {\n        var value = styleProps[styleProp];\n        // @ts-ignore\n        node.style[styleProp] =\n            isNumber_1(value) && !reNonDimension.test(styleProp) ? value + \"px\" : value;\n    });\n}\n\nfunction commit(vnode) {\n    VNode.removalNodes.forEach(function (removalNode) { return diff(removalNode); });\n    if (vnode) {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (next.entering) {\n                diff(vnode);\n            }\n            else if (isFunction_1(vnode.type)) {\n                var comp = vnode.component;\n                // lifecycle method\n                if (!vnode.old && comp.mounted) {\n                    comp.mounted();\n                }\n                if (vnode.old && comp.updated) {\n                    var prevProps = comp.prevProps || {};\n                    comp.updated(prevProps);\n                }\n            }\n        }\n    }\n}\nfunction getParentNode(vnode) {\n    var parent = vnode.parent;\n    while (!parent.node) {\n        parent = parent.parent;\n    }\n    return parent.node;\n}\nfunction diff(vnode) {\n    if (!vnode || !vnode.parent) {\n        return;\n    }\n    if (vnode.node) {\n        var parentNode = getParentNode(vnode);\n        if (vnode.effect === 'A') {\n            parentNode.appendChild(vnode.node);\n        }\n        else if (vnode.effect === 'U') {\n            innerDiff(vnode.node, vnode.old.props, vnode.props);\n        }\n    }\n    if (vnode.effect === 'D') {\n        var next = void 0;\n        var walker = vnode.walker();\n        while ((next = walker.walk())) {\n            vnode = next.vnode;\n            if (!next.entering) {\n                if (isFunction_1(vnode.type)) {\n                    var comp = vnode.component;\n                    // lifecycle method\n                    if (comp.beforeDestroy) {\n                        comp.beforeDestroy();\n                    }\n                }\n                else {\n                    var parentNode = getParentNode(vnode);\n                    removeNode(vnode, parentNode);\n                }\n            }\n        }\n    }\n    // apply ref\n    if (vnode.ref) {\n        if (vnode.component) {\n            vnode.ref(vnode.component);\n        }\n        else if (vnode.node) {\n            vnode.ref(vnode.node);\n        }\n    }\n}\n\nfunction createComponent(Comp, vnode) {\n    var props = vnode.props, component = vnode.component;\n    if (component) {\n        component.prevProps = component.props;\n        component.props = vnode.props;\n        return component;\n    }\n    return new Comp(props);\n}\nfunction buildVNode(vnode) {\n    var root = vnode;\n    while (vnode && !vnode.skip) {\n        if (isFunction_1(vnode.type)) {\n            var instance = createComponent(vnode.type, vnode);\n            instance.vnode = vnode;\n            vnode.component = instance;\n            vnode.props.children = vnode.children = [instance.render()];\n            buildChildrenVNode(vnode);\n        }\n        else {\n            if (!vnode.node) {\n                vnode.node = createNode(vnode);\n            }\n            buildChildrenVNode(vnode);\n        }\n        if (vnode.firstChild) {\n            vnode = vnode.firstChild;\n        }\n        else {\n            while (vnode && vnode.parent && !vnode.next) {\n                vnode = vnode.parent;\n                if (vnode === root) {\n                    break;\n                }\n            }\n            vnode = vnode.next;\n        }\n    }\n}\nfunction isSameType(old, vnode) {\n    return old && vnode && vnode.type === old.type && (!vnode.key || vnode.key === old.key);\n}\n// @TODO: add key diff algorithm\nfunction buildChildrenVNode(parent) {\n    var children = parent.children;\n    var old = parent.old ? parent.old.firstChild : null;\n    var prev = null;\n    children.forEach(function (vnode, index) {\n        var sameType = isSameType(old, vnode);\n        if (sameType) {\n            vnode.old = old;\n            vnode.parent = parent;\n            vnode.node = old.node;\n            vnode.component = old.component;\n            vnode.effect = 'U';\n        }\n        if (vnode && !sameType) {\n            vnode.old = null;\n            vnode.parent = parent;\n            vnode.node = null;\n            vnode.effect = 'A';\n        }\n        if (old && !sameType) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n        }\n        if (old) {\n            old = old.next;\n        }\n        if (index === 0) {\n            parent.firstChild = vnode;\n        }\n        else if (vnode) {\n            prev.next = vnode;\n        }\n        prev = vnode;\n    });\n    var lastChild = last$1(children);\n    if (!children.length) {\n        while (old) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n            old = old.next;\n        }\n    }\n    while (old && lastChild) {\n        if (old && lastChild.old !== old) {\n            VNode.removalNodes.push(old);\n            old.effect = 'D';\n            old = old.next;\n        }\n    }\n}\n\nfunction destroy(vnode) {\n    vnode.effect = 'D';\n    VNode.removalNodes = [vnode];\n    commit();\n    VNode.removalNodes = [];\n}\nfunction rerender(comp) {\n    var root = comp.vnode;\n    root.effect = 'U';\n    root.old = root;\n    // skip for unnecessary reconciliation\n    if (root.next) {\n        root.next.skip = true;\n    }\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    if (root.next) {\n        root.next.skip = false;\n    }\n}\nfunction render(container, vnode) {\n    var root = new VNode(container.tagName.toLowerCase(), {}, [vnode]);\n    root.node = container;\n    VNode.removalNodes = [];\n    buildVNode(root);\n    commit(root);\n    return function () { return destroy(root.firstChild); };\n}\n\nvar Component = /** @class */ (function () {\n    function Component(props) {\n        this.props = props;\n        this.state = {};\n        this.refs = {};\n    }\n    Component.prototype.setState = function (state) {\n        var newState = __assign$1(__assign$1({}, this.state), state);\n        if (!shallowEqual(this.state, newState)) {\n            this.state = newState;\n            rerender(this);\n        }\n    };\n    return Component;\n}());\n\nvar Switch = /** @class */ (function (_super) {\n    __extends$1(Switch, _super);\n    function Switch(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            hide: false,\n        };\n        return _this;\n    }\n    Switch.prototype.show = function () {\n        this.setState({ hide: false });\n    };\n    Switch.prototype.hide = function () {\n        this.setState({ hide: true });\n    };\n    Switch.prototype.render = function () {\n        var _a = this.props, editorType = _a.editorType, eventEmitter = _a.eventEmitter;\n        return html(templateObject_1$h || (templateObject_1$h = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\\\"display: \", \"\\\">\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\", \"\\n        >\\n          \", \"\\n        </div>\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\", \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\\\"display: \", \"\\\">\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\",\n            \"\\n        >\\n          \", \"\\n        </div>\\n        <div\\n          class=\\\"tab-item\", \"\\\"\\n          onClick=\",\n            \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"])), cls('mode-switch'), this.state.hide ? 'none' : 'block', editorType === 'markdown' ? ' active' : '', function () {\n            eventEmitter.emit('needChangeMode', 'markdown');\n        }, i18n.get('Markdown'), editorType === 'wysiwyg' ? ' active' : '', function () {\n            eventEmitter.emit('needChangeMode', 'wysiwyg');\n        }, i18n.get('WYSIWYG'));\n    };\n    return Switch;\n}(Component));\nvar templateObject_1$h;\n\n/**\n * @fileoverview Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed since the last time the debouced function was invoked.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\n/**\n * @module tricks\n */\n\n/**\n * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed\n * since the last time the debouced function was invoked.\n * @param {function} fn The function to debounce.\n * @param {number} [delay=0] The number of milliseconds to delay\n * @returns {function} debounced function.\n * @memberof module:tricks\n * @example\n * // ES6\n * import debounce from 'tui-code-snippet/tricks/debounce';\n * \n * // CommonJS\n * const debounce = require('tui-code-snippet/tricks/debounce');\n *\n * function someMethodToInvokeDebounced() {}\n *\n * const debounced = debounce(someMethodToInvokeDebounced, 300);\n *\n * // invoke repeatedly\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();\n * debounced();    // last invoke of debounced()\n *\n * // invoke someMethodToInvokeDebounced() after 300 milliseconds.\n */\nfunction debounce$1(fn, delay) {\n  var timer, args;\n\n  /* istanbul ignore next */\n  delay = delay || 0;\n\n  function debounced() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    window.clearTimeout(timer);\n    timer = window.setTimeout(function() {\n      fn.apply(null, args);\n    }, delay);\n  }\n\n  return debounced;\n}\n\nvar debounce_1 = debounce$1;\n\n/**\n * @fileoverview Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * @author NHN FE Development Lab <dl_javascript.nhn.com>\n */\n\nvar debounce = debounce_1;\n\n/**\n * Creates a throttled function that only invokes fn at most once per every interval milliseconds.\n * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)\n * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.\n * @param {function} fn function to throttle\n * @param {number} [interval=0] the number of milliseconds to throttle invocations to.\n * @returns {function} throttled function\n * @memberof module:tricks\n * @example\n * // ES6\n * import throttle from 'tui-code-snippet/tricks/throttle';\n * \n * // CommonJS\n * const throttle = require('tui-code-snippet/tricks/throttle');\n *\n * function someMethodToInvokeThrottled() {}\n *\n * const throttled = throttle(someMethodToInvokeThrottled, 300);\n *\n * // invoke repeatedly\n * throttled();    // invoke (leading)\n * throttled();\n * throttled();    // invoke (near 300 milliseconds)\n * throttled();\n * throttled();\n * throttled();    // invoke (near 600 milliseconds)\n * // ...\n * // invoke (trailing)\n *\n * // if you need reuse throttled method. then invoke reset()\n * throttled.reset();\n */\nfunction throttle$1(fn, interval) {\n  var base;\n  var isLeading = true;\n  var tick = function(_args) {\n    fn.apply(null, _args);\n    base = null;\n  };\n  var debounced, stamp, args;\n\n  /* istanbul ignore next */\n  interval = interval || 0;\n\n  debounced = debounce(tick, interval);\n\n  function throttled() { // eslint-disable-line require-jsdoc\n    args = Array.prototype.slice.call(arguments);\n\n    if (isLeading) {\n      tick(args);\n      isLeading = false;\n\n      return;\n    }\n\n    stamp = Number(new Date());\n\n    base = base || stamp;\n\n    // pass array directly because `debounce()`, `tick()` are already use\n    // `apply()` method to invoke developer's `fn` handler.\n    //\n    // also, this `debounced` line invoked every time for implements\n    // `trailing` features.\n    debounced(args);\n\n    if ((stamp - base) >= interval) {\n      tick(args);\n    }\n  }\n\n  function reset() { // eslint-disable-line require-jsdoc\n    isLeading = true;\n    base = null;\n  }\n\n  throttled.reset = reset;\n\n  return throttled;\n}\n\nvar throttle_1 = throttle$1;\n\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nvar HeadingPopupBody = /** @class */ (function (_super) {\n    __extends$1(HeadingPopupBody, _super);\n    function HeadingPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    HeadingPopupBody.prototype.execCommand = function (ev) {\n        var el = closest(ev.target, 'li');\n        this.props.execCommand('heading', {\n            level: Number(el.getAttribute('data-level')),\n        });\n    };\n    HeadingPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject([\"\\n      <ul\\n        onClick=\", \"\\n        aria-role=\\\"menu\\\"\\n        aria-label=\\\"\", \"\\\"\\n      >\\n        \", \"\\n        <li data-type=\\\"Paragraph\\\" aria-role=\\\"menuitem\\\">\\n          <div>\", \"</div>\\n        </li>\\n      </ul>\\n    \"], [\"\\n      <ul\\n        onClick=\", \"\\n        aria-role=\\\"menu\\\"\\n        aria-label=\\\"\", \"\\\"\\n      >\\n        \",\n            \"\\n        <li data-type=\\\"Paragraph\\\" aria-role=\\\"menuitem\\\">\\n          <div>\", \"</div>\\n        </li>\\n      </ul>\\n    \"])), function (ev) { return _this.execCommand(ev); }, i18n.get('Headings'), [1, 2, 3, 4, 5, 6].map(function (level) {\n            return html(templateObject_1$g || (templateObject_1$g = __makeTemplateObject([\"\\n              <li data-level=\\\"\", \"\\\" data-type=\\\"Heading\\\" aria-role=\\\"menuitem\\\">\\n                <\", \">\", \" \", \"</$>\\n              </li>\\n            \"], [\"\\n              <li data-level=\\\"\", \"\\\" data-type=\\\"Heading\\\" aria-role=\\\"menuitem\\\">\\n                <\", \">\", \" \", \"</$>\\n              </li>\\n            \"])), level, \"h\" + level, i18n.get('Heading'), level);\n        }), i18n.get('Paragraph'));\n    };\n    return HeadingPopupBody;\n}(Component));\nvar templateObject_1$g, templateObject_2$8;\n\nvar Tabs = /** @class */ (function (_super) {\n    __extends$1(Tabs, _super);\n    function Tabs() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Tabs.prototype.toggleTab = function (ev, activeTab) {\n        this.props.onClick(ev, activeTab);\n    };\n    Tabs.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" aria-role=\\\"tabpanel\\\">\\n        \", \"\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" aria-role=\\\"tabpanel\\\">\\n        \",\n            \"\\n      </div>\\n    \"])), cls('tabs'), this.props.tabs.map(function (_a) {\n            var name = _a.name, text = _a.text;\n            var isActive = _this.props.activeTab === name;\n            return html(templateObject_1$f || (templateObject_1$f = __makeTemplateObject([\"\\n            <div\\n              class=\\\"tab-item\", \"\\\"\\n              onClick=\", \"\\n              aria-role=\\\"tab\\\"\\n              aria-label=\\\"\", \"\\\"\\n              aria-selected=\\\"\", \"\\\"\\n              tabindex=\\\"\", \"\\\"\\n            >\\n              \", \"\\n            </div>\\n          \"], [\"\\n            <div\\n              class=\\\"tab-item\", \"\\\"\\n              onClick=\", \"\\n              aria-role=\\\"tab\\\"\\n              aria-label=\\\"\", \"\\\"\\n              aria-selected=\\\"\", \"\\\"\\n              tabindex=\\\"\", \"\\\"\\n            >\\n              \", \"\\n            </div>\\n          \"])), isActive ? ' active' : '', function (ev) { return _this.toggleTab(ev, name); }, i18n.get(text), isActive ? 'true' : 'false', isActive ? '0' : '-1', i18n.get(text));\n        }));\n    };\n    return Tabs;\n}(Component));\nvar templateObject_1$f, templateObject_2$7;\n\nvar TYPE_UI = 'ui';\nvar ImagePopupBody = /** @class */ (function (_super) {\n    __extends$1(ImagePopupBody, _super);\n    function ImagePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.initialize = function (activeTab) {\n            if (activeTab === void 0) { activeTab = 'file'; }\n            var urlEl = _this.refs.url;\n            urlEl.value = '';\n            _this.refs.altText.value = '';\n            _this.refs.file.value = '';\n            removeClass_1(urlEl, 'wrong');\n            _this.setState({ activeTab: activeTab, file: null, fileNameElClassName: '' });\n        };\n        _this.execCommand = function () {\n            if (_this.state.activeTab === 'file') {\n                _this.emitAddImageBlob();\n            }\n            else {\n                _this.emitAddImage();\n            }\n        };\n        _this.toggleTab = function (_, activeTab) {\n            if (activeTab !== _this.state.activeTab) {\n                _this.initialize(activeTab);\n            }\n        };\n        _this.showFileSelectBox = function () {\n            _this.refs.file.click();\n        };\n        _this.changeFile = function (ev) {\n            var files = ev.target.files;\n            if (files === null || files === void 0 ? void 0 : files.length) {\n                _this.setState({ file: files[0] });\n            }\n        };\n        _this.state = { activeTab: 'file', file: null, fileNameElClassName: '' };\n        _this.tabs = [\n            { name: 'file', text: 'File' },\n            { name: 'url', text: 'URL' },\n        ];\n        return _this;\n    }\n    ImagePopupBody.prototype.emitAddImageBlob = function () {\n        var _this = this;\n        var files = this.refs.file.files;\n        var altTextEl = this.refs.altText;\n        var fileNameElClassName = ' wrong';\n        if (files === null || files === void 0 ? void 0 : files.length) {\n            fileNameElClassName = '';\n            var imageFile = files.item(0);\n            var hookCallback = function (url, text) {\n                return _this.props.execCommand('addImage', { imageUrl: url, altText: text || altTextEl.value });\n            };\n            this.props.eventEmitter.emit('addImageBlobHook', imageFile, hookCallback, TYPE_UI);\n        }\n        this.setState({ fileNameElClassName: fileNameElClassName });\n    };\n    ImagePopupBody.prototype.emitAddImage = function () {\n        var imageUrlEl = this.refs.url;\n        var altTextEl = this.refs.altText;\n        var imageUrl = imageUrlEl.value;\n        var altText = altTextEl.value || 'image';\n        removeClass_1(imageUrlEl, 'wrong');\n        if (!imageUrl.length) {\n            addClass_1(imageUrlEl, 'wrong');\n            return;\n        }\n        if (imageUrl) {\n            this.props.execCommand('addImage', { imageUrl: imageUrl, altText: altText });\n        }\n    };\n    ImagePopupBody.prototype.preventSelectStart = function (ev) {\n        ev.preventDefault();\n    };\n    ImagePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.initialize();\n        }\n    };\n    ImagePopupBody.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, activeTab = _a.activeTab, file = _a.file, fileNameElClassName = _a.fileNameElClassName;\n        return html(templateObject_1$e || (templateObject_1$e = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        <div style=\\\"display:\", \"\\\">\\n          <label for=\\\"toastuiImageUrlInput\\\">\", \"</label>\\n          <input\\n            id=\\\"toastuiImageUrlInput\\\"\\n            type=\\\"text\\\"\\n            ref=\", \"\\n          />\\n        </div>\\n        <div style=\\\"display:\", \";position: relative;\\\">\\n          <label for=\\\"toastuiImageFileInput\\\">\", \"</label>\\n          <span\\n            class=\\\"\", \"\", \"\\\"\\n            onClick=\", \"\\n            onSelectstart=\", \"\\n          >\\n            \", \"\\n          </span>\\n          <button\\n            type=\\\"button\\\"\\n            class=\\\"\", \"\\\"\\n            onClick=\", \"\\n          >\\n            \", \"\\n          </button>\\n          <input\\n            id=\\\"toastuiImageFileInput\\\"\\n            type=\\\"file\\\"\\n            accept=\\\"image/*\\\"\\n            onChange=\", \"\\n            ref=\", \"\\n          />\\n        </div>\\n        <label for=\\\"toastuiAltTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiAltTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        <div style=\\\"display:\", \"\\\">\\n          <label for=\\\"toastuiImageUrlInput\\\">\", \"</label>\\n          <input\\n            id=\\\"toastuiImageUrlInput\\\"\\n            type=\\\"text\\\"\\n            ref=\", \"\\n          />\\n        </div>\\n        <div style=\\\"display:\", \";position: relative;\\\">\\n          <label for=\\\"toastuiImageFileInput\\\">\", \"</label>\\n          <span\\n            class=\\\"\", \"\", \"\\\"\\n            onClick=\", \"\\n            onSelectstart=\", \"\\n          >\\n            \", \"\\n          </span>\\n          <button\\n            type=\\\"button\\\"\\n            class=\\\"\", \"\\\"\\n            onClick=\", \"\\n          >\\n            \", \"\\n          </button>\\n          <input\\n            id=\\\"toastuiImageFileInput\\\"\\n            type=\\\"file\\\"\\n            accept=\\\"image/*\\\"\\n            onChange=\", \"\\n            ref=\", \"\\n          />\\n        </div>\\n        <label for=\\\"toastuiAltTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiAltTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"])), i18n.get('Insert image'), Tabs, this.tabs, activeTab, this.toggleTab, activeTab === 'url' ? 'block' : 'none', i18n.get('Image URL'), function (el) { return (_this.refs.url = el); }, activeTab === 'file' ? 'block' : 'none', i18n.get('Select image file'), cls('file-name'), file ? ' has-file' : fileNameElClassName, this.showFileSelectBox, this.preventSelectStart, file ? file.name : i18n.get('No file'), cls('file-select-button'), this.showFileSelectBox, i18n.get('Choose a file'), this.changeFile, function (el) { return (_this.refs.file = el); }, i18n.get('Description'), function (el) { return (_this.refs.altText = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));\n    };\n    return ImagePopupBody;\n}(Component));\nvar templateObject_1$e;\n\nvar LinkPopupBody = /** @class */ (function (_super) {\n    __extends$1(LinkPopupBody, _super);\n    function LinkPopupBody() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.execCommand = function () {\n            var linkUrlEl = _this.refs.url;\n            var linkTextEl = _this.refs.text;\n            removeClass_1(linkUrlEl, 'wrong');\n            removeClass_1(linkTextEl, 'wrong');\n            if (linkUrlEl.value.length < 1) {\n                addClass_1(linkUrlEl, 'wrong');\n                return;\n            }\n            var checkLinkText = isUndefined_1(_this.props.initialValues.linkUrl);\n            if (checkLinkText && linkTextEl.value.length < 1) {\n                addClass_1(linkTextEl, 'wrong');\n                return;\n            }\n            _this.props.execCommand('addLink', {\n                linkUrl: linkUrlEl.value,\n                linkText: linkTextEl.value,\n            });\n        };\n        return _this;\n    }\n    LinkPopupBody.prototype.initialize = function () {\n        var _a = this.props.initialValues, linkUrl = _a.linkUrl, linkText = _a.linkText;\n        var linkUrlEl = this.refs.url;\n        var linkTextEl = this.refs.text;\n        removeClass_1(linkUrlEl, 'wrong');\n        removeClass_1(linkTextEl, 'wrong', 'disabled');\n        linkTextEl.removeAttribute('disabled');\n        if (linkUrl) {\n            addClass_1(linkTextEl, 'disabled');\n            linkTextEl.setAttribute('disabled', 'disabled');\n        }\n        linkUrlEl.value = linkUrl || '';\n        linkTextEl.value = linkText || '';\n    };\n    LinkPopupBody.prototype.mounted = function () {\n        this.initialize();\n    };\n    LinkPopupBody.prototype.updated = function (prevProps) {\n        if (!prevProps.show && this.props.show) {\n            this.initialize();\n        }\n    };\n    LinkPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$d || (templateObject_1$d = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <label for=\\\"toastuiLinkUrlInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkUrlInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <label for=\\\"toastuiLinkTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <label for=\\\"toastuiLinkUrlInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkUrlInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <label for=\\\"toastuiLinkTextInput\\\">\", \"</label>\\n        <input\\n          id=\\\"toastuiLinkTextInput\\\"\\n          type=\\\"text\\\"\\n          ref=\", \"\\n        />\\n        <div class=\\\"\", \"\\\">\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n          <button type=\\\"button\\\" class=\\\"\", \"\\\" onClick=\", \">\\n            \", \"\\n          </button>\\n        </div>\\n      </div>\\n    \"])), i18n.get('Insert link'), i18n.get('URL'), function (el) { return (_this.refs.url = el); }, i18n.get('Link text'), function (el) { return (_this.refs.text = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));\n    };\n    return LinkPopupBody;\n}(Component));\nvar templateObject_1$d;\n\nvar CELL_WIDTH = 20;\nvar CELL_HEIGHT = 20;\nvar MIN_ROW_INDEX = 5;\nvar MAX_ROW_INDEX = 14;\nvar MIN_COL_INDEX = 5;\nvar MAX_COL_INDEX = 9;\nvar MIN_ROW_SELECTION_INDEX = 1;\nvar MIN_COL_SELECTION_INDEX = 1;\nvar BORDER_WIDTH = 1;\nvar TablePopupBody = /** @class */ (function (_super) {\n    __extends$1(TablePopupBody, _super);\n    function TablePopupBody(props) {\n        var _this = _super.call(this, props) || this;\n        _this.extendSelectionRange = function (_a) {\n            var pageX = _a.pageX, pageY = _a.pageY;\n            var x = pageX - _this.offsetRect.left;\n            var y = pageY - _this.offsetRect.top;\n            var range = _this.getSelectionRangeByOffset(x, y);\n            _this.setState(__assign$1({}, range));\n        };\n        _this.execCommand = function () {\n            _this.props.execCommand('addTable', {\n                rowCount: _this.state.rowIdx + 1,\n                columnCount: _this.state.colIdx + 1,\n            });\n        };\n        _this.state = {\n            rowIdx: -1,\n            colIdx: -1,\n        };\n        return _this;\n    }\n    TablePopupBody.prototype.getDescription = function () {\n        return this.state.colIdx === -1 ? '' : this.state.colIdx + 1 + \" x \" + (this.state.rowIdx + 1);\n    };\n    TablePopupBody.prototype.getBoundByRange = function (colIdx, rowIdx) {\n        return {\n            width: (colIdx + 1) * CELL_WIDTH,\n            height: (rowIdx + 1) * CELL_HEIGHT,\n        };\n    };\n    TablePopupBody.prototype.getRangeByOffset = function (x, y) {\n        return {\n            colIdx: Math.floor(x / CELL_WIDTH),\n            rowIdx: Math.floor(y / CELL_HEIGHT),\n        };\n    };\n    TablePopupBody.prototype.getTableRange = function () {\n        var _a = this.state, orgColIdx = _a.colIdx, orgRowIdx = _a.rowIdx;\n        var colIdx = Math.max(orgColIdx, MIN_COL_INDEX);\n        var rowIdx = Math.max(orgRowIdx, MIN_ROW_INDEX);\n        if (orgColIdx >= MIN_COL_INDEX && colIdx < MAX_COL_INDEX) {\n            colIdx += 1;\n        }\n        if (orgRowIdx >= MIN_ROW_INDEX && rowIdx < MAX_ROW_INDEX) {\n            rowIdx += 1;\n        }\n        return { colIdx: colIdx + 1, rowIdx: rowIdx + 1 };\n    };\n    TablePopupBody.prototype.getSelectionAreaBound = function () {\n        var _a = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), width = _a.width, height = _a.height;\n        if (!width && !height) {\n            return { display: 'none' };\n        }\n        return { width: width - BORDER_WIDTH, height: height - BORDER_WIDTH, display: 'block' };\n    };\n    TablePopupBody.prototype.getSelectionRangeByOffset = function (x, y) {\n        var range = this.getRangeByOffset(x, y);\n        range.rowIdx = Math.min(Math.max(range.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX);\n        range.colIdx = Math.min(Math.max(range.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX);\n        return range;\n    };\n    TablePopupBody.prototype.updated = function () {\n        if (!this.props.show) {\n            this.setState({ colIdx: -1, rowIdx: -1 });\n        }\n        else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {\n            var _a = this.refs.tableEl.getBoundingClientRect(), left = _a.left, top_1 = _a.top;\n            this.offsetRect = {\n                left: window.pageXOffset + left,\n                top: window.pageYOffset + top_1,\n            };\n        }\n    };\n    TablePopupBody.prototype.createTableArea = function (tableRange) {\n        var colIdx = tableRange.colIdx, rowIdx = tableRange.rowIdx;\n        var rows = [];\n        for (var i = 0; i < rowIdx; i += 1) {\n            var cells = [];\n            for (var j = 0; j < colIdx; j += 1) {\n                var cellClassNames = \"\" + cls('table-cell') + (i > 0 ? '' : ' header');\n                cells.push(html(templateObject_1$c || (templateObject_1$c = __makeTemplateObject([\"<div class=\\\"\", \"\\\"></div>\"], [\"<div class=\\\"\", \"\\\"></div>\"])), cellClassNames));\n            }\n            rows.push(html(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject([\"<div class=\\\"\", \"\\\">\", \"</div>\"], [\"<div class=\\\"\", \"\\\">\", \"</div>\"])), cls('table-row'), cells));\n        }\n        return html(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject([\"<div class=\\\"\", \"\\\">\", \"</div>\"], [\"<div class=\\\"\", \"\\\">\", \"</div>\"])), cls('table'), rows);\n    };\n    TablePopupBody.prototype.render = function () {\n        var _this = this;\n        var tableRange = this.getTableRange();\n        var selectionAreaBound = this.getSelectionAreaBound();\n        return html(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject([\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          onMousemove=\", \"\\n          onClick=\", \"\\n        >\\n          \", \"\\n          <div class=\\\"\", \"\\\" style=\", \"></div>\\n        </div>\\n        <p class=\\\"\", \"\\\">\", \"</p>\\n      </div>\\n    \"], [\"\\n      <div aria-label=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          onMousemove=\", \"\\n          onClick=\", \"\\n        >\\n          \", \"\\n          <div class=\\\"\", \"\\\" style=\", \"></div>\\n        </div>\\n        <p class=\\\"\", \"\\\">\", \"</p>\\n      </div>\\n    \"])), i18n.get('Insert table'), cls('table-selection'), function (el) { return (_this.refs.tableEl = el); }, this.extendSelectionRange, this.execCommand, this.createTableArea(tableRange), cls('table-selection-layer'), selectionAreaBound, cls('table-description'), this.getDescription());\n    };\n    return TablePopupBody;\n}(Component));\nvar templateObject_1$c, templateObject_2$6, templateObject_3$2, templateObject_4$1;\n\nvar CustomPopupBody = /** @class */ (function (_super) {\n    __extends$1(CustomPopupBody, _super);\n    function CustomPopupBody() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    CustomPopupBody.prototype.mounted = function () {\n        // append the custom popup body element\n        this.refs.el.appendChild(this.props.body);\n    };\n    CustomPopupBody.prototype.updated = function (prevProps) {\n        // update custom popup element\n        this.refs.el.replaceChild(this.props.body, prevProps.body);\n    };\n    CustomPopupBody.prototype.render = function () {\n        var _this = this;\n        return html(templateObject_1$b || (templateObject_1$b = __makeTemplateObject([\"<div ref=\", \"></div>\"], [\"<div ref=\", \"></div>\"])), function (el) { return (_this.refs.el = el); });\n    };\n    return CustomPopupBody;\n}(Component));\nvar templateObject_1$b;\n\nfunction createToolbarItemInfo(type) {\n    return isString_1(type) ? createDefaultToolbarItemInfo(type) : type;\n}\nfunction createScrollSyncToolbarItem() {\n    var label = document.createElement('label');\n    var checkbox = document.createElement('input');\n    var toggleSwitch = document.createElement('span');\n    label.className = 'scroll-sync active';\n    checkbox.type = 'checkbox';\n    checkbox.checked = true;\n    toggleSwitch.className = 'switch';\n    var onMounted = function (execCommand) {\n        return checkbox.addEventListener('change', function (ev) {\n            var checked = ev.target.checked;\n            if (checked) {\n                addClass_1(label, 'active');\n            }\n            else {\n                removeClass_1(label, 'active');\n            }\n            execCommand('toggleScrollSync', { active: checked });\n        });\n    };\n    label.appendChild(checkbox);\n    label.appendChild(toggleSwitch);\n    return {\n        name: 'scrollSync',\n        el: label,\n        onMounted: onMounted,\n    };\n}\nfunction createDefaultToolbarItemInfo(type) {\n    var info;\n    switch (type) {\n        case 'heading':\n            info = {\n                name: 'heading',\n                className: 'heading',\n                tooltip: i18n.get('Headings'),\n                state: 'heading',\n            };\n            break;\n        case 'bold':\n            info = {\n                name: 'bold',\n                className: 'bold',\n                command: 'bold',\n                tooltip: i18n.get('Bold'),\n                state: 'strong',\n            };\n            break;\n        case 'italic':\n            info = {\n                name: 'italic',\n                className: 'italic',\n                command: 'italic',\n                tooltip: i18n.get('Italic'),\n                state: 'emph',\n            };\n            break;\n        case 'strike':\n            info = {\n                name: 'strike',\n                className: 'strike',\n                command: 'strike',\n                tooltip: i18n.get('Strike'),\n                state: 'strike',\n            };\n            break;\n        case 'hr':\n            info = {\n                name: 'hr',\n                className: 'hrline',\n                command: 'hr',\n                tooltip: i18n.get('Line'),\n                state: 'thematicBreak',\n            };\n            break;\n        case 'quote':\n            info = {\n                name: 'quote',\n                className: 'quote',\n                command: 'blockQuote',\n                tooltip: i18n.get('Blockquote'),\n                state: 'blockQuote',\n            };\n            break;\n        case 'ul':\n            info = {\n                name: 'ul',\n                className: 'bullet-list',\n                command: 'bulletList',\n                tooltip: i18n.get('Unordered list'),\n                state: 'bulletList',\n            };\n            break;\n        case 'ol':\n            info = {\n                name: 'ol',\n                className: 'ordered-list',\n                command: 'orderedList',\n                tooltip: i18n.get('Ordered list'),\n                state: 'orderedList',\n            };\n            break;\n        case 'task':\n            info = {\n                name: 'task',\n                className: 'task-list',\n                command: 'taskList',\n                tooltip: i18n.get('Task'),\n                state: 'taskList',\n            };\n            break;\n        case 'table':\n            info = {\n                name: 'table',\n                className: 'table',\n                tooltip: i18n.get('Insert table'),\n                state: 'table',\n            };\n            break;\n        case 'image':\n            info = {\n                name: 'image',\n                className: 'image',\n                tooltip: i18n.get('Insert image'),\n            };\n            break;\n        case 'link':\n            info = {\n                name: 'link',\n                className: 'link',\n                tooltip: i18n.get('Insert link'),\n            };\n            break;\n        case 'code':\n            info = {\n                name: 'code',\n                className: 'code',\n                command: 'code',\n                tooltip: i18n.get('Code'),\n                state: 'code',\n            };\n            break;\n        case 'codeblock':\n            info = {\n                name: 'codeblock',\n                className: 'codeblock',\n                command: 'codeBlock',\n                tooltip: i18n.get('Insert CodeBlock'),\n                state: 'codeBlock',\n            };\n            break;\n        case 'indent':\n            info = {\n                name: 'indent',\n                className: 'indent',\n                command: 'indent',\n                tooltip: i18n.get('Indent'),\n                state: 'indent',\n            };\n            break;\n        case 'outdent':\n            info = {\n                name: 'outdent',\n                className: 'outdent',\n                command: 'outdent',\n                tooltip: i18n.get('Outdent'),\n                state: 'outdent',\n            };\n            break;\n        case 'scrollSync':\n            info = createScrollSyncToolbarItem();\n            break;\n        case 'more':\n            info = {\n                name: 'more',\n                className: 'more',\n                tooltip: i18n.get('More'),\n            };\n            break;\n        // do nothing\n    }\n    if (info.name !== 'scrollSync') {\n        info.className += \" \" + cls('toolbar-icons');\n    }\n    return info;\n}\nfunction createPopupInfo(type, payload) {\n    var el = payload.el, pos = payload.pos, popup = payload.popup, initialValues = payload.initialValues;\n    switch (type) {\n        case 'heading':\n            return {\n                render: function (props) { return html(templateObject_1$a || (templateObject_1$a = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), HeadingPopupBody, props); },\n                className: cls('popup-add-heading'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'link':\n            return {\n                render: function (props) { return html(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), LinkPopupBody, props); },\n                className: cls('popup-add-link'),\n                fromEl: el,\n                pos: pos,\n                initialValues: initialValues,\n            };\n        case 'image':\n            return {\n                render: function (props) { return html(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), ImagePopupBody, props); },\n                className: cls('popup-add-image'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'table':\n            return {\n                render: function (props) { return html(templateObject_4 || (templateObject_4 = __makeTemplateObject([\"<\", \" ...\", \" />\"], [\"<\", \" ...\", \" />\"])), TablePopupBody, props); },\n                className: cls('popup-add-table'),\n                fromEl: el,\n                pos: pos,\n            };\n        case 'customPopupBody':\n            if (!popup) {\n                return null;\n            }\n            return __assign$1({ render: function (props) { return html(templateObject_5 || (templateObject_5 = __makeTemplateObject([\"<\", \" ...\", \" body=\", \" />\"], [\"<\", \" ...\", \" body=\", \" />\"])), CustomPopupBody, props, popup.body); }, fromEl: el, pos: pos }, popup);\n        default:\n            return null;\n    }\n}\nfunction setGroupState(group) {\n    group.hidden = group.length === group.filter(function (info) { return info.hidden; }).length;\n}\nfunction groupToolbarItems(toolbarItems, hiddenScrollSync) {\n    var toggleScrollSyncState = function (item) {\n        item.hidden = item.name === 'scrollSync' && hiddenScrollSync;\n        return item;\n    };\n    return toolbarItems.reduce(function (acc, item) {\n        acc.push(item.map(function (type) { return toggleScrollSyncState(createToolbarItemInfo(type)); }));\n        var group = acc[(acc.length || 1) - 1];\n        if (group) {\n            setGroupState(group);\n        }\n        return acc;\n    }, []);\n}\nfunction toggleScrollSync(toolbarItems, hiddenScrollSync) {\n    toolbarItems.forEach(function (group) {\n        group.forEach(function (item) { return (item.hidden = item.name === 'scrollSync' && hiddenScrollSync); });\n        setGroupState(group);\n    });\n}\nvar templateObject_1$a, templateObject_2$5, templateObject_3$1, templateObject_4, templateObject_5;\n\nvar MARGIN_FROM_RIGHT_SIDE = 20;\nvar Popup = /** @class */ (function (_super) {\n    __extends$1(Popup, _super);\n    function Popup() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleMousedown = function (ev) {\n            if (!closest(ev.target, \".\" + cls('popup')) &&\n                !closest(ev.target, _this.props.info.fromEl)) {\n                _this.props.hidePopup();\n            }\n        };\n        return _this;\n    }\n    Popup.prototype.mounted = function () {\n        document.addEventListener('mousedown', this.handleMousedown);\n        this.props.eventEmitter.listen('closePopup', this.props.hidePopup);\n    };\n    Popup.prototype.beforeDestroy = function () {\n        document.removeEventListener('mousedown', this.handleMousedown);\n    };\n    Popup.prototype.updated = function (prevProps) {\n        var _a = this.props, show = _a.show, info = _a.info;\n        if (show && info.pos && prevProps.show !== show) {\n            var popupPos = __assign$1({}, info.pos);\n            var offsetWidth = this.refs.el.offsetWidth;\n            var toolbarEl = closest(this.refs.el, \".\" + cls('toolbar'));\n            var toolbarOffsetWidth = toolbarEl.offsetWidth;\n            if (popupPos.left + offsetWidth >= toolbarOffsetWidth) {\n                popupPos.left = toolbarOffsetWidth - offsetWidth - MARGIN_FROM_RIGHT_SIDE;\n            }\n            if (!shallowEqual(this.state.popupPos, popupPos)) {\n                this.setState({ popupPos: popupPos });\n            }\n        }\n    };\n    Popup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, info = _a.info, show = _a.show, hidePopup = _a.hidePopup, eventEmitter = _a.eventEmitter, execCommand = _a.execCommand;\n        var _b = info || {}, _c = _b.className, className = _c === void 0 ? '' : _c, style = _b.style, render = _b.render, _d = _b.initialValues, initialValues = _d === void 0 ? {} : _d;\n        var popupStyle = __assign$1(__assign$1({ display: show ? 'block' : 'none' }, style), this.state.popupPos);\n        return html(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([\"\\n      <div\\n        class=\\\"\", \" \", \"\\\"\\n        style=\", \"\\n        ref=\", \"\\n        aria-role=\\\"dialog\\\"\\n      >\\n        <div class=\\\"\", \"\\\">\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div\\n        class=\\\"\", \" \", \"\\\"\\n        style=\", \"\\n        ref=\", \"\\n        aria-role=\\\"dialog\\\"\\n      >\\n        <div class=\\\"\", \"\\\">\\n          \", \"\\n        </div>\\n      </div>\\n    \"])), cls('popup'), className, popupStyle, function (el) { return (_this.refs.el = el); }, cls('popup-body'), render && render({ eventEmitter: eventEmitter, show: show, hidePopup: hidePopup, execCommand: execCommand, initialValues: initialValues }));\n    };\n    return Popup;\n}(Component));\nvar templateObject_1$9;\n\nvar TOOLTIP_INDENT = 6;\nfunction connectHOC(WrappedComponent) {\n    return /** @class */ (function (_super) {\n        __extends$1(ButtonHOC, _super);\n        function ButtonHOC(props) {\n            var _this = _super.call(this, props) || this;\n            _this.showTooltip = function (el) {\n                var tooltip = _this.props.item.tooltip;\n                if (!_this.props.disabled && tooltip) {\n                    var bound = _this.getBound(el);\n                    var left = bound.left + TOOLTIP_INDENT + \"px\";\n                    var top_1 = bound.top + TOOLTIP_INDENT + \"px\";\n                    css_1(_this.props.tooltipRef.current, { display: 'block', left: left, top: top_1 });\n                    _this.props.tooltipRef.current.querySelector('.text').textContent = tooltip;\n                }\n            };\n            _this.hideTooltip = function () {\n                css_1(_this.props.tooltipRef.current, 'display', 'none');\n            };\n            _this.state = { active: false, disabled: props.disabled };\n            _this.addEvent();\n            return _this;\n        }\n        ButtonHOC.prototype.addEvent = function () {\n            var _this = this;\n            var _a = this.props, item = _a.item, eventEmitter = _a.eventEmitter;\n            if (item.state) {\n                eventEmitter.listen('changeToolbarState', function (_a) {\n                    var _b;\n                    var toolbarState = _a.toolbarState;\n                    var _c = (_b = toolbarState[item.state]) !== null && _b !== void 0 ? _b : {}, active = _c.active, disabled = _c.disabled;\n                    _this.setState({ active: !!active, disabled: disabled !== null && disabled !== void 0 ? disabled : _this.props.disabled });\n                });\n            }\n        };\n        ButtonHOC.prototype.getBound = function (el) {\n            var _a = getTotalOffset(el, closest(el, \".\" + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n            return { left: offsetLeft, top: el.offsetHeight + offsetTop };\n        };\n        ButtonHOC.prototype.render = function () {\n            return html(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([\"\\n        <\", \"\\n          ...\", \"\\n          active=\", \"\\n          showTooltip=\", \"\\n          hideTooltip=\", \"\\n          getBound=\", \"\\n          disabled=\", \"\\n        />\\n      \"], [\"\\n        <\", \"\\n          ...\", \"\\n          active=\", \"\\n          showTooltip=\", \"\\n          hideTooltip=\", \"\\n          getBound=\", \"\\n          disabled=\", \"\\n        />\\n      \"])), WrappedComponent, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);\n        };\n        return ButtonHOC;\n    }(Component));\n}\nvar templateObject_1$8;\n\nvar DEFAULT_WIDTH = 80;\nvar ToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(ToolbarButtonComp, _super);\n    function ToolbarButtonComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.execCommand = function () {\n            var _a = _this.props, item = _a.item, execCommand = _a.execCommand, setPopupInfo = _a.setPopupInfo, getBound = _a.getBound, eventEmitter = _a.eventEmitter;\n            var command = item.command, name = item.name, popup = item.popup;\n            if (command) {\n                execCommand(command);\n            }\n            else {\n                var popupName = popup ? 'customPopupBody' : name;\n                var initialValues = eventEmitter.emit('query', 'getPopupInitialValues', { popupName: popupName })[0];\n                var info = createPopupInfo(popupName, {\n                    el: _this.refs.el,\n                    pos: getBound(_this.refs.el),\n                    popup: popup,\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    setPopupInfo(info);\n                }\n            }\n        };\n        return _this;\n    }\n    ToolbarButtonComp.prototype.mounted = function () {\n        this.setItemWidth();\n    };\n    ToolbarButtonComp.prototype.updated = function (prevProps) {\n        if (prevProps.item.name !== this.props.item.name) {\n            this.setItemWidth();\n        }\n    };\n    ToolbarButtonComp.prototype.setItemWidth = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el) + (item.hidden ? DEFAULT_WIDTH : 0));\n        }\n    };\n    ToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, hideTooltip = _a.hideTooltip, disabled = _a.disabled, item = _a.item, active = _a.active;\n        var style = __assign$1({ display: item.hidden ? 'none' : null }, item.style);\n        var classNames = \"\" + (item.className || '') + (active ? ' active' : '');\n        return html(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([\"\\n      <button\\n        ref=\", \"\\n        type=\\\"button\\\"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n        disabled=\", \"\\n        aria-label=\", \"\\n      >\\n        \", \"\\n      </button>\\n    \"], [\"\\n      <button\\n        ref=\", \"\\n        type=\\\"button\\\"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n        disabled=\", \"\\n        aria-label=\", \"\\n      >\\n        \", \"\\n      </button>\\n    \"])), function (el) { return (_this.refs.el = el); }, style, classNames, this.execCommand, this.showTooltip, hideTooltip, !!disabled, item.text || item.tooltip || '', item.text || '');\n    };\n    return ToolbarButtonComp;\n}(Component));\nvar ToolbarButton = connectHOC(ToolbarButtonComp);\nvar templateObject_1$7;\n\nvar CustomToolbarItemComp = /** @class */ (function (_super) {\n    __extends$1(CustomToolbarItemComp, _super);\n    function CustomToolbarItemComp() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.showPopup = function () {\n            var info = createPopupInfo('customPopupBody', {\n                el: _this.refs.el,\n                pos: _this.props.getBound(_this.refs.el),\n                popup: _this.props.item.popup,\n            });\n            if (info) {\n                _this.props.setPopupInfo(info);\n            }\n        };\n        return _this;\n    }\n    CustomToolbarItemComp.prototype.mounted = function () {\n        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;\n        // append the custom html element\n        this.refs.el.appendChild(item.el);\n        // set width only if it is not a dropdown toolbar\n        if (setItemWidth) {\n            setItemWidth(item.name, getOuterWidth(this.refs.el));\n        }\n        if (item.onMounted) {\n            item.onMounted(this.props.execCommand);\n        }\n    };\n    CustomToolbarItemComp.prototype.updated = function (prevProps) {\n        var _a;\n        var _b = this.props, item = _b.item, active = _b.active, disabled = _b.disabled;\n        if (prevProps.active !== active || prevProps.disabled !== disabled) {\n            (_a = item.onUpdated) === null || _a === void 0 ? void 0 : _a.call(item, { active: active, disabled: disabled });\n        }\n    };\n    CustomToolbarItemComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, disabled = _a.disabled, item = _a.item;\n        var style = { display: item.hidden ? 'none' : 'inline-block' };\n        var getListener = function (listener) { return (disabled ? null : listener); };\n        return html(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([\"\\n      <div\\n        ref=\", \"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n      ></div>\\n    \"], [\"\\n      <div\\n        ref=\", \"\\n        style=\", \"\\n        class=\", \"\\n        onClick=\", \"\\n        onMouseover=\", \"\\n        onMouseout=\", \"\\n      ></div>\\n    \"])), function (el) { return (_this.refs.el = el); }, style, cls('toolbar-item-wrapper'), getListener(this.showPopup), getListener(this.showTooltip), getListener(this.props.hideTooltip));\n    };\n    return CustomToolbarItemComp;\n}(Component));\nvar CustomToolbarItem = connectHOC(CustomToolbarItemComp);\nvar templateObject_1$6;\n\nvar ToolbarGroup = /** @class */ (function (_super) {\n    __extends$1(ToolbarGroup, _super);\n    function ToolbarGroup() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarGroup.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, group = _a.group, hiddenDivider = _a.hiddenDivider;\n        var groupStyle = group.hidden ? { display: 'none' } : null;\n        var dividerStyle = hiddenDivider ? { display: 'none' } : null;\n        return html(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        \", \"\\n        <div class=\\\"\", \"\\\" style=\", \"></div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        \",\n            \"\\n        <div class=\\\"\", \"\\\" style=\", \"></div>\\n      </div>\\n    \"])), cls('toolbar-group'), groupStyle, group.map(function (item) {\n            var Comp = item.el ? CustomToolbarItem : ToolbarButton;\n            return html(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject([\"<\", \" key=\", \" ...\", \" item=\", \" />\"], [\"<\", \" key=\", \" ...\", \" item=\", \" />\"])), Comp, item.name, _this.props, item);\n        }), cls('toolbar-divider'), dividerStyle);\n    };\n    return ToolbarGroup;\n}(Component));\nvar templateObject_1$5, templateObject_2$4;\n\nvar POPUP_INDENT = 4;\nvar DropdownToolbarButtonComp = /** @class */ (function (_super) {\n    __extends$1(DropdownToolbarButtonComp, _super);\n    function DropdownToolbarButtonComp(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (_a) {\n            var target = _a.target;\n            if (!closest(target, \".\" + cls('dropdown-toolbar')) &&\n                !closest(target, '.more')) {\n                _this.setState({ showDropdown: false, dropdownPos: null });\n            }\n        };\n        _this.showTooltip = function () {\n            _this.props.showTooltip(_this.refs.el);\n        };\n        _this.state = { showDropdown: false, dropdownPos: null };\n        return _this;\n    }\n    DropdownToolbarButtonComp.prototype.getBound = function () {\n        var rect = this.props.getBound(this.refs.el);\n        rect.top += POPUP_INDENT;\n        return __assign$1(__assign$1({}, rect), { left: null, right: 10 });\n    };\n    DropdownToolbarButtonComp.prototype.mounted = function () {\n        document.addEventListener('click', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.updated = function () {\n        if (this.state.showDropdown && !this.state.dropdownPos) {\n            this.setState({ dropdownPos: this.getBound() });\n        }\n    };\n    DropdownToolbarButtonComp.prototype.beforeDestroy = function () {\n        document.removeEventListener('click', this.handleClickDocument);\n    };\n    DropdownToolbarButtonComp.prototype.render = function () {\n        var _this = this;\n        var _a = this.state, showDropdown = _a.showDropdown, dropdownPos = _a.dropdownPos;\n        var _b = this.props, disabled = _b.disabled, item = _b.item, items = _b.items, hideTooltip = _b.hideTooltip;\n        var visibleItems = items.filter(function (dropdownItem) { return !dropdownItem.hidden; });\n        var groupStyle = visibleItems.length ? null : { display: 'none' };\n        var dropdownStyle = showDropdown ? null : { display: 'none' };\n        return html(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        <button\\n          ref=\", \"\\n          type=\\\"button\\\"\\n          class=\", \"\\n          onClick=\", \"\\n          onMouseover=\", \"\\n          onMouseout=\", \"\\n          disabled=\", \"\\n        ></button>\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\", \"\\n          ref=\", \"\\n        >\\n          \", \"\\n        </div>\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\" style=\", \">\\n        <button\\n          ref=\", \"\\n          type=\\\"button\\\"\\n          class=\", \"\\n          onClick=\", \"\\n          onMouseover=\", \"\\n          onMouseout=\", \"\\n          disabled=\", \"\\n        ></button>\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\", \"\\n          ref=\", \"\\n        >\\n          \",\n            \"\\n        </div>\\n      </div>\\n    \"])), cls('toolbar-group'), groupStyle, function (el) { return (_this.refs.el = el); }, item.className, function () { return _this.setState({ showDropdown: true }); }, this.showTooltip, hideTooltip, disabled, cls('dropdown-toolbar'), __assign$1(__assign$1({}, dropdownStyle), dropdownPos), function (el) { return (_this.refs.dropdownEl = el); }, visibleItems.length\n            ? visibleItems.map(function (group, index) {\n                var _a;\n                return html(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([\"\\n                  <\", \"\\n                    group=\", \"\\n                    hiddenDivider=\", \"\\n                    ...\", \"\\n                  />\\n                \"], [\"\\n                  <\", \"\\n                    group=\", \"\\n                    hiddenDivider=\",\n                    \"\\n                    ...\", \"\\n                  />\\n                \"])), ToolbarGroup, group, index === visibleItems.length - 1 ||\n                    ((_a = visibleItems[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.props);\n            })\n            : null);\n    };\n    return DropdownToolbarButtonComp;\n}(Component));\nvar DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp);\nvar templateObject_1$4, templateObject_2$3;\n\nvar INLINE_PADDING = 50;\nvar Toolbar = /** @class */ (function (_super) {\n    __extends$1(Toolbar, _super);\n    function Toolbar(props) {\n        var _this = _super.call(this, props) || this;\n        _this.toggleTab = function (_, activeTab) {\n            var eventEmitter = _this.props.eventEmitter;\n            if (_this.state.activeTab !== activeTab) {\n                var event_1 = activeTab === 'write' ? 'changePreviewTabWrite' : 'changePreviewTabPreview';\n                eventEmitter.emit(event_1);\n                _this.setState({ activeTab: activeTab });\n            }\n        };\n        _this.setItemWidth = function (name, width) {\n            _this.itemWidthMap[name] = width;\n        };\n        _this.setPopupInfo = function (popupInfo) {\n            _this.setState({ showPopup: true, popupInfo: popupInfo });\n        };\n        _this.openPopup = function (popupName, initialValues) {\n            if (initialValues === void 0) { initialValues = {}; }\n            var el = _this.refs.el.querySelector(\".\" + cls('toolbar-group') + \" .\" + popupName);\n            if (el) {\n                var _a = getTotalOffset(el, closest(el, \".\" + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;\n                var info = createPopupInfo(popupName, {\n                    el: el,\n                    pos: { left: offsetLeft, top: el.offsetHeight + offsetTop },\n                    initialValues: initialValues,\n                });\n                if (info) {\n                    _this.setPopupInfo(info);\n                }\n            }\n        };\n        _this.hidePopup = function () {\n            if (_this.state.showPopup) {\n                _this.setState({ showPopup: false });\n            }\n        };\n        _this.execCommand = function (command, payload) {\n            var eventEmitter = _this.props.eventEmitter;\n            eventEmitter.emit('command', command, payload);\n            _this.hidePopup();\n        };\n        _this.tabs = [\n            { name: 'write', text: 'Write' },\n            { name: 'preview', text: 'Preview' },\n        ];\n        _this.itemWidthMap = {};\n        _this.initialItems = groupToolbarItems(props.toolbarItems || [], _this.hiddenScrollSync());\n        _this.state = {\n            items: _this.initialItems,\n            dropdownItems: [],\n            showPopup: false,\n            popupInfo: {},\n            activeTab: 'write',\n        };\n        _this.tooltipRef = { current: null };\n        _this.resizeObserver = new index(function () { return _this.handleResize(); });\n        _this.addEvent();\n        return _this;\n    }\n    Toolbar.prototype.insertToolbarItem = function (indexList, item) {\n        var groupIndex = indexList.groupIndex, itemIndex = indexList.itemIndex;\n        var group = this.initialItems[groupIndex];\n        item = createToolbarItemInfo(item);\n        if (group) {\n            group.splice(itemIndex, 0, item);\n        }\n        else {\n            this.initialItems.push([item]);\n        }\n        this.setState(this.classifyToolbarItems());\n    };\n    Toolbar.prototype.removeToolbarItem = function (name) {\n        var _this = this;\n        forEachArray_1(this.initialItems, function (group) {\n            var found = false;\n            forEachArray_1(group, function (item, index) {\n                if (item.name === name) {\n                    found = true;\n                    group.splice(index, 1);\n                    _this.setState(_this.classifyToolbarItems());\n                    return false;\n                }\n                return true;\n            });\n            return !found;\n        });\n    };\n    Toolbar.prototype.addEvent = function () {\n        var _this = this;\n        var eventEmitter = this.props.eventEmitter;\n        this.handleResize = throttle_1(function () {\n            // reset toolbar items to re-layout toolbar items with each clientWidth\n            _this.setState({ items: _this.initialItems, dropdownItems: [] });\n            _this.setState(_this.classifyToolbarItems());\n        }, 200);\n        eventEmitter.listen('openPopup', this.openPopup);\n    };\n    Toolbar.prototype.appendTooltipToRoot = function () {\n        var tooltip = \"<div class=\\\"\" + cls('tooltip') + \"\\\" style=\\\"display:none\\\">\\n        <div class=\\\"arrow\\\"></div>\\n        <span class=\\\"text\\\"></span>\\n      </div>\";\n        this.tooltipRef.current = createElementWith(tooltip, this.refs.el);\n    };\n    Toolbar.prototype.hiddenScrollSync = function () {\n        return this.props.editorType === 'wysiwyg' || this.props.previewStyle === 'tab';\n    };\n    Toolbar.prototype.movePrevItemToDropdownToolbar = function (itemIndex, items, group, dropdownGroup) {\n        var moveItem = function (targetGroup) {\n            var item = targetGroup.pop();\n            if (item) {\n                dropdownGroup.push(item);\n            }\n        };\n        if (itemIndex > 1) {\n            moveItem(group);\n        }\n        else {\n            var prevGroup = last$1(items);\n            if (prevGroup) {\n                moveItem(prevGroup);\n            }\n        }\n    };\n    Toolbar.prototype.classifyToolbarItems = function () {\n        var _this = this;\n        var totalWidth = 0;\n        var clientWidth = this.refs.el.clientWidth;\n        var divider = this.refs.el.querySelector(\".\" + cls('toolbar-divider'));\n        var dividerWidth = divider ? getOuterWidth(divider) : 0;\n        var items = [];\n        var dropdownItems = [];\n        var moved = false;\n        this.initialItems.forEach(function (initialGroup, groupIndex) {\n            var group = [];\n            var dropdownGroup = [];\n            initialGroup.forEach(function (item, itemIndex) {\n                if (!item.hidden) {\n                    totalWidth += _this.itemWidthMap[item.name];\n                    if (totalWidth > clientWidth - INLINE_PADDING) {\n                        // should move the prev item to dropdown toolbar for placing the more button\n                        if (!moved) {\n                            _this.movePrevItemToDropdownToolbar(itemIndex, items, group, dropdownGroup);\n                            moved = true;\n                        }\n                        dropdownGroup.push(item);\n                    }\n                    else {\n                        group.push(item);\n                    }\n                }\n            });\n            if (group.length) {\n                setGroupState(group);\n                items.push(group);\n            }\n            if (dropdownGroup.length) {\n                setGroupState(dropdownGroup);\n                dropdownItems.push(dropdownGroup);\n            }\n            // add divider width\n            if (groupIndex < _this.state.items.length - 1) {\n                totalWidth += dividerWidth;\n            }\n        });\n        return { items: items, dropdownItems: dropdownItems };\n    };\n    Toolbar.prototype.mounted = function () {\n        if (this.props.previewStyle === 'tab') {\n            this.props.eventEmitter.emit('changePreviewTabWrite', true);\n        }\n        // classify toolbar and dropdown toolbar after DOM has been rendered\n        this.setState(this.classifyToolbarItems());\n        this.appendTooltipToRoot();\n        this.resizeObserver.observe(this.refs.el);\n    };\n    Toolbar.prototype.updated = function (prevProps) {\n        var _a = this.props, editorType = _a.editorType, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter;\n        var changedStyle = previewStyle !== prevProps.previewStyle;\n        var changedType = editorType !== prevProps.editorType;\n        if (changedStyle || changedType) {\n            // show or hide scrollSync button\n            toggleScrollSync(this.initialItems, this.hiddenScrollSync());\n            var newState = this.classifyToolbarItems();\n            if (changedStyle || (previewStyle === 'tab' && editorType === 'markdown')) {\n                eventEmitter.emit('changePreviewTabWrite');\n                newState.activeTab = 'write';\n            }\n            this.setState(newState);\n        }\n    };\n    Toolbar.prototype.beforeDestroy = function () {\n        window.removeEventListener('resize', this.handleResize);\n        this.resizeObserver.disconnect();\n        removeNode$1(this.tooltipRef.current);\n    };\n    Toolbar.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter, editorType = _a.editorType;\n        var _b = this.state, popupInfo = _b.popupInfo, showPopup = _b.showPopup, activeTab = _b.activeTab, items = _b.items, dropdownItems = _b.dropdownItems;\n        var props = {\n            eventEmitter: eventEmitter,\n            tooltipRef: this.tooltipRef,\n            disabled: editorType === 'markdown' && previewStyle === 'tab' && activeTab === 'preview',\n            execCommand: this.execCommand,\n            setPopupInfo: this.setPopupInfo,\n        };\n        var toolbarStyle = previewStyle === 'tab' ? { borderTopLeftRadius: 0 } : null;\n        return html(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject([\"\\n      <div class=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\\\"display: \", \"\\\"\\n        >\\n          <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        </div>\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          style=\", \"\\n        >\\n          \", \"\\n          <\", \"\\n            item=\", \"\\n            items=\", \"\\n            ...\", \"\\n          />\\n        </div>\\n        <\", \"\\n          info=\", \"\\n          show=\", \"\\n          eventEmitter=\", \"\\n          hidePopup=\", \"\\n          execCommand=\", \"\\n        />\\n      </div>\\n    \"], [\"\\n      <div class=\\\"\", \"\\\">\\n        <div\\n          class=\\\"\", \"\\\"\\n          style=\\\"display: \",\n            \"\\\"\\n        >\\n          <\", \" tabs=\", \" activeTab=\", \" onClick=\", \" />\\n        </div>\\n        <div\\n          class=\\\"\", \"\\\"\\n          ref=\", \"\\n          style=\", \"\\n        >\\n          \",\n            \"\\n          <\", \"\\n            item=\", \"\\n            items=\", \"\\n            ...\", \"\\n          />\\n        </div>\\n        <\", \"\\n          info=\", \"\\n          show=\", \"\\n          eventEmitter=\", \"\\n          hidePopup=\", \"\\n          execCommand=\", \"\\n        />\\n      </div>\\n    \"])), cls('toolbar'), cls('md-tab-container'), editorType === 'wysiwyg' || previewStyle === 'vertical'\n            ? 'none'\n            : 'block', Tabs, this.tabs, activeTab, this.toggleTab, cls('defaultUI-toolbar'), function (el) { return (_this.refs.el = el); }, toolbarStyle, items.map(function (group, index) {\n            var _a;\n            return html(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([\"\\n              <\", \"\\n                group=\", \"\\n                hiddenDivider=\", \"\\n                setItemWidth=\", \"\\n                ...\", \"\\n              />\\n            \"], [\"\\n              <\", \"\\n                group=\", \"\\n                hiddenDivider=\", \"\\n                setItemWidth=\", \"\\n                ...\", \"\\n              />\\n            \"])), ToolbarGroup, group, index === items.length - 1 || ((_a = items[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.setItemWidth, props);\n        }), DropdownToolbarButton, createToolbarItemInfo('more'), dropdownItems, props, Popup, popupInfo, showPopup, eventEmitter, this.hidePopup, this.execCommand);\n    };\n    return Toolbar;\n}(Component));\nvar templateObject_1$3, templateObject_2$2;\n\nvar ContextMenu = /** @class */ (function (_super) {\n    __extends$1(ContextMenu, _super);\n    function ContextMenu(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleClickDocument = function (ev) {\n            if (!closest(ev.target, \".\" + cls('context-menu'))) {\n                _this.setState({ pos: null });\n            }\n        };\n        _this.state = {\n            pos: null,\n            menuGroups: [],\n        };\n        _this.addEvent();\n        return _this;\n    }\n    ContextMenu.prototype.addEvent = function () {\n        var _this = this;\n        this.props.eventEmitter.listen('contextmenu', function (_a) {\n            var pos = _a.pos, menuGroups = _a.menuGroups;\n            _this.setState({ pos: pos, menuGroups: menuGroups });\n        });\n    };\n    ContextMenu.prototype.mounted = function () {\n        document.addEventListener('click', this.handleClickDocument);\n    };\n    ContextMenu.prototype.beforeDestroy = function () {\n        document.removeEventListener('click', this.handleClickDocument);\n    };\n    ContextMenu.prototype.getMenuGroupElements = function () {\n        var _this = this;\n        var _a = this.state, pos = _a.pos, menuGroups = _a.menuGroups;\n        return pos\n            ? menuGroups.reduce(function (acc, group) {\n                var menuItem = [];\n                group.forEach(function (_a) {\n                    var label = _a.label, _b = _a.className, className = _b === void 0 ? false : _b, disabled = _a.disabled, onClick = _a.onClick;\n                    var handleClick = function () {\n                        if (!disabled) {\n                            onClick();\n                            _this.setState({ pos: null });\n                        }\n                    };\n                    menuItem.push(html(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([\"\\n                <li\\n                  onClick=\", \"\\n                  class=\\\"menu-item\", \"\\\"\\n                  aria-role=\\\"menuitem\\\"\\n                >\\n                  <span class=\\\"\", \"\\\">\", \"</span>\\n                </li>\\n              \"], [\"\\n                <li\\n                  onClick=\", \"\\n                  class=\\\"menu-item\", \"\\\"\\n                  aria-role=\\\"menuitem\\\"\\n                >\\n                  <span class=\\\"\", \"\\\">\", \"</span>\\n                </li>\\n              \"])), handleClick, disabled ? ' disabled' : '', className, label));\n                });\n                acc.push(html(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\"<ul class=\\\"menu-group\\\">\\n              \", \"\\n            </ul>\"], [\"<ul class=\\\"menu-group\\\">\\n              \", \"\\n            </ul>\"])), menuItem));\n                return acc;\n            }, [])\n            : [];\n    };\n    ContextMenu.prototype.render = function () {\n        var style = __assign$1({ display: this.state.pos ? 'block' : 'none' }, this.state.pos);\n        return html(templateObject_3 || (templateObject_3 = __makeTemplateObject([\"<div class=\\\"\", \"\\\" style=\", \" aria-role=\\\"menu\\\">\\n      \", \"\\n    </div>\"], [\"<div class=\\\"\", \"\\\" style=\", \" aria-role=\\\"menu\\\">\\n      \", \"\\n    </div>\"])), cls('context-menu'), style, this.getMenuGroupElements());\n    };\n    return ContextMenu;\n}(Component));\nvar templateObject_1$2, templateObject_2$1, templateObject_3;\n\nvar Layout = /** @class */ (function (_super) {\n    __extends$1(Layout, _super);\n    function Layout(props) {\n        var _this = _super.call(this, props) || this;\n        _this.changeMode = function (editorType) {\n            if (editorType !== _this.state.editorType) {\n                _this.setState({ editorType: editorType });\n            }\n        };\n        _this.changePreviewStyle = function (previewStyle) {\n            if (previewStyle !== _this.state.previewStyle) {\n                _this.setState({ previewStyle: previewStyle });\n            }\n        };\n        _this.hide = function () {\n            _this.setState({ hide: true });\n        };\n        _this.show = function () {\n            _this.setState({ hide: false });\n        };\n        var editorType = props.editorType, previewStyle = props.previewStyle;\n        _this.state = {\n            editorType: editorType,\n            previewStyle: previewStyle,\n            hide: false,\n        };\n        _this.addEvent();\n        return _this;\n    }\n    Layout.prototype.mounted = function () {\n        var _a = this.props.slots, wwEditor = _a.wwEditor, mdEditor = _a.mdEditor, mdPreview = _a.mdPreview;\n        this.refs.wwContainer.appendChild(wwEditor);\n        this.refs.mdContainer.insertAdjacentElement('afterbegin', mdEditor);\n        this.refs.mdContainer.appendChild(mdPreview);\n    };\n    Layout.prototype.insertToolbarItem = function (indexList, item) {\n        this.toolbar.insertToolbarItem(indexList, item);\n    };\n    Layout.prototype.removeToolbarItem = function (name) {\n        this.toolbar.removeToolbarItem(name);\n    };\n    Layout.prototype.render = function () {\n        var _this = this;\n        var _a = this.props, eventEmitter = _a.eventEmitter, hideModeSwitch = _a.hideModeSwitch, toolbarItems = _a.toolbarItems, theme = _a.theme;\n        var _b = this.state, hide = _b.hide, previewStyle = _b.previewStyle, editorType = _b.editorType;\n        var displayClassName = hide ? ' hidden' : '';\n        var editorTypeClassName = cls(editorType === 'markdown' ? 'md-mode' : 'ww-mode');\n        var previewClassName = cls('md') + \"-\" + previewStyle + \"-style\";\n        var themeClassName = cls([theme !== 'light', theme + \" \"]);\n        return html(templateObject_2 || (templateObject_2 = __makeTemplateObject([\"\\n      <div\\n        class=\\\"\", \"\", \"\", \"\\\"\\n        ref=\", \"\\n      >\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          previewStyle=\", \"\\n          toolbarItems=\", \"\\n          editorType=\", \"\\n        />\\n        <div\\n          class=\\\"\", \" \", \"\\\"\\n          ref=\", \"\\n        >\\n          <div class=\\\"\", \"\\\">\\n            <div\\n              class=\\\"\", \" \", \"\\\"\\n              ref=\", \"\\n            >\\n              <div class=\\\"\", \"\\\"></div>\\n            </div>\\n            <div\\n              class=\\\"\", \"\\\"\\n              ref=\", \"\\n            />\\n          </div>\\n        </div>\\n        \", \"\\n        <\", \" eventEmitter=\", \" />\\n      </div>\\n    \"], [\"\\n      <div\\n        class=\\\"\", \"\", \"\", \"\\\"\\n        ref=\", \"\\n      >\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          previewStyle=\", \"\\n          toolbarItems=\", \"\\n          editorType=\", \"\\n        />\\n        <div\\n          class=\\\"\", \" \", \"\\\"\\n          ref=\", \"\\n        >\\n          <div class=\\\"\", \"\\\">\\n            <div\\n              class=\\\"\", \" \", \"\\\"\\n              ref=\", \"\\n            >\\n              <div class=\\\"\", \"\\\"></div>\\n            </div>\\n            <div\\n              class=\\\"\", \"\\\"\\n              ref=\", \"\\n            />\\n          </div>\\n        </div>\\n        \",\n            \"\\n        <\", \" eventEmitter=\", \" />\\n      </div>\\n    \"])), themeClassName, cls('defaultUI'), displayClassName, function (el) { return (_this.refs.el = el); }, Toolbar, function (toolbar) { return (_this.toolbar = toolbar); }, eventEmitter, previewStyle, toolbarItems, editorType, cls('main'), editorTypeClassName, function (el) { return (_this.refs.editorSection = el); }, cls('main-container'), cls('md-container'), previewClassName, function (el) { return (_this.refs.mdContainer = el); }, cls('md-splitter'), cls('ww-container'), function (el) { return (_this.refs.wwContainer = el); }, !hideModeSwitch && html(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\"<\", \" eventEmitter=\", \" editorType=\", \" />\"], [\"<\", \" eventEmitter=\", \" editorType=\", \" />\"])), Switch, eventEmitter, editorType), ContextMenu, eventEmitter);\n    };\n    Layout.prototype.addEvent = function () {\n        var eventEmitter = this.props.eventEmitter;\n        eventEmitter.listen('hide', this.hide);\n        eventEmitter.listen('show', this.show);\n        eventEmitter.listen('changeMode', this.changeMode);\n        eventEmitter.listen('changePreviewStyle', this.changePreviewStyle);\n    };\n    return Layout;\n}(Component));\nvar templateObject_1$1, templateObject_2;\n\n/**\n * ToastUI Editor\n * @extends ToastUIEditorCore\n */\nvar ToastUIEditor = /** @class */ (function (_super) {\n    __extends$1(ToastUIEditor, _super);\n    function ToastUIEditor(options) {\n        var _a;\n        var _this = _super.call(this, options) || this;\n        var layoutComp;\n        var destroy = render(_this.options.el, html(templateObject_1 || (templateObject_1 = __makeTemplateObject([\"\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          slots=\", \"\\n          hideModeSwitch=\", \"\\n          toolbarItems=\", \"\\n          previewStyle=\", \"\\n          editorType=\", \"\\n          theme=\", \"\\n        />\\n      \"], [\"\\n        <\", \"\\n          ref=\", \"\\n          eventEmitter=\", \"\\n          slots=\", \"\\n          hideModeSwitch=\", \"\\n          toolbarItems=\", \"\\n          previewStyle=\", \"\\n          editorType=\", \"\\n          theme=\", \"\\n        />\\n      \"])), Layout, function (layout) { return (layoutComp = layout); }, _this.eventEmitter, _this.getEditorElements(), _this.options.hideModeSwitch, _this.options.toolbarItems, _this.options.previewStyle, _this.options.initialEditType, _this.options.theme));\n        _this.setMinHeight(_this.options.minHeight);\n        _this.setHeight(_this.options.height);\n        _this.defaultUI = {\n            insertToolbarItem: layoutComp.insertToolbarItem.bind(layoutComp),\n            removeToolbarItem: layoutComp.removeToolbarItem.bind(layoutComp),\n            destroy: destroy,\n        };\n        (_a = _this.pluginInfo.toolbarItems) === null || _a === void 0 ? void 0 : _a.forEach(function (toolbarItem) {\n            var groupIndex = toolbarItem.groupIndex, itemIndex = toolbarItem.itemIndex, item = toolbarItem.item;\n            _this.defaultUI.insertToolbarItem({ groupIndex: groupIndex, itemIndex: itemIndex }, item);\n        });\n        _this.eventEmitter.emit('loadUI', _this);\n        return _this;\n    }\n    /**\n     * Factory method for Editor\n     * @param {object} options Option for initialize TUIEditor\n     * @returns {object} ToastUIEditor or ToastUIEditorViewer\n     */\n    ToastUIEditor.factory = function (options) {\n        return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditor(options);\n    };\n    /**\n     * add toolbar item\n     * @param {Object} indexInfo group index and item index of the toolbar item\n     * @param {string|Object} item toolbar item\n     */\n    ToastUIEditor.prototype.insertToolbarItem = function (indexInfo, item) {\n        this.defaultUI.insertToolbarItem(indexInfo, item);\n    };\n    /**\n     * Remove toolbar item\n     * @param {string} itemName toolbar item name\n     */\n    ToastUIEditor.prototype.removeToolbarItem = function (itemName) {\n        this.defaultUI.removeToolbarItem(itemName);\n    };\n    /**\n     * Destroy TUIEditor from document\n     */\n    ToastUIEditor.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n        this.defaultUI.destroy();\n    };\n    return ToastUIEditor;\n}(ToastUIEditorCore));\nvar templateObject_1;\n\n/**\n * @fileoverview I18N for English\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\nToastUIEditorCore.setLanguage(['en', 'en-US'], {\n    Markdown: 'Markdown',\n    WYSIWYG: 'WYSIWYG',\n    Write: 'Write',\n    Preview: 'Preview',\n    Headings: 'Headings',\n    Paragraph: 'Paragraph',\n    Bold: 'Bold',\n    Italic: 'Italic',\n    Strike: 'Strike',\n    Code: 'Inline code',\n    Line: 'Line',\n    Blockquote: 'Blockquote',\n    'Unordered list': 'Unordered list',\n    'Ordered list': 'Ordered list',\n    Task: 'Task',\n    Indent: 'Indent',\n    Outdent: 'Outdent',\n    'Insert link': 'Insert link',\n    'Insert CodeBlock': 'Insert codeBlock',\n    'Insert table': 'Insert table',\n    'Insert image': 'Insert image',\n    Heading: 'Heading',\n    'Image URL': 'Image URL',\n    'Select image file': 'Select image file',\n    'Choose a file': 'Choose a file',\n    'No file': 'No file',\n    Description: 'Description',\n    OK: 'OK',\n    More: 'More',\n    Cancel: 'Cancel',\n    File: 'File',\n    URL: 'URL',\n    'Link text': 'Link text',\n    'Add row to up': 'Add row to up',\n    'Add row to down': 'Add row to down',\n    'Add column to left': 'Add column to left',\n    'Add column to right': 'Add column to right',\n    'Remove row': 'Remove row',\n    'Remove column': 'Remove column',\n    'Align column to left': 'Align column to left',\n    'Align column to center': 'Align column to center',\n    'Align column to right': 'Align column to right',\n    'Remove table': 'Remove table',\n    'Would you like to paste as table?': 'Would you like to paste as table?',\n    'Text color': 'Text color',\n    'Auto scroll enabled': 'Auto scroll enabled',\n    'Auto scroll disabled': 'Auto scroll disabled',\n    'Choose language': 'Choose language',\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0g7QUFDekM7QUFDZ0I7QUFDaUQ7QUFDOUY7QUFDeUk7QUFDdkc7QUFDVDs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdB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S0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtEQUErRDtBQUNwSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBDQUEwQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILGlDQUFpQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWUsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRSxnQ0FBZ0MsS0FBSyw2Q0FBNkMsS0FBSztBQUM5SSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkNBQTJDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEdBQUcsR0FBRyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx3QkFBd0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSxhQUFhLElBQUk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixHQUFHLFdBQVcsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakMsd0NBQXdDLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRztBQUMzRTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qyx5QkFBeUIsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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VjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsTUFBTTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUZBQXVGLGdFQUFnRTtBQUN2Sjs7QUFFQTtBQUNBLE1BQU0sd0NBQXdDLHdGQUF3RixvS0FBb0ssdUhBQXVILG1CQUFtQjtBQUNwYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBEQUEwRCxnQ0FBZ0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFrRDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDhCQUE4QixrREFBa0Q7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9CQUFvQjtBQUNsRiwyQ0FBMkM7QUFDM0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3REFBd0QsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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ekw7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1vQkFBbW9CLCtCQUErQjtBQUNscUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDhDQUE4QztBQUM5RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTZGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGhwXFxPbmVEcml2ZVxcRGVza3RvcFxcTkFSUkFUSVZFIE5FWFVTXFxhaS1nZW5lcmF0b3JcXG5vZGVfbW9kdWxlc1xcQHRvYXN0LXVpXFxlZGl0b3JcXGRpc3RcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdG9hc3QtdWkvZWRpdG9yXG4gKiBAdmVyc2lvbiAzLjIuMiB8IEZyaSBGZWIgMTcgMjAyM1xuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG5pbXBvcnQgeyBGcmFnbWVudCwgU2NoZW1hLCBTbGljZSwgTm9kZVJhbmdlLCBNYXJrIGFzIE1hcmskMSwgRE9NUGFyc2VyLCBOb2RlIGFzIE5vZGUkMyB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IERlY29yYXRpb25TZXQsIERlY29yYXRpb24sIEVkaXRvclZpZXcgfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JztcbmltcG9ydCB7IFJlcGxhY2VBcm91bmRTdGVwLCBsaWZ0VGFyZ2V0LCBjYW5TcGxpdCwgU3RlcE1hcCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgRWRpdG9yU3RhdGUsIEFsbFNlbGVjdGlvbiwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gJ3Byb3NlbWlycm9yLWtleW1hcCc7XG5pbXBvcnQgeyBkZWxldGVTZWxlY3Rpb24sIHNlbGVjdEFsbCwgYmFzZUtleW1hcCwgY2hhaW5Db21tYW5kcywgam9pbkZvcndhcmQsIG5ld2xpbmVJbkNvZGUsIHNldEJsb2NrVHlwZSwgd3JhcEluLCB0b2dnbGVNYXJrIGFzIHRvZ2dsZU1hcmskMSwgZXhpdENvZGUgfSBmcm9tICdwcm9zZW1pcnJvci1jb21tYW5kcyc7XG5pbXBvcnQgeyBJbnB1dFJ1bGUsIGlucHV0UnVsZXMsIHVuZG9JbnB1dFJ1bGUgfSBmcm9tICdwcm9zZW1pcnJvci1pbnB1dHJ1bGVzJztcbmltcG9ydCB7IHVuZG8sIHJlZG8sIGhpc3RvcnksIHVuZG9EZXB0aCB9IGZyb20gJ3Byb3NlbWlycm9yLWhpc3RvcnknO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MkMSA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MkMSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MkMShkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyQxKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyQxKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiQxID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbiQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5JDEodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0IHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqICAyKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAqICAzKSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlICBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoT3duUHJvcGVydGllcyBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMnO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaE93blByb3BlcnRpZXMgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMnKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaE93blByb3BlcnRpZXMoe2E6MSxiOjIsYzozfSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaE93blByb3BlcnRpZXMkMihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIHZhciBrZXk7XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGlmIChpdGVyYXRlZS5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZm9yRWFjaE93blByb3BlcnRpZXNfMSA9IGZvckVhY2hPd25Qcm9wZXJ0aWVzJDI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlbmQgdGhlIHRhcmdldCBvYmplY3QgZnJvbSBvdGhlciBvYmplY3RzLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlIG9iamVjdFxuICovXG5cbi8qKlxuICogRXh0ZW5kIHRoZSB0YXJnZXQgb2JqZWN0IGZyb20gb3RoZXIgb2JqZWN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgdGhhdCB3aWxsIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0gey4uLm9iamVjdH0gb2JqZWN0cyAtIE9iamVjdHMgYXMgc291cmNlc1xuICogQHJldHVybnMge29iamVjdH0gRXh0ZW5kZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOm9iamVjdFxuICovXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBvYmplY3RzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgc291cmNlLCBwcm9wLCBpLCBsZW47XG5cbiAgZm9yIChpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIGV4dGVuZF8xID0gZXh0ZW5kO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcsIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgc3RyaW5nP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nJDMob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbnZhciBpc1N0cmluZ18xID0gaXNTdHJpbmckMztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXkgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFuIGluc3RhbmNlIG9mIEFycmF5LCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGFycmF5IGluc3RhbmNlP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkkMyhvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG52YXIgaXNBcnJheV8xID0gaXNBcnJheSQzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5KG9yIEFycmF5LWxpa2Ugb2JqZWN0KSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50XG4gKiBpbiB0aGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIGluIGFzY2VuZGluZyBvcmRlci5cbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuXG4gKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAxKSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnRcbiAqICAyKSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnRcbiAqICAzKSBUaGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIGJlaW5nIHRyYXZlcnNlZFxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN8Tm9kZUxpc3R9IGFyciBUaGUgYXJyYXkob3IgQXJyYXktbGlrZSBvYmplY3QpIHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIENvbnRleHQodGhpcykgb2YgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGZvckVhY2hBcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaEFycmF5JztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGZvckVhY2hBcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoQXJyYXknKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaEFycmF5KFsxLDIsM10sIGZ1bmN0aW9uKHZhbHVlKXtcbiAqICAgc3VtICs9IHZhbHVlO1xuICogfSk7XG4gKiBhbGVydChzdW0pOyAvLyA2XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBcnJheSQzKGFyciwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICBmb3IgKDsgaW5kZXggPCBsZW47IGluZGV4ICs9IDEpIHtcbiAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBhcnJbaW5kZXhdLCBpbmRleCwgYXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZm9yRWFjaEFycmF5XzEgPSBmb3JFYWNoQXJyYXkkMztcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0KG9yIGVsZW1lbnQgb2YgYXJyYXkpIHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzQXJyYXkkMiA9IGlzQXJyYXlfMTtcbnZhciBmb3JFYWNoQXJyYXkkMiA9IGZvckVhY2hBcnJheV8xO1xudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzJDEgPSBmb3JFYWNoT3duUHJvcGVydGllc18xO1xuXG4vKipcbiAqIEBtb2R1bGUgY29sbGVjdGlvblxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBJZiB0aGUgb2JqZWN0IGlzIEFycmF5LWxpa2Ugb2JqZWN0KGV4LWFyZ3VtZW50cyBvYmplY3QpLCBJdCBuZWVkcyB0byB0cmFuc2Zvcm0gdG8gQXJyYXkuKHNlZSAnZXgyJyBvZiBleGFtcGxlKS5cbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuXG4gKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAxKSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudClcbiAqICAyKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50KVxuICogIDMpIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaCBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaCc7IFxuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaCA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoJyk7IFxuICpcbiAqIGxldCBzdW0gPSAwO1xuICpcbiAqIGZvckVhY2goWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqXG4gKiAvLyBJbiBjYXNlIG9mIEFycmF5LWxpa2Ugb2JqZWN0XG4gKiBjb25zdCBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7IC8vIGNoYW5nZSB0byBhcnJheVxuICogZm9yRWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaCQ0KG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgaWYgKGlzQXJyYXkkMihvYmopKSB7XG4gICAgZm9yRWFjaEFycmF5JDIob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaE93blByb3BlcnRpZXMkMShvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZm9yRWFjaF8xID0gZm9yRWFjaCQ0O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNTdHJpbmckMiA9IGlzU3RyaW5nXzE7XG52YXIgZm9yRWFjaCQzID0gZm9yRWFjaF8xO1xuXG4vKipcbiAqIFNldHRpbmcgZWxlbWVudCBzdHlsZVxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSBlbGVtZW50IHRvIHNldHRpbmcgc3R5bGVcbiAqIEBwYXJhbSB7KHN0cmluZ3xvYmplY3QpfSBrZXkgLSBzdHlsZSBwcm9wIG5hbWUgb3Ige3Byb3A6IHZhbHVlfSBwYWlyIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gLSBzdHlsZSB2YWx1ZVxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIGNzcyhlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgaWYgKGlzU3RyaW5nJDIoa2V5KSkge1xuICAgIHN0eWxlW2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2gkMyhrZXksIGZ1bmN0aW9uKHYsIGspIHtcbiAgICBzdHlsZVtrXSA9IHY7XG4gIH0pO1xufVxuXG52YXIgY3NzXzEgPSBjc3M7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cblxudmFyIGlzQXJyYXkkMSA9IGlzQXJyYXlfMTtcblxuLyoqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheVxuICogZnJvbSBzdGFydCBpbmRleChkZWZhdWx0IDApLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqIEl0IGNvbXBhcmVzIHNlYXJjaEVsZW1lbnQgdG8gZWxlbWVudHMgb2YgdGhlIEFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICogKHRoZSBzYW1lIG1ldGhvZCB1c2VkIGJ5IHRoZSA9PT0sIG9yIHRyaXBsZS1lcXVhbHMsIG9wZXJhdG9yKS5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBTdGFydCBpbmRleCBpbiBhcnJheSBmb3Igc2VhcmNoaW5nIChkZWZhdWx0IDApXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgRmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudFxuICogQG1lbWJlcm9mIG1vZHVsZTphcnJheVxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGluQXJyYXkgZnJvbSAndHVpLWNvZGUtc25pcHBldC9hcnJheS9pbkFycmF5JztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGluQXJyYXkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2FycmF5L2luQXJyYXknKTtcbiAqXG4gKiBjb25zdCBhcnIgPSBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91ciddO1xuICogY29uc3QgaWR4MSA9IGluQXJyYXkoJ29uZScsIGFyciwgMyk7IC8vIC0xXG4gKiBjb25zdCBpZHgyID0gaW5BcnJheSgnb25lJywgYXJyKTsgLy8gMFxuICovXG5mdW5jdGlvbiBpbkFycmF5JDQoc2VhcmNoRWxlbWVudCwgYXJyYXksIHN0YXJ0SW5kZXgpIHtcbiAgdmFyIGk7XG4gIHZhciBsZW5ndGg7XG4gIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG5cbiAgaWYgKCFpc0FycmF5JDEoYXJyYXkpKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXJyYXksIHNlYXJjaEVsZW1lbnQsIHN0YXJ0SW5kZXgpO1xuICB9XG5cbiAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBmb3IgKGkgPSBzdGFydEluZGV4OyBzdGFydEluZGV4ID49IDAgJiYgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSBzZWFyY2hFbGVtZW50KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbnZhciBpbkFycmF5XzEgPSBpbkFycmF5JDQ7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB1bmRlZmluZWQgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB1bmRlZmluZWQgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgdW5kZWZpbmVkP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkJDQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZmluZWRcbn1cblxudmFyIGlzVW5kZWZpbmVkXzEgPSBpc1VuZGVmaW5lZCQ0O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgR2V0IEhUTUwgZWxlbWVudCdzIGRlc2lnbiBjbGFzc2VzLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzVW5kZWZpbmVkJDMgPSBpc1VuZGVmaW5lZF8xO1xuXG4vKipcbiAqIEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlbGVtZW50IGNzcyBjbGFzcyBuYW1lXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3MkMyhlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jbGFzc05hbWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQkMyhlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsKSkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS5iYXNlVmFsO1xufVxuXG52YXIgZ2V0Q2xhc3NfMSA9IGdldENsYXNzJDM7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBTZXQgY2xhc3NOYW1lIHZhbHVlXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNBcnJheSA9IGlzQXJyYXlfMTtcbnZhciBpc1VuZGVmaW5lZCQyID0gaXNVbmRlZmluZWRfMTtcblxuLyoqXG4gKiBTZXQgY2xhc3NOYW1lIHZhbHVlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBjc3NDbGFzcyAtIGNsYXNzIG5hbWVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbGFzc05hbWUkMihlbGVtZW50LCBjc3NDbGFzcykge1xuICBjc3NDbGFzcyA9IGlzQXJyYXkoY3NzQ2xhc3MpID8gY3NzQ2xhc3Muam9pbignICcpIDogY3NzQ2xhc3M7XG5cbiAgY3NzQ2xhc3MgPSBjc3NDbGFzcy5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4gIGlmIChpc1VuZGVmaW5lZCQyKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzcztcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgPSBjc3NDbGFzcztcbn1cblxudmFyIF9zZXRDbGFzc05hbWUgPSBzZXRDbGFzc05hbWUkMjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFkZCBjc3MgY2xhc3MgdG8gZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGZvckVhY2gkMiA9IGZvckVhY2hfMTtcbnZhciBpbkFycmF5JDMgPSBpbkFycmF5XzE7XG52YXIgZ2V0Q2xhc3MkMiA9IGdldENsYXNzXzE7XG52YXIgc2V0Q2xhc3NOYW1lJDEgPSBfc2V0Q2xhc3NOYW1lO1xuXG4vKipcbiAqIGRvbVV0aWwgbW9kdWxlXG4gKiBAbW9kdWxlIGRvbVV0aWxcbiAqL1xuXG4vKipcbiAqIEFkZCBjc3MgY2xhc3MgdG8gZWxlbWVudFxuICogQHBhcmFtIHsoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCl9IGVsZW1lbnQgLSB0YXJnZXQgZWxlbWVudFxuICogQHBhcmFtIHsuLi5zdHJpbmd9IGNzc0NsYXNzIC0gY3NzIGNsYXNzZXMgdG8gYWRkXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCkge1xuICB2YXIgY3NzQ2xhc3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG4gIHZhciBuZXdDbGFzcyA9IFtdO1xuICB2YXIgb3JpZ2luO1xuXG4gIGlmIChjbGFzc0xpc3QpIHtcbiAgICBmb3JFYWNoJDIoY3NzQ2xhc3MsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzJDIoZWxlbWVudCk7XG5cbiAgaWYgKG9yaWdpbikge1xuICAgIGNzc0NsYXNzID0gW10uY29uY2F0KG9yaWdpbi5zcGxpdCgvXFxzKy8pLCBjc3NDbGFzcyk7XG4gIH1cblxuICBmb3JFYWNoJDIoY3NzQ2xhc3MsIGZ1bmN0aW9uKGNscykge1xuICAgIGlmIChpbkFycmF5JDMoY2xzLCBuZXdDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKGNscyk7XG4gICAgfVxuICB9KTtcblxuICBzZXRDbGFzc05hbWUkMShlbGVtZW50LCBuZXdDbGFzcyk7XG59XG5cbnZhciBhZGRDbGFzc18xID0gYWRkQ2xhc3M7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZW1vdmUgY3NzIGNsYXNzIGZyb20gZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGZvckVhY2hBcnJheSQxID0gZm9yRWFjaEFycmF5XzE7XG52YXIgaW5BcnJheSQyID0gaW5BcnJheV8xO1xudmFyIGdldENsYXNzJDEgPSBnZXRDbGFzc18xO1xudmFyIHNldENsYXNzTmFtZSA9IF9zZXRDbGFzc05hbWU7XG5cbi8qKlxuICogUmVtb3ZlIGNzcyBjbGFzcyBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc2VzIHRvIHJlbW92ZVxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQpIHtcbiAgdmFyIGNzc0NsYXNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuICB2YXIgb3JpZ2luLCBuZXdDbGFzcztcblxuICBpZiAoY2xhc3NMaXN0KSB7XG4gICAgZm9yRWFjaEFycmF5JDEoY3NzQ2xhc3MsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBvcmlnaW4gPSBnZXRDbGFzcyQxKGVsZW1lbnQpLnNwbGl0KC9cXHMrLyk7XG4gIG5ld0NsYXNzID0gW107XG4gIGZvckVhY2hBcnJheSQxKG9yaWdpbiwgZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChpbkFycmF5JDIobmFtZSwgY3NzQ2xhc3MpIDwgMCkge1xuICAgICAgbmV3Q2xhc3MucHVzaChuYW1lKTtcbiAgICB9XG4gIH0pO1xuXG4gIHNldENsYXNzTmFtZShlbGVtZW50LCBuZXdDbGFzcyk7XG59XG5cbnZhciByZW1vdmVDbGFzc18xID0gcmVtb3ZlQ2xhc3M7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgbnVtYmVyIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIG51bWJlciwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBudW1iZXI/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBOdW1iZXI7XG59XG5cbnZhciBpc051bWJlcl8xID0gaXNOdW1iZXI7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUoYXJndW1lbnRzWzBdKSBpcyBudWxsLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBudWxsP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCQxKG9iaikge1xuICByZXR1cm4gb2JqID09PSBudWxsO1xufVxuXG52YXIgaXNOdWxsXzEgPSBpc051bGwkMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlcXVlc3QgaW1hZ2UgcGluZy5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBmb3JFYWNoT3duUHJvcGVydGllcyA9IGZvckVhY2hPd25Qcm9wZXJ0aWVzXzE7XG5cbi8qKlxuICogQG1vZHVsZSByZXF1ZXN0XG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IGltYWdlIHBpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIHVybCBmb3IgcGluZyByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gdHJhY2tpbmdJbmZvIGluZm9zIGZvciBtYWtlIHF1ZXJ5IHN0cmluZ1xuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICogQG1lbWJlcm9mIG1vZHVsZTpyZXF1ZXN0XG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgaW1hZ2VQaW5nIGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvcmVxdWVzdC9pbWFnZVBpbmcnO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgaW1hZ2VQaW5nID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9yZXF1ZXN0L2ltYWdlUGluZycpO1xuICpcbiAqIGltYWdlUGluZygnaHR0cHM6Ly93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vY29sbGVjdCcsIHtcbiAqICAgdjogMSxcbiAqICAgdDogJ2V2ZW50JyxcbiAqICAgdGlkOiAndHJhY2tpbmdpZCcsXG4gKiAgIGNpZDogJ2NpZCcsXG4gKiAgIGRwOiAnZHAnLFxuICogICBkaDogJ2RoJ1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGltYWdlUGluZyQxKHVybCwgdHJhY2tpbmdJbmZvKSB7XG4gIHZhciB0cmFja2luZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gJyc7XG4gIGZvckVhY2hPd25Qcm9wZXJ0aWVzKHRyYWNraW5nSW5mbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHF1ZXJ5U3RyaW5nICs9ICcmJyArIGtleSArICc9JyArIHZhbHVlO1xuICB9KTtcbiAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XG5cbiAgdHJhY2tpbmdFbGVtZW50LnNyYyA9IHVybCArICc/JyArIHF1ZXJ5U3RyaW5nO1xuXG4gIHRyYWNraW5nRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRyYWNraW5nRWxlbWVudCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcblxuICByZXR1cm4gdHJhY2tpbmdFbGVtZW50O1xufVxuXG52YXIgaW1hZ2VQaW5nXzEgPSBpbWFnZVBpbmckMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1VuZGVmaW5lZCQxID0gaXNVbmRlZmluZWRfMTtcbnZhciBpbWFnZVBpbmcgPSBpbWFnZVBpbmdfMTtcblxudmFyIG1zN2RheXMgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZGF0ZSBoYXMgcGFzc2VkIDcgZGF5c1xuICogQHBhcmFtIHtudW1iZXJ9IGRhdGUgLSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFeHBpcmVkKGRhdGUpIHtcbiAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIHJldHVybiBub3cgLSBkYXRlID4gbXM3ZGF5cztcbn1cblxuLyoqXG4gKiBTZW5kIGhvc3RuYW1lIG9uIERPTUNvbnRlbnRMb2FkZWQuXG4gKiBUbyBwcmV2ZW50IGhvc3RuYW1lIHNldCB0dWkudXNhZ2VTdGF0aXN0aWNzIHRvIGZhbHNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwcE5hbWUgLSBhcHBsaWNhdGlvbiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHJhY2tpbmdJZCAtIEdBIHRyYWNraW5nIElEXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHNlbmRIb3N0bmFtZShhcHBOYW1lLCB0cmFja2luZ0lkKSB7XG4gIHZhciB1cmwgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlLWFuYWx5dGljcy5jb20vY29sbGVjdCc7XG4gIHZhciBob3N0bmFtZSA9IGxvY2F0aW9uLmhvc3RuYW1lO1xuICB2YXIgaGl0VHlwZSA9ICdldmVudCc7XG4gIHZhciBldmVudENhdGVnb3J5ID0gJ3VzZSc7XG4gIHZhciBhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UgPSAnVE9BU1QgVUkgJyArIGFwcE5hbWUgKyAnIGZvciAnICsgaG9zdG5hbWUgKyAnOiBTdGF0aXN0aWNzJztcbiAgdmFyIGRhdGUgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oYXBwbGljYXRpb25LZXlGb3JTdG9yYWdlKTtcblxuICAvLyBza2lwIGlmIHRoZSBmbGFnIGlzIGRlZmluZWQgYW5kIGlzIHNldCB0byBmYWxzZSBleHBsaWNpdGx5XG4gIGlmICghaXNVbmRlZmluZWQkMSh3aW5kb3cudHVpKSAmJiB3aW5kb3cudHVpLnVzYWdlU3RhdGlzdGljcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBza2lwIGlmIG5vdCBwYXNzIHNldmVuIGRheXMgb2xkXG4gIGlmIChkYXRlICYmICFpc0V4cGlyZWQoZGF0ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwbGljYXRpb25LZXlGb3JTdG9yYWdlLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpbWFnZVBpbmcodXJsLCB7XG4gICAgICAgIHY6IDEsXG4gICAgICAgIHQ6IGhpdFR5cGUsXG4gICAgICAgIHRpZDogdHJhY2tpbmdJZCxcbiAgICAgICAgY2lkOiBob3N0bmFtZSxcbiAgICAgICAgZHA6IGhvc3RuYW1lLFxuICAgICAgICBkaDogYXBwTmFtZSxcbiAgICAgICAgZWw6IGFwcE5hbWUsXG4gICAgICAgIGVjOiBldmVudENhdGVnb3J5XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIDEwMDApO1xufVxuXG52YXIgc2VuZEhvc3RuYW1lXzEgPSBzZW5kSG9zdG5hbWU7XG5cbi9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciByZVNwYWNlTW9yZVRoYW5PbmUgPSAvW1xcdTAwMjBdKy9nO1xudmFyIHJlRXNjYXBlQ2hhcnMkMSA9IC9bPigpe31bXFxdKy0uISN8XS9nO1xudmFyIHJlRXNjYXBlSFRNTCA9IC88KFthLXpBLVpfXVthLXpBLVowLTlcXC0uX10qKShcXHN8W15cXFxcPl0pKlxcLz8+fDwoXFwvKShbYS16QS1aX11bYS16QS1aMC05XFwtLl9dKilcXHMqXFwvPz58PCEtLVteLV0rLS0+fDwoW2EtekEtWl9dW2EtekEtWjAtOVxcLS46L10qKT4vZztcbnZhciByZUVzY2FwZUJhY2tTbGFzaCA9IC9cXFxcWyFcIiMkJSYnKCkqKywtLi86Ozw9Pj9AW1xcXV5fYHt8fX5cXFxcXS9nO1xudmFyIHJlRXNjYXBlUGFpcmVkQ2hhcnMgPSAvWypffmBdL2c7XG52YXIgcmVNZEltYWdlU3ludGF4ID0gLyFcXFsuKlxcXVxcKC4qXFwpL2c7XG52YXIgcmVFc2NhcGVkQ2hhckluTGlua1N5bnRheCA9IC9bW1xcXV0vZztcbnZhciByZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UgPSAvKD86XnxbXlxcXFxdKVxcXFwoPyFcXFxcKS9nO1xudmFyIFhNTFNQRUNJQUwkMSA9ICdbJjw+XCJdJztcbnZhciByZVhtbFNwZWNpYWwkMSA9IG5ldyBSZWdFeHAoWE1MU1BFQ0lBTCQxLCAnZycpO1xuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIkMShjaGFyKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICcmYW1wOyc7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICcmbHQ7JztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICByZXR1cm4gJyZndDsnO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICB9XG59XG5mdW5jdGlvbiBlc2NhcGVYbWwkMSh0ZXh0KSB7XG4gICAgaWYgKHJlWG1sU3BlY2lhbCQxLnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZVhtbFNwZWNpYWwkMSwgcmVwbGFjZVVuc2FmZUNoYXIkMSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gc2VuZEhvc3ROYW1lKCkge1xuICAgIHNlbmRIb3N0bmFtZV8xKCdlZGl0b3InLCAnVUEtMTI5OTY2OTI5LTEnKTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzKGFyciwgdGFyZ2V0SXRlbSkge1xuICAgIHJldHVybiBhcnIuaW5kZXhPZih0YXJnZXRJdGVtKSAhPT0gLTE7XG59XG52YXIgYXZhaWxhYmxlTGlua0F0dHJpYnV0ZXMgPSBbJ3JlbCcsICd0YXJnZXQnLCAnaHJlZmxhbmcnLCAndHlwZSddO1xudmFyIHJlTWFya2Rvd25UZXh0VG9Fc2NhcGVNYXAgPSB7XG4gICAgY29kZWJsb2NrOiAvKF4gezR9W15cXG5dK1xcbiopKy8sXG4gICAgdGhlbWF0aWNCcmVhazogL14gKigoXFwqICopezMsfXwoLSAqKXszLH0gKnwoXyAqKXszLH0pICovLFxuICAgIGF0eEhlYWRpbmc6IC9eKCN7MSw2fSkgK1tcXHNcXFNdKy8sXG4gICAgc2VUZXh0aGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqLyxcbiAgICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rLiopKy8sXG4gICAgbGlzdDogL14gKihcXCorfC0rfFxcZCtcXC4pIFtcXHNcXFNdKy8sXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqLyxcbiAgICBsaW5rOiAvIT9cXFsuKlxcXVxcKC4qXFwpLyxcbiAgICByZWZsaW5rOiAvIT9cXFsuKlxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICAgIHZlcnRpY2FsQmFyOiAvXFx1MDA3Qy8sXG4gICAgZmVuY2VkQ29kZWJsb2NrOiAvXigoYHx+KXszLH0pLyxcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IHt9O1xuICAgIGF2YWlsYWJsZUxpbmtBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkXzEoYXR0cmlidXRlW2tleV0pKSB7XG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGlua0F0dHJpYnV0ZXM7XG59XG5mdW5jdGlvbiByZXBlYXQkMSh0ZXh0LCBjb3VudCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgcmVzdWx0ICs9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc05lZWRFc2NhcGVUZXh0KHRleHQpIHtcbiAgICB2YXIgbmVlZEVzY2FwZSA9IGZhbHNlO1xuICAgIGZvckVhY2hPd25Qcm9wZXJ0aWVzXzEocmVNYXJrZG93blRleHRUb0VzY2FwZU1hcCwgZnVuY3Rpb24gKHJlTWFya2Rvd25UZXh0VG9Fc2NhcGUpIHtcbiAgICAgICAgaWYgKHJlTWFya2Rvd25UZXh0VG9Fc2NhcGUudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgbmVlZEVzY2FwZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFuZWVkRXNjYXBlO1xuICAgIH0pO1xuICAgIHJldHVybiBuZWVkRXNjYXBlO1xufVxuZnVuY3Rpb24gZXNjYXBlVGV4dEZvckxpbmsodGV4dCkge1xuICAgIHZhciBpbWFnZVN5bnRheFJhbmdlcyA9IFtdO1xuICAgIHZhciByZXN1bHQgPSByZU1kSW1hZ2VTeW50YXguZXhlYyh0ZXh0KTtcbiAgICB3aGlsZSAocmVzdWx0KSB7XG4gICAgICAgIGltYWdlU3ludGF4UmFuZ2VzLnB1c2goW3Jlc3VsdC5pbmRleCwgcmVzdWx0LmluZGV4ICsgcmVzdWx0WzBdLmxlbmd0aF0pO1xuICAgICAgICByZXN1bHQgPSByZU1kSW1hZ2VTeW50YXguZXhlYyh0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShyZUVzY2FwZWRDaGFySW5MaW5rU3ludGF4LCBmdW5jdGlvbiAobWF0Y2hlZCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpc0RlbGltaXRlciA9IGltYWdlU3ludGF4UmFuZ2VzLnNvbWUoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBvZmZzZXQgPiByYW5nZVswXSAmJiBvZmZzZXQgPCByYW5nZVsxXTsgfSk7XG4gICAgICAgIHJldHVybiBpc0RlbGltaXRlciA/IG1hdGNoZWQgOiBcIlxcXFxcIiArIG1hdGNoZWQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlc2NhcGUkMSh0ZXh0KSB7XG4gICAgdmFyIGFoZWFkUmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2hlZCkgeyByZXR1cm4gXCJcXFxcXCIgKyBtYXRjaGVkOyB9O1xuICAgIHZhciBiZWhpbmRSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaGVkKSB7IHJldHVybiBtYXRjaGVkICsgXCJcXFxcXCI7IH07XG4gICAgdmFyIGVzY2FwZWRUZXh0ID0gdGV4dC5yZXBsYWNlKHJlU3BhY2VNb3JlVGhhbk9uZSwgJyAnKTtcbiAgICBpZiAocmVFc2NhcGVCYWNrU2xhc2gudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlQmFja1NsYXNoLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgaWYgKHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZS50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVCYWNrU2xhc2hJblNlbnRlbmNlLCBiZWhpbmRSZXBsYWNlcik7XG4gICAgfVxuICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZVBhaXJlZENoYXJzLCBhaGVhZFJlcGxhY2VyKTtcbiAgICBpZiAocmVFc2NhcGVIVE1MLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUhUTUwsIGFoZWFkUmVwbGFjZXIpO1xuICAgIH1cbiAgICBpZiAoaXNOZWVkRXNjYXBlVGV4dChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlQ2hhcnMkMSwgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbn1cbmZ1bmN0aW9uIHF1b3RlKHRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICh0ZXh0LmluZGV4T2YoJ1wiJykgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIlwiJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRleHQuaW5kZXhPZihcIidcIikgPT09IC0xID8gXCInJ1wiIDogJygpJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFswXSArIHRleHQgKyByZXN1bHRbMV07XG59XG5mdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgIHJldHVybiBpc051bGxfMSh2YWx1ZSkgfHwgaXNVbmRlZmluZWRfMSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwobzEsIG8yKSB7XG4gICAgaWYgKG8xID09PSBudWxsICYmIG8xID09PSBvMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG8yICE9PSAnb2JqZWN0JyB8fCBpc05pbChvMSkgfHwgaXNOaWwobzIpKSB7XG4gICAgICAgIHJldHVybiBvMSA9PT0gbzI7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvMSkge1xuICAgICAgICBpZiAobzFba2V5XSAhPT0gbzJba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvMikge1xuICAgICAgICBpZiAoIShrZXkgaW4gbzEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsYXN0JDEoYXJyKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBiZXR3ZWVuJDEodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXg7XG59XG5mdW5jdGlvbiBpc09iamVjdCQxKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2VkQ29weSh0YXJnZXRPYmosIG9iaikge1xuICAgIHZhciByZXN1bHRPYmogPSBfX2Fzc2lnbiQxKHt9LCB0YXJnZXRPYmopO1xuICAgIGlmICh0YXJnZXRPYmogJiYgb2JqKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0JDEocmVzdWx0T2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gZGVlcENvcHlBcnJheShvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHRPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gZGVlcE1lcmdlZENvcHkocmVzdWx0T2JqW3Byb3BdLCBvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0T2JqW3Byb3BdID0gZGVlcENvcHkob2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0T2JqO1xufVxuZnVuY3Rpb24gZGVlcENvcHlBcnJheShpdGVtcykge1xuICAgIHJldHVybiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0JDEoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pID8gZGVlcENvcHlBcnJheShpdGVtKSA6IGRlZXBDb3B5KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0JDEob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgYWNjW3Byb3BdID0gQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pID8gZGVlcENvcHlBcnJheShvYmpbcHJvcF0pIDogZGVlcENvcHkob2JqW3Byb3BdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY1twcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXRPYmosIG9iaikge1xuICAgIGlmIChvYmogPT09IHZvaWQgMCkgeyBvYmogPSB7fTsgfVxuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0T2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIHR5cGVvZiB0YXJnZXRPYmpbcHJvcF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzaWduKHRhcmdldE9ialtwcm9wXSwgb2JqW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXRPYmo7XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWROdW1QYWlyKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgcmV0dXJuIHZhbHVlQSA+IHZhbHVlQiA/IFt2YWx1ZUIsIHZhbHVlQV0gOiBbdmFsdWVBLCB2YWx1ZUJdO1xufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVHJhbnNmb3JtIHRoZSBBcnJheS1saWtlIG9iamVjdCB0byBBcnJheS5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmb3JFYWNoQXJyYXlfMTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIEFycmF5LWxpa2Ugb2JqZWN0IHRvIEFycmF5LlxuICogSW4gbG93IElFIChiZWxvdyA4KSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgaXMgbm90IHBlcmZlY3QuIFNvLCB0cnktY2F0Y2ggc3RhdGVtZW50IGlzIHVzZWQuXG4gKiBAcGFyYW0geyp9IGFycmF5TGlrZSBBcnJheS1saWtlIG9iamVjdFxuICogQHJldHVybnMge0FycmF5fSBBcnJheVxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgdG9BcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vdG9BcnJheSc7IFxuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5Jyk7IFxuICpcbiAqIGNvbnN0IGFycmF5TGlrZSA9IHtcbiAqICAgMDogJ29uZScsXG4gKiAgIDE6ICd0d28nLFxuICogICAyOiAndGhyZWUnLFxuICogICAzOiAnZm91cicsXG4gKiAgIGxlbmd0aDogNFxuICogfTtcbiAqIGNvbnN0IHJlc3VsdCA9IHRvQXJyYXkoYXJyYXlMaWtlKTtcbiAqXG4gKiBhbGVydChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSk7IC8vIHRydWVcbiAqIGFsZXJ0KHJlc3VsdCk7IC8vIG9uZSx0d28sdGhyZWUsZm91clxuICovXG5mdW5jdGlvbiB0b0FycmF5JDEoYXJyYXlMaWtlKSB7XG4gIHZhciBhcnI7XG4gIHRyeSB7XG4gICAgYXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFyciA9IFtdO1xuICAgIGZvckVhY2hBcnJheShhcnJheUxpa2UsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG52YXIgdG9BcnJheV8xID0gdG9BcnJheSQxO1xuXG5mdW5jdGlvbiBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hLCBjb250ZW50KSB7XG4gICAgdmFyIHBhcmFncmFwaCA9IHNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGg7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJhZ3JhcGguY3JlYXRlQW5kRmlsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYWdyYXBoLmNyZWF0ZShudWxsLCBpc1N0cmluZ18xKGNvbnRlbnQpID8gc2NoZW1hLnRleHQoY29udGVudCkgOiBjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCB0ZXh0LCBtYXJrcykge1xuICAgIHJldHVybiBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tLCB0bykge1xuICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gZnJvbTsgfVxuICAgIHZhciBjb250ZW50U2l6ZSA9IHRyLmRvYy5jb250ZW50LnNpemU7XG4gICAgdmFyIHNpemUgPSBjb250ZW50U2l6ZSA+IDAgPyBjb250ZW50U2l6ZSAtIDEgOiAxO1xuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIE1hdGgubWluKGZyb20sIHNpemUpLCBNYXRoLm1pbih0bywgc2l6ZSkpO1xufVxuZnVuY3Rpb24gYWRkUGFyYWdyYXBoKHRyLCBfYSwgc2NoZW1hKSB7XG4gICAgdmFyIHBvcyA9IF9hLnBvcztcbiAgICB0ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgY3JlYXRlUGFyYWdyYXBoKHNjaGVtYSkpO1xuICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgcG9zICsgMSkpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRleHROb2RlKF9hKSB7XG4gICAgdmFyIHN0YXRlID0gX2Euc3RhdGUsIGZyb20gPSBfYS5mcm9tLCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleCwgY3JlYXRlVGV4dCA9IF9hLmNyZWF0ZVRleHQ7XG4gICAgdmFyIHRyID0gc3RhdGUudHIsIGRvYyA9IHN0YXRlLmRvYywgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIF9iID0gZG9jLmNoaWxkKGkpLCBub2RlU2l6ZSA9IF9iLm5vZGVTaXplLCB0ZXh0Q29udGVudCA9IF9iLnRleHRDb250ZW50LCBjb250ZW50ID0gX2IuY29udGVudDtcbiAgICAgICAgdmFyIHRleHQgPSBjcmVhdGVUZXh0KHRleHRDb250ZW50KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZXh0ID8gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRleHQpIDogRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIHZhciBtYXBwZWRGcm9tID0gdHIubWFwcGluZy5tYXAoZnJvbSk7XG4gICAgICAgIHZhciBtYXBwZWRUbyA9IG1hcHBlZEZyb20gKyBjb250ZW50LnNpemU7XG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hcHBlZEZyb20sIG1hcHBlZFRvLCBub2RlKTtcbiAgICAgICAgZnJvbSArPSBub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gc3BsaXRBbmRFeHRlbmRCbG9jayh0ciwgcG9zLCB0ZXh0LCBub2RlKSB7XG4gICAgdmFyIHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICB0ci5zcGxpdChwb3MpXG4gICAgICAgIC5kZWxldGUocG9zIC0gdGV4dExlbiwgcG9zKVxuICAgICAgICAuaW5zZXJ0KHRyLm1hcHBpbmcubWFwKHBvcyksIG5vZGUpXG4gICAgICAgIC5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAocG9zKSAtIHRleHRMZW4pKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWRTdGFydExpbmUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMF1bMF07XG59XG5mdW5jdGlvbiBnZXRNZEVuZExpbmUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMV1bMF07XG59XG5mdW5jdGlvbiBnZXRNZFN0YXJ0Q2gobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZS5zb3VyY2Vwb3NbMF1bMV07XG59XG5mdW5jdGlvbiBnZXRNZEVuZENoKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzFdWzFdO1xufVxuZnVuY3Rpb24gaXNIVE1MTm9kZShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAnaHRtbEJsb2NrJyB8fCB0eXBlID09PSAnaHRtbElubGluZSc7XG59XG5mdW5jdGlvbiBpc1N0eWxlZElubGluZU5vZGUobWROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBtZE5vZGUudHlwZTtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdzdHJpa2UnIHx8XG4gICAgICAgIHR5cGUgPT09ICdzdHJvbmcnIHx8XG4gICAgICAgIHR5cGUgPT09ICdlbXBoJyB8fFxuICAgICAgICB0eXBlID09PSAnY29kZScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2xpbmsnIHx8XG4gICAgICAgIHR5cGUgPT09ICdpbWFnZScpO1xufVxuZnVuY3Rpb24gaXNDb2RlQmxvY2tOb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgbWROb2RlLnR5cGUgPT09ICdjb2RlQmxvY2snO1xufVxuZnVuY3Rpb24gaXNMaXN0Tm9kZSQxKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgKG1kTm9kZS50eXBlID09PSAnaXRlbScgfHwgbWROb2RlLnR5cGUgPT09ICdsaXN0Jyk7XG59XG5mdW5jdGlvbiBpc09yZGVyZWRMaXN0Tm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gaXNMaXN0Tm9kZSQxKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnR5cGUgPT09ICdvcmRlcmVkJztcbn1cbmZ1bmN0aW9uIGlzQnVsbGV0TGlzdE5vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIGlzTGlzdE5vZGUkMShtZE5vZGUpICYmIG1kTm9kZS5saXN0RGF0YS50eXBlICE9PSAnb3JkZXJlZCc7XG59XG5mdW5jdGlvbiBpc1RhYmxlQ2VsbE5vZGUobWROb2RlKSB7XG4gICAgcmV0dXJuIG1kTm9kZSAmJiAobWROb2RlLnR5cGUgPT09ICd0YWJsZUNlbGwnIHx8IG1kTm9kZS50eXBlID09PSAndGFibGVEZWxpbUNlbGwnKTtcbn1cbmZ1bmN0aW9uIGlzSW5saW5lTm9kZSQxKG1kTm9kZSkge1xuICAgIHN3aXRjaCAobWROb2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAnaHRtbElubGluZSc6XG4gICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgIGNhc2UgJ3NvZnRicmVhayc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBjb25kaXRpb24sIGluY2x1ZGVTZWxmKSB7XG4gICAgaWYgKGluY2x1ZGVTZWxmID09PSB2b2lkIDApIHsgaW5jbHVkZVNlbGYgPSB0cnVlOyB9XG4gICAgbWROb2RlID0gaW5jbHVkZVNlbGYgPyBtZE5vZGUgOiBtZE5vZGUucGFyZW50O1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihtZE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWROb2RlO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnROb2RlcyhtZE5vZGUsIGl0ZXJhdGVlLCBpbmNsdWRlU2VsZikge1xuICAgIGlmIChpbmNsdWRlU2VsZiA9PT0gdm9pZCAwKSB7IGluY2x1ZGVTZWxmID0gdHJ1ZTsgfVxuICAgIG1kTm9kZSA9IGluY2x1ZGVTZWxmID8gbWROb2RlIDogbWROb2RlLnBhcmVudDtcbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGl0ZXJhdGVlKG1kTm9kZSk7XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkT2Zmc2V0UG9zKG9yaWdpblBvcywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIFtvcmlnaW5Qb3NbMF0sIG9yaWdpblBvc1sxXSArIG9mZnNldF07XG59XG5mdW5jdGlvbiBzZXRPZmZzZXRQb3Mob3JpZ2luUG9zLCBuZXdPZmZzZXQpIHtcbiAgICByZXR1cm4gW29yaWdpblBvc1swXSwgbmV3T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdldElubGluZU1hcmtkb3duVGV4dChtZE5vZGUpIHtcbiAgICB2YXIgdGV4dCA9IG1kTm9kZS5maXJzdENoaWxkLmxpdGVyYWw7XG4gICAgc3dpdGNoIChtZE5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgICAgIHJldHVybiBcIipcIiArIHRleHQgKyBcIipcIjtcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHJldHVybiBcIioqXCIgKyB0ZXh0ICsgXCIqKlwiO1xuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICAgICAgcmV0dXJuIFwifn5cIiArIHRleHQgKyBcIn5+XCI7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgcmV0dXJuIFwiYFwiICsgdGV4dCArIFwiYFwiO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbiAgICAgICAgICAgIHZhciBfYSA9IG1kTm9kZSwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbiwgdGl0bGUgPSBfYS50aXRsZTtcbiAgICAgICAgICAgIHZhciBkZWxpbSA9IG1kTm9kZS50eXBlID09PSAnbGluaycgPyAnJyA6ICchJztcbiAgICAgICAgICAgIHJldHVybiBkZWxpbSArIFwiW1wiICsgdGV4dCArIFwiXShcIiArIGRlc3RpbmF0aW9uICsgKHRpdGxlID8gXCIgXFxcIlwiICsgdGl0bGUgKyBcIlxcXCJcIiA6ICcnKSArIFwiKVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb250YWluZXIkMihub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICBjYXNlICd0YWJsZURlbGltUm93JzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuVGV4dCQxKG5vZGUpIHtcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIHdhbGtlciA9IG5vZGUud2Fsa2VyKCk7XG4gICAgdmFyIGV2ZW50ID0gbnVsbDtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGV2ZW50Lm5vZGU7XG4gICAgICAgIGlmIChjaGlsZE5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBidWZmZXIucHVzaChjaGlsZE5vZGUubGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbn1cblxudmFyIHdpZGdldFJ1bGVzID0gW107XG52YXIgd2lkZ2V0UnVsZU1hcCA9IHt9O1xudmFyIHJlV2lkZ2V0UHJlZml4ID0gL1xcJFxcJHdpZGdldFxcZCtcXHMvO1xuZnVuY3Rpb24gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpIHtcbiAgICB2YXIgaW5kZXggPSB0ZXh0LnNlYXJjaChyZVdpZGdldFByZWZpeCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB2YXIgcmVzdCA9IHRleHQuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gcmVzdC5yZXBsYWNlKHJlV2lkZ2V0UHJlZml4LCAnJykucmVwbGFjZSgnJCQnLCAnJyk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIHRleHQgKz0gdW53cmFwV2lkZ2V0U3ludGF4KHJlcGxhY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIHRleHQpIHtcbiAgICByZXR1cm4gXCIkJFwiICsgaW5mbyArIFwiIFwiICsgdGV4dCArIFwiJCRcIjtcbn1cbmZ1bmN0aW9uIHdpZGdldFRvRE9NKGluZm8sIHRleHQpIHtcbiAgICB2YXIgX2EgPSB3aWRnZXRSdWxlTWFwW2luZm9dLCBydWxlID0gX2EucnVsZSwgdG9ET00gPSBfYS50b0RPTTtcbiAgICB2YXIgbWF0Y2hlcyA9IHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KS5tYXRjaChydWxlKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB0ZXh0ID0gbWF0Y2hlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvRE9NKHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHdpZGdldFJ1bGVzO1xufVxuZnVuY3Rpb24gc2V0V2lkZ2V0UnVsZXMocnVsZXMpIHtcbiAgICB3aWRnZXRSdWxlcyA9IHJ1bGVzO1xuICAgIHdpZGdldFJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgIHdpZGdldFJ1bGVNYXBbXCJ3aWRnZXRcIiArIGluZGV4XSA9IHJ1bGU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkge1xuICAgIHJldHVybiBub2Rlcy5jb25jYXQoY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSk7XG59XG4vKipcbiAqIGNyZWF0ZSBub2RlcyB3aXRoIHBsYWluIHRleHQgYW5kIHJlcGxhY2UgdGV4dCBtYXRjaGVkIHRvIHRoZSB3aWRnZXQgcnVsZXMgd2l0aCB0aGUgd2lkZ2V0IG5vZGVcbiAqIEZvciBleGFtcGxlLCBpbiBjYXNlIHRoZSB0ZXh0IGFuZCB3aWRnZXQgcnVsZXMgYXMgYmVsb3dcbiAqXG4gKiB0ZXh0OiAkdGVzdCBwbGFpbiB0ZXh0ICN0ZXN0XG4gKiB3aWRnZXQgcnVsZXM6IFt7IHJ1bGU6IC8kLisvIH0sIHsgcnVsZTogLyMuKy8gfV1cbiAqXG4gKiBUaGUgY3JlYXRpbmcgbm9kZSBwcm9jZXNzIGlzIHJlY3Vyc2l2ZSBhbmQgaXMgYXMgZm9sbG93cy5cbiAqXG4gKiBpbiBmaXJzdCB3aWRnZXQgcnVsZSgvJC4rLylcbiAqICAkdGVzdCAtPiB3aWRnZXQgbm9kZVxuICogIHBsYWluIHRleHQgLT4gbWF0Y2ggd2l0aCBuZXh0IHdpZGdldCBydWxlXG4gKiAgI3Rlc3QgLT4gbWF0Y2ggd2l0aCBuZXh0IHdpZGdldCBydWxlXG4gKlxuICogaW4gc2Vjb25kIHdpZGdldCBydWxlKC8jLisvKVxuICogIHBsYWluIHRleHQgLT4gdGV4dCBub2RlKG5vIHJ1bGUgZm9yIG1hdGNoaW5nKVxuICogICN0ZXN0IC0+IHdpZGdldCBub2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzV2l0aFdpZGdldCh0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkge1xuICAgIGlmIChydWxlSW5kZXggPT09IHZvaWQgMCkgeyBydWxlSW5kZXggPSAwOyB9XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHJ1bGUgPSAod2lkZ2V0UnVsZXNbcnVsZUluZGV4XSB8fCB7fSkucnVsZTtcbiAgICB2YXIgbmV4dFJ1bGVJbmRleCA9IHJ1bGVJbmRleCArIDE7XG4gICAgdGV4dCA9IHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KTtcbiAgICBpZiAocnVsZSAmJiBydWxlLnRlc3QodGV4dCkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoKGluZGV4ID0gdGV4dC5zZWFyY2gocnVsZSkpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAvLyBnZXQgd2lkZ2V0IG5vZGUgb24gZmlyc3Qgc3BsaXR0ZWQgdGV4dCB1c2luZyBuZXh0IHdpZGdldCBydWxlXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIG5vZGVzID0gbWVyZ2VOb2Rlcyhub2RlcywgcHJldiwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1aWxkIHdpZGdldCBub2RlIHVzaW5nIGN1cnJlbnQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRleHQubWF0Y2gocnVsZSlbMF07XG4gICAgICAgICAgICB2YXIgaW5mbyA9IFwid2lkZ2V0XCIgKyBydWxlSW5kZXg7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNjaGVtYS5ub2Rlcy53aWRnZXQuY3JlYXRlKHsgaW5mbzogaW5mbyB9LCBzY2hlbWEudGV4dChjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIGxpdGVyYWwpKSkpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKGxpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgd2lkZ2V0IG5vZGUgb24gbGFzdCBzcGxpdHRlZCB0ZXh0IHVzaW5nIG5leHQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0KSB7XG4gICAgICAgIG5vZGVzID1cbiAgICAgICAgICAgIHJ1bGVJbmRleCA8IHdpZGdldFJ1bGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICA/IG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgbmV4dFJ1bGVJbmRleClcbiAgICAgICAgICAgICAgICA6IFtzY2hlbWEudGV4dCh0ZXh0KV07XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldFdpZGdldENvbnRlbnQod2lkZ2V0Tm9kZSkge1xuICAgIHZhciBldmVudDtcbiAgICB2YXIgdGV4dCA9ICcnO1xuICAgIHZhciB3YWxrZXIgPSB3aWRnZXROb2RlLndhbGtlcigpO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHdpZGdldE5vZGUgJiYgbm9kZS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGdldElubGluZU1hcmtkb3duVGV4dChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHdhbGtlci5yZXN1bWVBdCh3aWRnZXROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLmxpdGVyYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxldGVTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlbGV0ZVNlbGVjdGlvbjsgfSxcbiAgICAgICAgc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxlY3RBbGw7IH0sXG4gICAgICAgIHVuZG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZG87IH0sXG4gICAgICAgIHJlZG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZG87IH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gc3RhdGUuZG9jO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9jLmNoaWxkQ291bnQgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9jLmZpcnN0Q2hpbGQuaXNUZXh0YmxvY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9jLmZpcnN0Q2hpbGQuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZUhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3NfMShwbGFjZUhvbGRlciwgJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3NfMShwbGFjZUhvbGRlciwgb3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlSG9sZGVyLnRleHRDb250ZW50ID0gb3B0aW9ucy50ZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBbRGVjb3JhdGlvbi53aWRnZXQoMSwgcGxhY2VIb2xkZXIpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIGVsZW1lbnQgaGFzIHNwZWNpZmljIGNzcyBjbGFzc1xuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGluQXJyYXkkMSA9IGluQXJyYXlfMTtcbnZhciBnZXRDbGFzcyA9IGdldENsYXNzXzE7XG5cbi8qKlxuICogQ2hlY2sgZWxlbWVudCBoYXMgc3BlY2lmaWMgY3NzIGNsYXNzXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gIHZhciBvcmlnaW47XG5cbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNzc0NsYXNzKTtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzKGVsZW1lbnQpLnNwbGl0KC9cXHMrLyk7XG5cbiAgcmV0dXJuIGluQXJyYXkkMShjc3NDbGFzcywgb3JpZ2luKSA+IC0xO1xufVxuXG52YXIgaGFzQ2xhc3NfMSA9IGhhc0NsYXNzO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgZWxlbWVudCBtYXRjaCBzZWxlY3RvclxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGluQXJyYXkgPSBpbkFycmF5XzE7XG52YXIgdG9BcnJheSA9IHRvQXJyYXlfMTtcblxudmFyIGVsUHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcbnZhciBtYXRjaFNlbGVjdG9yID0gZWxQcm90by5tYXRjaGVzIHx8XG4gICAgZWxQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbFByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGVsUHJvdG8ubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50O1xuXG4gICAgICByZXR1cm4gaW5BcnJheSh0aGlzLCB0b0FycmF5KGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpID4gLTE7XG4gICAgfTtcblxuLyoqXG4gKiBDaGVjayBlbGVtZW50IG1hdGNoIHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gc2VsZWN0b3IgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBpcyBzZWxlY3RvciBtYXRjaGVkIHRvIGVsZW1lbnQ/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICByZXR1cm4gbWF0Y2hTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cblxudmFyIG1hdGNoZXNfMSA9IG1hdGNoZXM7XG5cbnZhciBUQUdfTkFNRSA9ICdbQS1aYS16XVtBLVphLXowLTktXSonO1xudmFyIEFUVFJJQlVURV9OQU1FID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcbnZhciBVTlFVT1RFRF9WQUxVRSA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBTSU5HTEVfUVVPVEVEX1ZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFX1FVT1RFRF9WQUxVRSA9ICdcIlteXCJdKlwiJztcbnZhciBBVFRSSUJVVEVfVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURfVkFMVUUgKyBcInxcIiArIFNJTkdMRV9RVU9URURfVkFMVUUgKyBcInxcIiArIERPVUJMRV9RVU9URURfVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEVfVkFMVUVfU1BFQyA9IFwiXCIgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBBVFRSSUJVVEVfVkFMVUUgKyBcIilcIjtcbnZhciBBVFRSSUJVVEUkMSA9IFwiXCIgKyAnKD86XFxcXHMrJyArIEFUVFJJQlVURV9OQU1FICsgQVRUUklCVVRFX1ZBTFVFX1NQRUMgKyBcIj8pXCI7XG52YXIgT1BFTl9UQUcgPSBcIjwoXCIgKyBUQUdfTkFNRSArIFwiKShcIiArIEFUVFJJQlVURSQxICsgXCIpKlxcXFxzKi8/PlwiO1xudmFyIENMT1NFX1RBRyA9IFwiPC8oXCIgKyBUQUdfTkFNRSArIFwiKVxcXFxzKls+XVwiO1xudmFyIEhUTUxfVEFHID0gXCIoPzpcIiArIE9QRU5fVEFHICsgXCJ8XCIgKyBDTE9TRV9UQUcgKyBcIilcIjtcbnZhciByZUhUTUxUYWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgSFRNTF9UQUcsICdpJyk7XG52YXIgcmVCUiA9IC88YnJcXHMqXFwvKj4vaTtcbnZhciByZUhUTUxDb21tZW50ID0gLzwhIC0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+LztcbnZhciBBTFRFUk5BVElWRV9UQUdfRk9SX0JSID0gJzwvcD48cD4nO1xuXG5mdW5jdGlvbiBpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICB2YXIgbGVmdCA9IHBhcnNlSW50KHN0eWxlLmxlZnQsIDEwKTtcbiAgICB2YXIgdG9wID0gcGFyc2VJbnQoc3R5bGUudG9wLCAxMCk7XG4gICAgdmFyIHdpZHRoID0gcGFyc2VJbnQoc3R5bGUud2lkdGgsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgKyBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQsIDEwKTtcbiAgICB2YXIgaGVpZ2h0ID0gcGFyc2VJbnQoc3R5bGUuaGVpZ2h0LCAxMCkgKyBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgKyBwYXJzZUludChzdHlsZS5wYWRkaW5nQm90dG9tLCAxMCk7XG4gICAgcmV0dXJuIG9mZnNldFggPj0gbGVmdCAmJiBvZmZzZXRYIDw9IGxlZnQgKyB3aWR0aCAmJiBvZmZzZXRZID49IHRvcCAmJiBvZmZzZXRZIDw9IHRvcCArIGhlaWdodDtcbn1cbnZhciBDTFNfUFJFRklYID0gJ3RvYXN0dWktZWRpdG9yLSc7XG5mdW5jdGlvbiBjbHMoKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIF9hID0gMCwgbmFtZXNfMSA9IG5hbWVzOyBfYSA8IG5hbWVzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBuYW1lc18xW19hXTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZV8xKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gbmFtZV8xWzBdID8gbmFtZV8xWzFdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5hbWVfMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcIlwiICsgQ0xTX1BSRUZJWCArIGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBjbHNXaXRoTWRQcmVmaXgoKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBDTFNfUFJFRklYICsgXCJtZC1cIiArIGNsYXNzTmFtZTsgfSkuam9pbignICcpO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubm9kZVR5cGUpID09PSBOb2RlLlRFWFRfTk9ERTtcbn1cbmZ1bmN0aW9uIGlzRWxlbU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuZnVuY3Rpb24gZmluZE5vZGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVMaXN0ID0gdG9BcnJheV8xKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIGlmIChub2RlTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBhcHBlbmROb2Rlcyhub2RlLCBub2Rlc1RvQXBwZW5kKSB7XG4gICAgbm9kZXNUb0FwcGVuZCA9IGlzQXJyYXlfMShub2Rlc1RvQXBwZW5kKSA/IHRvQXJyYXlfMShub2Rlc1RvQXBwZW5kKSA6IFtub2Rlc1RvQXBwZW5kXTtcbiAgICBub2Rlc1RvQXBwZW5kLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUb0FwcGVuZCkge1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKG5vZGVUb0FwcGVuZCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmVOb2RlKGluc2VydGVkTm9kZSwgbm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnNlcnRlZE5vZGUsIG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGUkMShub2RlKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW53cmFwTm9kZShub2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLmZpcnN0Q2hpbGQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU5vZGUkMShub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBzdGF0ZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZF8xKHN0YXRlKSkge1xuICAgICAgICBzdGF0ZSA9ICFoYXNDbGFzc18xKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHZhciB0b2dnbGVGbiA9IHN0YXRlID8gYWRkQ2xhc3NfMSA6IHJlbW92ZUNsYXNzXzE7XG4gICAgdG9nZ2xlRm4oZWxlbWVudCwgY2xhc3NOYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoKGNvbnRlbnRzLCB0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKGlzU3RyaW5nXzEoY29udGVudHMpKSB7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBjb250ZW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgfVxuICAgIHZhciBmaXJzdENoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdENoaWxkO1xufVxuZnVuY3Rpb24gZ2V0T3V0ZXJXaWR0aChlbCkge1xuICAgIHZhciBjb21wdXRlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICByZXR1cm4gKFsnbWFyZ2luLWxlZnQnLCAnbWFyZ2luLXJpZ2h0J10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHR5cGUpIHsgcmV0dXJuIGFjYyArIHBhcnNlSW50KGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUodHlwZSksIDEwKTsgfSwgMCkgKyBlbC5vZmZzZXRXaWR0aCk7XG59XG5mdW5jdGlvbiBjbG9zZXN0KG5vZGUsIGZvdW5kKSB7XG4gICAgdmFyIGNvbmRpdGlvbjtcbiAgICBpZiAoaXNTdHJpbmdfMShmb3VuZCkpIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gbWF0Y2hlc18xKHRhcmdldCwgZm91bmQpOyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0ID09PSBmb3VuZDsgfTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZSAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGlzRWxlbU5vZGUobm9kZSkgJiYgY29uZGl0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRvdGFsT2Zmc2V0KGVsLCByb290KSB7XG4gICAgdmFyIG9mZnNldFRvcCA9IDA7XG4gICAgdmFyIG9mZnNldExlZnQgPSAwO1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gcm9vdCkge1xuICAgICAgICB2YXIgdG9wXzEgPSBlbC5vZmZzZXRUb3AsIGxlZnQgPSBlbC5vZmZzZXRMZWZ0LCBvZmZzZXRQYXJlbnQgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIG9mZnNldFRvcCArPSB0b3BfMTtcbiAgICAgICAgb2Zmc2V0TGVmdCArPSBsZWZ0O1xuICAgICAgICBpZiAob2Zmc2V0UGFyZW50ID09PSByb290Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB7IG9mZnNldFRvcDogb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0IH07XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGVsZW1lbnQpIHtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICBpZiAoaXNOaWwoYXR0cmlidXRlc1thdHRyTmFtZV0pKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cmlidXRlc1thdHRyTmFtZV0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlQlJXaXRoRW1wdHlCbG9jayhodG1sKSB7XG4gICAgLy8gcmVtb3ZlIGJyIGluIHBhcmFncmFwaCB0byBjb21wYXRpYmxlIHdpdGggbWFya2Rvd25cbiAgICB2YXIgcmVwbGFjZWRIVE1MID0gaHRtbC5yZXBsYWNlKC88cD48YnJcXHMqXFwvKj48XFwvcD4vZ2ksICc8cD48L3A+Jyk7XG4gICAgdmFyIHJlSFRNTFRhZyA9IG5ldyBSZWdFeHAoSFRNTF9UQUcsICdpZycpO1xuICAgIHZhciBodG1sVGFnTWF0Y2hlZCA9IHJlcGxhY2VkSFRNTC5tYXRjaChyZUhUTUxUYWcpO1xuICAgIGh0bWxUYWdNYXRjaGVkID09PSBudWxsIHx8IGh0bWxUYWdNYXRjaGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodG1sVGFnTWF0Y2hlZC5mb3JFYWNoKGZ1bmN0aW9uIChodG1sVGFnLCBpbmRleCkge1xuICAgICAgICBpZiAocmVCUi50ZXN0KGh0bWxUYWcpKSB7XG4gICAgICAgICAgICB2YXIgYWx0ZXJuYXRpdmVUYWcgPSBBTFRFUk5BVElWRV9UQUdfRk9SX0JSO1xuICAgICAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZUYWcgPSBodG1sVGFnTWF0Y2hlZFtpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBvcGVuVGFnTWF0Y2hlZCA9IHByZXZUYWcubWF0Y2goT1BFTl9UQUcpO1xuICAgICAgICAgICAgICAgIGlmIChvcGVuVGFnTWF0Y2hlZCAmJiAhL2JyL2kudGVzdChvcGVuVGFnTWF0Y2hlZFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSBvcGVuVGFnTWF0Y2hlZFsxXTtcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVUYWcgPSBcIjwvXCIgKyB0YWdOYW1lICsgXCI+PFwiICsgdGFnTmFtZSArIFwiPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2VkSFRNTCA9IHJlcGxhY2VkSFRNTC5yZXBsYWNlKHJlQlIsIGFsdGVybmF0aXZlVGFnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXBsYWNlZEhUTUw7XG59XG5mdW5jdGlvbiByZW1vdmVQcm9zZU1pcnJvckhhY2tOb2RlcyhodG1sKSB7XG4gICAgdmFyIHJlUHJvc2VNaXJyb3JJbWFnZSA9IC88aW1nIGNsYXNzPVwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCIgYWx0PVwiXCI+L2c7XG4gICAgdmFyIHJlUHJvc2VNaXJyb3JUcmFpbGluZ0JyZWFrID0gLyBjbGFzcz1cIlByb3NlTWlycm9yLXRyYWlsaW5nQnJlYWtcIi9nO1xuICAgIHZhciByZXN1bHRIVE1MID0gaHRtbDtcbiAgICByZXN1bHRIVE1MID0gcmVzdWx0SFRNTC5yZXBsYWNlKHJlUHJvc2VNaXJyb3JJbWFnZSwgJycpO1xuICAgIHJlc3VsdEhUTUwgPSByZXN1bHRIVE1MLnJlcGxhY2UocmVQcm9zZU1pcnJvclRyYWlsaW5nQnJlYWssICcnKTtcbiAgICByZXR1cm4gcmVzdWx0SFRNTDtcbn1cblxudmFyIHBsdWdpbktleSQxID0gbmV3IFBsdWdpbktleSgnd2lkZ2V0Jyk7XG52YXIgTUFSR0lOID0gNTtcbnZhciBQb3B1cFdpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3B1cFdpZGdldCh2aWV3LCBldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVtb3ZlV2lkZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnBvcHVwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucm9vdEVsLnJlbW92ZUNoaWxkKF90aGlzLnBvcHVwKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wb3B1cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucm9vdEVsID0gdmlldy5kb20ucGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignYmx1cicsIHRoaXMucmVtb3ZlV2lkZ2V0KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdsb2FkVUknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSBjbG9zZXN0KHZpZXcuZG9tLnBhcmVudEVsZW1lbnQsIFwiLlwiICsgY2xzKCdkZWZhdWx0VUknKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3JlbW92ZVBvcHVwV2lkZ2V0JywgdGhpcy5yZW1vdmVXaWRnZXQpO1xuICAgIH1cbiAgICBQb3B1cFdpZGdldC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdmFyIHdpZGdldCA9IHBsdWdpbktleSQxLmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLnJlbW92ZVdpZGdldCgpO1xuICAgICAgICBpZiAod2lkZ2V0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHdpZGdldC5ub2RlLCBzdHlsZSA9IHdpZGdldC5zdHlsZTtcbiAgICAgICAgICAgIHZhciBfYSA9IHZpZXcuY29vcmRzQXRQb3Mod2lkZ2V0LnBvcyksIHRvcF8xID0gX2EudG9wLCBsZWZ0ID0gX2EubGVmdCwgYm90dG9tID0gX2EuYm90dG9tO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcF8xO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciByZWxUb3BQb3MgPSB0b3BfMSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgY3NzXzEobm9kZSwgeyBvcGFjaXR5OiAnMCcgfSk7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIGNzc18xKG5vZGUsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gcmVjdC5sZWZ0ICsgTUFSR0lOICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHRvcDogKHN0eWxlID09PSAnYm90dG9tJyA/IHJlbFRvcFBvcyArIGhlaWdodCAtIE1BUkdJTiA6IHJlbFRvcFBvcyAtIGhlaWdodCkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwID0gbm9kZTtcbiAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wdXBXaWRnZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcignYmx1cicsIHRoaXMucmVtb3ZlV2lkZ2V0KTtcbiAgICB9O1xuICAgIHJldHVybiBQb3B1cFdpZGdldDtcbn0oKSk7XG5mdW5jdGlvbiBhZGRXaWRnZXQoZXZlbnRFbWl0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IHBsdWdpbktleSQxLFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIuZ2V0TWV0YSgnd2lkZ2V0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB2aWV3OiBmdW5jdGlvbiAoZWRpdG9yVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3B1cFdpZGdldChlZGl0b3JWaWV3LCBldmVudEVtaXR0ZXIpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREZWZhdWx0SW1hZ2VCbG9iSG9vayhldmVudEVtaXR0ZXIpIHtcbiAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdhZGRJbWFnZUJsb2JIb29rJywgZnVuY3Rpb24gKGJsb2IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGVtaXRJbWFnZUJsb2JIb29rKGV2ZW50RW1pdHRlciwgYmxvYiwgdHlwZSkge1xuICAgIHZhciBob29rID0gZnVuY3Rpb24gKGltYWdlVXJsLCBhbHRUZXh0KSB7XG4gICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjb21tYW5kJywgJ2FkZEltYWdlJywge1xuICAgICAgICAgICAgaW1hZ2VVcmw6IGltYWdlVXJsLFxuICAgICAgICAgICAgYWx0VGV4dDogYWx0VGV4dCB8fCBibG9iLm5hbWUgfHwgJ2ltYWdlJyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBldmVudEVtaXR0ZXIuZW1pdCgnYWRkSW1hZ2VCbG9iSG9vaycsIGJsb2IsIGhvb2ssIHR5cGUpO1xufVxuZnVuY3Rpb24gcGFzdGVJbWFnZU9ubHkoaXRlbXMpIHtcbiAgICB2YXIgaW1hZ2VzID0gdG9BcnJheV8xKGl0ZW1zKS5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUuaW5kZXhPZignaW1hZ2UnKSAhPT0gLTE7XG4gICAgfSk7XG4gICAgaWYgKGltYWdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBpbWFnZXNbMF07XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5nZXRBc0ZpbGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZHJvcEltYWdlKF9hKSB7XG4gICAgdmFyIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBkcm9wOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSAoX2EgPSBldi5kYXRhVHJhbnNmZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWxlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoQXJyYXlfMShpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlLmluZGV4T2YoJ2ltYWdlJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0SW1hZ2VCbG9iSG9vayhldmVudEVtaXR0ZXIsIGl0ZW0sIGV2LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbnZhciBOb2RlJDIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbm9kZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcblxuZnVuY3Rpb24gd2lkZ2V0Tm9kZVZpZXcocG1Ob2RlKSB7XG4gICAgdmFyIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB2YXIgbm9kZSA9IHdpZGdldFRvRE9NKHBtTm9kZS5hdHRycy5pbmZvLCBwbU5vZGUudGV4dENvbnRlbnQpO1xuICAgIGRvbS5jbGFzc05hbWUgPSAndHVpLXdpZGdldCc7XG4gICAgZG9tLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiB7IGRvbTogZG9tIH07XG59XG5mdW5jdGlvbiBpc1dpZGdldE5vZGUocG1Ob2RlKSB7XG4gICAgcmV0dXJuIHBtTm9kZS50eXBlLm5hbWUgPT09ICd3aWRnZXQnO1xufVxudmFyIFdpZGdldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShXaWRnZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2lkZ2V0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaWRnZXQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnd2lkZ2V0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXaWRnZXQucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBpbmZvOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdG9tOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiAndHVpLXdpZGdldCcgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdzcGFuLnR1aS13aWRnZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGRvbS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSB0ZXh0Lm1hdGNoKC9cXCRcXCQod2lkZ2V0XFxkKykvKSwgaW5mbyA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluZm86IGluZm8gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gV2lkZ2V0O1xufShOb2RlJDIpKTtcblxudmFyIEVkaXRvckJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRpdG9yQmFzZShldmVudEVtaXR0ZXIpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lbC5jbGFzc05hbWUgPSAndG9hc3R1aS1lZGl0b3InO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHsgdGV4dDogJycgfTtcbiAgICB9XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMuY3JlYXRlUGx1Z2lucygpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyLCB2aWV3ID0gX2EudmlldywgZWRpdG9yVHlwZSA9IF9hLmVkaXRvclR5cGU7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRFbWl0dGVyLmVtaXQoJ2ZvY3VzJywgZWRpdG9yVHlwZSk7IH0pO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZXZlbnRFbWl0dGVyLmVtaXQoJ2JsdXInLCBlZGl0b3JUeXBlKTsgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2FyZXRDaGFuZ2UnLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlJywgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVkaXRvckJhc2UucHJvdG90eXBlLCBcImRlZmF1bHRQbHVnaW5zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLmNyZWF0ZUlucHV0UnVsZXMoKTtcbiAgICAgICAgICAgIHZhciBwbHVnaW5zID0gX19zcHJlYWRBcnJheSQxKF9fc3ByZWFkQXJyYXkkMShbXSwgdGhpcy5rZXltYXBzKSwgW1xuICAgICAgICAgICAgICAgIGtleW1hcChfX2Fzc2lnbiQxKHsgJ1NoaWZ0LUVudGVyJzogYmFzZUtleW1hcC5FbnRlciB9LCBiYXNlS2V5bWFwKSksXG4gICAgICAgICAgICAgICAgaGlzdG9yeSgpLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyKHRoaXMucGxhY2Vob2xkZXIpLFxuICAgICAgICAgICAgICAgIGFkZFdpZGdldCh0aGlzLmV2ZW50RW1pdHRlciksXG4gICAgICAgICAgICAgICAgZHJvcEltYWdlKHRoaXMuY29udGV4dCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBydWxlcyA/IHBsdWdpbnMuY29uY2F0KHJ1bGVzKSA6IHBsdWdpbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVJbnB1dFJ1bGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2lkZ2V0UnVsZXMgPSBnZXRXaWRnZXRSdWxlcygpO1xuICAgICAgICB2YXIgcnVsZXMgPSB3aWRnZXRSdWxlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IF9hLnJ1bGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElucHV0UnVsZShydWxlLCBmdW5jdGlvbiAoc3RhdGUsIG1hdGNoLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50ciwgZG9jID0gc3RhdGUuZG9jO1xuICAgICAgICAgICAgICAgIHZhciBhbGxNYXRjaGVkID0gbWF0Y2guaW5wdXQubWF0Y2gobmV3IFJlZ0V4cChydWxlLCAnZycpKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gZG9jLnJlc29sdmUoc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwb3MucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZ2V0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBvcy5ub2RlKHBvcy5kZXB0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGlzV2lkZ2V0Tm9kZShjaGlsZCkgJiYgKGNvdW50ICs9IDEpOyB9KTtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBjb250ZW50IG9ubHkgaWYgdGhlIGNvdW50IG9mIG1hdGNoZWQgcnVsZXMgaW4gd2hvbGUgdGV4dCBpcyBncmVhdGVyIHRoYW4gY3VycmVudCB3aWRnZXQgbm9kZSBjb3VudFxuICAgICAgICAgICAgICAgIGlmIChhbGxNYXRjaGVkLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gbGFzdCQxKGFsbE1hdGNoZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQoY29udGVudCwgc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHN0YXJ0IHBvc2l0aW9uIGJhc2VkIG9uIHdpZGdldCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ci5yZXBsYWNlV2l0aChlbmQgLSBjb250ZW50Lmxlbmd0aCArIDEsIGVuZCwgbm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJ1bGVzLmxlbmd0aCA/IGlucHV0UnVsZXMoeyBydWxlczogcnVsZXMgfSkgOiBudWxsO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5jcmVhdGVTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICAgICAgICAgIG5vZGVzOiB0aGlzLnNwZWNzLm5vZGVzLFxuICAgICAgICAgICAgbWFya3M6IHRoaXMuc3BlY3MubWFya3MsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlS2V5bWFwcyA9IGZ1bmN0aW9uICh1c2VDb21tYW5kU2hvcnRjdXQpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0RGVmYXVsdENvbW1hbmRzKCksIHVuZG8gPSBfYS51bmRvLCByZWRvID0gX2EucmVkbztcbiAgICAgICAgdmFyIGFsbEtleW1hcHMgPSB0aGlzLnNwZWNzLmtleW1hcHModXNlQ29tbWFuZFNob3J0Y3V0KTtcbiAgICAgICAgdmFyIGhpc3RvcnlLZXltYXAgPSB7XG4gICAgICAgICAgICAnTW9kLXonOiB1bmRvKCksXG4gICAgICAgICAgICAnU2hpZnQtTW9kLXonOiByZWRvKCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB1c2VDb21tYW5kU2hvcnRjdXQgPyBhbGxLZXltYXBzLmNvbmNhdChrZXltYXAoaGlzdG9yeUtleW1hcCkpIDogYWxsS2V5bWFwcztcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLmNyZWF0ZUNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjcy5jb21tYW5kcyh0aGlzLnZpZXcpO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuY3JlYXRlUGx1Z2luUHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhUGx1Z2lucy5tYXAoZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKF90aGlzLmV2ZW50RW1pdHRlcik7IH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAvLyBwcmV2ZW50IHRoZSBlcnJvciBmb3IgSUUxMVxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBfdGhpcy52aWV3LmRpc3BhdGNoKF90aGlzLnZpZXcuc3RhdGUudHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5ibHVyKCk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgZGVsZXRlIF90aGlzW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVkaXRvckJhc2UucHJvdG90eXBlLm1vdmVDdXJzb3JUb1N0YXJ0ID0gZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCAxKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIGlmIChmb2N1cykge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9FbmQgPSBmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLmRvYy5jb250ZW50LnNpemUgLSAxKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIGlmIChmb2N1cykge1xuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20uc2Nyb2xsVG9wID0gdG9wO1xuICAgIH07XG4gICAgRWRpdG9yQmFzZS5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmRvbS5zY3JvbGxUb3A7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5zZXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0aGlzLnZpZXcuc3RhdGUudHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gICAgICAgIGNzc18xKHRoaXMuZWwsIHsgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5zZXRNaW5IZWlnaHQgPSBmdW5jdGlvbiAobWluSGVpZ2h0KSB7XG4gICAgICAgIGNzc18xKHRoaXMuZWwsIHsgbWluSGVpZ2h0OiBtaW5IZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICBFZGl0b3JCYXNlLnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9O1xuICAgIHJldHVybiBFZGl0b3JCYXNlO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLCByZXR1cm4gdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIGZ1bmN0aW9uP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cblxudmFyIGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb247XG5cbnZhciBkZWZhdWx0Q29tbWFuZFNob3J0Y3V0cyA9IFtcbiAgICAnRW50ZXInLFxuICAgICdTaGlmdC1FbnRlcicsXG4gICAgJ01vZC1FbnRlcicsXG4gICAgJ1RhYicsXG4gICAgJ1NoaWZ0LVRhYicsXG4gICAgJ0RlbGV0ZScsXG4gICAgJ0JhY2tzcGFjZScsXG4gICAgJ01vZC1EZWxldGUnLFxuICAgICdNb2QtQmFja3NwYWNlJyxcbiAgICAnQXJyb3dVcCcsXG4gICAgJ0Fycm93RG93bicsXG4gICAgJ0Fycm93TGVmdCcsXG4gICAgJ0Fycm93UmlnaHQnLFxuICAgICdNb2QtZCcsXG4gICAgJ01vZC1EJyxcbiAgICAnQWx0LUFycm93VXAnLFxuICAgICdBbHQtQXJyb3dEb3duJyxcbl07XG5mdW5jdGlvbiBleGVjQ29tbWFuZCh2aWV3LCBjb21tYW5kLCBwYXlsb2FkKSB7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHJldHVybiBjb21tYW5kKHBheWxvYWQpKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpO1xufVxudmFyIFNwZWNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNwZWNNYW5hZ2VyKHNwZWNzKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNwZWNNYW5hZ2VyLnByb3RvdHlwZSwgXCJub2Rlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzcGVjKSB7IHJldHVybiBzcGVjLnR5cGUgPT09ICdub2RlJzsgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChub2RlcywgX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgbm9kZXMpLCAoX2IgPSB7fSwgX2JbbmFtZV0gPSBzY2hlbWEsIF9iKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3BlY01hbmFnZXIucHJvdG90eXBlLCBcIm1hcmtzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNwZWMpIHsgcmV0dXJuIHNwZWMudHlwZSA9PT0gJ21hcmsnOyB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG1hcmtzLCBfYSkge1xuICAgICAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBtYXJrcyksIChfYiA9IHt9LCBfYltuYW1lXSA9IHNjaGVtYSwgX2IpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNwZWNNYW5hZ2VyLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICh2aWV3LCBhZGRlZENvbW1hbmRzKSB7XG4gICAgICAgIHZhciBzcGVjQ29tbWFuZHMgPSB0aGlzLnNwZWNzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmRzID0gX2EuY29tbWFuZHM7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZHM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhbGxDb21tYW5kcywgc3BlYykge1xuICAgICAgICAgICAgdmFyIGNvbW1hbmRzID0ge307XG4gICAgICAgICAgICB2YXIgc3BlY0NvbW1hbmQgPSBzcGVjLmNvbW1hbmRzKCk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xKHNwZWNDb21tYW5kKSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzW3NwZWMubmFtZV0gPSBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZXhlY0NvbW1hbmQodmlldywgc3BlY0NvbW1hbmQsIHBheWxvYWQpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3BlY0NvbW1hbmQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHNbbmFtZV0gPSBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZXhlY0NvbW1hbmQodmlldywgc3BlY0NvbW1hbmRbbmFtZV0sIHBheWxvYWQpOyB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYWxsQ29tbWFuZHMpLCBjb21tYW5kcyk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIGRlZmF1bHRDb21tYW5kcyA9IGdldERlZmF1bHRDb21tYW5kcygpO1xuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0Q29tbWFuZHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHNwZWNDb21tYW5kc1tuYW1lXSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBleGVjQ29tbWFuZCh2aWV3LCBkZWZhdWx0Q29tbWFuZHNbbmFtZV0sIHBheWxvYWQpOyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFkZGVkQ29tbWFuZHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGVkQ29tbWFuZHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzcGVjQ29tbWFuZHNbbmFtZV0gPSBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZXhlY0NvbW1hbmQodmlldywgYWRkZWRDb21tYW5kc1tuYW1lXSwgcGF5bG9hZCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BlY0NvbW1hbmRzO1xuICAgIH07XG4gICAgU3BlY01hbmFnZXIucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAodXNlQ29tbWFuZFNob3J0Y3V0KSB7XG4gICAgICAgIHZhciBzcGVjS2V5bWFwcyA9IHRoaXMuc3BlY3MuZmlsdGVyKGZ1bmN0aW9uIChzcGVjKSB7IHJldHVybiBzcGVjLmtleW1hcHM7IH0pLm1hcChmdW5jdGlvbiAoc3BlYykgeyByZXR1cm4gc3BlYy5rZXltYXBzKCk7IH0pO1xuICAgICAgICByZXR1cm4gc3BlY0tleW1hcHMubWFwKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICBpZiAoIXVzZUNvbW1hbmRTaG9ydGN1dCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGtleXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVzKGRlZmF1bHRDb21tYW5kU2hvcnRjdXRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUga2V5c1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5bWFwKGtleXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNwZWNNYW5hZ2VyLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zcGVjcy5mb3JFYWNoKGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgICAgICAgICBzcGVjLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNwZWNNYW5hZ2VyO1xufSgpKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvblBvcyhzZWxlY3Rpb24pIHtcbiAgICB2YXIgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBbZnJvbSArIDEsIHRvIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBbZnJvbSwgdG9dO1xufVxuZnVuY3Rpb24gZ2V0TWRMaW5lKHJlc29sdmVkUG9zKSB7XG4gICAgcmV0dXJuIHJlc29sdmVkUG9zLmluZGV4KDApICsgMTtcbn1cbmZ1bmN0aW9uIGdldFdpZGdldE5vZGVQb3Mobm9kZSwgY2hQb3MsIGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkgeyBkaXJlY3Rpb24gPSAxOyB9XG4gICAgdmFyIGFkZGl0aW9uYWxQb3MgPSAwO1xuICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIHBvcykge1xuICAgICAgICAvLyBhZGQgb3Igc3VidHJhY3Qgd2lkZ2V0IG5vZGUgdGFnXG4gICAgICAgIGlmIChpc1dpZGdldE5vZGUoY2hpbGQpICYmIHBvcyArIDIgPCBjaFBvcykge1xuICAgICAgICAgICAgYWRkaXRpb25hbFBvcyArPSAyICogZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZGl0aW9uYWxQb3M7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JUb01kUG9zKGRvYywgZnJvbSwgdG8pIHtcbiAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IGZyb207IH1cbiAgICB2YXIgY29sbGFwc2VkID0gZnJvbSA9PT0gdG87XG4gICAgdmFyIHN0YXJ0UmVzb2x2ZWRQb3MgPSBkb2MucmVzb2x2ZShmcm9tKTtcbiAgICB2YXIgc3RhcnRMaW5lID0gZ2V0TWRMaW5lKHN0YXJ0UmVzb2x2ZWRQb3MpO1xuICAgIHZhciBlbmRMaW5lID0gc3RhcnRMaW5lO1xuICAgIHZhciBzdGFydE9mZnNldCA9IHN0YXJ0UmVzb2x2ZWRQb3Muc3RhcnQoMSk7XG4gICAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgIGlmICghY29sbGFwc2VkKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGVuZCBvZmZzZXQgZnJvbSBwb2ludGluZyB0byB0aGUgcm9vdCBkb2N1bWVudCBwb3NpdGlvblxuICAgICAgICB2YXIgZW5kUmVzb2x2ZWRQb3MgPSBkb2MucmVzb2x2ZSh0byA9PT0gZG9jLmNvbnRlbnQuc2l6ZSA/IHRvIC0gMSA6IHRvKTtcbiAgICAgICAgZW5kT2Zmc2V0ID0gZW5kUmVzb2x2ZWRQb3Muc3RhcnQoMSk7XG4gICAgICAgIGVuZExpbmUgPSBnZXRNZExpbmUoZW5kUmVzb2x2ZWRQb3MpO1xuICAgICAgICAvLyBUbyByZXNvbHZlIHRoZSBlbmQgb2Zmc2V0IGV4Y2x1ZGluZyBkb2N1bWVudCB0YWcgc2l6ZVxuICAgICAgICBpZiAoZW5kUmVzb2x2ZWRQb3MucG9zID09PSBkb2MuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICB0byA9IGRvYy5jb250ZW50LnNpemUgLSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFydENoID0gTWF0aC5tYXgoZnJvbSAtIHN0YXJ0T2Zmc2V0ICsgMSwgMSk7XG4gICAgdmFyIGVuZENoID0gTWF0aC5tYXgodG8gLSBlbmRPZmZzZXQgKyAxLCAxKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBbc3RhcnRMaW5lLCBzdGFydENoICsgZ2V0V2lkZ2V0Tm9kZVBvcyhkb2MuY2hpbGQoc3RhcnRMaW5lIC0gMSksIHN0YXJ0Q2gsIC0xKV0sXG4gICAgICAgIFtlbmRMaW5lLCBlbmRDaCArIGdldFdpZGdldE5vZGVQb3MoZG9jLmNoaWxkKGVuZExpbmUgLSAxKSwgZW5kQ2gsIC0xKV0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0UG9zTGlzdFBlckxpbmUoZG9jLCBlbmRJbmRleCkge1xuICAgIHZhciBzdGFydFBvc0xpc3RQZXJMaW5lID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIHBvcyA9IDA7IGkgPCBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGRvYy5jaGlsZChpKTtcbiAgICAgICAgc3RhcnRQb3NMaXN0UGVyTGluZVtpXSA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRQb3NMaXN0UGVyTGluZTtcbn1cbmZ1bmN0aW9uIGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgdmFyIHN0YXJ0UG9zTGlzdFBlckxpbmUgPSBnZXRTdGFydFBvc0xpc3RQZXJMaW5lKGRvYywgZW5kUG9zWzBdKTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IHN0YXJ0UG9zWzBdIC0gMTtcbiAgICB2YXIgZW5kSW5kZXggPSBlbmRQb3NbMF0gLSAxO1xuICAgIHZhciBzdGFydE5vZGUgPSBkb2MuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgdmFyIGVuZE5vZGUgPSBkb2MuY2hpbGQoZW5kSW5kZXgpO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgbGluZVxuICAgIHZhciBmcm9tID0gc3RhcnRQb3NMaXN0UGVyTGluZVtzdGFydEluZGV4XTtcbiAgICB2YXIgdG8gPSBzdGFydFBvc0xpc3RQZXJMaW5lW2VuZEluZGV4XTtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNoYXJhY3RlciBvZmZzZXQgb2YgdGhlIGxpbmVcbiAgICBmcm9tICs9IHN0YXJ0UG9zWzFdICsgZ2V0V2lkZ2V0Tm9kZVBvcyhzdGFydE5vZGUsIHN0YXJ0UG9zWzFdIC0gMSk7XG4gICAgdG8gKz0gZW5kUG9zWzFdICsgZ2V0V2lkZ2V0Tm9kZVBvcyhlbmROb2RlLCBlbmRQb3NbMV0gLSAxKTtcbiAgICByZXR1cm4gW2Zyb20sIE1hdGgubWluKHRvLCBkb2MuY29udGVudC5zaXplKV07XG59XG5mdW5jdGlvbiBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSB7XG4gICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgIHZhciBkb2MgPSAkZnJvbS5kb2M7XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbikge1xuICAgICAgICAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20gKyAxKTtcbiAgICAgICAgJHRvID0gZG9jLnJlc29sdmUodG8gLSAxKTtcbiAgICB9XG4gICAgaWYgKCRmcm9tLmRlcHRoID09PSAwKSB7XG4gICAgICAgICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSAtIDEpO1xuICAgICAgICAkdG8gPSAkZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnRGcm9tT2Zmc2V0OiAkZnJvbS5zdGFydCgxKSxcbiAgICAgICAgZW5kRnJvbU9mZnNldDogJHRvLnN0YXJ0KDEpLFxuICAgICAgICBzdGFydFRvT2Zmc2V0OiAkZnJvbS5lbmQoMSksXG4gICAgICAgIGVuZFRvT2Zmc2V0OiAkdG8uZW5kKDEpLFxuICAgICAgICBzdGFydEluZGV4OiAkZnJvbS5pbmRleCgwKSxcbiAgICAgICAgZW5kSW5kZXg6ICR0by5pbmRleCgwKSxcbiAgICAgICAgZnJvbTogJGZyb20ucG9zLFxuICAgICAgICB0bzogJHRvLnBvcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUNvbnRlbnRPZmZzZXRSYW5nZShkb2MsIHRhcmdldEluZGV4KSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gMTtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gMTtcbiAgICBmb3IgKHZhciBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IGRvYy5jaGlsZENvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG5vZGVTaXplID0gZG9jLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICAvLyBjYWxjdWxhdGUgY29udGVudCBzdGFydCwgZW5kIG9mZnNldChub3Qgbm9kZSBvZmZzZXQpXG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgZW5kT2Zmc2V0ID0gb2Zmc2V0ICsgbm9kZVNpemUgLSAxO1xuICAgICAgICBpZiAoaSA9PT0gdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBub2RlU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldCB9O1xufVxuXG52YXIgSEVBRElORyA9ICdoZWFkaW5nJztcbnZhciBCTE9DS19RVU9URSA9ICdibG9ja1F1b3RlJztcbnZhciBMSVNUX0lURU0gPSAnbGlzdEl0ZW0nO1xudmFyIFRBQkxFID0gJ3RhYmxlJztcbnZhciBUQUJMRV9DRUxMID0gJ3RhYmxlQ2VsbCc7XG52YXIgQ09ERV9CTE9DSyA9ICdjb2RlQmxvY2snO1xudmFyIFRIRU1BVElDX0JSRUFLID0gJ3RoZW1hdGljQnJlYWsnO1xudmFyIExJTksgPSAnbGluayc7XG52YXIgQ09ERSA9ICdjb2RlJztcbnZhciBNRVRBID0gJ21ldGEnO1xudmFyIERFTElNID0gJ2RlbGltaXRlcic7XG52YXIgVEFTS19ERUxJTSA9ICd0YXNrRGVsaW1pdGVyJztcbnZhciBURVhUID0gJ21hcmtlZFRleHQnO1xudmFyIEhUTUwgPSAnaHRtbCc7XG52YXIgQ1VTVE9NX0JMT0NLID0gJ2N1c3RvbUJsb2NrJztcbnZhciBkZWxpbVNpemUgPSB7XG4gICAgc3Ryb25nOiAyLFxuICAgIGVtcGg6IDEsXG4gICAgc3RyaWtlOiAyLFxufTtcbmZ1bmN0aW9uIG1hcmtJbmZvKHN0YXJ0LCBlbmQsIHR5cGUsIGF0dHJzKSB7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgc3BlYzogeyB0eXBlOiB0eXBlLCBhdHRyczogYXR0cnMgfSB9O1xufVxuZnVuY3Rpb24gaGVhZGluZyQxKF9hLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGxldmVsID0gX2EubGV2ZWwsIGhlYWRpbmdUeXBlID0gX2EuaGVhZGluZ1R5cGU7XG4gICAgdmFyIG1hcmtzID0gW21hcmtJbmZvKHN0YXJ0LCBlbmQsIEhFQURJTkcsIHsgbGV2ZWw6IGxldmVsIH0pXTtcbiAgICBpZiAoaGVhZGluZ1R5cGUgPT09ICdhdHgnKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oc3RhcnQsIGFkZE9mZnNldFBvcyhzdGFydCwgbGV2ZWwpLCBERUxJTSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhzZXRPZmZzZXRQb3MoZW5kLCAwKSwgZW5kLCBIRUFESU5HLCB7IHNlVGV4dDogdHJ1ZSB9KSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIGVtcGhhc2lzQW5kU3RyaWtldGhyb3VnaChfYSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICB2YXIgc3RhcnREZWxpbVBvcyA9IGFkZE9mZnNldFBvcyhzdGFydCwgZGVsaW1TaXplW3R5cGVdKTtcbiAgICB2YXIgZW5kRGVsaW1Qb3MgPSBhZGRPZmZzZXRQb3MoZW5kLCAtZGVsaW1TaXplW3R5cGVdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrSW5mbyhzdGFydERlbGltUG9zLCBlbmREZWxpbVBvcywgdHlwZSksXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0LCBzdGFydERlbGltUG9zLCBERUxJTSksXG4gICAgICAgIG1hcmtJbmZvKGVuZERlbGltUG9zLCBlbmQsIERFTElNKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gbWFya0xpbmsoc3RhcnQsIGVuZCwgbGlua1RleHRTdGFydCwgbGFzdENoaWxkQ2gpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrSW5mbyhzdGFydCwgZW5kLCBMSU5LKSxcbiAgICAgICAgbWFya0luZm8oc2V0T2Zmc2V0UG9zKHN0YXJ0LCBsaW5rVGV4dFN0YXJ0WzFdICsgMSksIHNldE9mZnNldFBvcyhlbmQsIGxhc3RDaGlsZENoKSwgTElOSywge1xuICAgICAgICAgICAgZGVzYzogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIG1hcmtJbmZvKHNldE9mZnNldFBvcyhlbmQsIGxhc3RDaGlsZENoICsgMiksIGFkZE9mZnNldFBvcyhlbmQsIC0xKSwgTElOSywgeyB1cmw6IHRydWUgfSksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGltYWdlJDEoX2EsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gX2EubGFzdENoaWxkO1xuICAgIHZhciBsYXN0Q2hpbGRDaCA9IGxhc3RDaGlsZCA/IGdldE1kRW5kQ2gobGFzdENoaWxkKSArIDEgOiAzOyAvLyAzOiBsZW5ndGggb2YgJyFbXSdcbiAgICB2YXIgbGlua1RleHRFbmQgPSBhZGRPZmZzZXRQb3Moc3RhcnQsIDEpO1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5JDEoW21hcmtJbmZvKHN0YXJ0LCBsaW5rVGV4dEVuZCwgTUVUQSldLCBtYXJrTGluayhzdGFydCwgZW5kLCBsaW5rVGV4dEVuZCwgbGFzdENoaWxkQ2gpKTtcbn1cbmZ1bmN0aW9uIGxpbmsoX2EsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGFzdENoaWxkID0gX2EubGFzdENoaWxkLCBleHRlbmRlZEF1dG9saW5rID0gX2EuZXh0ZW5kZWRBdXRvbGluaztcbiAgICB2YXIgbGFzdENoaWxkQ2ggPSBsYXN0Q2hpbGQgPyBnZXRNZEVuZENoKGxhc3RDaGlsZCkgKyAxIDogMjsgLy8gMjogbGVuZ3RoIG9mICdbXSdcbiAgICByZXR1cm4gZXh0ZW5kZWRBdXRvbGlua1xuICAgICAgICA/IFttYXJrSW5mbyhzdGFydCwgZW5kLCBMSU5LLCB7IGRlc2M6IHRydWUgfSldXG4gICAgICAgIDogbWFya0xpbmsoc3RhcnQsIGVuZCwgc3RhcnQsIGxhc3RDaGlsZENoKTtcbn1cbmZ1bmN0aW9uIGNvZGUoX2EsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgdGlja0NvdW50ID0gX2EudGlja0NvdW50O1xuICAgIHZhciBvcGVuRGVsaW1FbmQgPSBhZGRPZmZzZXRQb3Moc3RhcnQsIHRpY2tDb3VudCk7XG4gICAgdmFyIGNsb3NlRGVsaW1TdGFydCA9IGFkZE9mZnNldFBvcyhlbmQsIC10aWNrQ291bnQpO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtJbmZvKHN0YXJ0LCBlbmQsIENPREUpLFxuICAgICAgICBtYXJrSW5mbyhzdGFydCwgb3BlbkRlbGltRW5kLCBDT0RFLCB7IHN0YXJ0OiB0cnVlIH0pLFxuICAgICAgICBtYXJrSW5mbyhvcGVuRGVsaW1FbmQsIGNsb3NlRGVsaW1TdGFydCwgQ09ERSwgeyBtYXJrZWQ6IHRydWUgfSksXG4gICAgICAgIG1hcmtJbmZvKGNsb3NlRGVsaW1TdGFydCwgZW5kLCBDT0RFLCB7IGVuZDogdHJ1ZSB9KSxcbiAgICBdO1xufVxuZnVuY3Rpb24gbGluZUJhY2tncm91bmQocGFyZW50LCBzdGFydCwgZW5kLCBwcmVmaXgpIHtcbiAgICB2YXIgZGVmYXVsdEJhY2tncm91bmQgPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIHNwZWM6IHtcbiAgICAgICAgICAgIGF0dHJzOiB7IGNsYXNzTmFtZTogcHJlZml4ICsgXCItbGluZS1iYWNrZ3JvdW5kXCIsIGNvZGVTdGFydDogc3RhcnRbMF0sIGNvZGVFbmQ6IGVuZFswXSB9LFxuICAgICAgICB9LFxuICAgICAgICBsaW5lQmFja2dyb3VuZDogdHJ1ZSxcbiAgICB9O1xuICAgIHJldHVybiBwYXJlbnQudHlwZSAhPT0gJ2l0ZW0nICYmIHBhcmVudC50eXBlICE9PSAnYmxvY2tRdW90ZSdcbiAgICAgICAgPyBbXG4gICAgICAgICAgICBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGRlZmF1bHRCYWNrZ3JvdW5kKSwgeyBlbmQ6IHN0YXJ0LCBzcGVjOiB7IGF0dHJzOiB7IGNsYXNzTmFtZTogcHJlZml4ICsgXCItbGluZS1iYWNrZ3JvdW5kIHN0YXJ0XCIgfSB9IH0pLFxuICAgICAgICAgICAgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBkZWZhdWx0QmFja2dyb3VuZCksIHsgc3RhcnQ6IFtNYXRoLm1pbihzdGFydFswXSArIDEsIGVuZFswXSksIHN0YXJ0WzFdXSB9KSxcbiAgICAgICAgXVxuICAgICAgICA6IG51bGw7XG59XG5mdW5jdGlvbiBjb2RlQmxvY2skMShub2RlLCBzdGFydCwgZW5kLCBlbmRMaW5lKSB7XG4gICAgdmFyIGZlbmNlT2Zmc2V0ID0gbm9kZS5mZW5jZU9mZnNldCwgZmVuY2VMZW5ndGggPSBub2RlLmZlbmNlTGVuZ3RoLCBmZW5jZUNoYXIgPSBub2RlLmZlbmNlQ2hhciwgaW5mbyA9IG5vZGUuaW5mbywgaW5mb1BhZGRpbmcgPSBub2RlLmluZm9QYWRkaW5nLCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICB2YXIgZmVuY2VFbmQgPSBmZW5jZU9mZnNldCArIGZlbmNlTGVuZ3RoO1xuICAgIHZhciBtYXJrcyA9IFttYXJrSW5mbyhzZXRPZmZzZXRQb3Moc3RhcnQsIDEpLCBlbmQsIENPREVfQkxPQ0spXTtcbiAgICBpZiAoZmVuY2VDaGFyKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oc3RhcnQsIGFkZE9mZnNldFBvcyhzdGFydCwgZmVuY2VFbmQpLCBERUxJTSkpO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKGFkZE9mZnNldFBvcyhzdGFydCwgZmVuY2VMZW5ndGgpLCBhZGRPZmZzZXRQb3Moc3RhcnQsIGZlbmNlTGVuZ3RoICsgaW5mb1BhZGRpbmcgKyBpbmZvLmxlbmd0aCksIE1FVEEpKTtcbiAgICB9XG4gICAgdmFyIGNvZGVCbG9ja0VuZCA9IFwiXihcXFxcc3swLDR9KShcIiArIGZlbmNlQ2hhciArIFwie1wiICsgZmVuY2VMZW5ndGggKyBcIix9KVwiO1xuICAgIHZhciByZUNvZGVCbG9ja0VuZCA9IG5ldyBSZWdFeHAoY29kZUJsb2NrRW5kKTtcbiAgICBpZiAocmVDb2RlQmxvY2tFbmQudGVzdChlbmRMaW5lKSkge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKHNldE9mZnNldFBvcyhlbmQsIDEpLCBlbmQsIERFTElNKSk7XG4gICAgfVxuICAgIHZhciBsaW5lQmFja2dyb3VuZE1hcmtJbmZvID0gbGluZUJhY2tncm91bmQocGFyZW50LCBzdGFydCwgZW5kLCAnY29kZS1ibG9jaycpO1xuICAgIHJldHVybiBsaW5lQmFja2dyb3VuZE1hcmtJbmZvID8gbWFya3MuY29uY2F0KGxpbmVCYWNrZ3JvdW5kTWFya0luZm8pIDogbWFya3M7XG59XG5mdW5jdGlvbiBjdXN0b21CbG9jayQyKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgX2EgPSBub2RlLCBvZmZzZXQgPSBfYS5vZmZzZXQsIHN5bnRheExlbmd0aCA9IF9hLnN5bnRheExlbmd0aCwgaW5mbyA9IF9hLmluZm8sIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICB2YXIgc3ludGF4RW5kID0gb2Zmc2V0ICsgc3ludGF4TGVuZ3RoO1xuICAgIHZhciBtYXJrcyA9IFttYXJrSW5mbyhzZXRPZmZzZXRQb3Moc3RhcnQsIDEpLCBlbmQsIENVU1RPTV9CTE9DSyldO1xuICAgIG1hcmtzLnB1c2gobWFya0luZm8oc3RhcnQsIGFkZE9mZnNldFBvcyhzdGFydCwgc3ludGF4RW5kKSwgREVMSU0pKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgICBtYXJrcy5wdXNoKG1hcmtJbmZvKGFkZE9mZnNldFBvcyhzdGFydCwgc3ludGF4RW5kKSwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBzeW50YXhMZW5ndGggKyBpbmZvLmxlbmd0aCksIE1FVEEpKTtcbiAgICB9XG4gICAgbWFya3MucHVzaChtYXJrSW5mbyhzZXRPZmZzZXRQb3MoZW5kLCAxKSwgZW5kLCBERUxJTSkpO1xuICAgIHZhciBsaW5lQmFja2dyb3VuZE1hcmtJbmZvID0gbGluZUJhY2tncm91bmQocGFyZW50LCBzdGFydCwgZW5kLCAnY3VzdG9tLWJsb2NrJyk7XG4gICAgcmV0dXJuIGxpbmVCYWNrZ3JvdW5kTWFya0luZm8gPyBtYXJrcy5jb25jYXQobGluZUJhY2tncm91bmRNYXJrSW5mbykgOiBtYXJrcztcbn1cbmZ1bmN0aW9uIG1hcmtMaXN0SXRlbUNoaWxkcmVuKG5vZGUsIG1hcmtUeXBlKSB7XG4gICAgdmFyIG1hcmtzID0gW107XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIGlmICh0eXBlID09PSAncGFyYWdyYXBoJyB8fCB0eXBlID09PSAnY29kZUJsb2NrJykge1xuICAgICAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhbZ2V0TWRTdGFydExpbmUobm9kZSksIGdldE1kU3RhcnRDaChub2RlKSAtIDFdLCBbZ2V0TWRFbmRMaW5lKG5vZGUpLCBnZXRNZEVuZENoKG5vZGUpICsgMV0sIG1hcmtUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuZnVuY3Rpb24gbWFya1BhcmFncmFwaEluQmxvY2tRdW90ZShub2RlKSB7XG4gICAgdmFyIG1hcmtzID0gW107XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhbZ2V0TWRTdGFydExpbmUobm9kZSksIGdldE1kU3RhcnRDaChub2RlKV0sIFtnZXRNZEVuZExpbmUobm9kZSksIGdldE1kRW5kQ2gobm9kZSkgKyAxXSwgVEVYVCkpO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbWFya3M7XG59XG5mdW5jdGlvbiBibG9ja1F1b3RlJDIobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBtYXJrcyA9IG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgIT09ICdibG9ja1F1b3RlJyA/IFttYXJrSW5mbyhzdGFydCwgZW5kLCBCTE9DS19RVU9URSldIDogW107XG4gICAgaWYgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRNYXJrcyA9IFtdO1xuICAgICAgICBpZiAobm9kZS5maXJzdENoaWxkLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICBjaGlsZE1hcmtzID0gbWFya1BhcmFncmFwaEluQmxvY2tRdW90ZShub2RlLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5maXJzdENoaWxkLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgY2hpbGRNYXJrcyA9IG1hcmtMaXN0SXRlbUNoaWxkcmVuKG5vZGUuZmlyc3RDaGlsZCwgVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MgPSBfX3NwcmVhZEFycmF5JDEoX19zcHJlYWRBcnJheSQxKFtdLCBtYXJrcyksIGNoaWxkTWFya3MpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3M7XG59XG5mdW5jdGlvbiBnZXRTcGVjT2ZMaXN0SXRlbVN0eWxlKG5vZGUpIHtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHdoaWxlIChub2RlLnBhcmVudC5wYXJlbnQgJiYgbm9kZS5wYXJlbnQucGFyZW50LnR5cGUgPT09ICdpdGVtJykge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICBkZXB0aCArPSAxO1xuICAgIH1cbiAgICB2YXIgYXR0cnMgPSBbeyBvZGQ6IHRydWUgfSwgeyBldmVuOiB0cnVlIH1dW2RlcHRoICUgMl07XG4gICAgcmV0dXJuIFtMSVNUX0lURU0sIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYXR0cnMpLCB7IGxpc3RTdHlsZTogdHJ1ZSB9KV07XG59XG5mdW5jdGlvbiBpdGVtJDEobm9kZSwgc3RhcnQpIHtcbiAgICB2YXIgX2EgPSBub2RlLmxpc3REYXRhLCBwYWRkaW5nID0gX2EucGFkZGluZywgdGFzayA9IF9hLnRhc2s7XG4gICAgdmFyIHNwZWMgPSBnZXRTcGVjT2ZMaXN0SXRlbVN0eWxlKG5vZGUpO1xuICAgIHZhciBtYXJrcyA9IFttYXJrSW5mby5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkkMShbc3RhcnQsIGFkZE9mZnNldFBvcyhzdGFydCwgcGFkZGluZyldLCBzcGVjKSldO1xuICAgIGlmICh0YXNrKSB7XG4gICAgICAgIG1hcmtzLnB1c2gobWFya0luZm8oYWRkT2Zmc2V0UG9zKHN0YXJ0LCBwYWRkaW5nKSwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBwYWRkaW5nICsgMyksIFRBU0tfREVMSU0pKTtcbiAgICAgICAgbWFya3MucHVzaChtYXJrSW5mbyhhZGRPZmZzZXRQb3Moc3RhcnQsIHBhZGRpbmcgKyAxKSwgYWRkT2Zmc2V0UG9zKHN0YXJ0LCBwYWRkaW5nICsgMiksIE1FVEEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzLmNvbmNhdChtYXJrTGlzdEl0ZW1DaGlsZHJlbihub2RlLmZpcnN0Q2hpbGQsIFRFWFQpKTtcbn1cbnZhciBtYXJrTm9kZUZ1bmNNYXAgPSB7XG4gICAgaGVhZGluZzogaGVhZGluZyQxLFxuICAgIHN0cm9uZzogZW1waGFzaXNBbmRTdHJpa2V0aHJvdWdoLFxuICAgIGVtcGg6IGVtcGhhc2lzQW5kU3RyaWtldGhyb3VnaCxcbiAgICBzdHJpa2U6IGVtcGhhc2lzQW5kU3RyaWtldGhyb3VnaCxcbiAgICBsaW5rOiBsaW5rLFxuICAgIGltYWdlOiBpbWFnZSQxLFxuICAgIGNvZGU6IGNvZGUsXG4gICAgY29kZUJsb2NrOiBjb2RlQmxvY2skMSxcbiAgICBibG9ja1F1b3RlOiBibG9ja1F1b3RlJDIsXG4gICAgaXRlbTogaXRlbSQxLFxuICAgIGN1c3RvbUJsb2NrOiBjdXN0b21CbG9jayQyLFxufTtcbnZhciBzaW1wbGVNYXJrQ2xhc3NOYW1lTWFwID0ge1xuICAgIHRoZW1hdGljQnJlYWs6IFRIRU1BVElDX0JSRUFLLFxuICAgIHRhYmxlOiBUQUJMRSxcbiAgICB0YWJsZUNlbGw6IFRBQkxFX0NFTEwsXG4gICAgaHRtbElubGluZTogSFRNTCxcbn07XG5mdW5jdGlvbiBnZXRNYXJrSW5mbyhub2RlLCBzdGFydCwgZW5kLCBlbmRMaW5lKSB7XG4gICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgaWYgKGlzRnVuY3Rpb25fMShtYXJrTm9kZUZ1bmNNYXBbdHlwZV0pKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIG1hcmtOb2RlRnVuY01hcFt0eXBlXShub2RlLCBzdGFydCwgZW5kLCBlbmRMaW5lKTtcbiAgICB9XG4gICAgaWYgKHNpbXBsZU1hcmtDbGFzc05hbWVNYXBbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIFttYXJrSW5mbyhzdGFydCwgZW5kLCBzaW1wbGVNYXJrQ2xhc3NOYW1lTWFwW3R5cGVdKV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgcmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXAgPSB7fTtcbmZ1bmN0aW9uIHN5bnRheEhpZ2hsaWdodChfYSkge1xuICAgIHZhciBzY2hlbWEgPSBfYS5zY2hlbWEsIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaztcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHJhbnNhY3Rpb25zLCBfLCBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRyID0gdHJhbnNhY3Rpb25zWzBdO1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gbmV3U3RhdGUudHI7XG4gICAgICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrSW5mb18xID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB0ci5nZXRNZXRhKCdlZGl0UmVzdWx0Jyk7XG4gICAgICAgICAgICAgICAgZWRpdFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gcmVzdWx0Lm5vZGVzLCByZW1vdmVkTm9kZVJhbmdlID0gcmVzdWx0LnJlbW92ZWROb2RlUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtJbmZvXzEgPSBtYXJrSW5mb18xLmNvbmNhdChnZXRNYXJrRm9yUmVtb3ZpbmcobmV3VHIsIG5vZGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG5vZGVzXzEgPSBub2RlczsgX2kgPCBub2Rlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IG5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3YWxrZXIgPSBwYXJlbnRfMS53YWxrZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGV2ZW50XzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBldmVudF8xLm5vZGUsIGVudGVyaW5nID0gZXZlbnRfMS5lbnRlcmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrSW5mb18xID0gbWFya0luZm9fMS5jb25jYXQoZ2V0TWFya0ZvckFkZGluZyhub2RlLCB0b2FzdE1hcmspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudF8xID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVtb3ZlZE5vZGVSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heEluZGV4ID0gbmV3VHIuZG9jLmNoaWxkQ291bnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcmVtb3ZlZE5vZGVSYW5nZS5saW5lLCBzdGFydExpbmUgPSBfYVswXSwgZW5kTGluZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydExpbmUsIG1heEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IE1hdGgubWluKGVuZExpbmUsIG1heEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBpbmRleCB0byByZW1vdmUgY29kZSBibG9jaywgY3VzdG9tIGJsb2NrIGJhY2tncm91bmQgd2hlbiB0aGVyZSBhcmUgbm8gYWRkaW5nIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmdCYWNrZ3JvdW5kSW5kZXhNYXBbaV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXBwZW5kTWFya1RyKG5ld1RyLCBzY2hlbWEsIG1hcmtJbmZvXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld1RyLnNldE1ldGEoJ3dpZGdldCcsIHRyLmdldE1ldGEoJ3dpZGdldCcpKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzRGlmZmVyZW50QmxvY2soZG9jLCBpbmRleCwgYXR0cnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGF0dHJzW25hbWVdICE9PSBkb2MuY2hpbGQoaW5kZXgpLmF0dHJzW25hbWVdOyB9KTtcbn1cbmZ1bmN0aW9uIGFkZExpbmVCYWNrZ3JvdW5kKHRyLCBkb2MsIHBhcmFncmFwaCwgYmxvY2tQb3NJbmZvLCBhdHRycykge1xuICAgIGlmIChhdHRycyA9PT0gdm9pZCAwKSB7IGF0dHJzID0ge307IH1cbiAgICB2YXIgc3RhcnRJbmRleCA9IGJsb2NrUG9zSW5mby5zdGFydEluZGV4LCBlbmRJbmRleCA9IGJsb2NrUG9zSW5mby5lbmRJbmRleCwgZnJvbSA9IGJsb2NrUG9zSW5mby5mcm9tLCB0byA9IGJsb2NrUG9zSW5mby50bztcbiAgICB2YXIgc2hvdWxkQ2hhbmdlQmxvY2tUeXBlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkgKz0gMSkge1xuICAgICAgICAvLyBwcmV2ZW50IHRvIHJlbW92ZSBiYWNrZ3JvdW5kIG9mIHRoZSBub2RlIHRoYXQgbmVlZCB0byBoYXZlIGJhY2tncm91bmRcbiAgICAgICAgZGVsZXRlIHJlbW92aW5nQmFja2dyb3VuZEluZGV4TWFwW2ldO1xuICAgICAgICBzaG91bGRDaGFuZ2VCbG9ja1R5cGUgPSBpc0RpZmZlcmVudEJsb2NrKGRvYywgaSwgYXR0cnMpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQ2hhbmdlQmxvY2tUeXBlKSB7XG4gICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgcGFyYWdyYXBoLCBhdHRycyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kTWFya1RyKHRyLCBzY2hlbWEsIG1hcmtzKSB7XG4gICAgdmFyIGRvYyA9IHRyLmRvYztcbiAgICB2YXIgcGFyYWdyYXBoID0gc2NoZW1hLm5vZGVzLnBhcmFncmFwaDtcbiAgICAvLyBnZXQgc3RhcnQgcG9zaXRpb24gcGVyIGxpbmUgZm9yIGxhenkgY2FsY3VsYXRpb25cbiAgICB2YXIgc3RhcnRQb3NMaXN0UGVyTGluZSA9IGdldFN0YXJ0UG9zTGlzdFBlckxpbmUoZG9jLCBkb2MuY2hpbGRDb3VudCk7XG4gICAgbWFya3MuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gX2Euc3RhcnQsIGVuZCA9IF9hLmVuZCwgc3BlYyA9IF9hLnNwZWMsIGxpbmVCYWNrZ3JvdW5kID0gX2EubGluZUJhY2tncm91bmQ7XG4gICAgICAgIHZhciBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRbMF0sIGRvYy5jaGlsZENvdW50KSAtIDE7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IE1hdGgubWluKGVuZFswXSwgZG9jLmNoaWxkQ291bnQpIC0gMTtcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGRvYy5jaGlsZChzdGFydEluZGV4KTtcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBkb2MuY2hpbGQoZW5kSW5kZXgpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxpbmVcbiAgICAgICAgdmFyIGZyb20gPSBzdGFydFBvc0xpc3RQZXJMaW5lW3N0YXJ0SW5kZXhdO1xuICAgICAgICB2YXIgdG8gPSBzdGFydFBvc0xpc3RQZXJMaW5lW2VuZEluZGV4XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBjaGFyYWN0ZXIgb2Zmc2V0IG9mIHRoZSBsaW5lXG4gICAgICAgIGZyb20gKz0gc3RhcnRbMV0gKyBnZXRXaWRnZXROb2RlUG9zKHN0YXJ0Tm9kZSwgc3RhcnRbMV0gLSAxKTtcbiAgICAgICAgdG8gKz0gZW5kWzFdICsgZ2V0V2lkZ2V0Tm9kZVBvcyhlbmROb2RlLCBlbmRbMV0gLSAxKTtcbiAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lQmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NJbmZvID0geyBmcm9tOiBmcm9tLCB0bzogdG8sIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsIGVuZEluZGV4OiBlbmRJbmRleCB9O1xuICAgICAgICAgICAgICAgIGFkZExpbmVCYWNrZ3JvdW5kKHRyLCBkb2MsIHBhcmFncmFwaCwgcG9zSW5mbywgc3BlYy5hdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBzY2hlbWEubWFyayhzcGVjLnR5cGUsIHNwZWMuYXR0cnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlQmxvY2tCYWNrZ3JvdW5kKHRyLCBzdGFydFBvc0xpc3RQZXJMaW5lLCBwYXJhZ3JhcGgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQmxvY2tCYWNrZ3JvdW5kKHRyLCBzdGFydFBvc0xpc3RQZXJMaW5lLCBwYXJhZ3JhcGgpIHtcbiAgICBPYmplY3Qua2V5cyhyZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBOdW1iZXIoaW5kZXgpO1xuICAgICAgICAvLyBnZXQgdGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBsaW5lIHdpdGggdGhlIG5leHQgbm9kZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5taW4oTnVtYmVyKGluZGV4KSArIDEsIHRyLmRvYy5jaGlsZENvdW50IC0gMSk7XG4gICAgICAgIHZhciBmcm9tID0gc3RhcnRQb3NMaXN0UGVyTGluZVtzdGFydEluZGV4XTtcbiAgICAgICAgLy8gc3VidHJhY3QgJzEnIGZvciBnZXR0aW5nIGVuZCBwb3NpdGlvbiBvZiB0aGUgbGluZVxuICAgICAgICB2YXIgdG8gPSBzdGFydFBvc0xpc3RQZXJMaW5lW2VuZEluZGV4XSAtIDE7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSBlbmRJbmRleCkge1xuICAgICAgICAgICAgdG8gKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIHBhcmFncmFwaCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjYWNoZUluZGV4VG9SZW1vdmVCYWNrZ3JvdW5kKGRvYywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBza2lwTGluZXMgPSBbXTtcbiAgICByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSBzdGFydFswXSAtIDE7IGkgPCBlbmRbMF07IGkgKz0gMSkge1xuICAgICAgICB2YXIgbm9kZSA9IGRvYy5jaGlsZChpKTtcbiAgICAgICAgdmFyIGNvZGVFbmQgPSBub2RlLmF0dHJzLmNvZGVFbmQ7XG4gICAgICAgIHZhciBjb2RlU3RhcnQgPSBub2RlLmF0dHJzLmNvZGVTdGFydDtcbiAgICAgICAgaWYgKGNvZGVTdGFydCAmJiBjb2RlRW5kICYmICFpbmNsdWRlcyhza2lwTGluZXMsIGNvZGVTdGFydCkpIHtcbiAgICAgICAgICAgIHNraXBMaW5lcy5wdXNoKGNvZGVTdGFydCk7XG4gICAgICAgICAgICBjb2RlRW5kID0gTWF0aC5taW4oY29kZUVuZCwgZG9jLmNoaWxkQ291bnQpO1xuICAgICAgICAgICAgLy8gc2hvdWxkIHN1YnRyYWN0ICcxJyB0byBtYXJrZG93biBsaW5lIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG1hcmtkb3duIHBhcnNlciBoYXMgJzEnKG5vdCB6ZXJvKSBhcyB0aGUgc3RhcnQgbnVtYmVyXG4gICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGNvZGVTdGFydCAtIDE7XG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBlbmRbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IHN0YXJ0SW5kZXg7IGluZGV4IDwgZW5kSW5kZXg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZW1vdmluZ0JhY2tncm91bmRJbmRleE1hcFtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWFya0ZvclJlbW92aW5nKF9hLCBub2Rlcykge1xuICAgIHZhciBkb2MgPSBfYS5kb2M7XG4gICAgdmFyIHN0YXJ0ID0gbm9kZXNbMF0uc291cmNlcG9zWzBdO1xuICAgIHZhciBfYiA9IGxhc3QkMShub2Rlcykuc291cmNlcG9zLCBlbmQgPSBfYlsxXTtcbiAgICB2YXIgc3RhcnRQb3MgPSBbc3RhcnRbMF0sIHN0YXJ0WzFdXTtcbiAgICB2YXIgZW5kUG9zID0gW2VuZFswXSwgZW5kWzFdICsgMV07XG4gICAgdmFyIG1hcmtzID0gW107XG4gICAgY2FjaGVJbmRleFRvUmVtb3ZlQmFja2dyb3VuZChkb2MsIHN0YXJ0LCBlbmQpO1xuICAgIG1hcmtzLnB1c2goeyBzdGFydDogc3RhcnRQb3MsIGVuZDogZW5kUG9zIH0pO1xuICAgIHJldHVybiBtYXJrcztcbn1cbmZ1bmN0aW9uIGdldE1hcmtGb3JBZGRpbmcobm9kZSwgdG9hc3RNYXJrKSB7XG4gICAgdmFyIGxpbmVUZXh0cyA9IHRvYXN0TWFyay5nZXRMaW5lVGV4dHMoKTtcbiAgICB2YXIgc3RhcnRQb3MgPSBbZ2V0TWRTdGFydExpbmUobm9kZSksIGdldE1kU3RhcnRDaChub2RlKV07XG4gICAgdmFyIGVuZFBvcyA9IFtnZXRNZEVuZExpbmUobm9kZSksIGdldE1kRW5kQ2gobm9kZSkgKyAxXTtcbiAgICB2YXIgbWFya0luZm8gPSBnZXRNYXJrSW5mbyhub2RlLCBzdGFydFBvcywgZW5kUG9zLCBsaW5lVGV4dHNbZW5kUG9zWzBdIC0gMV0pO1xuICAgIHJldHVybiBtYXJrSW5mbyAhPT0gbnVsbCAmJiBtYXJrSW5mbyAhPT0gdm9pZCAwID8gbWFya0luZm8gOiBbXTtcbn1cblxudmFyIGRlZmF1bHRUb29sYmFyU3RhdGVLZXlzID0gW1xuICAgICd0YXNrTGlzdCcsXG4gICAgJ29yZGVyZWRMaXN0JyxcbiAgICAnYnVsbGV0TGlzdCcsXG4gICAgJ3RhYmxlJyxcbiAgICAnc3Ryb25nJyxcbiAgICAnZW1waCcsXG4gICAgJ3N0cmlrZScsXG4gICAgJ2hlYWRpbmcnLFxuICAgICd0aGVtYXRpY0JyZWFrJyxcbiAgICAnYmxvY2tRdW90ZScsXG4gICAgJ2NvZGUnLFxuICAgICdjb2RlQmxvY2snLFxuICAgICdpbmRlbnQnLFxuICAgICdvdXRkZW50Jyxcbl07XG5mdW5jdGlvbiBnZXRUb29sYmFyU3RhdGVUeXBlJDEobWROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBtZE5vZGUudHlwZTtcbiAgICBpZiAoaXNMaXN0Tm9kZSQxKG1kTm9kZSkpIHtcbiAgICAgICAgaWYgKG1kTm9kZS5saXN0RGF0YS50YXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Rhc2tMaXN0JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWROb2RlLmxpc3REYXRhLnR5cGUgPT09ICdvcmRlcmVkJyA/ICdvcmRlcmVkTGlzdCcgOiAnYnVsbGV0TGlzdCc7XG4gICAgfVxuICAgIGlmICh0eXBlLmluZGV4T2YoJ3RhYmxlJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiAndGFibGUnO1xuICAgIH1cbiAgICBpZiAoIWluY2x1ZGVzKGRlZmF1bHRUb29sYmFyU3RhdGVLZXlzLCB0eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBnZXRUb29sYmFyU3RhdGUkMSh0YXJnZXROb2RlKSB7XG4gICAgdmFyIHRvb2xiYXJTdGF0ZSA9IHtcbiAgICAgICAgaW5kZW50OiB7IGFjdGl2ZTogZmFsc2UsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgICAgIG91dGRlbnQ6IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICB9O1xuICAgIHZhciBsaXN0RW5hYmxlZCA9IHRydWU7XG4gICAgdHJhdmVyc2VQYXJlbnROb2Rlcyh0YXJnZXROb2RlLCBmdW5jdGlvbiAobWROb2RlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VG9vbGJhclN0YXRlVHlwZSQxKG1kTm9kZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnYnVsbGV0TGlzdCcgfHwgdHlwZSA9PT0gJ29yZGVyZWRMaXN0Jykge1xuICAgICAgICAgICAgLy8gdG8gYXBwbHkgdGhlIG5lYXJsaXN0IGxpc3Qgc3RhdGUgaW4gdGhlIG5lc3RlZCBsaXN0XG4gICAgICAgICAgICBpZiAobGlzdEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0b29sYmFyU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZS5pbmRlbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0b29sYmFyU3RhdGUub3V0ZGVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxpc3RFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvb2xiYXJTdGF0ZTtcbn1cbmZ1bmN0aW9uIHByZXZpZXdIaWdobGlnaHQoX2EpIHtcbiAgICB2YXIgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICB2aWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHZpZXcsIHByZXZTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gc3RhdGUuZG9jLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2U3RhdGUgJiYgcHJldlN0YXRlLmRvYy5lcShkb2MpICYmIHByZXZTdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydENoT2Zmc2V0ID0gc3RhdGUuZG9jLnJlc29sdmUoZnJvbSkuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGF0ZS5kb2MuY29udGVudC5maW5kSW5kZXgoZnJvbSkuaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSBmcm9tIC0gc3RhcnRDaE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHN0YXJ0Q2hPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvclBvcyA9IFtsaW5lLCBjaF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZE5vZGVBdFBvc2l0aW9uKGN1cnNvclBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b29sYmFyU3RhdGUgPSBnZXRUb29sYmFyU3RhdGUkMShtZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY2hhbmdlVG9vbGJhclN0YXRlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yUG9zOiBjdXJzb3JQb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZE5vZGU6IG1kTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZTogdG9vbGJhclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ3NldEZvY3VzZWROb2RlJywgbWROb2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIERvYyQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKERvYywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb2MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvYy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERvYy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBEb2M7XG59KE5vZGUkMikpO1xuXG52YXIgTWFyayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXJrKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFyay5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdtYXJrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1hcmsucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIE1hcms7XG59KCkpO1xuXG5mdW5jdGlvbiBnZXRUZXh0QnlNZExpbmUoZG9jLCBtZExpbmUpIHtcbiAgICByZXR1cm4gZ2V0VGV4dENvbnRlbnQoZG9jLCBtZExpbmUgLSAxKTtcbn1cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50KGRvYywgaW5kZXgpIHtcbiAgICByZXR1cm4gZG9jLmNoaWxkKGluZGV4KS50ZXh0Q29udGVudDtcbn1cblxudmFyIHJlQmxvY2tRdW90ZSA9IC9eXFxzKj4gPy87XG52YXIgQmxvY2tRdW90ZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEJsb2NrUXVvdGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmxvY2tRdW90ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvY2tRdW90ZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdibG9ja1F1b3RlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja1F1b3RlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnYmxvY2stcXVvdGUnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEJsb2NrUXVvdGUucHJvdG90eXBlLmNyZWF0ZUJsb2NrUXVvdGVUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGlzQmxvY2tRdW90ZSkge1xuICAgICAgICByZXR1cm4gaXNCbG9ja1F1b3RlID8gdGV4dC5yZXBsYWNlKHJlQmxvY2tRdW90ZSwgJycpLnRyaW0oKSA6IFwiPiBcIiArIHRleHQudHJpbSgpO1xuICAgIH07XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUuZXh0ZW5kQmxvY2tRdW90ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYywgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGVuZEZyb21PZmZzZXQgPSBfYi5lbmRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9iLmVuZFRvT2Zmc2V0LCBlbmRJbmRleCA9IF9iLmVuZEluZGV4LCB0byA9IF9iLnRvO1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBlbmRJbmRleCk7XG4gICAgICAgICAgICB2YXIgaXNCbG9ja1F1b3RlID0gcmVCbG9ja1F1b3RlLnRlc3QodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2tRdW90ZSAmJiB0byA+IGVuZEZyb21PZmZzZXQgJiYgc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRW1wdHkgPSAhdGV4dENvbnRlbnQucmVwbGFjZShyZUJsb2NrUXVvdGUsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZW5kRnJvbU9mZnNldCwgZW5kVG9PZmZzZXQpLnNwbGl0KHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpY2VkVGV4dCA9IHRleHRDb250ZW50LnNsaWNlKHRvIC0gZW5kRnJvbU9mZnNldCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBfdGhpcy5jcmVhdGVCbG9ja1F1b3RlVGV4dChzbGljZWRUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0QW5kRXh0ZW5kQmxvY2sodHIsIGVuZFRvT2Zmc2V0LCBzbGljZWRUZXh0LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0LCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleDtcbiAgICAgICAgICAgIHZhciBpc0Jsb2NrUXVvdGUgPSByZUJsb2NrUXVvdGUudGVzdChnZXRUZXh0Q29udGVudChkb2MsIHN0YXJ0SW5kZXgpKTtcbiAgICAgICAgICAgIHZhciB0ciA9IHJlcGxhY2VUZXh0Tm9kZSh7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICAgIGZyb206IHN0YXJ0RnJvbU9mZnNldCxcbiAgICAgICAgICAgICAgICBjcmVhdGVUZXh0OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUJsb2NrUXVvdGVUZXh0KHRleHRDb250ZW50LCBpc0Jsb2NrUXVvdGUpOyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmxvY2tRdW90ZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdhbHQtcSc6IGJsb2NrUXVvdGVDb21tYW5kLFxuICAgICAgICAgICAgJ2FsdC1RJzogYmxvY2tRdW90ZUNvbW1hbmQsXG4gICAgICAgICAgICBFbnRlcjogdGhpcy5leHRlbmRCbG9ja1F1b3RlKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tRdW90ZTtcbn0oTWFyaykpO1xuXG52YXIgcmVMaXN0ID0gLyheXFxzKikoWy0qK10gfFtcXGRdK1xcLiApLztcbnZhciByZU9yZGVyZWRMaXN0ID0gLyheXFxzKikoW1xcZF0pK1xcLiggXFxbWyB4WF1dKT8gLztcbnZhciByZU9yZGVyZWRMaXN0R3JvdXAgPSAvXihcXHMqKSgoXFxkKykoWy4pXVxccyg/OlxcWyg/Onh8XFxzKVxcXVxccyk/KSkoLiopLztcbnZhciByZUNhbkJlVGFza0xpc3QgPSAvKF5cXHMqKShbLSorXXxbXFxkXStcXC4pKCBcXFtbIHhYXV0pPyAvO1xudmFyIHJlQnVsbGV0TGlzdEdyb3VwID0gL14oXFxzKikoWy0qK10rKFxccyg/OlxcWyg/Onh8XFxzKVxcXVxccyk/KSkoLiopLztcbnZhciByZVRhc2tMaXN0ID0gLyheXFxzKikoWy0qK10gfFtcXGRdK1xcLiApKFxcW1sgeFhdXSApLztcbnZhciByZUJ1bGxldFRhc2tMaXN0ID0gLyheXFxzKikoWy0qK10pKCBcXFtbIHhYXV0pIC87XG5mdW5jdGlvbiBnZXRMaXN0VHlwZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHJlT3JkZXJlZExpc3QudGVzdCh0ZXh0KSA/ICdvcmRlcmVkJyA6ICdidWxsZXQnO1xufVxuZnVuY3Rpb24gZ2V0TGlzdERlcHRoKG1kTm9kZSkge1xuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpZiAobWROb2RlLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBtZE5vZGUgPSBtZE5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG59XG5mdW5jdGlvbiBmaW5kU2FtZURlcHRoTGlzdCh0b2FzdE1hcmssIGN1cnJlbnRMaW5lLCBkZXB0aCwgYmFja3dhcmQpIHtcbiAgICB2YXIgbGluZVRleHRzID0gdG9hc3RNYXJrLmdldExpbmVUZXh0cygpO1xuICAgIHZhciBsaW5lTGVuID0gbGluZVRleHRzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGxpbmUgPSBjdXJyZW50TGluZTtcbiAgICB3aGlsZSAoYmFja3dhcmQgPyBsaW5lIDwgbGluZUxlbiA6IGxpbmUgPiAxKSB7XG4gICAgICAgIGxpbmUgPSBiYWNrd2FyZCA/IGxpbmUgKyAxIDogbGluZSAtIDE7XG4gICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShsaW5lKTtcbiAgICAgICAgdmFyIGN1cnJlbnRMaXN0RGVwdGggPSBnZXRMaXN0RGVwdGgobWROb2RlKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaXN0RGVwdGggPT09IGRlcHRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGxpbmU6IGxpbmUsIGRlcHRoOiBkZXB0aCwgbWROb2RlOiBtZE5vZGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudExpc3REZXB0aCA8IGRlcHRoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0U2FtZURlcHRoSXRlbXMoX2EpIHtcbiAgICB2YXIgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBtZE5vZGUgPSBfYS5tZE5vZGUsIGxpbmUgPSBfYS5saW5lO1xuICAgIHZhciBkZXB0aCA9IGdldExpc3REZXB0aChtZE5vZGUpO1xuICAgIHZhciBmb3J3YXJkTGlzdCA9IGZpbmRTYW1lRGVwdGhMaXN0KHRvYXN0TWFyaywgbGluZSwgZGVwdGgsIGZhbHNlKS5yZXZlcnNlKCk7XG4gICAgdmFyIGJhY2t3YXJkTGlzdCA9IGZpbmRTYW1lRGVwdGhMaXN0KHRvYXN0TWFyaywgbGluZSwgZGVwdGgsIHRydWUpO1xuICAgIHJldHVybiBmb3J3YXJkTGlzdC5jb25jYXQoW3sgbGluZTogbGluZSwgZGVwdGg6IGRlcHRoLCBtZE5vZGU6IG1kTm9kZSB9XSkuY29uY2F0KGJhY2t3YXJkTGlzdCk7XG59XG5mdW5jdGlvbiB0ZXh0VG9CdWxsZXQodGV4dCkge1xuICAgIGlmICghcmVMaXN0LnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIFwiKiBcIiArIHRleHQ7XG4gICAgfVxuICAgIHZhciB0eXBlID0gZ2V0TGlzdFR5cGUodGV4dCk7XG4gICAgaWYgKHR5cGUgPT09ICdidWxsZXQnICYmIHJlQ2FuQmVUYXNrTGlzdC50ZXN0KHRleHQpKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVCdWxsZXRUYXNrTGlzdCwgJyQxJDIgJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvcmRlcmVkJykge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlT3JkZXJlZExpc3QsICckMSogJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gdGV4dFRvT3JkZXJlZCh0ZXh0LCBvcmRpbmFsTnVtKSB7XG4gICAgaWYgKCFyZUxpc3QudGVzdCh0ZXh0KSkge1xuICAgICAgICByZXR1cm4gb3JkaW5hbE51bSArIFwiLiBcIiArIHRleHQ7XG4gICAgfVxuICAgIHZhciB0eXBlID0gZ2V0TGlzdFR5cGUodGV4dCk7XG4gICAgaWYgKHR5cGUgPT09ICdidWxsZXQnIHx8ICh0eXBlID09PSAnb3JkZXJlZCcgJiYgcmVDYW5CZVRhc2tMaXN0LnRlc3QodGV4dCkpKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVDYW5CZVRhc2tMaXN0LCBcIiQxXCIgKyBvcmRpbmFsTnVtICsgXCIuIFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ29yZGVyZWQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgc3RhcnQgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyh0ZXh0KVszXTtcbiAgICAgICAgaWYgKE51bWJlcihzdGFydCkgIT09IG9yZGluYWxOdW0pIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVPcmRlcmVkTGlzdCwgXCIkMVwiICsgb3JkaW5hbE51bSArIFwiLiBcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBnZXRDaGFuZ2VkSW5mbyhkb2MsIHNhbWVEZXB0aEl0ZW1zLCB0eXBlLCBzdGFydCkge1xuICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgIHZhciBmaXJzdEluZGV4ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSBzYW1lRGVwdGhJdGVtcy5tYXAoZnVuY3Rpb24gKF9hLCBpbmRleCkge1xuICAgICAgICB2YXIgbGluZSA9IF9hLmxpbmU7XG4gICAgICAgIGZpcnN0SW5kZXggPSBNYXRoLm1pbihsaW5lIC0gMSwgZmlyc3RJbmRleCk7XG4gICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KGxpbmUgLSAxLCBsYXN0SW5kZXgpO1xuICAgICAgICB2YXIgdGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB0ZXh0ID0gdHlwZSA9PT0gJ2J1bGxldCcgPyB0ZXh0VG9CdWxsZXQodGV4dCkgOiB0ZXh0VG9PcmRlcmVkKHRleHQsIGluZGV4ICsgMSArIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogdGV4dCwgbGluZTogbGluZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBjaGFuZ2VkUmVzdWx0cywgZmlyc3RJbmRleDogZmlyc3RJbmRleCwgbGFzdEluZGV4OiBsYXN0SW5kZXggfTtcbn1cbmZ1bmN0aW9uIGdldEJ1bGxldE9yT3JkZXJlZCh0eXBlLCBjb250ZXh0KSB7XG4gICAgdmFyIHNhbWVEZXB0aExpc3RJbmZvID0gZ2V0U2FtZURlcHRoSXRlbXMoY29udGV4dCk7XG4gICAgcmV0dXJuIGdldENoYW5nZWRJbmZvKGNvbnRleHQuZG9jLCBzYW1lRGVwdGhMaXN0SW5mbywgdHlwZSk7XG59XG52YXIgb3RoZXJMaXN0VG9MaXN0ID0ge1xuICAgIGJ1bGxldDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1bGxldE9yT3JkZXJlZCgnYnVsbGV0JywgY29udGV4dCk7XG4gICAgfSxcbiAgICBvcmRlcmVkOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZ2V0QnVsbGV0T3JPcmRlcmVkKCdvcmRlcmVkJywgY29udGV4dCk7XG4gICAgfSxcbiAgICB0YXNrOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgZG9jID0gX2EuZG9jLCBsaW5lID0gX2EubGluZTtcbiAgICAgICAgdmFyIHRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgaWYgKG1kTm9kZS5saXN0RGF0YS50YXNrKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlVGFza0xpc3QsICckMSQyJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMaXN0Tm9kZSQxKG1kTm9kZSkpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVMaXN0LCAnJDEkMlsgXSAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VkUmVzdWx0czogW3sgdGV4dDogdGV4dCwgbGluZTogbGluZSB9XSB9O1xuICAgIH0sXG59O1xudmFyIG90aGVyTm9kZVRvTGlzdCA9IHtcbiAgICBidWxsZXQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZG9jID0gX2EuZG9jLCBsaW5lID0gX2EubGluZTtcbiAgICAgICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgICAgIHZhciBjaGFuZ2VkUmVzdWx0cyA9IFt7IHRleHQ6IFwiKiBcIiArIGxpbmVUZXh0LCBsaW5lOiBsaW5lIH1dO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VkUmVzdWx0czogY2hhbmdlZFJlc3VsdHMgfTtcbiAgICB9LFxuICAgIG9yZGVyZWQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrLCBkb2MgPSBfYS5kb2MsIGxpbmUgPSBfYS5saW5lLCBzdGFydExpbmUgPSBfYS5zdGFydExpbmU7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgZmlyc3RPcmRlcmVkTGlzdE51bSA9IDE7XG4gICAgICAgIHZhciBmaXJzdE9yZGVyZWRMaXN0TGluZSA9IHN0YXJ0TGluZTtcbiAgICAgICAgdmFyIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lIC0gMTsgaSA+IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGkpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBpKTtcbiAgICAgICAgICAgIHZhciBjYW5CZUxpc3ROb2RlID0gdGV4dCAmJiAhIWZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGZ1bmN0aW9uICh0YXJnZXROb2RlKSB7IHJldHVybiBpc0xpc3ROb2RlJDEodGFyZ2V0Tm9kZSk7IH0pO1xuICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGdldFRleHRCeU1kTGluZShkb2MsIGkpKTtcbiAgICAgICAgICAgIGlmICghc2VhcmNoUmVzdWx0ICYmICFjYW5CZUxpc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlYXJjaFJlc3VsdCAmJiBjYW5CZUxpc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCArPSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gc2VhcmNoUmVzdWx0LCBpbmRlbnQgPSBfYlsxXSwgc3RhcnQgPSBfYlszXTtcbiAgICAgICAgICAgIC8vIGJhc2lzIG9uIG9uZSBkZXB0aCBsaXN0XG4gICAgICAgICAgICBpZiAoIWluZGVudCkge1xuICAgICAgICAgICAgICAgIGZpcnN0T3JkZXJlZExpc3ROdW0gPSBOdW1iZXIoc3RhcnQpO1xuICAgICAgICAgICAgICAgIGZpcnN0T3JkZXJlZExpc3RMaW5lID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JkaW5hbE51bSA9IGZpcnN0T3JkZXJlZExpc3ROdW0gKyBsaW5lIC0gZmlyc3RPcmRlcmVkTGlzdExpbmUgLSBza2lwcGVkO1xuICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdHMgPSBbeyB0ZXh0OiBvcmRpbmFsTnVtICsgXCIuIFwiICsgbGluZVRleHQsIGxpbmU6IGxpbmUgfV07XG4gICAgICAgIHJldHVybiB7IGNoYW5nZWRSZXN1bHRzOiBjaGFuZ2VkUmVzdWx0cyB9O1xuICAgIH0sXG4gICAgdGFzazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBkb2MgPSBfYS5kb2MsIGxpbmUgPSBfYS5saW5lO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIGNoYW5nZWRSZXN1bHRzID0gW3sgdGV4dDogXCIqIFsgXSBcIiArIGxpbmVUZXh0LCBsaW5lOiBsaW5lIH1dO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VkUmVzdWx0czogY2hhbmdlZFJlc3VsdHMgfTtcbiAgICB9LFxufTtcbnZhciBleHRlbmRMaXN0ID0ge1xuICAgIGJ1bGxldDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBsaW5lID0gX2EubGluZSwgZG9jID0gX2EuZG9jO1xuICAgICAgICB2YXIgbGluZVRleHQgPSBnZXRUZXh0QnlNZExpbmUoZG9jLCBsaW5lKTtcbiAgICAgICAgdmFyIF9iID0gcmVCdWxsZXRMaXN0R3JvdXAuZXhlYyhsaW5lVGV4dCksIGluZGVudCA9IF9iWzFdLCBkZWxpbWl0ZXIgPSBfYlsyXTtcbiAgICAgICAgcmV0dXJuIHsgbGlzdFN5bnRheDogXCJcIiArIGluZGVudCArIGRlbGltaXRlciB9O1xuICAgIH0sXG4gICAgb3JkZXJlZDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIGxpbmUgPSBfYS5saW5lLCBtZE5vZGUgPSBfYS5tZE5vZGUsIGRvYyA9IF9hLmRvYztcbiAgICAgICAgdmFyIGRlcHRoID0gZ2V0TGlzdERlcHRoKG1kTm9kZSk7XG4gICAgICAgIHZhciBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICB2YXIgX2IgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhsaW5lVGV4dCksIGluZGVudCA9IF9iWzFdLCBzdGFydCA9IF9iWzNdLCBkZWxpbWl0ZXIgPSBfYls0XTtcbiAgICAgICAgdmFyIG9yZGluYWxOdW0gPSBOdW1iZXIoc3RhcnQpICsgMTtcbiAgICAgICAgdmFyIGxpc3RTeW50YXggPSBcIlwiICsgaW5kZW50ICsgb3JkaW5hbE51bSArIGRlbGltaXRlcjtcbiAgICAgICAgdmFyIGJhY2t3YXJkTGlzdCA9IGZpbmRTYW1lRGVwdGhMaXN0KHRvYXN0TWFyaywgbGluZSwgZGVwdGgsIHRydWUpO1xuICAgICAgICB2YXIgZmlsdGVyZWRMaXN0ID0gYmFja3dhcmRMaXN0LmZpbHRlcihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3VsdCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGdldFRleHRCeU1kTGluZShkb2MsIGluZm8ubGluZSkpO1xuICAgICAgICAgICAgcmV0dXJuIChzZWFyY2hSZXN1bHQgJiZcbiAgICAgICAgICAgICAgICBzZWFyY2hSZXN1bHRbMV0ubGVuZ3RoID09PSBpbmRlbnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgISFmaW5kQ2xvc2VzdE5vZGUoaW5mby5tZE5vZGUsIGZ1bmN0aW9uICh0YXJnZXROb2RlKSB7IHJldHVybiBpc09yZGVyZWRMaXN0Tm9kZSh0YXJnZXROb2RlKTsgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoeyBsaXN0U3ludGF4OiBsaXN0U3ludGF4IH0sIGdldENoYW5nZWRJbmZvKGRvYywgZmlsdGVyZWRMaXN0LCAnb3JkZXJlZCcsIG9yZGluYWxOdW0pKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFJlb3JkZXJlZExpc3RJbmZvKGRvYywgc2NoZW1hLCBsaW5lLCBvcmRpbmFsTnVtLCBwcmV2SW5kZW50TGVuZ3RoKSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGxpbmVUZXh0ID0gZ2V0VGV4dEJ5TWRMaW5lKGRvYywgbGluZSk7XG4gICAgdmFyIHNlYXJjaFJlc3VsdCA9IHJlT3JkZXJlZExpc3RHcm91cC5leGVjKGxpbmVUZXh0KTtcbiAgICB3aGlsZSAoc2VhcmNoUmVzdWx0KSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzZWFyY2hSZXN1bHRbMV0sIGRlbGltaXRlciA9IHNlYXJjaFJlc3VsdFs0XSwgdGV4dCA9IHNlYXJjaFJlc3VsdFs1XTtcbiAgICAgICAgdmFyIGluZGVudExlbmd0aCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgIGlmIChpbmRlbnRMZW5ndGggPT09IHByZXZJbmRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIFwiXCIgKyBpbmRlbnQgKyBvcmRpbmFsTnVtICsgZGVsaW1pdGVyICsgdGV4dCkpO1xuICAgICAgICAgICAgb3JkaW5hbE51bSArPSAxO1xuICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGVudExlbmd0aCA+IHByZXZJbmRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWRMaXN0SW5mbyA9IGdldFJlb3JkZXJlZExpc3RJbmZvKGRvYywgc2NoZW1hLCBsaW5lLCAxLCBpbmRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgbGluZSA9IG5lc3RlZExpc3RJbmZvLmxpbmU7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChuZXN0ZWRMaXN0SW5mby5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGVudExlbmd0aCA8IHByZXZJbmRlbnRMZW5ndGggfHwgbGluZSA+IGRvYy5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsaW5lVGV4dCA9IGdldFRleHRCeU1kTGluZShkb2MsIGxpbmUpO1xuICAgICAgICBzZWFyY2hSZXN1bHQgPSByZU9yZGVyZWRMaXN0R3JvdXAuZXhlYyhsaW5lVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVzOiBub2RlcywgbGluZTogbGluZSB9O1xufVxuXG52YXIgcmVTdGFydFNwYWNlID0gLyheXFxzezEsNH0pKC4qKS87XG5mdW5jdGlvbiBpc0Jsb2NrVW5pdChmcm9tLCB0bywgdGV4dCkge1xuICAgIHJldHVybiBmcm9tIDwgdG8gfHwgcmVMaXN0LnRlc3QodGV4dCkgfHwgcmVCbG9ja1F1b3RlLnRlc3QodGV4dCk7XG59XG5mdW5jdGlvbiBpc0luVGFibGVDZWxsTm9kZShkb2MsIHNjaGVtYSwgc2VsZWN0aW9uKSB7XG4gICAgdmFyICRwb3MgPSBzZWxlY3Rpb24uJGZyb207XG4gICAgaWYgKCRwb3MuZGVwdGggPT09IDApIHtcbiAgICAgICAgJHBvcyA9IGRvYy5yZXNvbHZlKCRwb3MucG9zIC0gMSk7XG4gICAgfVxuICAgIHZhciBub2RlID0gJHBvcy5ub2RlKDEpO1xuICAgIHZhciBzdGFydE9mZnNldCA9ICRwb3Muc3RhcnQoMSk7XG4gICAgdmFyIGNvbnRlbnRTaXplID0gbm9kZS5jb250ZW50LnNpemU7XG4gICAgcmV0dXJuIChub2RlLnJhbmdlSGFzTWFyaygwLCBjb250ZW50U2l6ZSwgc2NoZW1hLm1hcmtzLnRhYmxlKSAmJlxuICAgICAgICAkcG9zLnBvcyAtIHN0YXJ0T2Zmc2V0ICE9PSBjb250ZW50U2l6ZSAmJlxuICAgICAgICAkcG9zLnBvcyAhPT0gc3RhcnRPZmZzZXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uKHRyLCBwb3NJbmZvKSB7XG4gICAgdmFyIGZyb20gPSBwb3NJbmZvLmZyb20sIHRvID0gcG9zSW5mby50bztcbiAgICBpZiAocG9zSW5mby50eXBlID09PSAnaW5kZW50Jykge1xuICAgICAgICB2YXIgc29mdFRhYkxlbiA9IDQ7XG4gICAgICAgIGZyb20gKz0gc29mdFRhYkxlbjtcbiAgICAgICAgdG8gKz0gKHBvc0luZm8ubGluZUxlbiArIDEpICogc29mdFRhYkxlbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBzcGFjZUxlbkxpc3QgPSBwb3NJbmZvLnNwYWNlTGVuTGlzdDtcbiAgICAgICAgZnJvbSAtPSBzcGFjZUxlbkxpc3RbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhY2VMZW5MaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0byAtPSBzcGFjZUxlbkxpc3RbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIGZyb20sIHRvKTtcbn1cbnZhciBQYXJhZ3JhcGgkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShQYXJhZ3JhcGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFyYWdyYXBoKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhZ3JhcGgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAncGFyYWdyYXBoJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhZ3JhcGgucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZVN0YXJ0OiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgY29kZUVuZDogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW3sgdGFnOiAnZGl2JyB9XSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0cnMuY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFsnZGl2JywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KGF0dHJzLmNsYXNzTmFtZSkgfSwgMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogWydkaXYnLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUucmVvcmRlckxpc3QgPSBmdW5jdGlvbiAoc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuY29udGV4dCwgdmlldyA9IF9hLnZpZXcsIHRvYXN0TWFyayA9IF9hLnRvYXN0TWFyaywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICB2YXIgX2IgPSB2aWV3LnN0YXRlLCB0ciA9IF9iLnRyLCBzZWxlY3Rpb24gPSBfYi5zZWxlY3Rpb24sIGRvYyA9IF9iLmRvYztcbiAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKHN0YXJ0TGluZSk7XG4gICAgICAgIHZhciB0b3BMaXN0Tm9kZSA9IG1kTm9kZTtcbiAgICAgICAgd2hpbGUgKG1kTm9kZSAmJiAhaXNCdWxsZXRMaXN0Tm9kZShtZE5vZGUpICYmIG1kTm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChpc09yZGVyZWRMaXN0Tm9kZShtZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdG9wTGlzdE5vZGUgPSBtZE5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcExpc3ROb2RlKSB7XG4gICAgICAgICAgICBzdGFydExpbmUgPSB0b3BMaXN0Tm9kZS5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jID0gcmVPcmRlcmVkTGlzdEdyb3VwLmV4ZWMoZ2V0VGV4dEJ5TWRMaW5lKGRvYywgc3RhcnRMaW5lKSksIGluZGVudCA9IF9jWzFdLCBzdGFydCA9IF9jWzNdO1xuICAgICAgICB2YXIgaW5kZW50TGVuID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgdmFyIF9kID0gZ2V0UmVvcmRlcmVkTGlzdEluZm8oZG9jLCBzY2hlbWEsIHN0YXJ0TGluZSwgTnVtYmVyKHN0YXJ0KSwgaW5kZW50TGVuKSwgbGluZSA9IF9kLmxpbmUsIG5vZGVzID0gX2Qubm9kZXM7XG4gICAgICAgIGVuZExpbmUgPSBNYXRoLm1heChlbmRMaW5lLCBsaW5lIC0gMSk7XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IGdldE5vZGVDb250ZW50T2Zmc2V0UmFuZ2UoZG9jLCBzdGFydExpbmUgLSAxKS5zdGFydE9mZnNldDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZSAtIDE7IGkgPD0gZW5kTGluZSAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIF9lID0gZG9jLmNoaWxkKGkpLCBub2RlU2l6ZSA9IF9lLm5vZGVTaXplLCBjb250ZW50ID0gX2UuY29udGVudDtcbiAgICAgICAgICAgIHZhciBtYXBwZWRGcm9tID0gdHIubWFwcGluZy5tYXAoc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgdmFyIG1hcHBlZFRvID0gbWFwcGVkRnJvbSArIGNvbnRlbnQuc2l6ZTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hcHBlZEZyb20sIG1hcHBlZFRvLCBub2Rlc1tpIC0gc3RhcnRMaW5lICsgMV0pO1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgKz0gbm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pKTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUuaW5kZW50ID0gZnVuY3Rpb24gKHRhYktleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGFiS2V5ID09PSB2b2lkIDApIHsgdGFiS2V5ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgZG9jID0gc3RhdGUuZG9jO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKHRhYktleSAmJiBpc0luVGFibGVDZWxsTm9kZShkb2MsIHNjaGVtYSwgc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmICgodGFiS2V5ICYmIGlzQmxvY2tVbml0KGZyb20sIHRvLCBzdGFydExpbmVUZXh0KSkgfHxcbiAgICAgICAgICAgICAgICAoIXRhYktleSAmJiByZUxpc3QudGVzdChzdGFydExpbmVUZXh0KSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSByZXBsYWNlVGV4dE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHN0YXJ0RnJvbU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUZXh0OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHsgcmV0dXJuIFwiICAgIFwiICsgdGV4dENvbnRlbnQ7IH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbmRlbnQnLFxuICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVMZW46IGVuZEluZGV4IC0gc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVTZWxlY3Rpb24odHIsIHBvc0luZm8pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlT3JkZXJlZExpc3RHcm91cC50ZXN0KHN0YXJ0TGluZVRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlb3JkZXJMaXN0KHN0YXJ0SW5kZXggKyAxLCBlbmRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRhYktleSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydCh0bywgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsICcgICAgJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgUGFyYWdyYXBoLnByb3RvdHlwZS5vdXRkZW50ID0gZnVuY3Rpb24gKHRhYktleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGFiS2V5ID09PSB2b2lkIDApIHsgdGFiS2V5ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIGRvYyA9IHN0YXRlLmRvYywgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvLCBzdGFydEZyb21PZmZzZXQgPSBfYS5zdGFydEZyb21PZmZzZXQsIHN0YXJ0SW5kZXggPSBfYS5zdGFydEluZGV4LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKHRhYktleSAmJiBpc0luVGFibGVDZWxsTm9kZShkb2MsIHNjaGVtYSwgc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmICgodGFiS2V5ICYmIGlzQmxvY2tVbml0KGZyb20sIHRvLCBzdGFydExpbmVUZXh0KSkgfHxcbiAgICAgICAgICAgICAgICAoIXRhYktleSAmJiByZUxpc3QudGVzdChzdGFydExpbmVUZXh0KSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VMZW5MaXN0XzEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdHIgPSByZXBsYWNlVGV4dE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHN0YXJ0RnJvbU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUZXh0OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hSZXN1bHQgPSByZVN0YXJ0U3BhY2UuZXhlYyh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUxlbkxpc3RfMS5wdXNoKHNlYXJjaFJlc3VsdCA/IHNlYXJjaFJlc3VsdFsxXS5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5yZXBsYWNlKHJlU3RhcnRTcGFjZSwgJyQyJyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHBvc0luZm8gPSB7IHR5cGU6ICdvdXRkZW50JywgZnJvbTogZnJvbSwgdG86IHRvLCBzcGFjZUxlbkxpc3Q6IHNwYWNlTGVuTGlzdF8xIH07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVNlbGVjdGlvbih0ciwgcG9zSW5mbykpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVPcmRlcmVkTGlzdEdyb3VwLnRlc3Qoc3RhcnRMaW5lVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVvcmRlckxpc3Qoc3RhcnRJbmRleCArIDEsIGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGFiS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0VGV4dCA9IHN0YXJ0TGluZVRleHQuc2xpY2UoMCwgdG8gLSBzdGFydEZyb21PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydFRleHRXaXRob3V0U3BhY2UgPSBzdGFydFRleHQucmVwbGFjZSgvXFxzezEsNH0kLywgJycpO1xuICAgICAgICAgICAgICAgIHZhciBkZWxldFN0YXJ0ID0gdG8gLSAoc3RhcnRUZXh0Lmxlbmd0aCAtIHN0YXJ0VGV4dFdpdGhvdXRTcGFjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZShkZWxldFN0YXJ0LCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLmRlbGV0ZUxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5jb250ZXh0LnZpZXc7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc3RhdGUuc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGRlbGV0ZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVJhbmdlKHN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5Db21tYW5kcyhkZWxldGVSYW5nZSwgam9pbkZvcndhcmQpKHN0YXRlLCBkaXNwYXRjaCwgdmlldyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHN0YXRlLmRvYywgdHIgPSBzdGF0ZS50ciwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0LCBlbmRJbmRleCA9IF9hLmVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKGVuZEluZGV4IDwgZG9jLmNvbnRlbnQuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBkb2MuY2hpbGQoZW5kSW5kZXggKyAxKSwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZSwgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZW5kVG9PZmZzZXQsIGVuZFRvT2Zmc2V0ICsgbm9kZVNpemUpXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdChzdGFydEZyb21PZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IDIoc3RhcnQsIGVuZCB0YWcgbGVuZ3RoKSB0byBpbnNlcnQgcHJldiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQodHIubWFwcGluZy5tYXAoc3RhcnRGcm9tT2Zmc2V0KSAtIDIsIGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCB0ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhcmFncmFwaC5wcm90b3R5cGUubW92ZVVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHRyID0gc3RhdGUudHIsIGRvYyA9IHN0YXRlLmRvYywgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0LCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGRvYy5jaGlsZChzdGFydEluZGV4IC0gMSksIG5vZGVTaXplID0gX2Iubm9kZVNpemUsIHRleHRDb250ZW50ID0gX2IudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlKHN0YXJ0RnJvbU9mZnNldCAtIG5vZGVTaXplLCBzdGFydEZyb21PZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIC5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpXG4gICAgICAgICAgICAgICAgICAgIC5pbnNlcnQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgdGV4dENvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCgpLFxuICAgICAgICAgICAgb3V0ZGVudDogdGhpcy5vdXRkZW50KCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQYXJhZ3JhcGgucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUYWI6IHRoaXMuaW5kZW50KHRydWUpKCksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogdGhpcy5vdXRkZW50KHRydWUpKCksXG4gICAgICAgICAgICAnTW9kLWQnOiB0aGlzLmRlbGV0ZUxpbmVzKCksXG4gICAgICAgICAgICAnTW9kLUQnOiB0aGlzLmRlbGV0ZUxpbmVzKCksXG4gICAgICAgICAgICAnQWx0LUFycm93VXAnOiB0aGlzLm1vdmVVcCgpLFxuICAgICAgICAgICAgJ0FsdC1BcnJvd0Rvd24nOiB0aGlzLm1vdmVEb3duKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gUGFyYWdyYXBoO1xufShOb2RlJDIpKTtcblxudmFyIFRleHQkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGV4dCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGV4dDtcbn0oTm9kZSQyKSk7XG5cbnZhciByZUhlYWRpbmcgPSAvXiN7MSw2fVxccy87XG52YXIgSGVhZGluZyQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEhlYWRpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGluZy5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdoZWFkaW5nJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkaW5nLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IHsgZGVmYXVsdDogMSB9LFxuICAgICAgICAgICAgICAgICAgICBzZVRleHQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IGF0dHJzLmxldmVsLCBzZVRleHQgPSBhdHRycy5zZVRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gXCJoZWFkaW5nfGhlYWRpbmdcIiArIGxldmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8ZGVsaW1pdGVyfHNldGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeC5hcHBseSh2b2lkIDAsIGNsYXNzTmFtZXMuc3BsaXQoJ3wnKSkgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIZWFkaW5nLnByb3RvdHlwZS5jcmVhdGVIZWFkaW5nVGV4dCA9IGZ1bmN0aW9uIChsZXZlbCwgdGV4dCwgY3VySGVhZGluZ1N5bnRheCkge1xuICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSB0ZXh0LnJlcGxhY2UoY3VySGVhZGluZ1N5bnRheCwgJycpLnRyaW0oKTtcbiAgICAgICAgdmFyIGhlYWRpbmdUZXh0ID0gJyc7XG4gICAgICAgIHdoaWxlIChsZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGhlYWRpbmdUZXh0ICs9ICcjJztcbiAgICAgICAgICAgIGxldmVsIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRpbmdUZXh0ICsgXCIgXCIgKyB0ZXh0Q29udGVudDtcbiAgICB9O1xuICAgIEhlYWRpbmcucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHBheWxvYWQubGV2ZWw7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc3RhdGUuc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0LCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleDtcbiAgICAgICAgICAgIHZhciB0ciA9IHJlcGxhY2VUZXh0Tm9kZSh7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgIGZyb206IHN0YXJ0RnJvbU9mZnNldCxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4LFxuICAgICAgICAgICAgICAgIGVuZEluZGV4OiBlbmRJbmRleCxcbiAgICAgICAgICAgICAgICBjcmVhdGVUZXh0OiBmdW5jdGlvbiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZWRIZWFkaW5nID0gdGV4dENvbnRlbnQubWF0Y2gocmVIZWFkaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckhlYWRpbmdTeW50YXggPSBtYXRjaGVkSGVhZGluZyA/IG1hdGNoZWRIZWFkaW5nWzBdIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVIZWFkaW5nVGV4dChsZXZlbCwgdGV4dENvbnRlbnQsIGN1ckhlYWRpbmdTeW50YXgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCB0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBIZWFkaW5nO1xufShNYXJrKSk7XG5cbnZhciBmZW5jZWRDb2RlQmxvY2tTeW50YXggPSAnYGBgJztcbnZhciBDb2RlQmxvY2skMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb2RlQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZUJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlQmxvY2sucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29kZUJsb2NrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlQmxvY2sucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdjb2RlLWJsb2NrJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2RlQmxvY2sucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmFuZ2VJbmZvKHNlbGVjdGlvbiksIHN0YXJ0RnJvbU9mZnNldCA9IF9hLnN0YXJ0RnJvbU9mZnNldCwgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciBmZW5jZWROb2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIGZlbmNlZENvZGVCbG9ja1N5bnRheCk7XG4gICAgICAgICAgICAvLyBhZGQgZmVuY2VkIHN0YXJ0IGJsb2NrXG4gICAgICAgICAgICB0ci5pbnNlcnQoc3RhcnRGcm9tT2Zmc2V0LCBmZW5jZWROb2RlKS5zcGxpdChzdGFydEZyb21PZmZzZXQgKyBmZW5jZWRDb2RlQmxvY2tTeW50YXgubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGFkZCBmZW5jZWQgZW5kIGJsb2NrXG4gICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGZlbmNlZE5vZGUpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgICAgLy8gc3VidHJhY3QgZmVuY2VkIHN5bnRheCBsZW5ndGggYW5kIG9wZW4sIGNsb3NlIHRhZygyKVxuICAgICAgICAgICAgY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpIC0gKGZlbmNlZENvZGVCbG9ja1N5bnRheC5sZW5ndGggKyAyKSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5rZWVwSW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2MsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciB0b2FzdE1hcmsgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyaztcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEZyb21PZmZzZXQgPSBfYi5zdGFydEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2IuZW5kVG9PZmZzZXQsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXgsIGZyb20gPSBfYi5mcm9tLCB0byA9IF9iLnRvO1xuICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQoZG9jLCBlbmRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8gJiYgdGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSB0ZXh0Q29udGVudC5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gdG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUoZW5kSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb2RlQmxvY2tOb2RlKG1kTm9kZSkgJiYgbWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhY2VzID0gbWF0Y2hlZFswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWNlZFRleHQgPSB0ZXh0Q29udGVudC5zbGljZSh0byAtIHN0YXJ0RnJvbU9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHNwYWNlcyArIHNsaWNlZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdEFuZEV4dGVuZEJsb2NrKHRyLCBlbmRUb09mZnNldCwgc2xpY2VkVGV4dCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZUJsb2NrQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1wJzogY29kZUJsb2NrQ29tbWFuZCxcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtUCc6IGNvZGVCbG9ja0NvbW1hbmQsXG4gICAgICAgICAgICBFbnRlcjogdGhpcy5rZWVwSW5kZW50YXRpb24oKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2RlQmxvY2s7XG59KE1hcmspKTtcblxudmFyIHJlRW1wdHlUYWJsZSA9IC9cXHx8XFxzL2c7XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUhlYWRlcihjb2x1bW5Db3VudCkge1xuICAgIHJldHVybiBbY3JlYXRlVGFibGVSb3coY29sdW1uQ291bnQpLCBjcmVhdGVUYWJsZVJvdyhjb2x1bW5Db3VudCwgdHJ1ZSldO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVCb2R5JDEoY29sdW1uQ291bnQsIHJvd0NvdW50KSB7XG4gICAgdmFyIGJvZHlSb3dzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGJvZHlSb3dzLnB1c2goY3JlYXRlVGFibGVSb3coY29sdW1uQ291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHlSb3dzO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVSb3coY29sdW1uQ291bnQsIGRlbGltKSB7XG4gICAgdmFyIHJvdyA9ICd8JztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgcm93ICs9IGRlbGltID8gJyAtLS0gfCcgOiAnICB8JztcbiAgICB9XG4gICAgcmV0dXJuIHJvdztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhcmdldFR5cGVzKG1vdmVOZXh0KSB7XG4gICAgcmV0dXJuIG1vdmVOZXh0XG4gICAgICAgID8geyB0eXBlOiAnbmV4dCcsIHBhcmVudFR5cGU6ICd0YWJsZUhlYWQnLCBjaGlsZFR5cGU6ICdmaXJzdENoaWxkJyB9XG4gICAgICAgIDogeyB0eXBlOiAncHJldicsIHBhcmVudFR5cGU6ICd0YWJsZUJvZHknLCBjaGlsZFR5cGU6ICdsYXN0Q2hpbGQnIH07XG59XG52YXIgVGFibGUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgndGFibGUnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRhYmxlLnByb3RvdHlwZS5leHRlbmRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIGRvYyA9IF9hLmRvYywgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgZW5kRnJvbU9mZnNldCA9IF9iLmVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0ID0gX2IuZW5kVG9PZmZzZXQsIGVuZEluZGV4ID0gX2IuZW5kSW5kZXgsIHRvID0gX2IudG87XG4gICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChkb2MsIGVuZEluZGV4KTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDFgIHRvIGxpbmUgZm9yIHRoZSBtYXJrZG93biBwYXJzZXJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyBgMWAobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgIHZhciBtZFBvcyA9IFtlbmRJbmRleCArIDEsIHRvIC0gZW5kRnJvbU9mZnNldCArIDFdO1xuICAgICAgICAgICAgdmFyIG1kTm9kZSA9IF90aGlzLmNvbnRleHQudG9hc3RNYXJrLmZpbmROb2RlQXRQb3NpdGlvbihtZFBvcyk7XG4gICAgICAgICAgICB2YXIgY2VsbE5vZGUgPSBmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1RhYmxlQ2VsbE5vZGUobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKG5vZGUucGFyZW50LnR5cGUgPT09ICd0YWJsZURlbGltUm93JyB8fCBub2RlLnBhcmVudC5wYXJlbnQudHlwZSA9PT0gJ3RhYmxlQm9keScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNFbXB0eSA9ICF0ZXh0Q29udGVudC5yZXBsYWNlKHJlRW1wdHlUYWJsZSwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBjZWxsTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gcGFyZW50XzEucGFyZW50LnBhcmVudC5jb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gY3JlYXRlVGFibGVSb3coY29sdW1uQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGVuZEZyb21PZmZzZXQsIGVuZFRvT2Zmc2V0KS5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChlbmRUb09mZnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnNlcnQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgcm93KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBzdWJ0cmFjdCBgMmAgdG8gc2VsZWN0aW9uIGVuZCBwb3NpdGlvbiBjb25zaWRlcmluZyBgIHxgIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpIC0gMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUubW92ZVRhYmxlQ2VsbCA9IGZ1bmN0aW9uIChtb3ZlTmV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBlbmRGcm9tT2Zmc2V0ID0gX2IuZW5kRnJvbU9mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgdG8gPSBfYi50bztcbiAgICAgICAgICAgIHZhciBtZFBvcyA9IFtlbmRJbmRleCArIDEsIHRvIC0gZW5kRnJvbU9mZnNldF07XG4gICAgICAgICAgICB2YXIgbWROb2RlID0gX3RoaXMuY29udGV4dC50b2FzdE1hcmsuZmluZE5vZGVBdFBvc2l0aW9uKG1kUG9zKTtcbiAgICAgICAgICAgIHZhciBjZWxsTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBpc1RhYmxlQ2VsbE5vZGUobm9kZSk7IH0pO1xuICAgICAgICAgICAgaWYgKGNlbGxOb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudF8yID0gY2VsbE5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IGNyZWF0ZVRhcmdldFR5cGVzKG1vdmVOZXh0KSwgdHlwZSA9IF9jLnR5cGUsIHBhcmVudFR5cGUgPSBfYy5wYXJlbnRUeXBlLCBjaGlsZFR5cGUgPSBfYy5jaGlsZFR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGNoT2Zmc2V0ID0gZ2V0TWRFbmRDaChjZWxsTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxOb2RlW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoT2Zmc2V0ID0gZ2V0TWRFbmRDaChjZWxsTm9kZVt0eXBlXSkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9ICFwYXJlbnRfMlt0eXBlXSAmJiBwYXJlbnRfMi5wYXJlbnQudHlwZSA9PT0gcGFyZW50VHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJlbnRfMi5wYXJlbnRbdHlwZV1bY2hpbGRUeXBlXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnRfMlt0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICduZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbmV4dCByb3csIHRoZSBiYXNlIG9mZnNldCB3b3VsZCBiZSBlbmQgcG9zaXRpb24gb2YgdGhlIG5leHQgcm93J3MgZmlyc3QgY2hpbGQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBiYXNlIG9mZnNldCBpcyB6ZXJvLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VPZmZzZXQgPSByb3cgPyBnZXRNZEVuZENoKHJvd1tjaGlsZFR5cGVdKSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGFnKG9wZW4sIGNsb3NlKSBwb3NpdGlvbignMicpIGZvciBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoT2Zmc2V0ICs9IGJhc2VPZmZzZXQgKyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdwcmV2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgcHJldiByb3csIHRoZSB0YXJnZXQgcG9zaXRpb24gd291bGQgYmUgJy00JyBmb3IgY2FsY3VsYXRpbmcgJyB8JyBjaGFyYWN0ZXJzIGFuZCB0YWcob3BlbiwgY2xvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB0YXJnZXQgcG9zaXRpb24gaXMgemVyby5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoT2Zmc2V0ID0gcm93ID8gLTQgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBlbmRGcm9tT2Zmc2V0ICsgY2hPZmZzZXQpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuYWRkVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9iID0gcGF5bG9hZCwgY29sdW1uQ291bnQgPSBfYi5jb2x1bW5Db3VudCwgcm93Q291bnQgPSBfYi5yb3dDb3VudDtcbiAgICAgICAgICAgIHZhciBlbmRUb09mZnNldCA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGhlYWRlclJvd3MgPSBjcmVhdGVUYWJsZUhlYWRlcihjb2x1bW5Db3VudCk7XG4gICAgICAgICAgICB2YXIgYm9keVJvd3MgPSBjcmVhdGVUYWJsZUJvZHkkMShjb2x1bW5Db3VudCwgcm93Q291bnQgLSAxKTtcbiAgICAgICAgICAgIHZhciByb3dzID0gX19zcHJlYWRBcnJheSQxKF9fc3ByZWFkQXJyYXkkMShbXSwgaGVhZGVyUm93cyksIGJvZHlSb3dzKTtcbiAgICAgICAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKS5pbnNlcnQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpLCBjcmVhdGVUZXh0Tm9kZSQxKHNjaGVtYSwgcm93KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDRgIHRvIHNlbGVjdGlvbiBwb3NpdGlvbiBjb25zaWRlcmluZyBgfCBgIHRleHQgYW5kIHN0YXJ0IGJsb2NrIHRhZyBsZW5ndGhcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBlbmRUb09mZnNldCArIDQpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgYWRkVGFibGU6IHRoaXMuYWRkVGFibGUoKSB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFbnRlcjogdGhpcy5leHRlbmRUYWJsZSgpLFxuICAgICAgICAgICAgVGFiOiB0aGlzLm1vdmVUYWJsZUNlbGwodHJ1ZSksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogdGhpcy5tb3ZlVGFibGVDZWxsKGZhbHNlKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZTtcbn0oTWFyaykpO1xuXG52YXIgdGhlbWF0aWNCcmVha1N5bnRheCA9ICcqKionO1xudmFyIFRoZW1hdGljQnJlYWskMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUaGVtYXRpY0JyZWFrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRoZW1hdGljQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRoZW1hdGljQnJlYWsucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGhlbWF0aWNCcmVhayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGhlbWF0aWNCcmVhay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ3RoZW1hdGljLWJyZWFrJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5ociA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBmcm9tID0gX2EuZnJvbSwgdG8gPSBfYS50bywgZW5kVG9PZmZzZXQgPSBfYS5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHRoZW1hdGljQnJlYWtTeW50YXgpO1xuICAgICAgICAgICAgdHJcbiAgICAgICAgICAgICAgICAuc3BsaXQoZnJvbSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZVdpdGgodHIubWFwcGluZy5tYXAoZnJvbSksIHRyLm1hcHBpbmcubWFwKHRvKSwgbm9kZSlcbiAgICAgICAgICAgICAgICAuc3BsaXQodHIubWFwcGluZy5tYXAodG8pKS5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBocjogdGhpcy5ocigpIH07XG4gICAgfTtcbiAgICBUaGVtYXRpY0JyZWFrLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZUNvbW1hbmQgPSB0aGlzLmhyKCkoKTtcbiAgICAgICAgcmV0dXJuIHsgJ01vZC1sJzogbGluZUNvbW1hbmQsICdNb2QtTCc6IGxpbmVDb21tYW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gVGhlbWF0aWNCcmVhaztcbn0oTWFyaykpO1xuXG5mdW5jdGlvbiBjYW5ub3RCZUxpc3ROb2RlKF9hLCBsaW5lKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlLCBzb3VyY2Vwb3MgPSBfYS5zb3VyY2Vwb3M7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgdmFyIHN0YXJ0TGluZSA9IHNvdXJjZXBvc1swXVswXTtcbiAgICByZXR1cm4gbGluZSA8PSBzdGFydExpbmUgJiYgKHR5cGUgPT09ICdjb2RlQmxvY2snIHx8IHR5cGUgPT09ICdoZWFkaW5nJyB8fCB0eXBlLm1hdGNoKCd0YWJsZScpKTtcbn1cbnZhciBMaXN0SXRlbSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKExpc3RJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3RJdGVtKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0SXRlbS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdsaXN0SXRlbSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlzdEl0ZW0ucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICBvZGQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbjogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBsaXN0U3R5bGU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZGQgPSBhdHRycy5vZGQsIGV2ZW4gPSBhdHRycy5ldmVuLCBsaXN0U3R5bGUgPSBhdHRycy5saXN0U3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gJ2xpc3QtaXRlbSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaXN0LWl0ZW0tc3R5bGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xsaXN0LWl0ZW0tb2RkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGxpc3QtaXRlbS1ldmVuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4LmFwcGx5KHZvaWQgMCwgY2xhc3NOYW1lcy5zcGxpdCgnfCcpKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5leHRlbmRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgZG9jID0gX2EuZG9jLCBzY2hlbWEgPSBfYS5zY2hlbWEsIHRyID0gX2EudHI7XG4gICAgICAgICAgICB2YXIgdG9hc3RNYXJrID0gX3RoaXMuY29udGV4dC50b2FzdE1hcms7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgdG8gPSBfYi50bywgc3RhcnRGcm9tT2Zmc2V0ID0gX2Iuc3RhcnRGcm9tT2Zmc2V0LCBlbmRGcm9tT2Zmc2V0ID0gX2IuZW5kRnJvbU9mZnNldCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleCwgZW5kVG9PZmZzZXQgPSBfYi5lbmRUb09mZnNldDtcbiAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGRvYywgZW5kSW5kZXgpO1xuICAgICAgICAgICAgdmFyIGlzTGlzdCA9IHJlTGlzdC50ZXN0KHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIGlmICghaXNMaXN0IHx8IHNlbGVjdGlvbi5mcm9tID09PSBzdGFydEZyb21PZmZzZXQgfHwgIXNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0VtcHR5ID0gIXRleHRDb250ZW50LnJlcGxhY2UocmVDYW5CZVRhc2tMaXN0LCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVSYW5nZShlbmRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCkuc3BsaXQodHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb21tYW5kVHlwZSA9IGdldExpc3RUeXBlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWRkIGAxYCB0byBsaW5lIGZvciB0aGUgbWFya2Rvd24gcGFyc2VyXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBtYXJrZG93biBwYXJzZXIgaGFzIGAxYChub3QgemVybykgYXMgdGhlIHN0YXJ0IG51bWJlclxuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShlbmRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBzbGljZWRUZXh0ID0gdGV4dENvbnRlbnQuc2xpY2UodG8gLSBlbmRGcm9tT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHsgdG9hc3RNYXJrOiB0b2FzdE1hcmssIG1kTm9kZTogbWROb2RlLCBkb2M6IGRvYywgbGluZTogZW5kSW5kZXggKyAxIH07XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gZXh0ZW5kTGlzdFtjb21tYW5kVHlwZV0oY29udGV4dCksIGxpc3RTeW50YXggPSBfYy5saXN0U3ludGF4LCBjaGFuZ2VkUmVzdWx0cyA9IF9jLmNoYW5nZWRSZXN1bHRzO1xuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBvcmRpbmFsIG51bWJlciBvZiBiYWNrd2FyZCBvcmRlcmVkIGxpc3RcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZFJlc3VsdHMgPT09IG51bGwgfHwgY2hhbmdlZFJlc3VsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5nZWRSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgdHIuc3BsaXQodG8pO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgZmlyc3Qgb3JkZXJlZCBsaXN0IGluZm9cbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZFJlc3VsdHMudW5zaGlmdCh7IHRleHQ6IGxpc3RTeW50YXggKyBzbGljZWRUZXh0LCBsaW5lOiBlbmRJbmRleCArIDEgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVRvTGlzdFBlckxpbmUodHIsIGNoYW5nZWRSZXN1bHRzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1YnRyYWN0IDEgYmVjYXVzZSB0aGUgbGluZSBoYXMgaW5jcmVhc2VkIHRocm91Z2ggJ3NwbGl0JyBjb21tYW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lOiBjaGFuZ2VkUmVzdWx0c1swXS5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTGluZTogbGFzdCQxKGNoYW5nZWRSZXN1bHRzKS5saW5lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSAtIHNsaWNlZFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgcG9zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBsaXN0U3ludGF4ICsgc2xpY2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0QW5kRXh0ZW5kQmxvY2sodHIsIGVuZFRvT2Zmc2V0LCBzbGljZWRUZXh0LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS50b0xpc3QgPSBmdW5jdGlvbiAoY29tbWFuZFR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSBfYS5kb2MsIHRyID0gX2EudHIsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciB0b2FzdE1hcmsgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyaztcbiAgICAgICAgICAgIHZhciByYW5nZUluZm8gPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBhZGQgYDFgIHRvIGxpbmUgZm9yIHRoZSBtYXJrZG93biBwYXJzZXJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgbWFya2Rvd24gcGFyc2VyIGhhcyBgMWAobm90IHplcm8pIGFzIHRoZSBzdGFydCBudW1iZXJcbiAgICAgICAgICAgIHZhciBzdGFydExpbmUgPSByYW5nZUluZm8uc3RhcnRJbmRleCArIDE7XG4gICAgICAgICAgICB2YXIgZW5kTGluZSA9IHJhbmdlSW5mby5lbmRJbmRleCArIDE7XG4gICAgICAgICAgICB2YXIgZW5kVG9PZmZzZXQgPSByYW5nZUluZm8uZW5kVG9PZmZzZXQ7XG4gICAgICAgICAgICB2YXIgc2tpcExpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBsaW5lID0gc3RhcnRMaW5lOyBsaW5lIDw9IGVuZExpbmU7IGxpbmUgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZEZpcnN0Tm9kZUF0TGluZShsaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAobWROb2RlICYmIGNhbm5vdEJlTGlzdE5vZGUobWROb2RlLCBsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdG8gc2tpcCB1bm5lY2Vzc2FyeSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgaWYgKHNraXBMaW5lcy5pbmRleE9mKGxpbmUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7IHRvYXN0TWFyazogdG9hc3RNYXJrLCBtZE5vZGU6IG1kTm9kZSwgZG9jOiBkb2MsIGxpbmU6IGxpbmUsIHN0YXJ0TGluZTogc3RhcnRMaW5lIH07XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRSZXN1bHRzID0gKGlzTGlzdE5vZGUkMShtZE5vZGUpXG4gICAgICAgICAgICAgICAgICAgID8gb3RoZXJMaXN0VG9MaXN0W2NvbW1hbmRUeXBlXShjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICA6IG90aGVyTm9kZVRvTGlzdFtjb21tYW5kVHlwZV0oY29udGV4dCkpLmNoYW5nZWRSZXN1bHRzO1xuICAgICAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBfdGhpcy5jaGFuZ2VUb0xpc3RQZXJMaW5lKHRyLCBjaGFuZ2VkUmVzdWx0cywge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgY2hhbmdlZFJlc3VsdHNbMF0ubGluZSAtIDEpLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydExpbmU6IGNoYW5nZWRSZXN1bHRzWzBdLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGVuZExpbmU6IGxhc3QkMShjaGFuZ2VkUmVzdWx0cykubGluZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhEaWZmOiAxLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVuZFRvT2Zmc2V0ID0gTWF0aC5tYXgoZW5kT2Zmc2V0LCBlbmRUb09mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBMaW5lcyA9IHNraXBMaW5lcy5jb25jYXQoY2hhbmdlZFJlc3VsdHMubWFwKGZ1bmN0aW9uIChpbmZvKSB7IHJldHVybiBpbmZvLmxpbmU7IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgdHIubWFwcGluZy5tYXAoZW5kVG9PZmZzZXQpKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUuY2hhbmdlVG9MaXN0UGVyTGluZSA9IGZ1bmN0aW9uICh0ciwgY2hhbmdlZFJlc3VsdHMsIF9hKSB7XG4gICAgICAgIHZhciBmcm9tID0gX2EuZnJvbSwgc3RhcnRMaW5lID0gX2Euc3RhcnRMaW5lLCBlbmRMaW5lID0gX2EuZW5kTGluZSwgX2IgPSBfYS5pbmRleERpZmYsIGluZGV4RGlmZiA9IF9iID09PSB2b2lkIDAgPyAwIDogX2I7XG4gICAgICAgIHZhciBtYXhFbmRPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSB0ci5kb2MuY2hpbGQoaSksIG5vZGVTaXplID0gX2Mubm9kZVNpemUsIGNvbnRlbnQgPSBfYy5jb250ZW50O1xuICAgICAgICAgICAgdmFyIG1hcHBlZEZyb20gPSB0ci5tYXBwaW5nLm1hcChmcm9tKTtcbiAgICAgICAgICAgIHZhciBtYXBwZWRUbyA9IG1hcHBlZEZyb20gKyBjb250ZW50LnNpemU7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZFJlc3VsdCA9IGNoYW5nZWRSZXN1bHRzLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQubGluZSAtIGluZGV4RGlmZiA9PT0gaTsgfSlbMF07XG4gICAgICAgICAgICBpZiAoY2hhbmdlZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hcHBlZEZyb20sIG1hcHBlZFRvLCBjcmVhdGVUZXh0Tm9kZSQxKHRoaXNfMS5jb250ZXh0LnNjaGVtYSwgY2hhbmdlZFJlc3VsdC50ZXh0KSk7XG4gICAgICAgICAgICAgICAgbWF4RW5kT2Zmc2V0ID0gTWF0aC5tYXgobWF4RW5kT2Zmc2V0LCBmcm9tICsgY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb20gKz0gbm9kZVNpemU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lIC0gaW5kZXhEaWZmOyBpIDw9IGVuZExpbmUgLSBpbmRleERpZmY7IGkgKz0gMSkge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4RW5kT2Zmc2V0O1xuICAgIH07XG4gICAgTGlzdEl0ZW0ucHJvdG90eXBlLnRvZ2dsZVRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2MsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciB0b2FzdE1hcmsgPSBfdGhpcy5jb250ZXh0LnRvYXN0TWFyaztcbiAgICAgICAgICAgIHZhciBfYiA9IGdldFJhbmdlSW5mbyhzZWxlY3Rpb24pLCBzdGFydEluZGV4ID0gX2Iuc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYi5lbmRJbmRleDtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8PSBlbmRJbmRleDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IHRvYXN0TWFyay5maW5kRmlyc3ROb2RlQXRMaW5lKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaXN0Tm9kZSQxKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gbWROb2RlLmxpc3REYXRhLCBjaGVja2VkID0gX2MuY2hlY2tlZCwgcGFkZGluZyA9IF9jLnBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZUNoYXIgPSBjaGVja2VkID8gJyAnIDogJ3gnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWRQb3MgPSBtZE5vZGUuc291cmNlcG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBnZXROb2RlQ29udGVudE9mZnNldFJhbmdlKGRvYywgbWRQb3NbMF0gLSAxKS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQgKz0gbWRQb3NbMV0gKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICBuZXdUciA9IHRyLnJlcGxhY2VXaXRoKHN0YXJ0T2Zmc2V0LCBzdGFydE9mZnNldCArIDEsIHNjaGVtYS50ZXh0KHN0YXRlQ2hhcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdUcikge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1bGxldExpc3Q6IHRoaXMudG9MaXN0KCdidWxsZXQnKSxcbiAgICAgICAgICAgIG9yZGVyZWRMaXN0OiB0aGlzLnRvTGlzdCgnb3JkZXJlZCcpLFxuICAgICAgICAgICAgdGFza0xpc3Q6IHRoaXMudG9MaXN0KCd0YXNrJyksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1bGxldENvbW1hbmQgPSB0aGlzLnRvTGlzdCgnYnVsbGV0JykoKTtcbiAgICAgICAgdmFyIG9yZGVyZWRDb21tYW5kID0gdGhpcy50b0xpc3QoJ29yZGVyZWQnKSgpO1xuICAgICAgICB2YXIgdGFza0NvbW1hbmQgPSB0aGlzLnRvTGlzdCgndGFzaycpKCk7XG4gICAgICAgIHZhciB0b2dsZVRhc2tDb21tYW5kID0gdGhpcy50b2dnbGVUYXNrKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLXUnOiBidWxsZXRDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1VJzogYnVsbGV0Q29tbWFuZCxcbiAgICAgICAgICAgICdNb2Qtbyc6IG9yZGVyZWRDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1PJzogb3JkZXJlZENvbW1hbmQsXG4gICAgICAgICAgICAnYWx0LXQnOiB0YXNrQ29tbWFuZCxcbiAgICAgICAgICAgICdhbHQtVCc6IHRhc2tDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LUN0cmwteCc6IHRvZ2xlVGFza0NvbW1hbmQsXG4gICAgICAgICAgICAnU2hpZnQtQ3RybC1YJzogdG9nbGVUYXNrQ29tbWFuZCxcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmV4dGVuZExpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaXN0SXRlbTtcbn0oTWFyaykpO1xuXG5mdW5jdGlvbiB0b2dnbGVNYXJrKGNvbmRpdGlvbiwgc3ludGF4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gX2EudHIsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGNvbmRpdGlvbkZuID0gIWlzRnVuY3Rpb25fMShjb25kaXRpb24pXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBjb25kaXRpb24udGVzdCh0ZXh0KTsgfVxuICAgICAgICAgICAgOiBjb25kaXRpb247XG4gICAgICAgIHZhciBzeW50YXhMZW4gPSBzeW50YXgubGVuZ3RoO1xuICAgICAgICB2YXIgZG9jID0gdHIuZG9jO1xuICAgICAgICB2YXIgX2IgPSByZXNvbHZlU2VsZWN0aW9uUG9zKHNlbGVjdGlvbiksIGZyb20gPSBfYlswXSwgdG8gPSBfYlsxXTtcbiAgICAgICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChmcm9tIC0gc3ludGF4TGVuLCAxKTtcbiAgICAgICAgdmFyIG5leHRQb3MgPSBNYXRoLm1pbih0byArIHN5bnRheExlbiwgZG9jLmNvbnRlbnQuc2l6ZSAtIDEpO1xuICAgICAgICB2YXIgc2xpY2UgPSBzZWxlY3Rpb24uY29udGVudCgpO1xuICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBzbGljZS5jb250ZW50LnRleHRCZXR3ZWVuKDAsIHNsaWNlLmNvbnRlbnQuc2l6ZSwgJ1xcbicpO1xuICAgICAgICB2YXIgcHJldlRleHQgPSBkb2MudGV4dEJldHdlZW4ocHJldlBvcywgZnJvbSwgJ1xcbicpO1xuICAgICAgICB2YXIgbmV4dFRleHQgPSBkb2MudGV4dEJldHdlZW4odG8sIG5leHRQb3MsICdcXG4nKTtcbiAgICAgICAgdGV4dENvbnRlbnQgPSBcIlwiICsgcHJldlRleHQgKyB0ZXh0Q29udGVudCArIG5leHRUZXh0O1xuICAgICAgICBpZiAocHJldlRleHQgJiYgbmV4dFRleHQgJiYgY29uZGl0aW9uRm4odGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICB0ci5kZWxldGUobmV4dFBvcyAtIHN5bnRheExlbiwgbmV4dFBvcykuZGVsZXRlKHByZXZQb3MsIHByZXZQb3MgKyBzeW50YXhMZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dChzeW50YXgsIHRvKS5pbnNlcnRUZXh0KHN5bnRheCwgZnJvbSk7XG4gICAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmVtcHR5XG4gICAgICAgICAgICAgICAgPyBjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBmcm9tICsgc3ludGF4TGVuKVxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZnJvbSArIHN5bnRheExlbiwgdG8gKyBzeW50YXhMZW4pO1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9OyB9O1xufVxuXG52YXIgcmVTdHJvbmcgPSAvXihcXCp7Mn18X3syfSkuKihbXFxzXFxTXSopXFwxJC9tO1xudmFyIHN0cm9uZ1N5bnRheCA9ICcqKic7XG52YXIgU3Ryb25nJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoU3Ryb25nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cm9uZygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Ryb25nLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cm9uZyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3Ryb25nLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnc3Ryb25nJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJvbmcucHJvdG90eXBlLmJvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b2dnbGVNYXJrKHJlU3Ryb25nLCBzdHJvbmdTeW50YXgpO1xuICAgIH07XG4gICAgU3Ryb25nLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9sZDogdGhpcy5ib2xkKCkgfTtcbiAgICB9O1xuICAgIFN0cm9uZy5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvbGRDb21tYW5kID0gdGhpcy5ib2xkKCkoKTtcbiAgICAgICAgcmV0dXJuIHsgJ01vZC1iJzogYm9sZENvbW1hbmQsICdNb2QtQic6IGJvbGRDb21tYW5kIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3Ryb25nO1xufShNYXJrKSk7XG5cbnZhciByZVN0cmlrZSA9IC9eKH57Mn0pLiooW1xcc1xcU10qKVxcMSQvbTtcbnZhciBzdHJpa2VTeW50YXggPSAnfn4nO1xudmFyIFN0cmlrZSQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFN0cmlrZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJpa2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmlrZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdzdHJpa2UnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmlrZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ3N0cmlrZScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RyaWtlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmsocmVTdHJpa2UsIHN0cmlrZVN5bnRheCk7XG4gICAgfTtcbiAgICBTdHJpa2UucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJpa2VDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7ICdNb2Qtcyc6IHN0cmlrZUNvbW1hbmQsICdNb2QtUyc6IHN0cmlrZUNvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpa2U7XG59KE1hcmspKTtcblxudmFyIHJlRW1waCA9IC9eKFxcKnxfKS4qKFtcXHNcXFNdKilcXDEkL207XG52YXIgZW1waFN5bnRheCA9ICcqJztcbnZhciBFbXBoJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRW1waCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXBoKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbXBoLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2VtcGgnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtcGgucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdlbXBoJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbXBoLnByb3RvdHlwZS5pdGFsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0b2dnbGVNYXJrKHJlRW1waCwgZW1waFN5bnRheCk7XG4gICAgfTtcbiAgICBFbXBoLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgaXRhbGljOiB0aGlzLml0YWxpYygpIH07XG4gICAgfTtcbiAgICBFbXBoLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRhbGljQ29tbWFuZCA9IHRoaXMuaXRhbGljKCkoKTtcbiAgICAgICAgcmV0dXJuIHsgJ01vZC1pJzogaXRhbGljQ29tbWFuZCwgJ01vZC1JJzogaXRhbGljQ29tbWFuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIEVtcGg7XG59KE1hcmspKTtcblxudmFyIHJlQ29kZSA9IC9eKGApLiooW1xcc1xcU10qKVxcMSQvbTtcbnZhciBjb2RlU3ludGF4ID0gJ2AnO1xudmFyIENvZGUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29kZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29kZS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICBtYXJrZWQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAobWFyaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBtYXJrLmF0dHJzLCBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQsIG1hcmtlZCA9IF9hLm1hcmtlZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAnY29kZSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGRlbGltaXRlcnxzdGFydCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcyArPSAnfGRlbGltaXRlcnxlbmQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMgKz0gJ3xtYXJrZWQtdGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeC5hcHBseSh2b2lkIDAsIGNsYXNzTmFtZXMuc3BsaXQoJ3wnKSkgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2RlLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvZ2dsZU1hcmsocmVDb2RlLCBjb2RlU3ludGF4KTtcbiAgICB9O1xuICAgIENvZGUucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2RlQ29tbWFuZCA9IHRoaXMuY29tbWFuZHMoKSgpO1xuICAgICAgICByZXR1cm4geyAnU2hpZnQtTW9kLWMnOiBjb2RlQ29tbWFuZCwgJ1NoaWZ0LU1vZC1DJzogY29kZUNvbW1hbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBDb2RlO1xufShNYXJrKSk7XG5cbnZhciBMaW5rJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpbmsnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmsucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGF0dHJzLnVybCwgZGVzYyA9IGF0dHJzLmRlc2M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gJ2xpbmsnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bGluay11cmx8bWFya2VkLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzICs9ICd8bGluay1kZXNjfG1hcmtlZC10ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4LmFwcGx5KHZvaWQgMCwgY2xhc3NOYW1lcy5zcGxpdCgnfCcpKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExpbmsucHJvdG90eXBlLmFkZExpbmtPckltYWdlID0gZnVuY3Rpb24gKGNvbW1hbmRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50ciwgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICAgICAgdmFyIF9iID0gcmVzb2x2ZVNlbGVjdGlvblBvcyhzZWxlY3Rpb24pLCBmcm9tID0gX2JbMF0sIHRvID0gX2JbMV07XG4gICAgICAgICAgICB2YXIgX2MgPSBwYXlsb2FkLCBsaW5rVGV4dCA9IF9jLmxpbmtUZXh0LCBhbHRUZXh0ID0gX2MuYWx0VGV4dCwgbGlua1VybCA9IF9jLmxpbmtVcmwsIGltYWdlVXJsID0gX2MuaW1hZ2VVcmw7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGxpbmtUZXh0O1xuICAgICAgICAgICAgdmFyIHVybCA9IGxpbmtVcmw7XG4gICAgICAgICAgICB2YXIgc3ludGF4ID0gJyc7XG4gICAgICAgICAgICBpZiAoY29tbWFuZFR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gYWx0VGV4dDtcbiAgICAgICAgICAgICAgICB1cmwgPSBpbWFnZVVybDtcbiAgICAgICAgICAgICAgICBzeW50YXggPSAnISc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gZXNjYXBlVGV4dEZvckxpbmsodGV4dCk7XG4gICAgICAgICAgICBzeW50YXggKz0gXCJbXCIgKyB0ZXh0ICsgXCJdKFwiICsgdXJsICsgXCIpXCI7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgY3JlYXRlVGV4dE5vZGUkMShzY2hlbWEsIHN5bnRheCkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRJbWFnZTogdGhpcy5hZGRMaW5rT3JJbWFnZSgnaW1hZ2UnKSxcbiAgICAgICAgICAgIGFkZExpbms6IHRoaXMuYWRkTGlua09ySW1hZ2UoJ2xpbmsnKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rO1xufShNYXJrKSk7XG5cbnZhciBUYXNrRGVsaW1pdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhc2tEZWxpbWl0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFza0RlbGltaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFza0RlbGltaXRlci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YXNrRGVsaW1pdGVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYXNrRGVsaW1pdGVyLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnZGVsaW1pdGVyJywgJ2xpc3QtaXRlbScpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhc2tEZWxpbWl0ZXI7XG59KE1hcmspKTtcbnZhciBEZWxpbWl0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoRGVsaW1pdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlbGltaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVsaW1pdGVyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RlbGltaXRlcic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVsaW1pdGVyLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnZGVsaW1pdGVyJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRGVsaW1pdGVyO1xufShNYXJrKSk7XG52YXIgTWV0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShNZXRhLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1ldGEoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ldGEucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWV0YSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWV0YS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ21ldGEnKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBNZXRhO1xufShNYXJrKSk7XG52YXIgTWFya2VkVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShNYXJrZWRUZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcmtlZFRleHQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcmtlZFRleHQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFya2VkVGV4dCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFya2VkVGV4dC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7IGNsYXNzOiBjbHNXaXRoTWRQcmVmaXgoJ21hcmtlZC10ZXh0JykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTWFya2VkVGV4dDtcbn0oTWFyaykpO1xudmFyIFRhYmxlQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZUNlbGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUNlbGwucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVDZWxsJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUNlbGwucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCd0YWJsZS1jZWxsJykgfSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVGFibGVDZWxsO1xufShNYXJrKSk7XG5cbnZhciBIdG1sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEh0bWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHRtbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdodG1sJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIdG1sLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIHsgY2xhc3M6IGNsc1dpdGhNZFByZWZpeCgnaHRtbCcpIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEh0bWw7XG59KE1hcmspKTtcblxudmFyIGN1c3RvbUJsb2NrU3ludGF4ID0gJyQkJztcbnZhciBDdXN0b21CbG9jayQxID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEN1c3RvbUJsb2NrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21CbG9jay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjdXN0b21CbG9jayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQmxvY2sucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydzcGFuJywgeyBjbGFzczogY2xzV2l0aE1kUHJlZml4KCdjdXN0b20tYmxvY2snKSB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEN1c3RvbUJsb2NrLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRGcm9tT2Zmc2V0ID0gX2Euc3RhcnRGcm9tT2Zmc2V0LCBlbmRUb09mZnNldCA9IF9hLmVuZFRvT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCEocGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLmluZm8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1c3RvbUJsb2NrID0gXCJcIiArIGN1c3RvbUJsb2NrU3ludGF4ICsgcGF5bG9hZC5pbmZvO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBjdXN0b21CbG9jayk7XG4gICAgICAgICAgICB2YXIgZW5kTm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBjdXN0b21CbG9ja1N5bnRheCk7XG4gICAgICAgICAgICB0ci5pbnNlcnQoc3RhcnRGcm9tT2Zmc2V0LCBzdGFydE5vZGUpLnNwbGl0KHN0YXJ0RnJvbU9mZnNldCArIGN1c3RvbUJsb2NrLmxlbmd0aCk7XG4gICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCkpLmluc2VydCh0ci5tYXBwaW5nLm1hcChlbmRUb09mZnNldCksIGVuZE5vZGUpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2V0U2VsZWN0aW9uKGNyZWF0ZVRleHRTZWxlY3Rpb24odHIsIHRyLm1hcHBpbmcubWFwKGVuZFRvT2Zmc2V0KSAtIChjdXN0b21CbG9ja1N5bnRheC5sZW5ndGggKyAyKSkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbUJsb2NrO1xufShNYXJrKSk7XG5cbnZhciByZVRhc2tNYXJrZXJLZXkgPSAveHxiYWNrc3BhY2UvaTtcbnZhciByZVRhc2tNYXJrZXIgPSAvXlxcWyhcXHMqKSh4PykoXFxzKilcXF0oPzpcXHMrKS9pO1xuZnVuY3Rpb24gc21hcnRUYXNrKF9hKSB7XG4gICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYSwgdG9hc3RNYXJrID0gX2EudG9hc3RNYXJrO1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGtleXVwOiBmdW5jdGlvbiAodmlldywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSB2aWV3LnN0YXRlLCBkb2MgPSBfYi5kb2MsIHRyID0gX2IudHIsIHNlbGVjdGlvbiA9IF9iLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSAmJiByZVRhc2tNYXJrZXJLZXkudGVzdChldi5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2MgPSBnZXRSYW5nZUluZm8oc2VsZWN0aW9uKSwgc3RhcnRJbmRleCA9IF9jLnN0YXJ0SW5kZXgsIHN0YXJ0RnJvbU9mZnNldCA9IF9jLnN0YXJ0RnJvbU9mZnNldCwgZnJvbSA9IF9jLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWRkIGAxYCB0byBsaW5lIGZvciB0aGUgbWFya2Rvd24gcGFyc2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIG1hcmtkb3duIHBhcnNlciBoYXMgYDFgKG5vdCB6ZXJvKSBhcyB0aGUgc3RhcnQgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWRQb3MgPSBbc3RhcnRJbmRleCArIDEsIGZyb20gLSBzdGFydEZyb21PZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0b2FzdE1hcmsuZmluZE5vZGVBdFBvc2l0aW9uKG1kUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShtZE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7IHZhciBfYTsgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgKChfYSA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkgPT09ICdpdGVtJzsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gcGFyYU5vZGUgPT09IG51bGwgfHwgcGFyYU5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFOb2RlLmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBwYXJhTm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gZmlyc3RDaGlsZC5saXRlcmFsLm1hdGNoKHJlVGFza01hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TWRQb3MgPSBmaXJzdENoaWxkLnNvdXJjZXBvc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0U3BhY2VzID0gbWF0Y2hlZFsxXSwgc3RhdGVDaGFyID0gbWF0Y2hlZFsyXSwgbGFzdFNwYWNlcyA9IG1hdGNoZWRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZXMgPSBzdGFydFNwYWNlcy5sZW5ndGggKyBsYXN0U3BhY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZ2V0Tm9kZUNvbnRlbnRPZmZzZXRSYW5nZShkb2MsIHN0YXJ0TWRQb3NbMF0gLSAxKS5zdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zID0gc3RhcnRNZFBvc1sxXSArIHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkZWRQb3MgPSBzcGFjZXMgPyBzcGFjZXMgKyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0UG9zLCBhZGRlZFBvcyArIHN0YXJ0UG9zLCBzY2hlbWEudGV4dChzdGF0ZUNoYXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzcGFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydFRleHQoJyAnLCBzdGFydFBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbnZhciBFVkVOVF9UWVBFID0gJ2N1dCc7XG52YXIgcmVMaW5lRW5kaW5nJDIgPSAvXFxyXFxufFxcbnxcXHIvO1xudmFyIE1kRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKE1kRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kRWRpdG9yKGV2ZW50RW1pdHRlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBldmVudEVtaXR0ZXIpIHx8IHRoaXM7XG4gICAgICAgIHZhciB0b2FzdE1hcmsgPSBvcHRpb25zLnRvYXN0TWFyaywgX2EgPSBvcHRpb25zLnVzZUNvbW1hbmRTaG9ydGN1dCwgdXNlQ29tbWFuZFNob3J0Y3V0ID0gX2EgPT09IHZvaWQgMCA/IHRydWUgOiBfYSwgX2IgPSBvcHRpb25zLm1kUGx1Z2lucywgbWRQbHVnaW5zID0gX2IgPT09IHZvaWQgMCA/IFtdIDogX2I7XG4gICAgICAgIF90aGlzLmVkaXRvclR5cGUgPSAnbWFya2Rvd24nO1xuICAgICAgICBfdGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdtZC1tb2RlJyk7XG4gICAgICAgIF90aGlzLnRvYXN0TWFyayA9IHRvYXN0TWFyaztcbiAgICAgICAgX3RoaXMuZXh0cmFQbHVnaW5zID0gbWRQbHVnaW5zO1xuICAgICAgICBfdGhpcy5zcGVjcyA9IF90aGlzLmNyZWF0ZVNwZWNzKCk7XG4gICAgICAgIF90aGlzLnNjaGVtYSA9IF90aGlzLmNyZWF0ZVNjaGVtYSgpO1xuICAgICAgICBfdGhpcy5jb250ZXh0ID0gX3RoaXMuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICBfdGhpcy5rZXltYXBzID0gX3RoaXMuY3JlYXRlS2V5bWFwcyh1c2VDb21tYW5kU2hvcnRjdXQpO1xuICAgICAgICBfdGhpcy52aWV3ID0gX3RoaXMuY3JlYXRlVmlldygpO1xuICAgICAgICBfdGhpcy5jb21tYW5kcyA9IF90aGlzLmNyZWF0ZUNvbW1hbmRzKCk7XG4gICAgICAgIF90aGlzLnNwZWNzLnNldENvbnRleHQoX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBfdGhpcy5jb250ZXh0KSwgeyB2aWV3OiBfdGhpcy52aWV3IH0pKTtcbiAgICAgICAgX3RoaXMuY3JlYXRlQ2xpcGJvYXJkKCk7XG4gICAgICAgIC8vIFRvIHByZXZlbnQgdW5uZWNlc3NhcnkgZm9jdXMgc2V0dGluZyBkdXJpbmcgaW5pdGlhbCByZW5kZXJpbmdcbiAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlUHJldmlld1RhYldyaXRlJywgZnVuY3Rpb24gKGlzTWFya2Rvd25UYWJNb3VudGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudG9nZ2xlQWN0aXZlKHRydWUsIGlzTWFya2Rvd25UYWJNb3VudGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG9nZ2xlQWN0aXZlKGZhbHNlKTsgfSk7XG4gICAgICAgIF90aGlzLmluaXRFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1kRWRpdG9yLnByb3RvdHlwZS50b2dnbGVBY3RpdmUgPSBmdW5jdGlvbiAoYWN0aXZlLCBpc01hcmtkb3duVGFiTW91bnRlZCkge1xuICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLmVsLCAnYWN0aXZlJywgYWN0aXZlKTtcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKCFpc01hcmtkb3duVGFiTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlQ2xpcGJvYXJkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsaXBib2FyZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkLmNsYXNzTmFtZSA9IGNscygncHNldWRvLWNsaXBib2FyZCcpO1xuICAgICAgICB0aGlzLmNsaXBib2FyZC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIGNsaXBib2FyZERhdGEgPSBldi5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gY2xpcGJvYXJkRGF0YSAmJiBjbGlwYm9hcmREYXRhLml0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5SdGZJdGVtID0gdG9BcnJheV8xKGl0ZW1zKS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmtpbmQgPT09ICdzdHJpbmcnICYmIGl0ZW0udHlwZSA9PT0gJ3RleHQvcnRmJzsgfSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgY29udGFpbnMgcnRmLCBpdCdzIG1vc3QgbGlrZWx5IGNvcHkgcGFzdGUgZnJvbSBvZmZpY2UgLT4gbm8gaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5SdGZJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUJsb2IgPSBwYXN0ZUltYWdlT25seShpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZUJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0SW1hZ2VCbG9iSG9vayhfdGhpcy5ldmVudEVtaXR0ZXIsIGltYWdlQmxvYiwgZXYudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcm9jZXNzIHRoZSBwYXN0ZWQgZGF0YSBpbiBpbnB1dCBldmVudCBmb3IgSUUxMVxuICAgICAgICB0aGlzLmNsaXBib2FyZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHRleHQgPSBldi50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBfdGhpcy5yZXBsYWNlU2VsZWN0aW9uKHRleHQpO1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2LnRhcmdldC52YWx1ZSA9ICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUodGhpcy5jbGlwYm9hcmQsIHRoaXMudmlldy5kb20pO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2FzdE1hcms6IHRoaXMudG9hc3RNYXJrLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlU3BlY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3BlY01hbmFnZXIoW1xuICAgICAgICAgICAgbmV3IERvYyQxKCksXG4gICAgICAgICAgICBuZXcgUGFyYWdyYXBoJDEoKSxcbiAgICAgICAgICAgIG5ldyBXaWRnZXQoKSxcbiAgICAgICAgICAgIG5ldyBUZXh0JDEoKSxcbiAgICAgICAgICAgIG5ldyBIZWFkaW5nJDEoKSxcbiAgICAgICAgICAgIG5ldyBCbG9ja1F1b3RlJDEoKSxcbiAgICAgICAgICAgIG5ldyBDb2RlQmxvY2skMSgpLFxuICAgICAgICAgICAgbmV3IEN1c3RvbUJsb2NrJDEoKSxcbiAgICAgICAgICAgIG5ldyBUYWJsZSQxKCksXG4gICAgICAgICAgICBuZXcgVGFibGVDZWxsKCksXG4gICAgICAgICAgICBuZXcgVGhlbWF0aWNCcmVhayQxKCksXG4gICAgICAgICAgICBuZXcgTGlzdEl0ZW0kMSgpLFxuICAgICAgICAgICAgbmV3IFN0cm9uZyQxKCksXG4gICAgICAgICAgICBuZXcgU3RyaWtlJDEoKSxcbiAgICAgICAgICAgIG5ldyBFbXBoJDEoKSxcbiAgICAgICAgICAgIG5ldyBDb2RlJDEoKSxcbiAgICAgICAgICAgIG5ldyBMaW5rJDEoKSxcbiAgICAgICAgICAgIG5ldyBEZWxpbWl0ZXIoKSxcbiAgICAgICAgICAgIG5ldyBUYXNrRGVsaW1pdGVyKCksXG4gICAgICAgICAgICBuZXcgTWFya2VkVGV4dCgpLFxuICAgICAgICAgICAgbmV3IE1ldGEoKSxcbiAgICAgICAgICAgIG5ldyBIdG1sKCksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVBsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5JDEoW1xuICAgICAgICAgICAgc3ludGF4SGlnaGxpZ2h0KHRoaXMuY29udGV4dCksXG4gICAgICAgICAgICBwcmV2aWV3SGlnaGxpZ2h0KHRoaXMuY29udGV4dCksXG4gICAgICAgICAgICBzbWFydFRhc2sodGhpcy5jb250ZXh0KVxuICAgICAgICBdLCB0aGlzLmNyZWF0ZVBsdWdpblByb3BzKCkpLmNvbmNhdCh0aGlzLmRlZmF1bHRQbHVnaW5zKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclZpZXcodGhpcy5lbCwge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY3JlYXRlU3RhdGUoKSxcbiAgICAgICAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IGZ1bmN0aW9uICh0cikge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZU1hcmtkb3duKHRyKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfdGhpcy52aWV3LnN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odHIpLnN0YXRlO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXRDaGFuZ2VFdmVudCh0cik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpICYmIGV2LmtleS50b1VwcGVyQ2FzZSgpID09PSAnVicpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpcGJvYXJkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdrZXlkb3duJywgX3RoaXMuZWRpdG9yVHlwZSwgZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBjb3B5OiBmdW5jdGlvbiAoXywgZXYpIHsgcmV0dXJuIF90aGlzLmNhcHR1cmVDb3B5KGV2KTsgfSxcbiAgICAgICAgICAgICAgICBjdXQ6IGZ1bmN0aW9uIChfLCBldikgeyByZXR1cm4gX3RoaXMuY2FwdHVyZUNvcHkoZXYsIEVWRU5UX1RZUEUpOyB9LFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2Nyb2xsJywgJ2VkaXRvcicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGtleXVwOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2tleXVwJywgX3RoaXMuZWRpdG9yVHlwZSwgZXYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlVmlld3M6IHtcbiAgICAgICAgICAgICAgICB3aWRnZXQ6IHdpZGdldE5vZGVWaWV3LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY3JlYXRlQ29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNzLmNvbW1hbmRzKHRoaXMudmlldyk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuY2FwdHVyZUNvcHkgPSBmdW5jdGlvbiAoZXYsIHR5cGUpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRDaGFuZ2VkKHNlbGVjdGlvbi5jb250ZW50KCkpO1xuICAgICAgICBpZiAoZXYuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgZXYuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdUZXh0JywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IEVWRU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoJ3VpRXZlbnQnLCBFVkVOVF9UWVBFKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUudXBkYXRlTWFya2Rvd24gPSBmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRyLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAuc2xpY2UgJiYgIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0ci5kb2NzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gW3N0ZXAuZnJvbSwgc3RlcC50b10sIGZyb20gPSBfYVswXSwgdG8gPSBfYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gZ2V0RWRpdG9yVG9NZFBvcyhkb2MsIGZyb20sIHRvKSwgc3RhcnRQb3MgPSBfYlswXSwgZW5kUG9zID0gX2JbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gX3RoaXMuZ2V0Q2hhbmdlZChzdGVwLnNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0UG9zWzBdID09PSBlbmRQb3NbMF0gJiYgc3RhcnRQb3NbMV0gPT09IGVuZFBvc1sxXSAmJiBjaGFuZ2VkID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGl0UmVzdWx0ID0gX3RoaXMudG9hc3RNYXJrLmVkaXRNYXJrZG93bihzdGFydFBvcywgZW5kUG9zLCBjaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3VwZGF0ZVByZXZpZXcnLCBlZGl0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgnZWRpdFJlc3VsdCcsIGVkaXRSZXN1bHQpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRDaGFuZ2VkID0gZnVuY3Rpb24gKHNsaWNlKSB7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gJyc7XG4gICAgICAgIHZhciBmcm9tID0gMDtcbiAgICAgICAgdmFyIHRvID0gc2xpY2UuY29udGVudC5zaXplO1xuICAgICAgICBzbGljZS5jb250ZW50Lm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCArPSBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5pc0Jsb2NrICYmIHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHN0YXJ0OyB9XG4gICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgdmFyIF9hID0gZ2V0TWRUb0VkaXRvclBvcyh0ci5kb2MsIHN0YXJ0LCBlbmQpLCBmcm9tID0gX2FbMF0sIHRvID0gX2FbMV07XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgZnJvbSwgdG8pKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5yZXBsYWNlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIG5ld1RyO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIHNjaGVtYSA9IF9hLnNjaGVtYSwgZG9jID0gX2EuZG9jO1xuICAgICAgICB2YXIgbGluZVRleHRzID0gdGV4dC5zcGxpdChyZUxpbmVFbmRpbmckMik7XG4gICAgICAgIHZhciBub2RlcyA9IGxpbmVUZXh0cy5tYXAoZnVuY3Rpb24gKGxpbmVUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUGFyYWdyYXBoKHNjaGVtYSwgY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KGxpbmVUZXh0LCBzY2hlbWEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGVzKSwgMSwgMSk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0LCBlbmQpLCBmcm9tID0gX2JbMF0sIHRvID0gX2JbMV07XG4gICAgICAgICAgICBuZXdUciA9IHRyLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VHIgPSB0ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2gobmV3VHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZGVsZXRlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIG5ld1RyO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYztcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICAgICAgdmFyIF9iID0gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0LCBlbmQpLCBmcm9tID0gX2JbMF0sIHRvID0gX2JbMV07XG4gICAgICAgICAgICBuZXdUciA9IHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RyID0gdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKG5ld1RyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldFNlbGVjdGVkVGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgZG9jID0gX2EuZG9jLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgZnJvbSA9IHBvc1swXTtcbiAgICAgICAgICAgIHRvID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2MudGV4dEJldHdlZW4oZnJvbSwgdG8sICdcXG4nKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24sIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvO1xuICAgICAgICByZXR1cm4gZ2V0RWRpdG9yVG9NZFBvcyh0aGlzLnZpZXcuc3RhdGUudHIuZG9jLCBmcm9tLCB0byk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuc2V0TWFya2Rvd24gPSBmdW5jdGlvbiAobWFya2Rvd24sIGN1cnNvclRvRW5kKSB7XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCA9PT0gdm9pZCAwKSB7IGN1cnNvclRvRW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgbGluZVRleHRzID0gbWFya2Rvd24uc3BsaXQocmVMaW5lRW5kaW5nJDIpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYywgc2NoZW1hID0gX2Euc2NoZW1hO1xuICAgICAgICB2YXIgbm9kZXMgPSBsaW5lVGV4dHMubWFwKGZ1bmN0aW9uIChsaW5lVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaChzY2hlbWEsIGNyZWF0ZU5vZGVzV2l0aFdpZGdldChsaW5lVGV4dCwgc2NoZW1hKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgbm9kZXMpKTtcbiAgICAgICAgaWYgKGN1cnNvclRvRW5kKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVDdXJzb3JUb0VuZCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uIChub2RlLCBzdHlsZSwgbWRQb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIHBvcyA9IG1kUG9zID8gZ2V0TWRUb0VkaXRvclBvcyhkb2MsIG1kUG9zLCBtZFBvcylbMF0gOiBzZWxlY3Rpb24udG87XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5zZXRNZXRhKCd3aWRnZXQnLCB7IHBvczogcG9zLCBub2RlOiBub2RlLCBzdHlsZTogc3R5bGUgfSkpO1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VXaXRoV2lkZ2V0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRleHQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWEsIGRvYyA9IF9hLmRvYztcbiAgICAgICAgdmFyIHBvcyA9IGdldE1kVG9FZGl0b3JQb3MoZG9jLCBzdGFydCwgZW5kKTtcbiAgICAgICAgdmFyIG5vZGVzID0gY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5yZXBsYWNlV2l0aChwb3NbMF0sIHBvc1sxXSwgbm9kZXMpKTtcbiAgICB9O1xuICAgIE1kRWRpdG9yLnByb3RvdHlwZS5nZXRSYW5nZUluZm9PZk5vZGUgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZSwgZG9jID0gX2EuZG9jLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciBtZFBvcyA9IHBvcyB8fCBnZXRFZGl0b3JUb01kUG9zKGRvYywgc2VsZWN0aW9uLmZyb20pWzBdO1xuICAgICAgICB2YXIgbWROb2RlID0gdGhpcy50b2FzdE1hcmsuZmluZE5vZGVBdFBvc2l0aW9uKG1kUG9zKTtcbiAgICAgICAgaWYgKG1kTm9kZS50eXBlID09PSAndGV4dCcgJiYgbWROb2RlLnBhcmVudC50eXBlICE9PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgMSBzeW5jIGZvciBwcm9zZW1pcnJvciBwb3NpdGlvblxuICAgICAgICBtZE5vZGUuc291cmNlcG9zWzFdWzFdICs9IDE7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBtZE5vZGUuc291cmNlcG9zLCB0eXBlOiBtZE5vZGUudHlwZSB9O1xuICAgIH07XG4gICAgTWRFZGl0b3IucHJvdG90eXBlLmdldE1hcmtkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdE1hcmtcbiAgICAgICAgICAgIC5nZXRMaW5lVGV4dHMoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZVRleHQpIHsgcmV0dXJuIHVud3JhcFdpZGdldFN5bnRheChsaW5lVGV4dCk7IH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICBNZEVkaXRvci5wcm90b3R5cGUuZ2V0VG9hc3RNYXJrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdE1hcms7XG4gICAgfTtcbiAgICByZXR1cm4gTWRFZGl0b3I7XG59KEVkaXRvckJhc2UpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdldCBldmVudCBjb2xsZWN0aW9uIGZvciBzcGVjaWZpYyBIVE1MIGVsZW1lbnRcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBFVkVOVF9LRVkgPSAnX2ZlRXZlbnRLZXknO1xuXG4vKipcbiAqIEdldCBldmVudCBjb2xsZWN0aW9uIGZvciBzcGVjaWZpYyBIVE1MIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBIVE1MIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICogQHJldHVybnMge2FycmF5fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2FmZUV2ZW50JDIoZWxlbWVudCwgdHlwZSkge1xuICB2YXIgZXZlbnRzID0gZWxlbWVudFtFVkVOVF9LRVldO1xuICB2YXIgaGFuZGxlcnM7XG5cbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSBlbGVtZW50W0VWRU5UX0tFWV0gPSB7fTtcbiAgfVxuXG4gIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gPSBbXTtcbiAgfVxuXG4gIHJldHVybiBoYW5kbGVycztcbn1cblxudmFyIF9zYWZlRXZlbnQgPSBzYWZlRXZlbnQkMjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVuYmluZCBET00gZXZlbnRzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG52YXIgaXNTdHJpbmckMSA9IGlzU3RyaW5nXzE7XG52YXIgZm9yRWFjaCQxID0gZm9yRWFjaF8xO1xuXG52YXIgc2FmZUV2ZW50JDEgPSBfc2FmZUV2ZW50O1xuXG4vKipcbiAqIFVuYmluZCBET00gZXZlbnRzXG4gKiBJZiBhIGhhbmRsZXIgZnVuY3Rpb24gaXMgbm90IHBhc3NlZCwgcmVtb3ZlIGFsbCBldmVudHMgb2YgdGhhdCB0eXBlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gdW5iaW5kIGV2ZW50c1xuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHR5cGVzIC0gU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIC0gaGFuZGxlciBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21FdmVudFxuICogQGV4YW1wbGVcbiAqIC8vIEZvbGxvd2luZyB0aGUgZXhhbXBsZSBvZiBkb21FdmVudCNvblxuICogXG4gKiAvLyBVbmJpbmQgb25lIGV2ZW50IGZyb20gYW4gZWxlbWVudC5cbiAqIG9mZihkaXYsICdjbGljaycsIHRvZ2dsZSk7XG4gKiBcbiAqIC8vIFVuYmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBhIHNhbWUgaGFuZGxlciBmcm9tIG11bHRpcGxlIGVsZW1lbnRzIGF0IG9uY2UuXG4gKiAvLyBVc2UgZXZlbnQgbmFtZXMgc3BsaXR0ZWQgYnkgYSBzcGFjZS5cbiAqIG9mZihlbGVtZW50LCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgY2hhbmdlQ29sb3IpO1xuICogXG4gKiAvLyBVbmJpbmQgbXVsdGlwbGUgZXZlbnRzIHdpdGggZGlmZmVyZW50IGhhbmRsZXJzIGZyb20gYW4gZWxlbWVudCBhdCBvbmNlLlxuICogLy8gVXNlIGFuIG9iamVjdCB3aGljaCBvZiBrZXkgaXMgYW4gZXZlbnQgbmFtZSBhbmQgdmFsdWUgaXMgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICogb2ZmKGRpdiwge1xuICogICBrZXlkb3duOiBoaWdobGlnaHQsXG4gKiAgIGtleXVwOiBkZWhpZ2hsaWdodFxuICogfSk7XG4gKiBcbiAqIC8vIFVuYmluZCBldmVudHMgd2l0aG91dCBoYW5kbGVycy5cbiAqIG9mZihkaXYsICdkcmFnJyk7XG4gKi9cbmZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlcywgaGFuZGxlcikge1xuICBpZiAoaXNTdHJpbmckMSh0eXBlcykpIHtcbiAgICBmb3JFYWNoJDEodHlwZXMuc3BsaXQoL1xccysvZyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHVuYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yRWFjaCQxKHR5cGVzLCBmdW5jdGlvbihmdW5jLCB0eXBlKSB7XG4gICAgdW5iaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgZnVuYyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVuYmluZCBET00gZXZlbnRzXG4gKiBJZiBhIGhhbmRsZXIgZnVuY3Rpb24gaXMgbm90IHBhc3NlZCwgcmVtb3ZlIGFsbCBldmVudHMgb2YgdGhhdCB0eXBlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gdW5iaW5kIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBldmVudHMgbmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIC0gaGFuZGxlciBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdW5iaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICB2YXIgZXZlbnRzID0gc2FmZUV2ZW50JDEoZWxlbWVudCwgdHlwZSk7XG4gIHZhciBpbmRleDtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBmb3JFYWNoJDEoZXZlbnRzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGl0ZW0ud3JhcHBlZEhhbmRsZXIpO1xuICAgIH0pO1xuICAgIGV2ZW50cy5zcGxpY2UoMCwgZXZlbnRzLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaCQxKGV2ZW50cywgZnVuY3Rpb24oaXRlbSwgaWR4KSB7XG4gICAgICBpZiAoaGFuZGxlciA9PT0gaXRlbS5oYW5kbGVyKSB7XG4gICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaXRlbS53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgIGluZGV4ID0gaWR4O1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gcmVtb3ZlIGFuIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKCdyZW1vdmVFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKCdkZXRhY2hFdmVudCcgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xuICB9XG59XG5cbnZhciBvZmZfMSA9IG9mZjtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEJpbmQgRE9NIGV2ZW50c1xuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzU3RyaW5nID0gaXNTdHJpbmdfMTtcbnZhciBmb3JFYWNoID0gZm9yRWFjaF8xO1xuXG52YXIgc2FmZUV2ZW50ID0gX3NhZmVFdmVudDtcblxuLyoqXG4gKiBCaW5kIERPTSBldmVudHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBiaW5kIGV2ZW50c1xuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHR5cGVzIC0gU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdFxuICogQHBhcmFtIHsoZnVuY3Rpb258b2JqZWN0KX0gaGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gY29udGV4dCAtIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21FdmVudFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICogXG4gKiAvLyBCaW5kIG9uZSBldmVudCB0byBhbiBlbGVtZW50LlxuICogb24oZGl2LCAnY2xpY2snLCB0b2dnbGUpO1xuICogXG4gKiAvLyBCaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIHRvIG11bHRpcGxlIGVsZW1lbnRzIGF0IG9uY2UuXG4gKiAvLyBVc2UgZXZlbnQgbmFtZXMgc3BsaXR0ZWQgYnkgYSBzcGFjZS5cbiAqIG9uKGRpdiwgJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGNoYW5nZUNvbG9yKTtcbiAqIFxuICogLy8gQmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgdG8gYW4gZWxlbWVudCBhdCBvbmNlLlxuICogLy8gVXNlIGFuIG9iamVjdCB3aGljaCBvZiBrZXkgaXMgYW4gZXZlbnQgbmFtZSBhbmQgdmFsdWUgaXMgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICogb24oZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gU2V0IGEgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBjb25zdCBuYW1lID0gJ2dsb2JhbCc7XG4gKiBjb25zdCByZXBvc2l0b3J5ID0ge25hbWU6ICdDb2RlU25pcHBldCd9O1xuICogb24oZGl2LCAnZHJhZycsIGZ1bmN0aW9uKCkge1xuICogICBjb25zb2xlLmxvZyh0aGlzLm5hbWUpO1xuICogfSwgcmVwb3NpdG9yeSk7XG4gKiAvLyBSZXN1bHQgd2hlbiB5b3UgZHJhZyBhIGRpdjogXCJDb2RlU25pcHBldFwiXG4gKi9cbmZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gIGlmIChpc1N0cmluZyh0eXBlcykpIHtcbiAgICBmb3JFYWNoKHR5cGVzLnNwbGl0KC9cXHMrL2cpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKHR5cGVzLCBmdW5jdGlvbihmdW5jLCB0eXBlKSB7XG4gICAgYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGhhbmRsZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kIERPTSBldmVudHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBjb250ZXh0IC0gY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSAtIGV2ZW50IG9iamVjdFxuICAgICAqL1xuICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZSkge1xuICAgIGhhbmRsZXIuY2FsbChjb250ZXh0IHx8IGVsZW1lbnQsIGUgfHwgd2luZG93LmV2ZW50KTtcbiAgfVxuXG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGV2ZW50SGFuZGxlcik7XG4gIH1cbiAgbWVtb3JpemVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGV2ZW50SGFuZGxlcik7XG59XG5cbi8qKlxuICogTWVtb3JpemUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIHVuYmluZGluZy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHVzZXIgcGFzc2VkIGF0IG9uKCkgdXNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVkSGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3cmFwcGVkIGJ5IGRvbWV2ZW50IGZvciBpbXBsZW1lbnRpbmcgc29tZSBmZWF0dXJlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWVtb3JpemVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIHdyYXBwZWRIYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQoZWxlbWVudCwgdHlwZSk7XG4gIHZhciBleGlzdEluRXZlbnRzID0gZmFsc2U7XG5cbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgZXhpc3RJbkV2ZW50cyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFleGlzdEluRXZlbnRzKSB7XG4gICAgZXZlbnRzLnB1c2goe1xuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIHdyYXBwZWRIYW5kbGVyOiB3cmFwcGVkSGFuZGxlclxuICAgIH0pO1xuICB9XG59XG5cbnZhciBvbl8xID0gb247XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxudmFyIGVuY29kZUNhY2hlID0ge307XG5cblxuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG5cbiAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlJDEoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZSQxLmRlZmF1bHRDaGFycztcbiAgfVxuXG4gIGlmICh0eXBlb2Yga2VlcEVzY2FwZWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICB9XG5cbiAgY2FjaGUgPSBnZXRFbmNvZGVDYWNoZShleGNsdWRlKTtcblxuICBmb3IgKGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChrZWVwRXNjYXBlZCAmJiBjb2RlID09PSAweDI1IC8qICUgKi8gJiYgaSArIDIgPCBsKSB7XG4gICAgICBpZiAoL15bMC05YS1mXXsyfSQvaS50ZXN0KHN0cmluZy5zbGljZShpICsgMSwgaSArIDMpKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5nLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA8IDEyOCkge1xuICAgICAgcmVzdWx0ICs9IGNhY2hlW2NvZGVdO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhERkZGKSB7XG4gICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERCRkYgJiYgaSArIDEgPCBsKSB7XG4gICAgICAgIG5leHRDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldICsgc3RyaW5nW2kgKyAxXSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJyVFRiVCRiVCRCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5lbmNvZGUkMS5kZWZhdWx0Q2hhcnMgICA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZSQxLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG52YXIgZW5jb2RlXzEgPSBlbmNvZGUkMTtcblxudmFyIGxpYiA9IHt9O1xuXG52YXIgZGVjb2RlID0ge307XG5cbnZhciBBYWN1dGUkMSA9IFwiw4FcIjtcbnZhciBhYWN1dGUkMSA9IFwiw6FcIjtcbnZhciBBYnJldmUgPSBcIsSCXCI7XG52YXIgYWJyZXZlID0gXCLEg1wiO1xudmFyIGFjID0gXCLiiL5cIjtcbnZhciBhY2QgPSBcIuKIv1wiO1xudmFyIGFjRSA9IFwi4oi+zLNcIjtcbnZhciBBY2lyYyQxID0gXCLDglwiO1xudmFyIGFjaXJjJDEgPSBcIsOiXCI7XG52YXIgYWN1dGUkMSA9IFwiwrRcIjtcbnZhciBBY3kgPSBcItCQXCI7XG52YXIgYWN5ID0gXCLQsFwiO1xudmFyIEFFbGlnJDEgPSBcIsOGXCI7XG52YXIgYWVsaWckMSA9IFwiw6ZcIjtcbnZhciBhZiA9IFwi4oGhXCI7XG52YXIgQWZyID0gXCLwnZSEXCI7XG52YXIgYWZyID0gXCLwnZSeXCI7XG52YXIgQWdyYXZlJDEgPSBcIsOAXCI7XG52YXIgYWdyYXZlJDEgPSBcIsOgXCI7XG52YXIgYWxlZnN5bSA9IFwi4oS1XCI7XG52YXIgYWxlcGggPSBcIuKEtVwiO1xudmFyIEFscGhhID0gXCLOkVwiO1xudmFyIGFscGhhID0gXCLOsVwiO1xudmFyIEFtYWNyID0gXCLEgFwiO1xudmFyIGFtYWNyID0gXCLEgVwiO1xudmFyIGFtYWxnID0gXCLiqL9cIjtcbnZhciBhbXAkMiA9IFwiJlwiO1xudmFyIEFNUCQxID0gXCImXCI7XG52YXIgYW5kYW5kID0gXCLiqZVcIjtcbnZhciBBbmQgPSBcIuKpk1wiO1xudmFyIGFuZCA9IFwi4oinXCI7XG52YXIgYW5kZCA9IFwi4qmcXCI7XG52YXIgYW5kc2xvcGUgPSBcIuKpmFwiO1xudmFyIGFuZHYgPSBcIuKpmlwiO1xudmFyIGFuZyA9IFwi4oigXCI7XG52YXIgYW5nZSA9IFwi4qakXCI7XG52YXIgYW5nbGUgPSBcIuKIoFwiO1xudmFyIGFuZ21zZGFhID0gXCLipqhcIjtcbnZhciBhbmdtc2RhYiA9IFwi4qapXCI7XG52YXIgYW5nbXNkYWMgPSBcIuKmqlwiO1xudmFyIGFuZ21zZGFkID0gXCLipqtcIjtcbnZhciBhbmdtc2RhZSA9IFwi4qasXCI7XG52YXIgYW5nbXNkYWYgPSBcIuKmrVwiO1xudmFyIGFuZ21zZGFnID0gXCLipq5cIjtcbnZhciBhbmdtc2RhaCA9IFwi4qavXCI7XG52YXIgYW5nbXNkID0gXCLiiKFcIjtcbnZhciBhbmdydCA9IFwi4oifXCI7XG52YXIgYW5ncnR2YiA9IFwi4oq+XCI7XG52YXIgYW5ncnR2YmQgPSBcIuKmnVwiO1xudmFyIGFuZ3NwaCA9IFwi4oiiXCI7XG52YXIgYW5nc3QgPSBcIsOFXCI7XG52YXIgYW5nemFyciA9IFwi4o28XCI7XG52YXIgQW9nb24gPSBcIsSEXCI7XG52YXIgYW9nb24gPSBcIsSFXCI7XG52YXIgQW9wZiA9IFwi8J2UuFwiO1xudmFyIGFvcGYgPSBcIvCdlZJcIjtcbnZhciBhcGFjaXIgPSBcIuKpr1wiO1xudmFyIGFwID0gXCLiiYhcIjtcbnZhciBhcEUgPSBcIuKpsFwiO1xudmFyIGFwZSA9IFwi4omKXCI7XG52YXIgYXBpZCA9IFwi4omLXCI7XG52YXIgYXBvcyQxID0gXCInXCI7XG52YXIgQXBwbHlGdW5jdGlvbiA9IFwi4oGhXCI7XG52YXIgYXBwcm94ID0gXCLiiYhcIjtcbnZhciBhcHByb3hlcSA9IFwi4omKXCI7XG52YXIgQXJpbmckMSA9IFwiw4VcIjtcbnZhciBhcmluZyQxID0gXCLDpVwiO1xudmFyIEFzY3IgPSBcIvCdkpxcIjtcbnZhciBhc2NyID0gXCLwnZK2XCI7XG52YXIgQXNzaWduID0gXCLiiZRcIjtcbnZhciBhc3QgPSBcIipcIjtcbnZhciBhc3ltcCA9IFwi4omIXCI7XG52YXIgYXN5bXBlcSA9IFwi4omNXCI7XG52YXIgQXRpbGRlJDEgPSBcIsODXCI7XG52YXIgYXRpbGRlJDEgPSBcIsOjXCI7XG52YXIgQXVtbCQxID0gXCLDhFwiO1xudmFyIGF1bWwkMSA9IFwiw6RcIjtcbnZhciBhd2NvbmludCA9IFwi4oizXCI7XG52YXIgYXdpbnQgPSBcIuKokVwiO1xudmFyIGJhY2tjb25nID0gXCLiiYxcIjtcbnZhciBiYWNrZXBzaWxvbiA9IFwiz7ZcIjtcbnZhciBiYWNrcHJpbWUgPSBcIuKAtVwiO1xudmFyIGJhY2tzaW0gPSBcIuKIvVwiO1xudmFyIGJhY2tzaW1lcSA9IFwi4ouNXCI7XG52YXIgQmFja3NsYXNoID0gXCLiiJZcIjtcbnZhciBCYXJ2ID0gXCLiq6dcIjtcbnZhciBiYXJ2ZWUgPSBcIuKKvVwiO1xudmFyIGJhcndlZCA9IFwi4oyFXCI7XG52YXIgQmFyd2VkID0gXCLijIZcIjtcbnZhciBiYXJ3ZWRnZSA9IFwi4oyFXCI7XG52YXIgYmJyayA9IFwi4o61XCI7XG52YXIgYmJya3RicmsgPSBcIuKOtlwiO1xudmFyIGJjb25nID0gXCLiiYxcIjtcbnZhciBCY3kgPSBcItCRXCI7XG52YXIgYmN5ID0gXCLQsVwiO1xudmFyIGJkcXVvID0gXCLigJ5cIjtcbnZhciBiZWNhdXMgPSBcIuKItVwiO1xudmFyIGJlY2F1c2UgPSBcIuKItVwiO1xudmFyIEJlY2F1c2UgPSBcIuKItVwiO1xudmFyIGJlbXB0eXYgPSBcIuKmsFwiO1xudmFyIGJlcHNpID0gXCLPtlwiO1xudmFyIGJlcm5vdSA9IFwi4oSsXCI7XG52YXIgQmVybm91bGxpcyA9IFwi4oSsXCI7XG52YXIgQmV0YSA9IFwizpJcIjtcbnZhciBiZXRhID0gXCLOslwiO1xudmFyIGJldGggPSBcIuKEtlwiO1xudmFyIGJldHdlZW4gPSBcIuKJrFwiO1xudmFyIEJmciA9IFwi8J2UhVwiO1xudmFyIGJmciA9IFwi8J2Un1wiO1xudmFyIGJpZ2NhcCA9IFwi4ouCXCI7XG52YXIgYmlnY2lyYyA9IFwi4pevXCI7XG52YXIgYmlnY3VwID0gXCLii4NcIjtcbnZhciBiaWdvZG90ID0gXCLiqIBcIjtcbnZhciBiaWdvcGx1cyA9IFwi4qiBXCI7XG52YXIgYmlnb3RpbWVzID0gXCLiqIJcIjtcbnZhciBiaWdzcWN1cCA9IFwi4qiGXCI7XG52YXIgYmlnc3RhciA9IFwi4piFXCI7XG52YXIgYmlndHJpYW5nbGVkb3duID0gXCLilr1cIjtcbnZhciBiaWd0cmlhbmdsZXVwID0gXCLilrNcIjtcbnZhciBiaWd1cGx1cyA9IFwi4qiEXCI7XG52YXIgYmlndmVlID0gXCLii4FcIjtcbnZhciBiaWd3ZWRnZSA9IFwi4ouAXCI7XG52YXIgYmthcm93ID0gXCLipI1cIjtcbnZhciBibGFja2xvemVuZ2UgPSBcIuKnq1wiO1xudmFyIGJsYWNrc3F1YXJlID0gXCLilqpcIjtcbnZhciBibGFja3RyaWFuZ2xlID0gXCLilrRcIjtcbnZhciBibGFja3RyaWFuZ2xlZG93biA9IFwi4pa+XCI7XG52YXIgYmxhY2t0cmlhbmdsZWxlZnQgPSBcIuKXglwiO1xudmFyIGJsYWNrdHJpYW5nbGVyaWdodCA9IFwi4pa4XCI7XG52YXIgYmxhbmsgPSBcIuKQo1wiO1xudmFyIGJsazEyID0gXCLilpJcIjtcbnZhciBibGsxNCA9IFwi4paRXCI7XG52YXIgYmxrMzQgPSBcIuKWk1wiO1xudmFyIGJsb2NrID0gXCLilohcIjtcbnZhciBibmUgPSBcIj3ig6VcIjtcbnZhciBibmVxdWl2ID0gXCLiiaHig6VcIjtcbnZhciBiTm90ID0gXCLiq61cIjtcbnZhciBibm90ID0gXCLijJBcIjtcbnZhciBCb3BmID0gXCLwnZS5XCI7XG52YXIgYm9wZiA9IFwi8J2Vk1wiO1xudmFyIGJvdCA9IFwi4oqlXCI7XG52YXIgYm90dG9tID0gXCLiiqVcIjtcbnZhciBib3d0aWUgPSBcIuKLiFwiO1xudmFyIGJveGJveCA9IFwi4qeJXCI7XG52YXIgYm94ZGwgPSBcIuKUkFwiO1xudmFyIGJveGRMID0gXCLilZVcIjtcbnZhciBib3hEbCA9IFwi4pWWXCI7XG52YXIgYm94REwgPSBcIuKVl1wiO1xudmFyIGJveGRyID0gXCLilIxcIjtcbnZhciBib3hkUiA9IFwi4pWSXCI7XG52YXIgYm94RHIgPSBcIuKVk1wiO1xudmFyIGJveERSID0gXCLilZRcIjtcbnZhciBib3hoID0gXCLilIBcIjtcbnZhciBib3hIID0gXCLilZBcIjtcbnZhciBib3hoZCA9IFwi4pSsXCI7XG52YXIgYm94SGQgPSBcIuKVpFwiO1xudmFyIGJveGhEID0gXCLilaVcIjtcbnZhciBib3hIRCA9IFwi4pWmXCI7XG52YXIgYm94aHUgPSBcIuKUtFwiO1xudmFyIGJveEh1ID0gXCLiladcIjtcbnZhciBib3hoVSA9IFwi4pWoXCI7XG52YXIgYm94SFUgPSBcIuKVqVwiO1xudmFyIGJveG1pbnVzID0gXCLiip9cIjtcbnZhciBib3hwbHVzID0gXCLiip5cIjtcbnZhciBib3h0aW1lcyA9IFwi4oqgXCI7XG52YXIgYm94dWwgPSBcIuKUmFwiO1xudmFyIGJveHVMID0gXCLilZtcIjtcbnZhciBib3hVbCA9IFwi4pWcXCI7XG52YXIgYm94VUwgPSBcIuKVnVwiO1xudmFyIGJveHVyID0gXCLilJRcIjtcbnZhciBib3h1UiA9IFwi4pWYXCI7XG52YXIgYm94VXIgPSBcIuKVmVwiO1xudmFyIGJveFVSID0gXCLilZpcIjtcbnZhciBib3h2ID0gXCLilIJcIjtcbnZhciBib3hWID0gXCLilZFcIjtcbnZhciBib3h2aCA9IFwi4pS8XCI7XG52YXIgYm94dkggPSBcIuKVqlwiO1xudmFyIGJveFZoID0gXCLilatcIjtcbnZhciBib3hWSCA9IFwi4pWsXCI7XG52YXIgYm94dmwgPSBcIuKUpFwiO1xudmFyIGJveHZMID0gXCLilaFcIjtcbnZhciBib3hWbCA9IFwi4pWiXCI7XG52YXIgYm94VkwgPSBcIuKVo1wiO1xudmFyIGJveHZyID0gXCLilJxcIjtcbnZhciBib3h2UiA9IFwi4pWeXCI7XG52YXIgYm94VnIgPSBcIuKVn1wiO1xudmFyIGJveFZSID0gXCLilaBcIjtcbnZhciBicHJpbWUgPSBcIuKAtVwiO1xudmFyIGJyZXZlID0gXCLLmFwiO1xudmFyIEJyZXZlID0gXCLLmFwiO1xudmFyIGJydmJhciQxID0gXCLCplwiO1xudmFyIGJzY3IgPSBcIvCdkrdcIjtcbnZhciBCc2NyID0gXCLihKxcIjtcbnZhciBic2VtaSA9IFwi4oGPXCI7XG52YXIgYnNpbSA9IFwi4oi9XCI7XG52YXIgYnNpbWUgPSBcIuKLjVwiO1xudmFyIGJzb2xiID0gXCLip4VcIjtcbnZhciBic29sID0gXCJcXFxcXCI7XG52YXIgYnNvbGhzdWIgPSBcIuKfiFwiO1xudmFyIGJ1bGwgPSBcIuKAolwiO1xudmFyIGJ1bGxldCA9IFwi4oCiXCI7XG52YXIgYnVtcCA9IFwi4omOXCI7XG52YXIgYnVtcEUgPSBcIuKqrlwiO1xudmFyIGJ1bXBlID0gXCLiiY9cIjtcbnZhciBCdW1wZXEgPSBcIuKJjlwiO1xudmFyIGJ1bXBlcSA9IFwi4omPXCI7XG52YXIgQ2FjdXRlID0gXCLEhlwiO1xudmFyIGNhY3V0ZSA9IFwixIdcIjtcbnZhciBjYXBhbmQgPSBcIuKphFwiO1xudmFyIGNhcGJyY3VwID0gXCLiqYlcIjtcbnZhciBjYXBjYXAgPSBcIuKpi1wiO1xudmFyIGNhcCA9IFwi4oipXCI7XG52YXIgQ2FwID0gXCLii5JcIjtcbnZhciBjYXBjdXAgPSBcIuKph1wiO1xudmFyIGNhcGRvdCA9IFwi4qmAXCI7XG52YXIgQ2FwaXRhbERpZmZlcmVudGlhbEQgPSBcIuKFhVwiO1xudmFyIGNhcHMgPSBcIuKIqe+4gFwiO1xudmFyIGNhcmV0ID0gXCLigYFcIjtcbnZhciBjYXJvbiA9IFwiy4dcIjtcbnZhciBDYXlsZXlzID0gXCLihK1cIjtcbnZhciBjY2FwcyA9IFwi4qmNXCI7XG52YXIgQ2Nhcm9uID0gXCLEjFwiO1xudmFyIGNjYXJvbiA9IFwixI1cIjtcbnZhciBDY2VkaWwkMSA9IFwiw4dcIjtcbnZhciBjY2VkaWwkMSA9IFwiw6dcIjtcbnZhciBDY2lyYyA9IFwixIhcIjtcbnZhciBjY2lyYyA9IFwixIlcIjtcbnZhciBDY29uaW50ID0gXCLiiLBcIjtcbnZhciBjY3VwcyA9IFwi4qmMXCI7XG52YXIgY2N1cHNzbSA9IFwi4qmQXCI7XG52YXIgQ2RvdCA9IFwixIpcIjtcbnZhciBjZG90ID0gXCLEi1wiO1xudmFyIGNlZGlsJDEgPSBcIsK4XCI7XG52YXIgQ2VkaWxsYSA9IFwiwrhcIjtcbnZhciBjZW1wdHl2ID0gXCLiprJcIjtcbnZhciBjZW50JDEgPSBcIsKiXCI7XG52YXIgY2VudGVyZG90ID0gXCLCt1wiO1xudmFyIENlbnRlckRvdCA9IFwiwrdcIjtcbnZhciBjZnIgPSBcIvCdlKBcIjtcbnZhciBDZnIgPSBcIuKErVwiO1xudmFyIENIY3kgPSBcItCnXCI7XG52YXIgY2hjeSA9IFwi0YdcIjtcbnZhciBjaGVjayA9IFwi4pyTXCI7XG52YXIgY2hlY2ttYXJrID0gXCLinJNcIjtcbnZhciBDaGkgPSBcIs6nXCI7XG52YXIgY2hpID0gXCLPh1wiO1xudmFyIGNpcmMgPSBcIsuGXCI7XG52YXIgY2lyY2VxID0gXCLiiZdcIjtcbnZhciBjaXJjbGVhcnJvd2xlZnQgPSBcIuKGulwiO1xudmFyIGNpcmNsZWFycm93cmlnaHQgPSBcIuKGu1wiO1xudmFyIGNpcmNsZWRhc3QgPSBcIuKKm1wiO1xudmFyIGNpcmNsZWRjaXJjID0gXCLiippcIjtcbnZhciBjaXJjbGVkZGFzaCA9IFwi4oqdXCI7XG52YXIgQ2lyY2xlRG90ID0gXCLiiplcIjtcbnZhciBjaXJjbGVkUiA9IFwiwq5cIjtcbnZhciBjaXJjbGVkUyA9IFwi4pOIXCI7XG52YXIgQ2lyY2xlTWludXMgPSBcIuKKllwiO1xudmFyIENpcmNsZVBsdXMgPSBcIuKKlVwiO1xudmFyIENpcmNsZVRpbWVzID0gXCLiipdcIjtcbnZhciBjaXIgPSBcIuKXi1wiO1xudmFyIGNpckUgPSBcIuKng1wiO1xudmFyIGNpcmUgPSBcIuKJl1wiO1xudmFyIGNpcmZuaW50ID0gXCLiqJBcIjtcbnZhciBjaXJtaWQgPSBcIuKrr1wiO1xudmFyIGNpcnNjaXIgPSBcIuKnglwiO1xudmFyIENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCA9IFwi4oiyXCI7XG52YXIgQ2xvc2VDdXJseURvdWJsZVF1b3RlID0gXCLigJ1cIjtcbnZhciBDbG9zZUN1cmx5UXVvdGUgPSBcIuKAmVwiO1xudmFyIGNsdWJzID0gXCLimaNcIjtcbnZhciBjbHVic3VpdCA9IFwi4pmjXCI7XG52YXIgY29sb24gPSBcIjpcIjtcbnZhciBDb2xvbiA9IFwi4oi3XCI7XG52YXIgQ29sb25lID0gXCLiqbRcIjtcbnZhciBjb2xvbmUgPSBcIuKJlFwiO1xudmFyIGNvbG9uZXEgPSBcIuKJlFwiO1xudmFyIGNvbW1hID0gXCIsXCI7XG52YXIgY29tbWF0ID0gXCJAXCI7XG52YXIgY29tcCA9IFwi4oiBXCI7XG52YXIgY29tcGZuID0gXCLiiJhcIjtcbnZhciBjb21wbGVtZW50ID0gXCLiiIFcIjtcbnZhciBjb21wbGV4ZXMgPSBcIuKEglwiO1xudmFyIGNvbmcgPSBcIuKJhVwiO1xudmFyIGNvbmdkb3QgPSBcIuKprVwiO1xudmFyIENvbmdydWVudCA9IFwi4omhXCI7XG52YXIgY29uaW50ID0gXCLiiK5cIjtcbnZhciBDb25pbnQgPSBcIuKIr1wiO1xudmFyIENvbnRvdXJJbnRlZ3JhbCA9IFwi4oiuXCI7XG52YXIgY29wZiA9IFwi8J2VlFwiO1xudmFyIENvcGYgPSBcIuKEglwiO1xudmFyIGNvcHJvZCA9IFwi4oiQXCI7XG52YXIgQ29wcm9kdWN0ID0gXCLiiJBcIjtcbnZhciBjb3B5JDEgPSBcIsKpXCI7XG52YXIgQ09QWSQxID0gXCLCqVwiO1xudmFyIGNvcHlzciA9IFwi4oSXXCI7XG52YXIgQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCA9IFwi4oizXCI7XG52YXIgY3JhcnIgPSBcIuKGtVwiO1xudmFyIGNyb3NzID0gXCLinJdcIjtcbnZhciBDcm9zcyA9IFwi4qivXCI7XG52YXIgQ3NjciA9IFwi8J2SnlwiO1xudmFyIGNzY3IgPSBcIvCdkrhcIjtcbnZhciBjc3ViID0gXCLiq49cIjtcbnZhciBjc3ViZSA9IFwi4quRXCI7XG52YXIgY3N1cCA9IFwi4quQXCI7XG52YXIgY3N1cGUgPSBcIuKrklwiO1xudmFyIGN0ZG90ID0gXCLii69cIjtcbnZhciBjdWRhcnJsID0gXCLipLhcIjtcbnZhciBjdWRhcnJyID0gXCLipLVcIjtcbnZhciBjdWVwciA9IFwi4oueXCI7XG52YXIgY3Vlc2MgPSBcIuKLn1wiO1xudmFyIGN1bGFyciA9IFwi4oa2XCI7XG52YXIgY3VsYXJycCA9IFwi4qS9XCI7XG52YXIgY3VwYnJjYXAgPSBcIuKpiFwiO1xudmFyIGN1cGNhcCA9IFwi4qmGXCI7XG52YXIgQ3VwQ2FwID0gXCLiiY1cIjtcbnZhciBjdXAgPSBcIuKIqlwiO1xudmFyIEN1cCA9IFwi4ouTXCI7XG52YXIgY3VwY3VwID0gXCLiqYpcIjtcbnZhciBjdXBkb3QgPSBcIuKKjVwiO1xudmFyIGN1cG9yID0gXCLiqYVcIjtcbnZhciBjdXBzID0gXCLiiKrvuIBcIjtcbnZhciBjdXJhcnIgPSBcIuKGt1wiO1xudmFyIGN1cmFycm0gPSBcIuKkvFwiO1xudmFyIGN1cmx5ZXFwcmVjID0gXCLii55cIjtcbnZhciBjdXJseWVxc3VjYyA9IFwi4oufXCI7XG52YXIgY3VybHl2ZWUgPSBcIuKLjlwiO1xudmFyIGN1cmx5d2VkZ2UgPSBcIuKLj1wiO1xudmFyIGN1cnJlbiQxID0gXCLCpFwiO1xudmFyIGN1cnZlYXJyb3dsZWZ0ID0gXCLihrZcIjtcbnZhciBjdXJ2ZWFycm93cmlnaHQgPSBcIuKGt1wiO1xudmFyIGN1dmVlID0gXCLii45cIjtcbnZhciBjdXdlZCA9IFwi4ouPXCI7XG52YXIgY3djb25pbnQgPSBcIuKIslwiO1xudmFyIGN3aW50ID0gXCLiiLFcIjtcbnZhciBjeWxjdHkgPSBcIuKMrVwiO1xudmFyIGRhZ2dlciA9IFwi4oCgXCI7XG52YXIgRGFnZ2VyID0gXCLigKFcIjtcbnZhciBkYWxldGggPSBcIuKEuFwiO1xudmFyIGRhcnIgPSBcIuKGk1wiO1xudmFyIERhcnIgPSBcIuKGoVwiO1xudmFyIGRBcnIgPSBcIuKHk1wiO1xudmFyIGRhc2ggPSBcIuKAkFwiO1xudmFyIERhc2h2ID0gXCLiq6RcIjtcbnZhciBkYXNodiA9IFwi4oqjXCI7XG52YXIgZGJrYXJvdyA9IFwi4qSPXCI7XG52YXIgZGJsYWMgPSBcIsudXCI7XG52YXIgRGNhcm9uID0gXCLEjlwiO1xudmFyIGRjYXJvbiA9IFwixI9cIjtcbnZhciBEY3kgPSBcItCUXCI7XG52YXIgZGN5ID0gXCLQtFwiO1xudmFyIGRkYWdnZXIgPSBcIuKAoVwiO1xudmFyIGRkYXJyID0gXCLih4pcIjtcbnZhciBERCA9IFwi4oWFXCI7XG52YXIgZGQgPSBcIuKFhlwiO1xudmFyIEREb3RyYWhkID0gXCLipJFcIjtcbnZhciBkZG90c2VxID0gXCLiqbdcIjtcbnZhciBkZWckMSA9IFwiwrBcIjtcbnZhciBEZWwgPSBcIuKIh1wiO1xudmFyIERlbHRhID0gXCLOlFwiO1xudmFyIGRlbHRhID0gXCLOtFwiO1xudmFyIGRlbXB0eXYgPSBcIuKmsVwiO1xudmFyIGRmaXNodCA9IFwi4qW/XCI7XG52YXIgRGZyID0gXCLwnZSHXCI7XG52YXIgZGZyID0gXCLwnZShXCI7XG52YXIgZEhhciA9IFwi4qWlXCI7XG52YXIgZGhhcmwgPSBcIuKHg1wiO1xudmFyIGRoYXJyID0gXCLih4JcIjtcbnZhciBEaWFjcml0aWNhbEFjdXRlID0gXCLCtFwiO1xudmFyIERpYWNyaXRpY2FsRG90ID0gXCLLmVwiO1xudmFyIERpYWNyaXRpY2FsRG91YmxlQWN1dGUgPSBcIsudXCI7XG52YXIgRGlhY3JpdGljYWxHcmF2ZSA9IFwiYFwiO1xudmFyIERpYWNyaXRpY2FsVGlsZGUgPSBcIsucXCI7XG52YXIgZGlhbSA9IFwi4ouEXCI7XG52YXIgZGlhbW9uZCA9IFwi4ouEXCI7XG52YXIgRGlhbW9uZCA9IFwi4ouEXCI7XG52YXIgZGlhbW9uZHN1aXQgPSBcIuKZplwiO1xudmFyIGRpYW1zID0gXCLimaZcIjtcbnZhciBkaWUgPSBcIsKoXCI7XG52YXIgRGlmZmVyZW50aWFsRCA9IFwi4oWGXCI7XG52YXIgZGlnYW1tYSA9IFwiz51cIjtcbnZhciBkaXNpbiA9IFwi4ouyXCI7XG52YXIgZGl2ID0gXCLDt1wiO1xudmFyIGRpdmlkZSQxID0gXCLDt1wiO1xudmFyIGRpdmlkZW9udGltZXMgPSBcIuKLh1wiO1xudmFyIGRpdm9ueCA9IFwi4ouHXCI7XG52YXIgREpjeSA9IFwi0IJcIjtcbnZhciBkamN5ID0gXCLRklwiO1xudmFyIGRsY29ybiA9IFwi4oyeXCI7XG52YXIgZGxjcm9wID0gXCLijI1cIjtcbnZhciBkb2xsYXIgPSBcIiRcIjtcbnZhciBEb3BmID0gXCLwnZS7XCI7XG52YXIgZG9wZiA9IFwi8J2VlVwiO1xudmFyIERvdCA9IFwiwqhcIjtcbnZhciBkb3QgPSBcIsuZXCI7XG52YXIgRG90RG90ID0gXCLig5xcIjtcbnZhciBkb3RlcSA9IFwi4omQXCI7XG52YXIgZG90ZXFkb3QgPSBcIuKJkVwiO1xudmFyIERvdEVxdWFsID0gXCLiiZBcIjtcbnZhciBkb3RtaW51cyA9IFwi4oi4XCI7XG52YXIgZG90cGx1cyA9IFwi4oiUXCI7XG52YXIgZG90c3F1YXJlID0gXCLiiqFcIjtcbnZhciBkb3VibGViYXJ3ZWRnZSA9IFwi4oyGXCI7XG52YXIgRG91YmxlQ29udG91ckludGVncmFsID0gXCLiiK9cIjtcbnZhciBEb3VibGVEb3QgPSBcIsKoXCI7XG52YXIgRG91YmxlRG93bkFycm93ID0gXCLih5NcIjtcbnZhciBEb3VibGVMZWZ0QXJyb3cgPSBcIuKHkFwiO1xudmFyIERvdWJsZUxlZnRSaWdodEFycm93ID0gXCLih5RcIjtcbnZhciBEb3VibGVMZWZ0VGVlID0gXCLiq6RcIjtcbnZhciBEb3VibGVMb25nTGVmdEFycm93ID0gXCLin7hcIjtcbnZhciBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cgPSBcIuKfulwiO1xudmFyIERvdWJsZUxvbmdSaWdodEFycm93ID0gXCLin7lcIjtcbnZhciBEb3VibGVSaWdodEFycm93ID0gXCLih5JcIjtcbnZhciBEb3VibGVSaWdodFRlZSA9IFwi4oqoXCI7XG52YXIgRG91YmxlVXBBcnJvdyA9IFwi4oeRXCI7XG52YXIgRG91YmxlVXBEb3duQXJyb3cgPSBcIuKHlVwiO1xudmFyIERvdWJsZVZlcnRpY2FsQmFyID0gXCLiiKVcIjtcbnZhciBEb3duQXJyb3dCYXIgPSBcIuKkk1wiO1xudmFyIGRvd25hcnJvdyA9IFwi4oaTXCI7XG52YXIgRG93bkFycm93ID0gXCLihpNcIjtcbnZhciBEb3duYXJyb3cgPSBcIuKHk1wiO1xudmFyIERvd25BcnJvd1VwQXJyb3cgPSBcIuKHtVwiO1xudmFyIERvd25CcmV2ZSA9IFwizJFcIjtcbnZhciBkb3duZG93bmFycm93cyA9IFwi4oeKXCI7XG52YXIgZG93bmhhcnBvb25sZWZ0ID0gXCLih4NcIjtcbnZhciBkb3duaGFycG9vbnJpZ2h0ID0gXCLih4JcIjtcbnZhciBEb3duTGVmdFJpZ2h0VmVjdG9yID0gXCLipZBcIjtcbnZhciBEb3duTGVmdFRlZVZlY3RvciA9IFwi4qWeXCI7XG52YXIgRG93bkxlZnRWZWN0b3JCYXIgPSBcIuKlllwiO1xudmFyIERvd25MZWZ0VmVjdG9yID0gXCLihr1cIjtcbnZhciBEb3duUmlnaHRUZWVWZWN0b3IgPSBcIuKln1wiO1xudmFyIERvd25SaWdodFZlY3RvckJhciA9IFwi4qWXXCI7XG52YXIgRG93blJpZ2h0VmVjdG9yID0gXCLih4FcIjtcbnZhciBEb3duVGVlQXJyb3cgPSBcIuKGp1wiO1xudmFyIERvd25UZWUgPSBcIuKKpFwiO1xudmFyIGRyYmthcm93ID0gXCLipJBcIjtcbnZhciBkcmNvcm4gPSBcIuKMn1wiO1xudmFyIGRyY3JvcCA9IFwi4oyMXCI7XG52YXIgRHNjciA9IFwi8J2Sn1wiO1xudmFyIGRzY3IgPSBcIvCdkrlcIjtcbnZhciBEU2N5ID0gXCLQhVwiO1xudmFyIGRzY3kgPSBcItGVXCI7XG52YXIgZHNvbCA9IFwi4qe2XCI7XG52YXIgRHN0cm9rID0gXCLEkFwiO1xudmFyIGRzdHJvayA9IFwixJFcIjtcbnZhciBkdGRvdCA9IFwi4ouxXCI7XG52YXIgZHRyaSA9IFwi4pa/XCI7XG52YXIgZHRyaWYgPSBcIuKWvlwiO1xudmFyIGR1YXJyID0gXCLih7VcIjtcbnZhciBkdWhhciA9IFwi4qWvXCI7XG52YXIgZHdhbmdsZSA9IFwi4qamXCI7XG52YXIgRFpjeSA9IFwi0I9cIjtcbnZhciBkemN5ID0gXCLRn1wiO1xudmFyIGR6aWdyYXJyID0gXCLin79cIjtcbnZhciBFYWN1dGUkMSA9IFwiw4lcIjtcbnZhciBlYWN1dGUkMSA9IFwiw6lcIjtcbnZhciBlYXN0ZXIgPSBcIuKprlwiO1xudmFyIEVjYXJvbiA9IFwixJpcIjtcbnZhciBlY2Fyb24gPSBcIsSbXCI7XG52YXIgRWNpcmMkMSA9IFwiw4pcIjtcbnZhciBlY2lyYyQxID0gXCLDqlwiO1xudmFyIGVjaXIgPSBcIuKJllwiO1xudmFyIGVjb2xvbiA9IFwi4omVXCI7XG52YXIgRWN5ID0gXCLQrVwiO1xudmFyIGVjeSA9IFwi0Y1cIjtcbnZhciBlRERvdCA9IFwi4qm3XCI7XG52YXIgRWRvdCA9IFwixJZcIjtcbnZhciBlZG90ID0gXCLEl1wiO1xudmFyIGVEb3QgPSBcIuKJkVwiO1xudmFyIGVlID0gXCLihYdcIjtcbnZhciBlZkRvdCA9IFwi4omSXCI7XG52YXIgRWZyID0gXCLwnZSIXCI7XG52YXIgZWZyID0gXCLwnZSiXCI7XG52YXIgZWcgPSBcIuKqmlwiO1xudmFyIEVncmF2ZSQxID0gXCLDiFwiO1xudmFyIGVncmF2ZSQxID0gXCLDqFwiO1xudmFyIGVncyA9IFwi4qqWXCI7XG52YXIgZWdzZG90ID0gXCLiqphcIjtcbnZhciBlbCA9IFwi4qqZXCI7XG52YXIgRWxlbWVudCQxID0gXCLiiIhcIjtcbnZhciBlbGludGVycyA9IFwi4o+nXCI7XG52YXIgZWxsID0gXCLihJNcIjtcbnZhciBlbHMgPSBcIuKqlVwiO1xudmFyIGVsc2RvdCA9IFwi4qqXXCI7XG52YXIgRW1hY3IgPSBcIsSSXCI7XG52YXIgZW1hY3IgPSBcIsSTXCI7XG52YXIgZW1wdHkgPSBcIuKIhVwiO1xudmFyIGVtcHR5c2V0ID0gXCLiiIVcIjtcbnZhciBFbXB0eVNtYWxsU3F1YXJlID0gXCLil7tcIjtcbnZhciBlbXB0eXYgPSBcIuKIhVwiO1xudmFyIEVtcHR5VmVyeVNtYWxsU3F1YXJlID0gXCLilqtcIjtcbnZhciBlbXNwMTMgPSBcIuKAhFwiO1xudmFyIGVtc3AxNCA9IFwi4oCFXCI7XG52YXIgZW1zcCA9IFwi4oCDXCI7XG52YXIgRU5HID0gXCLFilwiO1xudmFyIGVuZyA9IFwixYtcIjtcbnZhciBlbnNwID0gXCLigIJcIjtcbnZhciBFb2dvbiA9IFwixJhcIjtcbnZhciBlb2dvbiA9IFwixJlcIjtcbnZhciBFb3BmID0gXCLwnZS8XCI7XG52YXIgZW9wZiA9IFwi8J2VllwiO1xudmFyIGVwYXIgPSBcIuKLlVwiO1xudmFyIGVwYXJzbCA9IFwi4qejXCI7XG52YXIgZXBsdXMgPSBcIuKpsVwiO1xudmFyIGVwc2kgPSBcIs61XCI7XG52YXIgRXBzaWxvbiA9IFwizpVcIjtcbnZhciBlcHNpbG9uID0gXCLOtVwiO1xudmFyIGVwc2l2ID0gXCLPtVwiO1xudmFyIGVxY2lyYyA9IFwi4omWXCI7XG52YXIgZXFjb2xvbiA9IFwi4omVXCI7XG52YXIgZXFzaW0gPSBcIuKJglwiO1xudmFyIGVxc2xhbnRndHIgPSBcIuKqllwiO1xudmFyIGVxc2xhbnRsZXNzID0gXCLiqpVcIjtcbnZhciBFcXVhbCA9IFwi4qm1XCI7XG52YXIgZXF1YWxzID0gXCI9XCI7XG52YXIgRXF1YWxUaWxkZSA9IFwi4omCXCI7XG52YXIgZXF1ZXN0ID0gXCLiiZ9cIjtcbnZhciBFcXVpbGlicml1bSA9IFwi4oeMXCI7XG52YXIgZXF1aXYgPSBcIuKJoVwiO1xudmFyIGVxdWl2REQgPSBcIuKpuFwiO1xudmFyIGVxdnBhcnNsID0gXCLip6VcIjtcbnZhciBlcmFyciA9IFwi4qWxXCI7XG52YXIgZXJEb3QgPSBcIuKJk1wiO1xudmFyIGVzY3IgPSBcIuKEr1wiO1xudmFyIEVzY3IgPSBcIuKEsFwiO1xudmFyIGVzZG90ID0gXCLiiZBcIjtcbnZhciBFc2ltID0gXCLiqbNcIjtcbnZhciBlc2ltID0gXCLiiYJcIjtcbnZhciBFdGEgPSBcIs6XXCI7XG52YXIgZXRhID0gXCLOt1wiO1xudmFyIEVUSCQxID0gXCLDkFwiO1xudmFyIGV0aCQxID0gXCLDsFwiO1xudmFyIEV1bWwkMSA9IFwiw4tcIjtcbnZhciBldW1sJDEgPSBcIsOrXCI7XG52YXIgZXVybyA9IFwi4oKsXCI7XG52YXIgZXhjbCA9IFwiIVwiO1xudmFyIGV4aXN0ID0gXCLiiINcIjtcbnZhciBFeGlzdHMgPSBcIuKIg1wiO1xudmFyIGV4cGVjdGF0aW9uID0gXCLihLBcIjtcbnZhciBleHBvbmVudGlhbGUgPSBcIuKFh1wiO1xudmFyIEV4cG9uZW50aWFsRSA9IFwi4oWHXCI7XG52YXIgZmFsbGluZ2RvdHNlcSA9IFwi4omSXCI7XG52YXIgRmN5ID0gXCLQpFwiO1xudmFyIGZjeSA9IFwi0YRcIjtcbnZhciBmZW1hbGUgPSBcIuKZgFwiO1xudmFyIGZmaWxpZyA9IFwi76yDXCI7XG52YXIgZmZsaWcgPSBcIu+sgFwiO1xudmFyIGZmbGxpZyA9IFwi76yEXCI7XG52YXIgRmZyID0gXCLwnZSJXCI7XG52YXIgZmZyID0gXCLwnZSjXCI7XG52YXIgZmlsaWcgPSBcIu+sgVwiO1xudmFyIEZpbGxlZFNtYWxsU3F1YXJlID0gXCLil7xcIjtcbnZhciBGaWxsZWRWZXJ5U21hbGxTcXVhcmUgPSBcIuKWqlwiO1xudmFyIGZqbGlnID0gXCJmalwiO1xudmFyIGZsYXQgPSBcIuKZrVwiO1xudmFyIGZsbGlnID0gXCLvrIJcIjtcbnZhciBmbHRucyA9IFwi4paxXCI7XG52YXIgZm5vZiA9IFwixpJcIjtcbnZhciBGb3BmID0gXCLwnZS9XCI7XG52YXIgZm9wZiA9IFwi8J2Vl1wiO1xudmFyIGZvcmFsbCA9IFwi4oiAXCI7XG52YXIgRm9yQWxsID0gXCLiiIBcIjtcbnZhciBmb3JrID0gXCLii5RcIjtcbnZhciBmb3JrdiA9IFwi4quZXCI7XG52YXIgRm91cmllcnRyZiA9IFwi4oSxXCI7XG52YXIgZnBhcnRpbnQgPSBcIuKojVwiO1xudmFyIGZyYWMxMiQxID0gXCLCvVwiO1xudmFyIGZyYWMxMyA9IFwi4oWTXCI7XG52YXIgZnJhYzE0JDEgPSBcIsK8XCI7XG52YXIgZnJhYzE1ID0gXCLihZVcIjtcbnZhciBmcmFjMTYgPSBcIuKFmVwiO1xudmFyIGZyYWMxOCA9IFwi4oWbXCI7XG52YXIgZnJhYzIzID0gXCLihZRcIjtcbnZhciBmcmFjMjUgPSBcIuKFllwiO1xudmFyIGZyYWMzNCQxID0gXCLCvlwiO1xudmFyIGZyYWMzNSA9IFwi4oWXXCI7XG52YXIgZnJhYzM4ID0gXCLihZxcIjtcbnZhciBmcmFjNDUgPSBcIuKFmFwiO1xudmFyIGZyYWM1NiA9IFwi4oWaXCI7XG52YXIgZnJhYzU4ID0gXCLihZ1cIjtcbnZhciBmcmFjNzggPSBcIuKFnlwiO1xudmFyIGZyYXNsID0gXCLigYRcIjtcbnZhciBmcm93biA9IFwi4oyiXCI7XG52YXIgZnNjciA9IFwi8J2Su1wiO1xudmFyIEZzY3IgPSBcIuKEsVwiO1xudmFyIGdhY3V0ZSA9IFwix7VcIjtcbnZhciBHYW1tYSA9IFwizpNcIjtcbnZhciBnYW1tYSA9IFwizrNcIjtcbnZhciBHYW1tYWQgPSBcIs+cXCI7XG52YXIgZ2FtbWFkID0gXCLPnVwiO1xudmFyIGdhcCA9IFwi4qqGXCI7XG52YXIgR2JyZXZlID0gXCLEnlwiO1xudmFyIGdicmV2ZSA9IFwixJ9cIjtcbnZhciBHY2VkaWwgPSBcIsSiXCI7XG52YXIgR2NpcmMgPSBcIsScXCI7XG52YXIgZ2NpcmMgPSBcIsSdXCI7XG52YXIgR2N5ID0gXCLQk1wiO1xudmFyIGdjeSA9IFwi0LNcIjtcbnZhciBHZG90ID0gXCLEoFwiO1xudmFyIGdkb3QgPSBcIsShXCI7XG52YXIgZ2UgPSBcIuKJpVwiO1xudmFyIGdFID0gXCLiiadcIjtcbnZhciBnRWwgPSBcIuKqjFwiO1xudmFyIGdlbCA9IFwi4oubXCI7XG52YXIgZ2VxID0gXCLiiaVcIjtcbnZhciBnZXFxID0gXCLiiadcIjtcbnZhciBnZXFzbGFudCA9IFwi4qm+XCI7XG52YXIgZ2VzY2MgPSBcIuKqqVwiO1xudmFyIGdlcyA9IFwi4qm+XCI7XG52YXIgZ2VzZG90ID0gXCLiqoBcIjtcbnZhciBnZXNkb3RvID0gXCLiqoJcIjtcbnZhciBnZXNkb3RvbCA9IFwi4qqEXCI7XG52YXIgZ2VzbCA9IFwi4oub77iAXCI7XG52YXIgZ2VzbGVzID0gXCLiqpRcIjtcbnZhciBHZnIgPSBcIvCdlIpcIjtcbnZhciBnZnIgPSBcIvCdlKRcIjtcbnZhciBnZyA9IFwi4omrXCI7XG52YXIgR2cgPSBcIuKLmVwiO1xudmFyIGdnZyA9IFwi4ouZXCI7XG52YXIgZ2ltZWwgPSBcIuKEt1wiO1xudmFyIEdKY3kgPSBcItCDXCI7XG52YXIgZ2pjeSA9IFwi0ZNcIjtcbnZhciBnbGEgPSBcIuKqpVwiO1xudmFyIGdsID0gXCLiibdcIjtcbnZhciBnbEUgPSBcIuKqklwiO1xudmFyIGdsaiA9IFwi4qqkXCI7XG52YXIgZ25hcCA9IFwi4qqKXCI7XG52YXIgZ25hcHByb3ggPSBcIuKqilwiO1xudmFyIGduZSA9IFwi4qqIXCI7XG52YXIgZ25FID0gXCLiialcIjtcbnZhciBnbmVxID0gXCLiqohcIjtcbnZhciBnbmVxcSA9IFwi4ompXCI7XG52YXIgZ25zaW0gPSBcIuKLp1wiO1xudmFyIEdvcGYgPSBcIvCdlL5cIjtcbnZhciBnb3BmID0gXCLwnZWYXCI7XG52YXIgZ3JhdmUgPSBcImBcIjtcbnZhciBHcmVhdGVyRXF1YWwgPSBcIuKJpVwiO1xudmFyIEdyZWF0ZXJFcXVhbExlc3MgPSBcIuKLm1wiO1xudmFyIEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp1wiO1xudmFyIEdyZWF0ZXJHcmVhdGVyID0gXCLiqqJcIjtcbnZhciBHcmVhdGVyTGVzcyA9IFwi4om3XCI7XG52YXIgR3JlYXRlclNsYW50RXF1YWwgPSBcIuKpvlwiO1xudmFyIEdyZWF0ZXJUaWxkZSA9IFwi4omzXCI7XG52YXIgR3NjciA9IFwi8J2SolwiO1xudmFyIGdzY3IgPSBcIuKEilwiO1xudmFyIGdzaW0gPSBcIuKJs1wiO1xudmFyIGdzaW1lID0gXCLiqo5cIjtcbnZhciBnc2ltbCA9IFwi4qqQXCI7XG52YXIgZ3RjYyA9IFwi4qqnXCI7XG52YXIgZ3RjaXIgPSBcIuKpulwiO1xudmFyIGd0JDIgPSBcIj5cIjtcbnZhciBHVCQxID0gXCI+XCI7XG52YXIgR3QgPSBcIuKJq1wiO1xudmFyIGd0ZG90ID0gXCLii5dcIjtcbnZhciBndGxQYXIgPSBcIuKmlVwiO1xudmFyIGd0cXVlc3QgPSBcIuKpvFwiO1xudmFyIGd0cmFwcHJveCA9IFwi4qqGXCI7XG52YXIgZ3RyYXJyID0gXCLipbhcIjtcbnZhciBndHJkb3QgPSBcIuKLl1wiO1xudmFyIGd0cmVxbGVzcyA9IFwi4oubXCI7XG52YXIgZ3RyZXFxbGVzcyA9IFwi4qqMXCI7XG52YXIgZ3RybGVzcyA9IFwi4om3XCI7XG52YXIgZ3Ryc2ltID0gXCLiibNcIjtcbnZhciBndmVydG5lcXEgPSBcIuKJqe+4gFwiO1xudmFyIGd2bkUgPSBcIuKJqe+4gFwiO1xudmFyIEhhY2VrID0gXCLLh1wiO1xudmFyIGhhaXJzcCA9IFwi4oCKXCI7XG52YXIgaGFsZiA9IFwiwr1cIjtcbnZhciBoYW1pbHQgPSBcIuKEi1wiO1xudmFyIEhBUkRjeSA9IFwi0KpcIjtcbnZhciBoYXJkY3kgPSBcItGKXCI7XG52YXIgaGFycmNpciA9IFwi4qWIXCI7XG52YXIgaGFyciA9IFwi4oaUXCI7XG52YXIgaEFyciA9IFwi4oeUXCI7XG52YXIgaGFycncgPSBcIuKGrVwiO1xudmFyIEhhdCA9IFwiXlwiO1xudmFyIGhiYXIgPSBcIuKEj1wiO1xudmFyIEhjaXJjID0gXCLEpFwiO1xudmFyIGhjaXJjID0gXCLEpVwiO1xudmFyIGhlYXJ0cyA9IFwi4pmlXCI7XG52YXIgaGVhcnRzdWl0ID0gXCLimaVcIjtcbnZhciBoZWxsaXAgPSBcIuKAplwiO1xudmFyIGhlcmNvbiA9IFwi4oq5XCI7XG52YXIgaGZyID0gXCLwnZSlXCI7XG52YXIgSGZyID0gXCLihIxcIjtcbnZhciBIaWxiZXJ0U3BhY2UgPSBcIuKEi1wiO1xudmFyIGhrc2Vhcm93ID0gXCLipKVcIjtcbnZhciBoa3N3YXJvdyA9IFwi4qSmXCI7XG52YXIgaG9hcnIgPSBcIuKHv1wiO1xudmFyIGhvbXRodCA9IFwi4oi7XCI7XG52YXIgaG9va2xlZnRhcnJvdyA9IFwi4oapXCI7XG52YXIgaG9va3JpZ2h0YXJyb3cgPSBcIuKGqlwiO1xudmFyIGhvcGYgPSBcIvCdlZlcIjtcbnZhciBIb3BmID0gXCLihI1cIjtcbnZhciBob3JiYXIgPSBcIuKAlVwiO1xudmFyIEhvcml6b250YWxMaW5lID0gXCLilIBcIjtcbnZhciBoc2NyID0gXCLwnZK9XCI7XG52YXIgSHNjciA9IFwi4oSLXCI7XG52YXIgaHNsYXNoID0gXCLihI9cIjtcbnZhciBIc3Ryb2sgPSBcIsSmXCI7XG52YXIgaHN0cm9rID0gXCLEp1wiO1xudmFyIEh1bXBEb3duSHVtcCA9IFwi4omOXCI7XG52YXIgSHVtcEVxdWFsID0gXCLiiY9cIjtcbnZhciBoeWJ1bGwgPSBcIuKBg1wiO1xudmFyIGh5cGhlbiA9IFwi4oCQXCI7XG52YXIgSWFjdXRlJDEgPSBcIsONXCI7XG52YXIgaWFjdXRlJDEgPSBcIsOtXCI7XG52YXIgaWMgPSBcIuKBo1wiO1xudmFyIEljaXJjJDEgPSBcIsOOXCI7XG52YXIgaWNpcmMkMSA9IFwiw65cIjtcbnZhciBJY3kgPSBcItCYXCI7XG52YXIgaWN5ID0gXCLQuFwiO1xudmFyIElkb3QgPSBcIsSwXCI7XG52YXIgSUVjeSA9IFwi0JVcIjtcbnZhciBpZWN5ID0gXCLQtVwiO1xudmFyIGlleGNsJDEgPSBcIsKhXCI7XG52YXIgaWZmID0gXCLih5RcIjtcbnZhciBpZnIgPSBcIvCdlKZcIjtcbnZhciBJZnIgPSBcIuKEkVwiO1xudmFyIElncmF2ZSQxID0gXCLDjFwiO1xudmFyIGlncmF2ZSQxID0gXCLDrFwiO1xudmFyIGlpID0gXCLihYhcIjtcbnZhciBpaWlpbnQgPSBcIuKojFwiO1xudmFyIGlpaW50ID0gXCLiiK1cIjtcbnZhciBpaW5maW4gPSBcIuKnnFwiO1xudmFyIGlpb3RhID0gXCLihKlcIjtcbnZhciBJSmxpZyA9IFwixLJcIjtcbnZhciBpamxpZyA9IFwixLNcIjtcbnZhciBJbWFjciA9IFwixKpcIjtcbnZhciBpbWFjciA9IFwixKtcIjtcbnZhciBpbWFnZSA9IFwi4oSRXCI7XG52YXIgSW1hZ2luYXJ5SSA9IFwi4oWIXCI7XG52YXIgaW1hZ2xpbmUgPSBcIuKEkFwiO1xudmFyIGltYWdwYXJ0ID0gXCLihJFcIjtcbnZhciBpbWF0aCA9IFwixLFcIjtcbnZhciBJbSA9IFwi4oSRXCI7XG52YXIgaW1vZiA9IFwi4oq3XCI7XG52YXIgaW1wZWQgPSBcIsa1XCI7XG52YXIgSW1wbGllcyA9IFwi4oeSXCI7XG52YXIgaW5jYXJlID0gXCLihIVcIjtcbnZhciBpbmZpbiA9IFwi4oieXCI7XG52YXIgaW5maW50aWUgPSBcIuKnnVwiO1xudmFyIGlub2RvdCA9IFwixLFcIjtcbnZhciBpbnRjYWwgPSBcIuKKulwiO1xudmFyIGludCA9IFwi4oirXCI7XG52YXIgSW50ID0gXCLiiKxcIjtcbnZhciBpbnRlZ2VycyA9IFwi4oSkXCI7XG52YXIgSW50ZWdyYWwgPSBcIuKIq1wiO1xudmFyIGludGVyY2FsID0gXCLiirpcIjtcbnZhciBJbnRlcnNlY3Rpb24gPSBcIuKLglwiO1xudmFyIGludGxhcmhrID0gXCLiqJdcIjtcbnZhciBpbnRwcm9kID0gXCLiqLxcIjtcbnZhciBJbnZpc2libGVDb21tYSA9IFwi4oGjXCI7XG52YXIgSW52aXNpYmxlVGltZXMgPSBcIuKBolwiO1xudmFyIElPY3kgPSBcItCBXCI7XG52YXIgaW9jeSA9IFwi0ZFcIjtcbnZhciBJb2dvbiA9IFwixK5cIjtcbnZhciBpb2dvbiA9IFwixK9cIjtcbnZhciBJb3BmID0gXCLwnZWAXCI7XG52YXIgaW9wZiA9IFwi8J2VmlwiO1xudmFyIElvdGEgPSBcIs6ZXCI7XG52YXIgaW90YSA9IFwizrlcIjtcbnZhciBpcHJvZCA9IFwi4qi8XCI7XG52YXIgaXF1ZXN0JDEgPSBcIsK/XCI7XG52YXIgaXNjciA9IFwi8J2SvlwiO1xudmFyIElzY3IgPSBcIuKEkFwiO1xudmFyIGlzaW4gPSBcIuKIiFwiO1xudmFyIGlzaW5kb3QgPSBcIuKLtVwiO1xudmFyIGlzaW5FID0gXCLii7lcIjtcbnZhciBpc2lucyA9IFwi4ou0XCI7XG52YXIgaXNpbnN2ID0gXCLii7NcIjtcbnZhciBpc2ludiA9IFwi4oiIXCI7XG52YXIgaXQgPSBcIuKBolwiO1xudmFyIEl0aWxkZSA9IFwixKhcIjtcbnZhciBpdGlsZGUgPSBcIsSpXCI7XG52YXIgSXVrY3kgPSBcItCGXCI7XG52YXIgaXVrY3kgPSBcItGWXCI7XG52YXIgSXVtbCQxID0gXCLDj1wiO1xudmFyIGl1bWwkMSA9IFwiw69cIjtcbnZhciBKY2lyYyA9IFwixLRcIjtcbnZhciBqY2lyYyA9IFwixLVcIjtcbnZhciBKY3kgPSBcItCZXCI7XG52YXIgamN5ID0gXCLQuVwiO1xudmFyIEpmciA9IFwi8J2UjVwiO1xudmFyIGpmciA9IFwi8J2Up1wiO1xudmFyIGptYXRoID0gXCLIt1wiO1xudmFyIEpvcGYgPSBcIvCdlYFcIjtcbnZhciBqb3BmID0gXCLwnZWbXCI7XG52YXIgSnNjciA9IFwi8J2SpVwiO1xudmFyIGpzY3IgPSBcIvCdkr9cIjtcbnZhciBKc2VyY3kgPSBcItCIXCI7XG52YXIganNlcmN5ID0gXCLRmFwiO1xudmFyIEp1a2N5ID0gXCLQhFwiO1xudmFyIGp1a2N5ID0gXCLRlFwiO1xudmFyIEthcHBhID0gXCLOmlwiO1xudmFyIGthcHBhID0gXCLOulwiO1xudmFyIGthcHBhdiA9IFwiz7BcIjtcbnZhciBLY2VkaWwgPSBcIsS2XCI7XG52YXIga2NlZGlsID0gXCLEt1wiO1xudmFyIEtjeSA9IFwi0JpcIjtcbnZhciBrY3kgPSBcItC6XCI7XG52YXIgS2ZyID0gXCLwnZSOXCI7XG52YXIga2ZyID0gXCLwnZSoXCI7XG52YXIga2dyZWVuID0gXCLEuFwiO1xudmFyIEtIY3kgPSBcItClXCI7XG52YXIga2hjeSA9IFwi0YVcIjtcbnZhciBLSmN5ID0gXCLQjFwiO1xudmFyIGtqY3kgPSBcItGcXCI7XG52YXIgS29wZiA9IFwi8J2VglwiO1xudmFyIGtvcGYgPSBcIvCdlZxcIjtcbnZhciBLc2NyID0gXCLwnZKmXCI7XG52YXIga3NjciA9IFwi8J2TgFwiO1xudmFyIGxBYXJyID0gXCLih5pcIjtcbnZhciBMYWN1dGUgPSBcIsS5XCI7XG52YXIgbGFjdXRlID0gXCLEulwiO1xudmFyIGxhZW1wdHl2ID0gXCLiprRcIjtcbnZhciBsYWdyYW4gPSBcIuKEklwiO1xudmFyIExhbWJkYSA9IFwizptcIjtcbnZhciBsYW1iZGEgPSBcIs67XCI7XG52YXIgbGFuZyA9IFwi4p+oXCI7XG52YXIgTGFuZyA9IFwi4p+qXCI7XG52YXIgbGFuZ2QgPSBcIuKmkVwiO1xudmFyIGxhbmdsZSA9IFwi4p+oXCI7XG52YXIgbGFwID0gXCLiqoVcIjtcbnZhciBMYXBsYWNldHJmID0gXCLihJJcIjtcbnZhciBsYXF1byQxID0gXCLCq1wiO1xudmFyIGxhcnJiID0gXCLih6RcIjtcbnZhciBsYXJyYmZzID0gXCLipJ9cIjtcbnZhciBsYXJyID0gXCLihpBcIjtcbnZhciBMYXJyID0gXCLihp5cIjtcbnZhciBsQXJyID0gXCLih5BcIjtcbnZhciBsYXJyZnMgPSBcIuKknVwiO1xudmFyIGxhcnJoayA9IFwi4oapXCI7XG52YXIgbGFycmxwID0gXCLihqtcIjtcbnZhciBsYXJycGwgPSBcIuKkuVwiO1xudmFyIGxhcnJzaW0gPSBcIuKls1wiO1xudmFyIGxhcnJ0bCA9IFwi4oaiXCI7XG52YXIgbGF0YWlsID0gXCLipJlcIjtcbnZhciBsQXRhaWwgPSBcIuKkm1wiO1xudmFyIGxhdCA9IFwi4qqrXCI7XG52YXIgbGF0ZSA9IFwi4qqtXCI7XG52YXIgbGF0ZXMgPSBcIuKqre+4gFwiO1xudmFyIGxiYXJyID0gXCLipIxcIjtcbnZhciBsQmFyciA9IFwi4qSOXCI7XG52YXIgbGJicmsgPSBcIuKdslwiO1xudmFyIGxicmFjZSA9IFwie1wiO1xudmFyIGxicmFjayA9IFwiW1wiO1xudmFyIGxicmtlID0gXCLipotcIjtcbnZhciBsYnJrc2xkID0gXCLipo9cIjtcbnZhciBsYnJrc2x1ID0gXCLipo1cIjtcbnZhciBMY2Fyb24gPSBcIsS9XCI7XG52YXIgbGNhcm9uID0gXCLEvlwiO1xudmFyIExjZWRpbCA9IFwixLtcIjtcbnZhciBsY2VkaWwgPSBcIsS8XCI7XG52YXIgbGNlaWwgPSBcIuKMiFwiO1xudmFyIGxjdWIgPSBcIntcIjtcbnZhciBMY3kgPSBcItCbXCI7XG52YXIgbGN5ID0gXCLQu1wiO1xudmFyIGxkY2EgPSBcIuKktlwiO1xudmFyIGxkcXVvID0gXCLigJxcIjtcbnZhciBsZHF1b3IgPSBcIuKAnlwiO1xudmFyIGxkcmRoYXIgPSBcIuKlp1wiO1xudmFyIGxkcnVzaGFyID0gXCLipYtcIjtcbnZhciBsZHNoID0gXCLihrJcIjtcbnZhciBsZSA9IFwi4omkXCI7XG52YXIgbEUgPSBcIuKJplwiO1xudmFyIExlZnRBbmdsZUJyYWNrZXQgPSBcIuKfqFwiO1xudmFyIExlZnRBcnJvd0JhciA9IFwi4oekXCI7XG52YXIgbGVmdGFycm93ID0gXCLihpBcIjtcbnZhciBMZWZ0QXJyb3cgPSBcIuKGkFwiO1xudmFyIExlZnRhcnJvdyA9IFwi4oeQXCI7XG52YXIgTGVmdEFycm93UmlnaHRBcnJvdyA9IFwi4oeGXCI7XG52YXIgbGVmdGFycm93dGFpbCA9IFwi4oaiXCI7XG52YXIgTGVmdENlaWxpbmcgPSBcIuKMiFwiO1xudmFyIExlZnREb3VibGVCcmFja2V0ID0gXCLin6ZcIjtcbnZhciBMZWZ0RG93blRlZVZlY3RvciA9IFwi4qWhXCI7XG52YXIgTGVmdERvd25WZWN0b3JCYXIgPSBcIuKlmVwiO1xudmFyIExlZnREb3duVmVjdG9yID0gXCLih4NcIjtcbnZhciBMZWZ0Rmxvb3IgPSBcIuKMilwiO1xudmFyIGxlZnRoYXJwb29uZG93biA9IFwi4oa9XCI7XG52YXIgbGVmdGhhcnBvb251cCA9IFwi4oa8XCI7XG52YXIgbGVmdGxlZnRhcnJvd3MgPSBcIuKHh1wiO1xudmFyIGxlZnRyaWdodGFycm93ID0gXCLihpRcIjtcbnZhciBMZWZ0UmlnaHRBcnJvdyA9IFwi4oaUXCI7XG52YXIgTGVmdHJpZ2h0YXJyb3cgPSBcIuKHlFwiO1xudmFyIGxlZnRyaWdodGFycm93cyA9IFwi4oeGXCI7XG52YXIgbGVmdHJpZ2h0aGFycG9vbnMgPSBcIuKHi1wiO1xudmFyIGxlZnRyaWdodHNxdWlnYXJyb3cgPSBcIuKGrVwiO1xudmFyIExlZnRSaWdodFZlY3RvciA9IFwi4qWOXCI7XG52YXIgTGVmdFRlZUFycm93ID0gXCLihqRcIjtcbnZhciBMZWZ0VGVlID0gXCLiiqNcIjtcbnZhciBMZWZ0VGVlVmVjdG9yID0gXCLipZpcIjtcbnZhciBsZWZ0dGhyZWV0aW1lcyA9IFwi4ouLXCI7XG52YXIgTGVmdFRyaWFuZ2xlQmFyID0gXCLip49cIjtcbnZhciBMZWZ0VHJpYW5nbGUgPSBcIuKKslwiO1xudmFyIExlZnRUcmlhbmdsZUVxdWFsID0gXCLiirRcIjtcbnZhciBMZWZ0VXBEb3duVmVjdG9yID0gXCLipZFcIjtcbnZhciBMZWZ0VXBUZWVWZWN0b3IgPSBcIuKloFwiO1xudmFyIExlZnRVcFZlY3RvckJhciA9IFwi4qWYXCI7XG52YXIgTGVmdFVwVmVjdG9yID0gXCLihr9cIjtcbnZhciBMZWZ0VmVjdG9yQmFyID0gXCLipZJcIjtcbnZhciBMZWZ0VmVjdG9yID0gXCLihrxcIjtcbnZhciBsRWcgPSBcIuKqi1wiO1xudmFyIGxlZyA9IFwi4ouaXCI7XG52YXIgbGVxID0gXCLiiaRcIjtcbnZhciBsZXFxID0gXCLiiaZcIjtcbnZhciBsZXFzbGFudCA9IFwi4qm9XCI7XG52YXIgbGVzY2MgPSBcIuKqqFwiO1xudmFyIGxlcyA9IFwi4qm9XCI7XG52YXIgbGVzZG90ID0gXCLiqb9cIjtcbnZhciBsZXNkb3RvID0gXCLiqoFcIjtcbnZhciBsZXNkb3RvciA9IFwi4qqDXCI7XG52YXIgbGVzZyA9IFwi4oua77iAXCI7XG52YXIgbGVzZ2VzID0gXCLiqpNcIjtcbnZhciBsZXNzYXBwcm94ID0gXCLiqoVcIjtcbnZhciBsZXNzZG90ID0gXCLii5ZcIjtcbnZhciBsZXNzZXFndHIgPSBcIuKLmlwiO1xudmFyIGxlc3NlcXFndHIgPSBcIuKqi1wiO1xudmFyIExlc3NFcXVhbEdyZWF0ZXIgPSBcIuKLmlwiO1xudmFyIExlc3NGdWxsRXF1YWwgPSBcIuKJplwiO1xudmFyIExlc3NHcmVhdGVyID0gXCLiibZcIjtcbnZhciBsZXNzZ3RyID0gXCLiibZcIjtcbnZhciBMZXNzTGVzcyA9IFwi4qqhXCI7XG52YXIgbGVzc3NpbSA9IFwi4omyXCI7XG52YXIgTGVzc1NsYW50RXF1YWwgPSBcIuKpvVwiO1xudmFyIExlc3NUaWxkZSA9IFwi4omyXCI7XG52YXIgbGZpc2h0ID0gXCLipbxcIjtcbnZhciBsZmxvb3IgPSBcIuKMilwiO1xudmFyIExmciA9IFwi8J2Uj1wiO1xudmFyIGxmciA9IFwi8J2UqVwiO1xudmFyIGxnID0gXCLiibZcIjtcbnZhciBsZ0UgPSBcIuKqkVwiO1xudmFyIGxIYXIgPSBcIuKlolwiO1xudmFyIGxoYXJkID0gXCLihr1cIjtcbnZhciBsaGFydSA9IFwi4oa8XCI7XG52YXIgbGhhcnVsID0gXCLipapcIjtcbnZhciBsaGJsayA9IFwi4paEXCI7XG52YXIgTEpjeSA9IFwi0IlcIjtcbnZhciBsamN5ID0gXCLRmVwiO1xudmFyIGxsYXJyID0gXCLih4dcIjtcbnZhciBsbCA9IFwi4omqXCI7XG52YXIgTGwgPSBcIuKLmFwiO1xudmFyIGxsY29ybmVyID0gXCLijJ5cIjtcbnZhciBMbGVmdGFycm93ID0gXCLih5pcIjtcbnZhciBsbGhhcmQgPSBcIuKlq1wiO1xudmFyIGxsdHJpID0gXCLil7pcIjtcbnZhciBMbWlkb3QgPSBcIsS/XCI7XG52YXIgbG1pZG90ID0gXCLFgFwiO1xudmFyIGxtb3VzdGFjaGUgPSBcIuKOsFwiO1xudmFyIGxtb3VzdCA9IFwi4o6wXCI7XG52YXIgbG5hcCA9IFwi4qqJXCI7XG52YXIgbG5hcHByb3ggPSBcIuKqiVwiO1xudmFyIGxuZSA9IFwi4qqHXCI7XG52YXIgbG5FID0gXCLiiahcIjtcbnZhciBsbmVxID0gXCLiqodcIjtcbnZhciBsbmVxcSA9IFwi4omoXCI7XG52YXIgbG5zaW0gPSBcIuKLplwiO1xudmFyIGxvYW5nID0gXCLin6xcIjtcbnZhciBsb2FyciA9IFwi4oe9XCI7XG52YXIgbG9icmsgPSBcIuKfplwiO1xudmFyIGxvbmdsZWZ0YXJyb3cgPSBcIuKftVwiO1xudmFyIExvbmdMZWZ0QXJyb3cgPSBcIuKftVwiO1xudmFyIExvbmdsZWZ0YXJyb3cgPSBcIuKfuFwiO1xudmFyIGxvbmdsZWZ0cmlnaHRhcnJvdyA9IFwi4p+3XCI7XG52YXIgTG9uZ0xlZnRSaWdodEFycm93ID0gXCLin7dcIjtcbnZhciBMb25nbGVmdHJpZ2h0YXJyb3cgPSBcIuKfulwiO1xudmFyIGxvbmdtYXBzdG8gPSBcIuKfvFwiO1xudmFyIGxvbmdyaWdodGFycm93ID0gXCLin7ZcIjtcbnZhciBMb25nUmlnaHRBcnJvdyA9IFwi4p+2XCI7XG52YXIgTG9uZ3JpZ2h0YXJyb3cgPSBcIuKfuVwiO1xudmFyIGxvb3BhcnJvd2xlZnQgPSBcIuKGq1wiO1xudmFyIGxvb3BhcnJvd3JpZ2h0ID0gXCLihqxcIjtcbnZhciBsb3BhciA9IFwi4qaFXCI7XG52YXIgTG9wZiA9IFwi8J2Vg1wiO1xudmFyIGxvcGYgPSBcIvCdlZ1cIjtcbnZhciBsb3BsdXMgPSBcIuKorVwiO1xudmFyIGxvdGltZXMgPSBcIuKotFwiO1xudmFyIGxvd2FzdCA9IFwi4oiXXCI7XG52YXIgbG93YmFyID0gXCJfXCI7XG52YXIgTG93ZXJMZWZ0QXJyb3cgPSBcIuKGmVwiO1xudmFyIExvd2VyUmlnaHRBcnJvdyA9IFwi4oaYXCI7XG52YXIgbG96ID0gXCLil4pcIjtcbnZhciBsb3plbmdlID0gXCLil4pcIjtcbnZhciBsb3pmID0gXCLip6tcIjtcbnZhciBscGFyID0gXCIoXCI7XG52YXIgbHBhcmx0ID0gXCLippNcIjtcbnZhciBscmFyciA9IFwi4oeGXCI7XG52YXIgbHJjb3JuZXIgPSBcIuKMn1wiO1xudmFyIGxyaGFyID0gXCLih4tcIjtcbnZhciBscmhhcmQgPSBcIuKlrVwiO1xudmFyIGxybSA9IFwi4oCOXCI7XG52YXIgbHJ0cmkgPSBcIuKKv1wiO1xudmFyIGxzYXF1byA9IFwi4oC5XCI7XG52YXIgbHNjciA9IFwi8J2TgVwiO1xudmFyIExzY3IgPSBcIuKEklwiO1xudmFyIGxzaCA9IFwi4oawXCI7XG52YXIgTHNoID0gXCLihrBcIjtcbnZhciBsc2ltID0gXCLiibJcIjtcbnZhciBsc2ltZSA9IFwi4qqNXCI7XG52YXIgbHNpbWcgPSBcIuKqj1wiO1xudmFyIGxzcWIgPSBcIltcIjtcbnZhciBsc3F1byA9IFwi4oCYXCI7XG52YXIgbHNxdW9yID0gXCLigJpcIjtcbnZhciBMc3Ryb2sgPSBcIsWBXCI7XG52YXIgbHN0cm9rID0gXCLFglwiO1xudmFyIGx0Y2MgPSBcIuKqplwiO1xudmFyIGx0Y2lyID0gXCLiqblcIjtcbnZhciBsdCQyID0gXCI8XCI7XG52YXIgTFQkMSA9IFwiPFwiO1xudmFyIEx0ID0gXCLiiapcIjtcbnZhciBsdGRvdCA9IFwi4ouWXCI7XG52YXIgbHRocmVlID0gXCLii4tcIjtcbnZhciBsdGltZXMgPSBcIuKLiVwiO1xudmFyIGx0bGFyciA9IFwi4qW2XCI7XG52YXIgbHRxdWVzdCA9IFwi4qm7XCI7XG52YXIgbHRyaSA9IFwi4peDXCI7XG52YXIgbHRyaWUgPSBcIuKKtFwiO1xudmFyIGx0cmlmID0gXCLil4JcIjtcbnZhciBsdHJQYXIgPSBcIuKmllwiO1xudmFyIGx1cmRzaGFyID0gXCLipYpcIjtcbnZhciBsdXJ1aGFyID0gXCLipaZcIjtcbnZhciBsdmVydG5lcXEgPSBcIuKJqO+4gFwiO1xudmFyIGx2bkUgPSBcIuKJqO+4gFwiO1xudmFyIG1hY3IkMSA9IFwiwq9cIjtcbnZhciBtYWxlID0gXCLimYJcIjtcbnZhciBtYWx0ID0gXCLinKBcIjtcbnZhciBtYWx0ZXNlID0gXCLinKBcIjtcbnZhciBtYXAgPSBcIuKGplwiO1xudmFyIG1hcHN0byA9IFwi4oamXCI7XG52YXIgbWFwc3RvZG93biA9IFwi4oanXCI7XG52YXIgbWFwc3RvbGVmdCA9IFwi4oakXCI7XG52YXIgbWFwc3RvdXAgPSBcIuKGpVwiO1xudmFyIG1hcmtlciA9IFwi4pauXCI7XG52YXIgbWNvbW1hID0gXCLiqKlcIjtcbnZhciBNY3kgPSBcItCcXCI7XG52YXIgbWN5ID0gXCLQvFwiO1xudmFyIG1kYXNoID0gXCLigJRcIjtcbnZhciBtRERvdCA9IFwi4oi6XCI7XG52YXIgbWVhc3VyZWRhbmdsZSA9IFwi4oihXCI7XG52YXIgTWVkaXVtU3BhY2UgPSBcIuKBn1wiO1xudmFyIE1lbGxpbnRyZiA9IFwi4oSzXCI7XG52YXIgTWZyID0gXCLwnZSQXCI7XG52YXIgbWZyID0gXCLwnZSqXCI7XG52YXIgbWhvID0gXCLihKdcIjtcbnZhciBtaWNybyQxID0gXCLCtVwiO1xudmFyIG1pZGFzdCA9IFwiKlwiO1xudmFyIG1pZGNpciA9IFwi4quwXCI7XG52YXIgbWlkID0gXCLiiKNcIjtcbnZhciBtaWRkb3QkMSA9IFwiwrdcIjtcbnZhciBtaW51c2IgPSBcIuKKn1wiO1xudmFyIG1pbnVzID0gXCLiiJJcIjtcbnZhciBtaW51c2QgPSBcIuKIuFwiO1xudmFyIG1pbnVzZHUgPSBcIuKoqlwiO1xudmFyIE1pbnVzUGx1cyA9IFwi4oiTXCI7XG52YXIgbWxjcCA9IFwi4qubXCI7XG52YXIgbWxkciA9IFwi4oCmXCI7XG52YXIgbW5wbHVzID0gXCLiiJNcIjtcbnZhciBtb2RlbHMgPSBcIuKKp1wiO1xudmFyIE1vcGYgPSBcIvCdlYRcIjtcbnZhciBtb3BmID0gXCLwnZWeXCI7XG52YXIgbXAgPSBcIuKIk1wiO1xudmFyIG1zY3IgPSBcIvCdk4JcIjtcbnZhciBNc2NyID0gXCLihLNcIjtcbnZhciBtc3Rwb3MgPSBcIuKIvlwiO1xudmFyIE11ID0gXCLOnFwiO1xudmFyIG11ID0gXCLOvFwiO1xudmFyIG11bHRpbWFwID0gXCLiirhcIjtcbnZhciBtdW1hcCA9IFwi4oq4XCI7XG52YXIgbmFibGEgPSBcIuKIh1wiO1xudmFyIE5hY3V0ZSA9IFwixYNcIjtcbnZhciBuYWN1dGUgPSBcIsWEXCI7XG52YXIgbmFuZyA9IFwi4oig4oOSXCI7XG52YXIgbmFwID0gXCLiiYlcIjtcbnZhciBuYXBFID0gXCLiqbDMuFwiO1xudmFyIG5hcGlkID0gXCLiiYvMuFwiO1xudmFyIG5hcG9zID0gXCLFiVwiO1xudmFyIG5hcHByb3ggPSBcIuKJiVwiO1xudmFyIG5hdHVyYWwgPSBcIuKZrlwiO1xudmFyIG5hdHVyYWxzID0gXCLihJVcIjtcbnZhciBuYXR1ciA9IFwi4pmuXCI7XG52YXIgbmJzcCQxID0gXCLCoFwiO1xudmFyIG5idW1wID0gXCLiiY7MuFwiO1xudmFyIG5idW1wZSA9IFwi4omPzLhcIjtcbnZhciBuY2FwID0gXCLiqYNcIjtcbnZhciBOY2Fyb24gPSBcIsWHXCI7XG52YXIgbmNhcm9uID0gXCLFiFwiO1xudmFyIE5jZWRpbCA9IFwixYVcIjtcbnZhciBuY2VkaWwgPSBcIsWGXCI7XG52YXIgbmNvbmcgPSBcIuKJh1wiO1xudmFyIG5jb25nZG90ID0gXCLiqa3MuFwiO1xudmFyIG5jdXAgPSBcIuKpglwiO1xudmFyIE5jeSA9IFwi0J1cIjtcbnZhciBuY3kgPSBcItC9XCI7XG52YXIgbmRhc2ggPSBcIuKAk1wiO1xudmFyIG5lYXJoayA9IFwi4qSkXCI7XG52YXIgbmVhcnIgPSBcIuKGl1wiO1xudmFyIG5lQXJyID0gXCLih5dcIjtcbnZhciBuZWFycm93ID0gXCLihpdcIjtcbnZhciBuZSA9IFwi4omgXCI7XG52YXIgbmVkb3QgPSBcIuKJkMy4XCI7XG52YXIgTmVnYXRpdmVNZWRpdW1TcGFjZSA9IFwi4oCLXCI7XG52YXIgTmVnYXRpdmVUaGlja1NwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVRoaW5TcGFjZSA9IFwi4oCLXCI7XG52YXIgTmVnYXRpdmVWZXJ5VGhpblNwYWNlID0gXCLigItcIjtcbnZhciBuZXF1aXYgPSBcIuKJolwiO1xudmFyIG5lc2VhciA9IFwi4qSoXCI7XG52YXIgbmVzaW0gPSBcIuKJgsy4XCI7XG52YXIgTmVzdGVkR3JlYXRlckdyZWF0ZXIgPSBcIuKJq1wiO1xudmFyIE5lc3RlZExlc3NMZXNzID0gXCLiiapcIjtcbnZhciBOZXdMaW5lID0gXCJcXG5cIjtcbnZhciBuZXhpc3QgPSBcIuKIhFwiO1xudmFyIG5leGlzdHMgPSBcIuKIhFwiO1xudmFyIE5mciA9IFwi8J2UkVwiO1xudmFyIG5mciA9IFwi8J2Uq1wiO1xudmFyIG5nRSA9IFwi4omnzLhcIjtcbnZhciBuZ2UgPSBcIuKJsVwiO1xudmFyIG5nZXEgPSBcIuKJsVwiO1xudmFyIG5nZXFxID0gXCLiiafMuFwiO1xudmFyIG5nZXFzbGFudCA9IFwi4qm+zLhcIjtcbnZhciBuZ2VzID0gXCLiqb7MuFwiO1xudmFyIG5HZyA9IFwi4ouZzLhcIjtcbnZhciBuZ3NpbSA9IFwi4om1XCI7XG52YXIgbkd0ID0gXCLiiavig5JcIjtcbnZhciBuZ3QgPSBcIuKJr1wiO1xudmFyIG5ndHIgPSBcIuKJr1wiO1xudmFyIG5HdHYgPSBcIuKJq8y4XCI7XG52YXIgbmhhcnIgPSBcIuKGrlwiO1xudmFyIG5oQXJyID0gXCLih45cIjtcbnZhciBuaHBhciA9IFwi4quyXCI7XG52YXIgbmkgPSBcIuKIi1wiO1xudmFyIG5pcyA9IFwi4ou8XCI7XG52YXIgbmlzZCA9IFwi4ou6XCI7XG52YXIgbml2ID0gXCLiiItcIjtcbnZhciBOSmN5ID0gXCLQilwiO1xudmFyIG5qY3kgPSBcItGaXCI7XG52YXIgbmxhcnIgPSBcIuKGmlwiO1xudmFyIG5sQXJyID0gXCLih41cIjtcbnZhciBubGRyID0gXCLigKVcIjtcbnZhciBubEUgPSBcIuKJpsy4XCI7XG52YXIgbmxlID0gXCLiibBcIjtcbnZhciBubGVmdGFycm93ID0gXCLihppcIjtcbnZhciBuTGVmdGFycm93ID0gXCLih41cIjtcbnZhciBubGVmdHJpZ2h0YXJyb3cgPSBcIuKGrlwiO1xudmFyIG5MZWZ0cmlnaHRhcnJvdyA9IFwi4oeOXCI7XG52YXIgbmxlcSA9IFwi4omwXCI7XG52YXIgbmxlcXEgPSBcIuKJpsy4XCI7XG52YXIgbmxlcXNsYW50ID0gXCLiqb3MuFwiO1xudmFyIG5sZXMgPSBcIuKpvcy4XCI7XG52YXIgbmxlc3MgPSBcIuKJrlwiO1xudmFyIG5MbCA9IFwi4ouYzLhcIjtcbnZhciBubHNpbSA9IFwi4om0XCI7XG52YXIgbkx0ID0gXCLiiarig5JcIjtcbnZhciBubHQgPSBcIuKJrlwiO1xudmFyIG5sdHJpID0gXCLii6pcIjtcbnZhciBubHRyaWUgPSBcIuKLrFwiO1xudmFyIG5MdHYgPSBcIuKJqsy4XCI7XG52YXIgbm1pZCA9IFwi4oikXCI7XG52YXIgTm9CcmVhayA9IFwi4oGgXCI7XG52YXIgTm9uQnJlYWtpbmdTcGFjZSA9IFwiwqBcIjtcbnZhciBub3BmID0gXCLwnZWfXCI7XG52YXIgTm9wZiA9IFwi4oSVXCI7XG52YXIgTm90ID0gXCLiq6xcIjtcbnZhciBub3QkMSA9IFwiwqxcIjtcbnZhciBOb3RDb25ncnVlbnQgPSBcIuKJolwiO1xudmFyIE5vdEN1cENhcCA9IFwi4omtXCI7XG52YXIgTm90RG91YmxlVmVydGljYWxCYXIgPSBcIuKIplwiO1xudmFyIE5vdEVsZW1lbnQgPSBcIuKIiVwiO1xudmFyIE5vdEVxdWFsID0gXCLiiaBcIjtcbnZhciBOb3RFcXVhbFRpbGRlID0gXCLiiYLMuFwiO1xudmFyIE5vdEV4aXN0cyA9IFwi4oiEXCI7XG52YXIgTm90R3JlYXRlciA9IFwi4omvXCI7XG52YXIgTm90R3JlYXRlckVxdWFsID0gXCLiibFcIjtcbnZhciBOb3RHcmVhdGVyRnVsbEVxdWFsID0gXCLiiafMuFwiO1xudmFyIE5vdEdyZWF0ZXJHcmVhdGVyID0gXCLiiavMuFwiO1xudmFyIE5vdEdyZWF0ZXJMZXNzID0gXCLiiblcIjtcbnZhciBOb3RHcmVhdGVyU2xhbnRFcXVhbCA9IFwi4qm+zLhcIjtcbnZhciBOb3RHcmVhdGVyVGlsZGUgPSBcIuKJtVwiO1xudmFyIE5vdEh1bXBEb3duSHVtcCA9IFwi4omOzLhcIjtcbnZhciBOb3RIdW1wRXF1YWwgPSBcIuKJj8y4XCI7XG52YXIgbm90aW4gPSBcIuKIiVwiO1xudmFyIG5vdGluZG90ID0gXCLii7XMuFwiO1xudmFyIG5vdGluRSA9IFwi4ou5zLhcIjtcbnZhciBub3RpbnZhID0gXCLiiIlcIjtcbnZhciBub3RpbnZiID0gXCLii7dcIjtcbnZhciBub3RpbnZjID0gXCLii7ZcIjtcbnZhciBOb3RMZWZ0VHJpYW5nbGVCYXIgPSBcIuKnj8y4XCI7XG52YXIgTm90TGVmdFRyaWFuZ2xlID0gXCLii6pcIjtcbnZhciBOb3RMZWZ0VHJpYW5nbGVFcXVhbCA9IFwi4ousXCI7XG52YXIgTm90TGVzcyA9IFwi4omuXCI7XG52YXIgTm90TGVzc0VxdWFsID0gXCLiibBcIjtcbnZhciBOb3RMZXNzR3JlYXRlciA9IFwi4om4XCI7XG52YXIgTm90TGVzc0xlc3MgPSBcIuKJqsy4XCI7XG52YXIgTm90TGVzc1NsYW50RXF1YWwgPSBcIuKpvcy4XCI7XG52YXIgTm90TGVzc1RpbGRlID0gXCLiibRcIjtcbnZhciBOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlciA9IFwi4qqizLhcIjtcbnZhciBOb3ROZXN0ZWRMZXNzTGVzcyA9IFwi4qqhzLhcIjtcbnZhciBub3RuaSA9IFwi4oiMXCI7XG52YXIgbm90bml2YSA9IFwi4oiMXCI7XG52YXIgbm90bml2YiA9IFwi4ou+XCI7XG52YXIgbm90bml2YyA9IFwi4ou9XCI7XG52YXIgTm90UHJlY2VkZXMgPSBcIuKKgFwiO1xudmFyIE5vdFByZWNlZGVzRXF1YWwgPSBcIuKqr8y4XCI7XG52YXIgTm90UHJlY2VkZXNTbGFudEVxdWFsID0gXCLii6BcIjtcbnZhciBOb3RSZXZlcnNlRWxlbWVudCA9IFwi4oiMXCI7XG52YXIgTm90UmlnaHRUcmlhbmdsZUJhciA9IFwi4qeQzLhcIjtcbnZhciBOb3RSaWdodFRyaWFuZ2xlID0gXCLii6tcIjtcbnZhciBOb3RSaWdodFRyaWFuZ2xlRXF1YWwgPSBcIuKLrVwiO1xudmFyIE5vdFNxdWFyZVN1YnNldCA9IFwi4oqPzLhcIjtcbnZhciBOb3RTcXVhcmVTdWJzZXRFcXVhbCA9IFwi4ouiXCI7XG52YXIgTm90U3F1YXJlU3VwZXJzZXQgPSBcIuKKkMy4XCI7XG52YXIgTm90U3F1YXJlU3VwZXJzZXRFcXVhbCA9IFwi4oujXCI7XG52YXIgTm90U3Vic2V0ID0gXCLiioLig5JcIjtcbnZhciBOb3RTdWJzZXRFcXVhbCA9IFwi4oqIXCI7XG52YXIgTm90U3VjY2VlZHMgPSBcIuKKgVwiO1xudmFyIE5vdFN1Y2NlZWRzRXF1YWwgPSBcIuKqsMy4XCI7XG52YXIgTm90U3VjY2VlZHNTbGFudEVxdWFsID0gXCLii6FcIjtcbnZhciBOb3RTdWNjZWVkc1RpbGRlID0gXCLiib/MuFwiO1xudmFyIE5vdFN1cGVyc2V0ID0gXCLiioPig5JcIjtcbnZhciBOb3RTdXBlcnNldEVxdWFsID0gXCLiiolcIjtcbnZhciBOb3RUaWxkZSA9IFwi4omBXCI7XG52YXIgTm90VGlsZGVFcXVhbCA9IFwi4omEXCI7XG52YXIgTm90VGlsZGVGdWxsRXF1YWwgPSBcIuKJh1wiO1xudmFyIE5vdFRpbGRlVGlsZGUgPSBcIuKJiVwiO1xudmFyIE5vdFZlcnRpY2FsQmFyID0gXCLiiKRcIjtcbnZhciBucGFyYWxsZWwgPSBcIuKIplwiO1xudmFyIG5wYXIgPSBcIuKIplwiO1xudmFyIG5wYXJzbCA9IFwi4qu94oOlXCI7XG52YXIgbnBhcnQgPSBcIuKIgsy4XCI7XG52YXIgbnBvbGludCA9IFwi4qiUXCI7XG52YXIgbnByID0gXCLiioBcIjtcbnZhciBucHJjdWUgPSBcIuKLoFwiO1xudmFyIG5wcmVjID0gXCLiioBcIjtcbnZhciBucHJlY2VxID0gXCLiqq/MuFwiO1xudmFyIG5wcmUgPSBcIuKqr8y4XCI7XG52YXIgbnJhcnJjID0gXCLipLPMuFwiO1xudmFyIG5yYXJyID0gXCLihptcIjtcbnZhciBuckFyciA9IFwi4oePXCI7XG52YXIgbnJhcnJ3ID0gXCLihp3MuFwiO1xudmFyIG5yaWdodGFycm93ID0gXCLihptcIjtcbnZhciBuUmlnaHRhcnJvdyA9IFwi4oePXCI7XG52YXIgbnJ0cmkgPSBcIuKLq1wiO1xudmFyIG5ydHJpZSA9IFwi4outXCI7XG52YXIgbnNjID0gXCLiioFcIjtcbnZhciBuc2NjdWUgPSBcIuKLoVwiO1xudmFyIG5zY2UgPSBcIuKqsMy4XCI7XG52YXIgTnNjciA9IFwi8J2SqVwiO1xudmFyIG5zY3IgPSBcIvCdk4NcIjtcbnZhciBuc2hvcnRtaWQgPSBcIuKIpFwiO1xudmFyIG5zaG9ydHBhcmFsbGVsID0gXCLiiKZcIjtcbnZhciBuc2ltID0gXCLiiYFcIjtcbnZhciBuc2ltZSA9IFwi4omEXCI7XG52YXIgbnNpbWVxID0gXCLiiYRcIjtcbnZhciBuc21pZCA9IFwi4oikXCI7XG52YXIgbnNwYXIgPSBcIuKIplwiO1xudmFyIG5zcXN1YmUgPSBcIuKLolwiO1xudmFyIG5zcXN1cGUgPSBcIuKLo1wiO1xudmFyIG5zdWIgPSBcIuKKhFwiO1xudmFyIG5zdWJFID0gXCLiq4XMuFwiO1xudmFyIG5zdWJlID0gXCLiiohcIjtcbnZhciBuc3Vic2V0ID0gXCLiioLig5JcIjtcbnZhciBuc3Vic2V0ZXEgPSBcIuKKiFwiO1xudmFyIG5zdWJzZXRlcXEgPSBcIuKrhcy4XCI7XG52YXIgbnN1Y2MgPSBcIuKKgVwiO1xudmFyIG5zdWNjZXEgPSBcIuKqsMy4XCI7XG52YXIgbnN1cCA9IFwi4oqFXCI7XG52YXIgbnN1cEUgPSBcIuKrhsy4XCI7XG52YXIgbnN1cGUgPSBcIuKKiVwiO1xudmFyIG5zdXBzZXQgPSBcIuKKg+KDklwiO1xudmFyIG5zdXBzZXRlcSA9IFwi4oqJXCI7XG52YXIgbnN1cHNldGVxcSA9IFwi4quGzLhcIjtcbnZhciBudGdsID0gXCLiiblcIjtcbnZhciBOdGlsZGUkMSA9IFwiw5FcIjtcbnZhciBudGlsZGUkMSA9IFwiw7FcIjtcbnZhciBudGxnID0gXCLiibhcIjtcbnZhciBudHJpYW5nbGVsZWZ0ID0gXCLii6pcIjtcbnZhciBudHJpYW5nbGVsZWZ0ZXEgPSBcIuKLrFwiO1xudmFyIG50cmlhbmdsZXJpZ2h0ID0gXCLii6tcIjtcbnZhciBudHJpYW5nbGVyaWdodGVxID0gXCLii61cIjtcbnZhciBOdSA9IFwizp1cIjtcbnZhciBudSA9IFwizr1cIjtcbnZhciBudW0gPSBcIiNcIjtcbnZhciBudW1lcm8gPSBcIuKEllwiO1xudmFyIG51bXNwID0gXCLigIdcIjtcbnZhciBudmFwID0gXCLiiY3ig5JcIjtcbnZhciBudmRhc2ggPSBcIuKKrFwiO1xudmFyIG52RGFzaCA9IFwi4oqtXCI7XG52YXIgblZkYXNoID0gXCLiiq5cIjtcbnZhciBuVkRhc2ggPSBcIuKKr1wiO1xudmFyIG52Z2UgPSBcIuKJpeKDklwiO1xudmFyIG52Z3QgPSBcIj7ig5JcIjtcbnZhciBudkhhcnIgPSBcIuKkhFwiO1xudmFyIG52aW5maW4gPSBcIuKnnlwiO1xudmFyIG52bEFyciA9IFwi4qSCXCI7XG52YXIgbnZsZSA9IFwi4omk4oOSXCI7XG52YXIgbnZsdCA9IFwiPOKDklwiO1xudmFyIG52bHRyaWUgPSBcIuKKtOKDklwiO1xudmFyIG52ckFyciA9IFwi4qSDXCI7XG52YXIgbnZydHJpZSA9IFwi4oq14oOSXCI7XG52YXIgbnZzaW0gPSBcIuKIvOKDklwiO1xudmFyIG53YXJoayA9IFwi4qSjXCI7XG52YXIgbndhcnIgPSBcIuKGllwiO1xudmFyIG53QXJyID0gXCLih5ZcIjtcbnZhciBud2Fycm93ID0gXCLihpZcIjtcbnZhciBud25lYXIgPSBcIuKkp1wiO1xudmFyIE9hY3V0ZSQxID0gXCLDk1wiO1xudmFyIG9hY3V0ZSQxID0gXCLDs1wiO1xudmFyIG9hc3QgPSBcIuKKm1wiO1xudmFyIE9jaXJjJDEgPSBcIsOUXCI7XG52YXIgb2NpcmMkMSA9IFwiw7RcIjtcbnZhciBvY2lyID0gXCLiippcIjtcbnZhciBPY3kgPSBcItCeXCI7XG52YXIgb2N5ID0gXCLQvlwiO1xudmFyIG9kYXNoID0gXCLiip1cIjtcbnZhciBPZGJsYWMgPSBcIsWQXCI7XG52YXIgb2RibGFjID0gXCLFkVwiO1xudmFyIG9kaXYgPSBcIuKouFwiO1xudmFyIG9kb3QgPSBcIuKKmVwiO1xudmFyIG9kc29sZCA9IFwi4qa8XCI7XG52YXIgT0VsaWcgPSBcIsWSXCI7XG52YXIgb2VsaWcgPSBcIsWTXCI7XG52YXIgb2ZjaXIgPSBcIuKmv1wiO1xudmFyIE9mciA9IFwi8J2UklwiO1xudmFyIG9mciA9IFwi8J2UrFwiO1xudmFyIG9nb24gPSBcIsubXCI7XG52YXIgT2dyYXZlJDEgPSBcIsOSXCI7XG52YXIgb2dyYXZlJDEgPSBcIsOyXCI7XG52YXIgb2d0ID0gXCLip4FcIjtcbnZhciBvaGJhciA9IFwi4qa1XCI7XG52YXIgb2htID0gXCLOqVwiO1xudmFyIG9pbnQgPSBcIuKIrlwiO1xudmFyIG9sYXJyID0gXCLihrpcIjtcbnZhciBvbGNpciA9IFwi4qa+XCI7XG52YXIgb2xjcm9zcyA9IFwi4qa7XCI7XG52YXIgb2xpbmUgPSBcIuKAvlwiO1xudmFyIG9sdCA9IFwi4qeAXCI7XG52YXIgT21hY3IgPSBcIsWMXCI7XG52YXIgb21hY3IgPSBcIsWNXCI7XG52YXIgT21lZ2EgPSBcIs6pXCI7XG52YXIgb21lZ2EgPSBcIs+JXCI7XG52YXIgT21pY3JvbiA9IFwizp9cIjtcbnZhciBvbWljcm9uID0gXCLOv1wiO1xudmFyIG9taWQgPSBcIuKmtlwiO1xudmFyIG9taW51cyA9IFwi4oqWXCI7XG52YXIgT29wZiA9IFwi8J2VhlwiO1xudmFyIG9vcGYgPSBcIvCdlaBcIjtcbnZhciBvcGFyID0gXCLiprdcIjtcbnZhciBPcGVuQ3VybHlEb3VibGVRdW90ZSA9IFwi4oCcXCI7XG52YXIgT3BlbkN1cmx5UXVvdGUgPSBcIuKAmFwiO1xudmFyIG9wZXJwID0gXCLiprlcIjtcbnZhciBvcGx1cyA9IFwi4oqVXCI7XG52YXIgb3JhcnIgPSBcIuKGu1wiO1xudmFyIE9yID0gXCLiqZRcIjtcbnZhciBvciA9IFwi4oioXCI7XG52YXIgb3JkID0gXCLiqZ1cIjtcbnZhciBvcmRlciA9IFwi4oS0XCI7XG52YXIgb3JkZXJvZiA9IFwi4oS0XCI7XG52YXIgb3JkZiQxID0gXCLCqlwiO1xudmFyIG9yZG0kMSA9IFwiwrpcIjtcbnZhciBvcmlnb2YgPSBcIuKKtlwiO1xudmFyIG9yb3IgPSBcIuKpllwiO1xudmFyIG9yc2xvcGUgPSBcIuKpl1wiO1xudmFyIG9ydiA9IFwi4qmbXCI7XG52YXIgb1MgPSBcIuKTiFwiO1xudmFyIE9zY3IgPSBcIvCdkqpcIjtcbnZhciBvc2NyID0gXCLihLRcIjtcbnZhciBPc2xhc2gkMSA9IFwiw5hcIjtcbnZhciBvc2xhc2gkMSA9IFwiw7hcIjtcbnZhciBvc29sID0gXCLiiphcIjtcbnZhciBPdGlsZGUkMSA9IFwiw5VcIjtcbnZhciBvdGlsZGUkMSA9IFwiw7VcIjtcbnZhciBvdGltZXNhcyA9IFwi4qi2XCI7XG52YXIgT3RpbWVzID0gXCLiqLdcIjtcbnZhciBvdGltZXMgPSBcIuKKl1wiO1xudmFyIE91bWwkMSA9IFwiw5ZcIjtcbnZhciBvdW1sJDEgPSBcIsO2XCI7XG52YXIgb3ZiYXIgPSBcIuKMvVwiO1xudmFyIE92ZXJCYXIgPSBcIuKAvlwiO1xudmFyIE92ZXJCcmFjZSA9IFwi4o+eXCI7XG52YXIgT3ZlckJyYWNrZXQgPSBcIuKOtFwiO1xudmFyIE92ZXJQYXJlbnRoZXNpcyA9IFwi4o+cXCI7XG52YXIgcGFyYSQxID0gXCLCtlwiO1xudmFyIHBhcmFsbGVsID0gXCLiiKVcIjtcbnZhciBwYXIgPSBcIuKIpVwiO1xudmFyIHBhcnNpbSA9IFwi4quzXCI7XG52YXIgcGFyc2wgPSBcIuKrvVwiO1xudmFyIHBhcnQgPSBcIuKIglwiO1xudmFyIFBhcnRpYWxEID0gXCLiiIJcIjtcbnZhciBQY3kgPSBcItCfXCI7XG52YXIgcGN5ID0gXCLQv1wiO1xudmFyIHBlcmNudCA9IFwiJVwiO1xudmFyIHBlcmlvZCA9IFwiLlwiO1xudmFyIHBlcm1pbCA9IFwi4oCwXCI7XG52YXIgcGVycCA9IFwi4oqlXCI7XG52YXIgcGVydGVuayA9IFwi4oCxXCI7XG52YXIgUGZyID0gXCLwnZSTXCI7XG52YXIgcGZyID0gXCLwnZStXCI7XG52YXIgUGhpID0gXCLOplwiO1xudmFyIHBoaSA9IFwiz4ZcIjtcbnZhciBwaGl2ID0gXCLPlVwiO1xudmFyIHBobW1hdCA9IFwi4oSzXCI7XG52YXIgcGhvbmUgPSBcIuKYjlwiO1xudmFyIFBpID0gXCLOoFwiO1xudmFyIHBpID0gXCLPgFwiO1xudmFyIHBpdGNoZm9yayA9IFwi4ouUXCI7XG52YXIgcGl2ID0gXCLPllwiO1xudmFyIHBsYW5jayA9IFwi4oSPXCI7XG52YXIgcGxhbmNraCA9IFwi4oSOXCI7XG52YXIgcGxhbmt2ID0gXCLihI9cIjtcbnZhciBwbHVzYWNpciA9IFwi4qijXCI7XG52YXIgcGx1c2IgPSBcIuKKnlwiO1xudmFyIHBsdXNjaXIgPSBcIuKoolwiO1xudmFyIHBsdXMgPSBcIitcIjtcbnZhciBwbHVzZG8gPSBcIuKIlFwiO1xudmFyIHBsdXNkdSA9IFwi4qilXCI7XG52YXIgcGx1c2UgPSBcIuKpslwiO1xudmFyIFBsdXNNaW51cyA9IFwiwrFcIjtcbnZhciBwbHVzbW4kMSA9IFwiwrFcIjtcbnZhciBwbHVzc2ltID0gXCLiqKZcIjtcbnZhciBwbHVzdHdvID0gXCLiqKdcIjtcbnZhciBwbSA9IFwiwrFcIjtcbnZhciBQb2luY2FyZXBsYW5lID0gXCLihIxcIjtcbnZhciBwb2ludGludCA9IFwi4qiVXCI7XG52YXIgcG9wZiA9IFwi8J2VoVwiO1xudmFyIFBvcGYgPSBcIuKEmVwiO1xudmFyIHBvdW5kJDEgPSBcIsKjXCI7XG52YXIgcHJhcCA9IFwi4qq3XCI7XG52YXIgUHIgPSBcIuKqu1wiO1xudmFyIHByID0gXCLiibpcIjtcbnZhciBwcmN1ZSA9IFwi4om8XCI7XG52YXIgcHJlY2FwcHJveCA9IFwi4qq3XCI7XG52YXIgcHJlYyA9IFwi4om6XCI7XG52YXIgcHJlY2N1cmx5ZXEgPSBcIuKJvFwiO1xudmFyIFByZWNlZGVzID0gXCLiibpcIjtcbnZhciBQcmVjZWRlc0VxdWFsID0gXCLiqq9cIjtcbnZhciBQcmVjZWRlc1NsYW50RXF1YWwgPSBcIuKJvFwiO1xudmFyIFByZWNlZGVzVGlsZGUgPSBcIuKJvlwiO1xudmFyIHByZWNlcSA9IFwi4qqvXCI7XG52YXIgcHJlY25hcHByb3ggPSBcIuKquVwiO1xudmFyIHByZWNuZXFxID0gXCLiqrVcIjtcbnZhciBwcmVjbnNpbSA9IFwi4ouoXCI7XG52YXIgcHJlID0gXCLiqq9cIjtcbnZhciBwckUgPSBcIuKqs1wiO1xudmFyIHByZWNzaW0gPSBcIuKJvlwiO1xudmFyIHByaW1lID0gXCLigLJcIjtcbnZhciBQcmltZSA9IFwi4oCzXCI7XG52YXIgcHJpbWVzID0gXCLihJlcIjtcbnZhciBwcm5hcCA9IFwi4qq5XCI7XG52YXIgcHJuRSA9IFwi4qq1XCI7XG52YXIgcHJuc2ltID0gXCLii6hcIjtcbnZhciBwcm9kID0gXCLiiI9cIjtcbnZhciBQcm9kdWN0ID0gXCLiiI9cIjtcbnZhciBwcm9mYWxhciA9IFwi4oyuXCI7XG52YXIgcHJvZmxpbmUgPSBcIuKMklwiO1xudmFyIHByb2ZzdXJmID0gXCLijJNcIjtcbnZhciBwcm9wID0gXCLiiJ1cIjtcbnZhciBQcm9wb3J0aW9uYWwgPSBcIuKInVwiO1xudmFyIFByb3BvcnRpb24gPSBcIuKIt1wiO1xudmFyIHByb3B0byA9IFwi4oidXCI7XG52YXIgcHJzaW0gPSBcIuKJvlwiO1xudmFyIHBydXJlbCA9IFwi4oqwXCI7XG52YXIgUHNjciA9IFwi8J2Sq1wiO1xudmFyIHBzY3IgPSBcIvCdk4VcIjtcbnZhciBQc2kgPSBcIs6oXCI7XG52YXIgcHNpID0gXCLPiFwiO1xudmFyIHB1bmNzcCA9IFwi4oCIXCI7XG52YXIgUWZyID0gXCLwnZSUXCI7XG52YXIgcWZyID0gXCLwnZSuXCI7XG52YXIgcWludCA9IFwi4qiMXCI7XG52YXIgcW9wZiA9IFwi8J2VolwiO1xudmFyIFFvcGYgPSBcIuKEmlwiO1xudmFyIHFwcmltZSA9IFwi4oGXXCI7XG52YXIgUXNjciA9IFwi8J2SrFwiO1xudmFyIHFzY3IgPSBcIvCdk4ZcIjtcbnZhciBxdWF0ZXJuaW9ucyA9IFwi4oSNXCI7XG52YXIgcXVhdGludCA9IFwi4qiWXCI7XG52YXIgcXVlc3QgPSBcIj9cIjtcbnZhciBxdWVzdGVxID0gXCLiiZ9cIjtcbnZhciBxdW90JDIgPSBcIlxcXCJcIjtcbnZhciBRVU9UJDEgPSBcIlxcXCJcIjtcbnZhciByQWFyciA9IFwi4oebXCI7XG52YXIgcmFjZSA9IFwi4oi9zLFcIjtcbnZhciBSYWN1dGUgPSBcIsWUXCI7XG52YXIgcmFjdXRlID0gXCLFlVwiO1xudmFyIHJhZGljID0gXCLiiJpcIjtcbnZhciByYWVtcHR5diA9IFwi4qazXCI7XG52YXIgcmFuZyA9IFwi4p+pXCI7XG52YXIgUmFuZyA9IFwi4p+rXCI7XG52YXIgcmFuZ2QgPSBcIuKmklwiO1xudmFyIHJhbmdlID0gXCLipqVcIjtcbnZhciByYW5nbGUgPSBcIuKfqVwiO1xudmFyIHJhcXVvJDEgPSBcIsK7XCI7XG52YXIgcmFycmFwID0gXCLipbVcIjtcbnZhciByYXJyYiA9IFwi4oelXCI7XG52YXIgcmFycmJmcyA9IFwi4qSgXCI7XG52YXIgcmFycmMgPSBcIuKks1wiO1xudmFyIHJhcnIgPSBcIuKGklwiO1xudmFyIFJhcnIgPSBcIuKGoFwiO1xudmFyIHJBcnIgPSBcIuKHklwiO1xudmFyIHJhcnJmcyA9IFwi4qSeXCI7XG52YXIgcmFycmhrID0gXCLihqpcIjtcbnZhciByYXJybHAgPSBcIuKGrFwiO1xudmFyIHJhcnJwbCA9IFwi4qWFXCI7XG52YXIgcmFycnNpbSA9IFwi4qW0XCI7XG52YXIgUmFycnRsID0gXCLipJZcIjtcbnZhciByYXJydGwgPSBcIuKGo1wiO1xudmFyIHJhcnJ3ID0gXCLihp1cIjtcbnZhciByYXRhaWwgPSBcIuKkmlwiO1xudmFyIHJBdGFpbCA9IFwi4qScXCI7XG52YXIgcmF0aW8gPSBcIuKItlwiO1xudmFyIHJhdGlvbmFscyA9IFwi4oSaXCI7XG52YXIgcmJhcnIgPSBcIuKkjVwiO1xudmFyIHJCYXJyID0gXCLipI9cIjtcbnZhciBSQmFyciA9IFwi4qSQXCI7XG52YXIgcmJicmsgPSBcIuKds1wiO1xudmFyIHJicmFjZSA9IFwifVwiO1xudmFyIHJicmFjayA9IFwiXVwiO1xudmFyIHJicmtlID0gXCLipoxcIjtcbnZhciByYnJrc2xkID0gXCLipo5cIjtcbnZhciByYnJrc2x1ID0gXCLippBcIjtcbnZhciBSY2Fyb24gPSBcIsWYXCI7XG52YXIgcmNhcm9uID0gXCLFmVwiO1xudmFyIFJjZWRpbCA9IFwixZZcIjtcbnZhciByY2VkaWwgPSBcIsWXXCI7XG52YXIgcmNlaWwgPSBcIuKMiVwiO1xudmFyIHJjdWIgPSBcIn1cIjtcbnZhciBSY3kgPSBcItCgXCI7XG52YXIgcmN5ID0gXCLRgFwiO1xudmFyIHJkY2EgPSBcIuKkt1wiO1xudmFyIHJkbGRoYXIgPSBcIuKlqVwiO1xudmFyIHJkcXVvID0gXCLigJ1cIjtcbnZhciByZHF1b3IgPSBcIuKAnVwiO1xudmFyIHJkc2ggPSBcIuKGs1wiO1xudmFyIHJlYWwgPSBcIuKEnFwiO1xudmFyIHJlYWxpbmUgPSBcIuKEm1wiO1xudmFyIHJlYWxwYXJ0ID0gXCLihJxcIjtcbnZhciByZWFscyA9IFwi4oSdXCI7XG52YXIgUmUgPSBcIuKEnFwiO1xudmFyIHJlY3QgPSBcIuKWrVwiO1xudmFyIHJlZyQxID0gXCLCrlwiO1xudmFyIFJFRyQxID0gXCLCrlwiO1xudmFyIFJldmVyc2VFbGVtZW50ID0gXCLiiItcIjtcbnZhciBSZXZlcnNlRXF1aWxpYnJpdW0gPSBcIuKHi1wiO1xudmFyIFJldmVyc2VVcEVxdWlsaWJyaXVtID0gXCLipa9cIjtcbnZhciByZmlzaHQgPSBcIuKlvVwiO1xudmFyIHJmbG9vciA9IFwi4oyLXCI7XG52YXIgcmZyID0gXCLwnZSvXCI7XG52YXIgUmZyID0gXCLihJxcIjtcbnZhciBySGFyID0gXCLipaRcIjtcbnZhciByaGFyZCA9IFwi4oeBXCI7XG52YXIgcmhhcnUgPSBcIuKHgFwiO1xudmFyIHJoYXJ1bCA9IFwi4qWsXCI7XG52YXIgUmhvID0gXCLOoVwiO1xudmFyIHJobyA9IFwiz4FcIjtcbnZhciByaG92ID0gXCLPsVwiO1xudmFyIFJpZ2h0QW5nbGVCcmFja2V0ID0gXCLin6lcIjtcbnZhciBSaWdodEFycm93QmFyID0gXCLih6VcIjtcbnZhciByaWdodGFycm93ID0gXCLihpJcIjtcbnZhciBSaWdodEFycm93ID0gXCLihpJcIjtcbnZhciBSaWdodGFycm93ID0gXCLih5JcIjtcbnZhciBSaWdodEFycm93TGVmdEFycm93ID0gXCLih4RcIjtcbnZhciByaWdodGFycm93dGFpbCA9IFwi4oajXCI7XG52YXIgUmlnaHRDZWlsaW5nID0gXCLijIlcIjtcbnZhciBSaWdodERvdWJsZUJyYWNrZXQgPSBcIuKfp1wiO1xudmFyIFJpZ2h0RG93blRlZVZlY3RvciA9IFwi4qWdXCI7XG52YXIgUmlnaHREb3duVmVjdG9yQmFyID0gXCLipZVcIjtcbnZhciBSaWdodERvd25WZWN0b3IgPSBcIuKHglwiO1xudmFyIFJpZ2h0Rmxvb3IgPSBcIuKMi1wiO1xudmFyIHJpZ2h0aGFycG9vbmRvd24gPSBcIuKHgVwiO1xudmFyIHJpZ2h0aGFycG9vbnVwID0gXCLih4BcIjtcbnZhciByaWdodGxlZnRhcnJvd3MgPSBcIuKHhFwiO1xudmFyIHJpZ2h0bGVmdGhhcnBvb25zID0gXCLih4xcIjtcbnZhciByaWdodHJpZ2h0YXJyb3dzID0gXCLih4lcIjtcbnZhciByaWdodHNxdWlnYXJyb3cgPSBcIuKGnVwiO1xudmFyIFJpZ2h0VGVlQXJyb3cgPSBcIuKGplwiO1xudmFyIFJpZ2h0VGVlID0gXCLiiqJcIjtcbnZhciBSaWdodFRlZVZlY3RvciA9IFwi4qWbXCI7XG52YXIgcmlnaHR0aHJlZXRpbWVzID0gXCLii4xcIjtcbnZhciBSaWdodFRyaWFuZ2xlQmFyID0gXCLip5BcIjtcbnZhciBSaWdodFRyaWFuZ2xlID0gXCLiirNcIjtcbnZhciBSaWdodFRyaWFuZ2xlRXF1YWwgPSBcIuKKtVwiO1xudmFyIFJpZ2h0VXBEb3duVmVjdG9yID0gXCLipY9cIjtcbnZhciBSaWdodFVwVGVlVmVjdG9yID0gXCLipZxcIjtcbnZhciBSaWdodFVwVmVjdG9yQmFyID0gXCLipZRcIjtcbnZhciBSaWdodFVwVmVjdG9yID0gXCLihr5cIjtcbnZhciBSaWdodFZlY3RvckJhciA9IFwi4qWTXCI7XG52YXIgUmlnaHRWZWN0b3IgPSBcIuKHgFwiO1xudmFyIHJpbmcgPSBcIsuaXCI7XG52YXIgcmlzaW5nZG90c2VxID0gXCLiiZNcIjtcbnZhciBybGFyciA9IFwi4oeEXCI7XG52YXIgcmxoYXIgPSBcIuKHjFwiO1xudmFyIHJsbSA9IFwi4oCPXCI7XG52YXIgcm1vdXN0YWNoZSA9IFwi4o6xXCI7XG52YXIgcm1vdXN0ID0gXCLijrFcIjtcbnZhciBybm1pZCA9IFwi4quuXCI7XG52YXIgcm9hbmcgPSBcIuKfrVwiO1xudmFyIHJvYXJyID0gXCLih75cIjtcbnZhciByb2JyayA9IFwi4p+nXCI7XG52YXIgcm9wYXIgPSBcIuKmhlwiO1xudmFyIHJvcGYgPSBcIvCdlaNcIjtcbnZhciBSb3BmID0gXCLihJ1cIjtcbnZhciByb3BsdXMgPSBcIuKorlwiO1xudmFyIHJvdGltZXMgPSBcIuKotVwiO1xudmFyIFJvdW5kSW1wbGllcyA9IFwi4qWwXCI7XG52YXIgcnBhciA9IFwiKVwiO1xudmFyIHJwYXJndCA9IFwi4qaUXCI7XG52YXIgcnBwb2xpbnQgPSBcIuKoklwiO1xudmFyIHJyYXJyID0gXCLih4lcIjtcbnZhciBScmlnaHRhcnJvdyA9IFwi4oebXCI7XG52YXIgcnNhcXVvID0gXCLigLpcIjtcbnZhciByc2NyID0gXCLwnZOHXCI7XG52YXIgUnNjciA9IFwi4oSbXCI7XG52YXIgcnNoID0gXCLihrFcIjtcbnZhciBSc2ggPSBcIuKGsVwiO1xudmFyIHJzcWIgPSBcIl1cIjtcbnZhciByc3F1byA9IFwi4oCZXCI7XG52YXIgcnNxdW9yID0gXCLigJlcIjtcbnZhciBydGhyZWUgPSBcIuKLjFwiO1xudmFyIHJ0aW1lcyA9IFwi4ouKXCI7XG52YXIgcnRyaSA9IFwi4pa5XCI7XG52YXIgcnRyaWUgPSBcIuKKtVwiO1xudmFyIHJ0cmlmID0gXCLilrhcIjtcbnZhciBydHJpbHRyaSA9IFwi4qeOXCI7XG52YXIgUnVsZURlbGF5ZWQgPSBcIuKntFwiO1xudmFyIHJ1bHVoYXIgPSBcIuKlqFwiO1xudmFyIHJ4ID0gXCLihJ5cIjtcbnZhciBTYWN1dGUgPSBcIsWaXCI7XG52YXIgc2FjdXRlID0gXCLFm1wiO1xudmFyIHNicXVvID0gXCLigJpcIjtcbnZhciBzY2FwID0gXCLiqrhcIjtcbnZhciBTY2Fyb24gPSBcIsWgXCI7XG52YXIgc2Nhcm9uID0gXCLFoVwiO1xudmFyIFNjID0gXCLiqrxcIjtcbnZhciBzYyA9IFwi4om7XCI7XG52YXIgc2NjdWUgPSBcIuKJvVwiO1xudmFyIHNjZSA9IFwi4qqwXCI7XG52YXIgc2NFID0gXCLiqrRcIjtcbnZhciBTY2VkaWwgPSBcIsWeXCI7XG52YXIgc2NlZGlsID0gXCLFn1wiO1xudmFyIFNjaXJjID0gXCLFnFwiO1xudmFyIHNjaXJjID0gXCLFnVwiO1xudmFyIHNjbmFwID0gXCLiqrpcIjtcbnZhciBzY25FID0gXCLiqrZcIjtcbnZhciBzY25zaW0gPSBcIuKLqVwiO1xudmFyIHNjcG9saW50ID0gXCLiqJNcIjtcbnZhciBzY3NpbSA9IFwi4om/XCI7XG52YXIgU2N5ID0gXCLQoVwiO1xudmFyIHNjeSA9IFwi0YFcIjtcbnZhciBzZG90YiA9IFwi4oqhXCI7XG52YXIgc2RvdCA9IFwi4ouFXCI7XG52YXIgc2RvdGUgPSBcIuKpplwiO1xudmFyIHNlYXJoayA9IFwi4qSlXCI7XG52YXIgc2VhcnIgPSBcIuKGmFwiO1xudmFyIHNlQXJyID0gXCLih5hcIjtcbnZhciBzZWFycm93ID0gXCLihphcIjtcbnZhciBzZWN0JDEgPSBcIsKnXCI7XG52YXIgc2VtaSA9IFwiO1wiO1xudmFyIHNlc3dhciA9IFwi4qSpXCI7XG52YXIgc2V0bWludXMgPSBcIuKIllwiO1xudmFyIHNldG1uID0gXCLiiJZcIjtcbnZhciBzZXh0ID0gXCLinLZcIjtcbnZhciBTZnIgPSBcIvCdlJZcIjtcbnZhciBzZnIgPSBcIvCdlLBcIjtcbnZhciBzZnJvd24gPSBcIuKMolwiO1xudmFyIHNoYXJwID0gXCLima9cIjtcbnZhciBTSENIY3kgPSBcItCpXCI7XG52YXIgc2hjaGN5ID0gXCLRiVwiO1xudmFyIFNIY3kgPSBcItCoXCI7XG52YXIgc2hjeSA9IFwi0YhcIjtcbnZhciBTaG9ydERvd25BcnJvdyA9IFwi4oaTXCI7XG52YXIgU2hvcnRMZWZ0QXJyb3cgPSBcIuKGkFwiO1xudmFyIHNob3J0bWlkID0gXCLiiKNcIjtcbnZhciBzaG9ydHBhcmFsbGVsID0gXCLiiKVcIjtcbnZhciBTaG9ydFJpZ2h0QXJyb3cgPSBcIuKGklwiO1xudmFyIFNob3J0VXBBcnJvdyA9IFwi4oaRXCI7XG52YXIgc2h5JDEgPSBcIsKtXCI7XG52YXIgU2lnbWEgPSBcIs6jXCI7XG52YXIgc2lnbWEgPSBcIs+DXCI7XG52YXIgc2lnbWFmID0gXCLPglwiO1xudmFyIHNpZ21hdiA9IFwiz4JcIjtcbnZhciBzaW0gPSBcIuKIvFwiO1xudmFyIHNpbWRvdCA9IFwi4qmqXCI7XG52YXIgc2ltZSA9IFwi4omDXCI7XG52YXIgc2ltZXEgPSBcIuKJg1wiO1xudmFyIHNpbWcgPSBcIuKqnlwiO1xudmFyIHNpbWdFID0gXCLiqqBcIjtcbnZhciBzaW1sID0gXCLiqp1cIjtcbnZhciBzaW1sRSA9IFwi4qqfXCI7XG52YXIgc2ltbmUgPSBcIuKJhlwiO1xudmFyIHNpbXBsdXMgPSBcIuKopFwiO1xudmFyIHNpbXJhcnIgPSBcIuKlslwiO1xudmFyIHNsYXJyID0gXCLihpBcIjtcbnZhciBTbWFsbENpcmNsZSA9IFwi4oiYXCI7XG52YXIgc21hbGxzZXRtaW51cyA9IFwi4oiWXCI7XG52YXIgc21hc2hwID0gXCLiqLNcIjtcbnZhciBzbWVwYXJzbCA9IFwi4qekXCI7XG52YXIgc21pZCA9IFwi4oijXCI7XG52YXIgc21pbGUgPSBcIuKMo1wiO1xudmFyIHNtdCA9IFwi4qqqXCI7XG52YXIgc210ZSA9IFwi4qqsXCI7XG52YXIgc210ZXMgPSBcIuKqrO+4gFwiO1xudmFyIFNPRlRjeSA9IFwi0KxcIjtcbnZhciBzb2Z0Y3kgPSBcItGMXCI7XG52YXIgc29sYmFyID0gXCLijL9cIjtcbnZhciBzb2xiID0gXCLip4RcIjtcbnZhciBzb2wgPSBcIi9cIjtcbnZhciBTb3BmID0gXCLwnZWKXCI7XG52YXIgc29wZiA9IFwi8J2VpFwiO1xudmFyIHNwYWRlcyA9IFwi4pmgXCI7XG52YXIgc3BhZGVzdWl0ID0gXCLimaBcIjtcbnZhciBzcGFyID0gXCLiiKVcIjtcbnZhciBzcWNhcCA9IFwi4oqTXCI7XG52YXIgc3FjYXBzID0gXCLiipPvuIBcIjtcbnZhciBzcWN1cCA9IFwi4oqUXCI7XG52YXIgc3FjdXBzID0gXCLiipTvuIBcIjtcbnZhciBTcXJ0ID0gXCLiiJpcIjtcbnZhciBzcXN1YiA9IFwi4oqPXCI7XG52YXIgc3FzdWJlID0gXCLiipFcIjtcbnZhciBzcXN1YnNldCA9IFwi4oqPXCI7XG52YXIgc3FzdWJzZXRlcSA9IFwi4oqRXCI7XG52YXIgc3FzdXAgPSBcIuKKkFwiO1xudmFyIHNxc3VwZSA9IFwi4oqSXCI7XG52YXIgc3FzdXBzZXQgPSBcIuKKkFwiO1xudmFyIHNxc3Vwc2V0ZXEgPSBcIuKKklwiO1xudmFyIHNxdWFyZSA9IFwi4pahXCI7XG52YXIgU3F1YXJlID0gXCLilqFcIjtcbnZhciBTcXVhcmVJbnRlcnNlY3Rpb24gPSBcIuKKk1wiO1xudmFyIFNxdWFyZVN1YnNldCA9IFwi4oqPXCI7XG52YXIgU3F1YXJlU3Vic2V0RXF1YWwgPSBcIuKKkVwiO1xudmFyIFNxdWFyZVN1cGVyc2V0ID0gXCLiipBcIjtcbnZhciBTcXVhcmVTdXBlcnNldEVxdWFsID0gXCLiipJcIjtcbnZhciBTcXVhcmVVbmlvbiA9IFwi4oqUXCI7XG52YXIgc3F1YXJmID0gXCLilqpcIjtcbnZhciBzcXUgPSBcIuKWoVwiO1xudmFyIHNxdWYgPSBcIuKWqlwiO1xudmFyIHNyYXJyID0gXCLihpJcIjtcbnZhciBTc2NyID0gXCLwnZKuXCI7XG52YXIgc3NjciA9IFwi8J2TiFwiO1xudmFyIHNzZXRtbiA9IFwi4oiWXCI7XG52YXIgc3NtaWxlID0gXCLijKNcIjtcbnZhciBzc3RhcmYgPSBcIuKLhlwiO1xudmFyIFN0YXIgPSBcIuKLhlwiO1xudmFyIHN0YXIgPSBcIuKYhlwiO1xudmFyIHN0YXJmID0gXCLimIVcIjtcbnZhciBzdHJhaWdodGVwc2lsb24gPSBcIs+1XCI7XG52YXIgc3RyYWlnaHRwaGkgPSBcIs+VXCI7XG52YXIgc3RybnMgPSBcIsKvXCI7XG52YXIgc3ViID0gXCLiioJcIjtcbnZhciBTdWIgPSBcIuKLkFwiO1xudmFyIHN1YmRvdCA9IFwi4qq9XCI7XG52YXIgc3ViRSA9IFwi4quFXCI7XG52YXIgc3ViZSA9IFwi4oqGXCI7XG52YXIgc3ViZWRvdCA9IFwi4quDXCI7XG52YXIgc3VibXVsdCA9IFwi4quBXCI7XG52YXIgc3VibkUgPSBcIuKri1wiO1xudmFyIHN1Ym5lID0gXCLiiopcIjtcbnZhciBzdWJwbHVzID0gXCLiqr9cIjtcbnZhciBzdWJyYXJyID0gXCLipblcIjtcbnZhciBzdWJzZXQgPSBcIuKKglwiO1xudmFyIFN1YnNldCA9IFwi4ouQXCI7XG52YXIgc3Vic2V0ZXEgPSBcIuKKhlwiO1xudmFyIHN1YnNldGVxcSA9IFwi4quFXCI7XG52YXIgU3Vic2V0RXF1YWwgPSBcIuKKhlwiO1xudmFyIHN1YnNldG5lcSA9IFwi4oqKXCI7XG52YXIgc3Vic2V0bmVxcSA9IFwi4quLXCI7XG52YXIgc3Vic2ltID0gXCLiq4dcIjtcbnZhciBzdWJzdWIgPSBcIuKrlVwiO1xudmFyIHN1YnN1cCA9IFwi4quTXCI7XG52YXIgc3VjY2FwcHJveCA9IFwi4qq4XCI7XG52YXIgc3VjYyA9IFwi4om7XCI7XG52YXIgc3VjY2N1cmx5ZXEgPSBcIuKJvVwiO1xudmFyIFN1Y2NlZWRzID0gXCLiibtcIjtcbnZhciBTdWNjZWVkc0VxdWFsID0gXCLiqrBcIjtcbnZhciBTdWNjZWVkc1NsYW50RXF1YWwgPSBcIuKJvVwiO1xudmFyIFN1Y2NlZWRzVGlsZGUgPSBcIuKJv1wiO1xudmFyIHN1Y2NlcSA9IFwi4qqwXCI7XG52YXIgc3VjY25hcHByb3ggPSBcIuKqulwiO1xudmFyIHN1Y2NuZXFxID0gXCLiqrZcIjtcbnZhciBzdWNjbnNpbSA9IFwi4oupXCI7XG52YXIgc3VjY3NpbSA9IFwi4om/XCI7XG52YXIgU3VjaFRoYXQgPSBcIuKIi1wiO1xudmFyIHN1bSA9IFwi4oiRXCI7XG52YXIgU3VtID0gXCLiiJFcIjtcbnZhciBzdW5nID0gXCLimapcIjtcbnZhciBzdXAxJDEgPSBcIsK5XCI7XG52YXIgc3VwMiQxID0gXCLCslwiO1xudmFyIHN1cDMkMSA9IFwiwrNcIjtcbnZhciBzdXAgPSBcIuKKg1wiO1xudmFyIFN1cCA9IFwi4ouRXCI7XG52YXIgc3VwZG90ID0gXCLiqr5cIjtcbnZhciBzdXBkc3ViID0gXCLiq5hcIjtcbnZhciBzdXBFID0gXCLiq4ZcIjtcbnZhciBzdXBlID0gXCLiiodcIjtcbnZhciBzdXBlZG90ID0gXCLiq4RcIjtcbnZhciBTdXBlcnNldCA9IFwi4oqDXCI7XG52YXIgU3VwZXJzZXRFcXVhbCA9IFwi4oqHXCI7XG52YXIgc3VwaHNvbCA9IFwi4p+JXCI7XG52YXIgc3VwaHN1YiA9IFwi4quXXCI7XG52YXIgc3VwbGFyciA9IFwi4qW7XCI7XG52YXIgc3VwbXVsdCA9IFwi4quCXCI7XG52YXIgc3VwbkUgPSBcIuKrjFwiO1xudmFyIHN1cG5lID0gXCLiiotcIjtcbnZhciBzdXBwbHVzID0gXCLiq4BcIjtcbnZhciBzdXBzZXQgPSBcIuKKg1wiO1xudmFyIFN1cHNldCA9IFwi4ouRXCI7XG52YXIgc3Vwc2V0ZXEgPSBcIuKKh1wiO1xudmFyIHN1cHNldGVxcSA9IFwi4quGXCI7XG52YXIgc3Vwc2V0bmVxID0gXCLiiotcIjtcbnZhciBzdXBzZXRuZXFxID0gXCLiq4xcIjtcbnZhciBzdXBzaW0gPSBcIuKriFwiO1xudmFyIHN1cHN1YiA9IFwi4quUXCI7XG52YXIgc3Vwc3VwID0gXCLiq5ZcIjtcbnZhciBzd2FyaGsgPSBcIuKkplwiO1xudmFyIHN3YXJyID0gXCLihplcIjtcbnZhciBzd0FyciA9IFwi4oeZXCI7XG52YXIgc3dhcnJvdyA9IFwi4oaZXCI7XG52YXIgc3dud2FyID0gXCLipKpcIjtcbnZhciBzemxpZyQxID0gXCLDn1wiO1xudmFyIFRhYiA9IFwiXFx0XCI7XG52YXIgdGFyZ2V0ID0gXCLijJZcIjtcbnZhciBUYXUgPSBcIs6kXCI7XG52YXIgdGF1ID0gXCLPhFwiO1xudmFyIHRicmsgPSBcIuKOtFwiO1xudmFyIFRjYXJvbiA9IFwixaRcIjtcbnZhciB0Y2Fyb24gPSBcIsWlXCI7XG52YXIgVGNlZGlsID0gXCLFolwiO1xudmFyIHRjZWRpbCA9IFwixaNcIjtcbnZhciBUY3kgPSBcItCiXCI7XG52YXIgdGN5ID0gXCLRglwiO1xudmFyIHRkb3QgPSBcIuKDm1wiO1xudmFyIHRlbHJlYyA9IFwi4oyVXCI7XG52YXIgVGZyID0gXCLwnZSXXCI7XG52YXIgdGZyID0gXCLwnZSxXCI7XG52YXIgdGhlcmU0ID0gXCLiiLRcIjtcbnZhciB0aGVyZWZvcmUgPSBcIuKItFwiO1xudmFyIFRoZXJlZm9yZSA9IFwi4oi0XCI7XG52YXIgVGhldGEgPSBcIs6YXCI7XG52YXIgdGhldGEgPSBcIs64XCI7XG52YXIgdGhldGFzeW0gPSBcIs+RXCI7XG52YXIgdGhldGF2ID0gXCLPkVwiO1xudmFyIHRoaWNrYXBwcm94ID0gXCLiiYhcIjtcbnZhciB0aGlja3NpbSA9IFwi4oi8XCI7XG52YXIgVGhpY2tTcGFjZSA9IFwi4oGf4oCKXCI7XG52YXIgVGhpblNwYWNlID0gXCLigIlcIjtcbnZhciB0aGluc3AgPSBcIuKAiVwiO1xudmFyIHRoa2FwID0gXCLiiYhcIjtcbnZhciB0aGtzaW0gPSBcIuKIvFwiO1xudmFyIFRIT1JOJDEgPSBcIsOeXCI7XG52YXIgdGhvcm4kMSA9IFwiw75cIjtcbnZhciB0aWxkZSA9IFwiy5xcIjtcbnZhciBUaWxkZSA9IFwi4oi8XCI7XG52YXIgVGlsZGVFcXVhbCA9IFwi4omDXCI7XG52YXIgVGlsZGVGdWxsRXF1YWwgPSBcIuKJhVwiO1xudmFyIFRpbGRlVGlsZGUgPSBcIuKJiFwiO1xudmFyIHRpbWVzYmFyID0gXCLiqLFcIjtcbnZhciB0aW1lc2IgPSBcIuKKoFwiO1xudmFyIHRpbWVzJDEgPSBcIsOXXCI7XG52YXIgdGltZXNkID0gXCLiqLBcIjtcbnZhciB0aW50ID0gXCLiiK1cIjtcbnZhciB0b2VhID0gXCLipKhcIjtcbnZhciB0b3Bib3QgPSBcIuKMtlwiO1xudmFyIHRvcGNpciA9IFwi4quxXCI7XG52YXIgdG9wID0gXCLiiqRcIjtcbnZhciBUb3BmID0gXCLwnZWLXCI7XG52YXIgdG9wZiA9IFwi8J2VpVwiO1xudmFyIHRvcGZvcmsgPSBcIuKrmlwiO1xudmFyIHRvc2EgPSBcIuKkqVwiO1xudmFyIHRwcmltZSA9IFwi4oC0XCI7XG52YXIgdHJhZGUgPSBcIuKEolwiO1xudmFyIFRSQURFID0gXCLihKJcIjtcbnZhciB0cmlhbmdsZSA9IFwi4pa1XCI7XG52YXIgdHJpYW5nbGVkb3duID0gXCLilr9cIjtcbnZhciB0cmlhbmdsZWxlZnQgPSBcIuKXg1wiO1xudmFyIHRyaWFuZ2xlbGVmdGVxID0gXCLiirRcIjtcbnZhciB0cmlhbmdsZXEgPSBcIuKJnFwiO1xudmFyIHRyaWFuZ2xlcmlnaHQgPSBcIuKWuVwiO1xudmFyIHRyaWFuZ2xlcmlnaHRlcSA9IFwi4oq1XCI7XG52YXIgdHJpZG90ID0gXCLil6xcIjtcbnZhciB0cmllID0gXCLiiZxcIjtcbnZhciB0cmltaW51cyA9IFwi4qi6XCI7XG52YXIgVHJpcGxlRG90ID0gXCLig5tcIjtcbnZhciB0cmlwbHVzID0gXCLiqLlcIjtcbnZhciB0cmlzYiA9IFwi4qeNXCI7XG52YXIgdHJpdGltZSA9IFwi4qi7XCI7XG52YXIgdHJwZXppdW0gPSBcIuKPolwiO1xudmFyIFRzY3IgPSBcIvCdkq9cIjtcbnZhciB0c2NyID0gXCLwnZOJXCI7XG52YXIgVFNjeSA9IFwi0KZcIjtcbnZhciB0c2N5ID0gXCLRhlwiO1xudmFyIFRTSGN5ID0gXCLQi1wiO1xudmFyIHRzaGN5ID0gXCLRm1wiO1xudmFyIFRzdHJvayA9IFwixaZcIjtcbnZhciB0c3Ryb2sgPSBcIsWnXCI7XG52YXIgdHdpeHQgPSBcIuKJrFwiO1xudmFyIHR3b2hlYWRsZWZ0YXJyb3cgPSBcIuKGnlwiO1xudmFyIHR3b2hlYWRyaWdodGFycm93ID0gXCLihqBcIjtcbnZhciBVYWN1dGUkMSA9IFwiw5pcIjtcbnZhciB1YWN1dGUkMSA9IFwiw7pcIjtcbnZhciB1YXJyID0gXCLihpFcIjtcbnZhciBVYXJyID0gXCLihp9cIjtcbnZhciB1QXJyID0gXCLih5FcIjtcbnZhciBVYXJyb2NpciA9IFwi4qWJXCI7XG52YXIgVWJyY3kgPSBcItCOXCI7XG52YXIgdWJyY3kgPSBcItGeXCI7XG52YXIgVWJyZXZlID0gXCLFrFwiO1xudmFyIHVicmV2ZSA9IFwixa1cIjtcbnZhciBVY2lyYyQxID0gXCLDm1wiO1xudmFyIHVjaXJjJDEgPSBcIsO7XCI7XG52YXIgVWN5ID0gXCLQo1wiO1xudmFyIHVjeSA9IFwi0YNcIjtcbnZhciB1ZGFyciA9IFwi4oeFXCI7XG52YXIgVWRibGFjID0gXCLFsFwiO1xudmFyIHVkYmxhYyA9IFwixbFcIjtcbnZhciB1ZGhhciA9IFwi4qWuXCI7XG52YXIgdWZpc2h0ID0gXCLipb5cIjtcbnZhciBVZnIgPSBcIvCdlJhcIjtcbnZhciB1ZnIgPSBcIvCdlLJcIjtcbnZhciBVZ3JhdmUkMSA9IFwiw5lcIjtcbnZhciB1Z3JhdmUkMSA9IFwiw7lcIjtcbnZhciB1SGFyID0gXCLipaNcIjtcbnZhciB1aGFybCA9IFwi4oa/XCI7XG52YXIgdWhhcnIgPSBcIuKGvlwiO1xudmFyIHVoYmxrID0gXCLiloBcIjtcbnZhciB1bGNvcm4gPSBcIuKMnFwiO1xudmFyIHVsY29ybmVyID0gXCLijJxcIjtcbnZhciB1bGNyb3AgPSBcIuKMj1wiO1xudmFyIHVsdHJpID0gXCLil7hcIjtcbnZhciBVbWFjciA9IFwixapcIjtcbnZhciB1bWFjciA9IFwixatcIjtcbnZhciB1bWwkMSA9IFwiwqhcIjtcbnZhciBVbmRlckJhciA9IFwiX1wiO1xudmFyIFVuZGVyQnJhY2UgPSBcIuKPn1wiO1xudmFyIFVuZGVyQnJhY2tldCA9IFwi4o61XCI7XG52YXIgVW5kZXJQYXJlbnRoZXNpcyA9IFwi4o+dXCI7XG52YXIgVW5pb24gPSBcIuKLg1wiO1xudmFyIFVuaW9uUGx1cyA9IFwi4oqOXCI7XG52YXIgVW9nb24gPSBcIsWyXCI7XG52YXIgdW9nb24gPSBcIsWzXCI7XG52YXIgVW9wZiA9IFwi8J2VjFwiO1xudmFyIHVvcGYgPSBcIvCdlaZcIjtcbnZhciBVcEFycm93QmFyID0gXCLipJJcIjtcbnZhciB1cGFycm93ID0gXCLihpFcIjtcbnZhciBVcEFycm93ID0gXCLihpFcIjtcbnZhciBVcGFycm93ID0gXCLih5FcIjtcbnZhciBVcEFycm93RG93bkFycm93ID0gXCLih4VcIjtcbnZhciB1cGRvd25hcnJvdyA9IFwi4oaVXCI7XG52YXIgVXBEb3duQXJyb3cgPSBcIuKGlVwiO1xudmFyIFVwZG93bmFycm93ID0gXCLih5VcIjtcbnZhciBVcEVxdWlsaWJyaXVtID0gXCLipa5cIjtcbnZhciB1cGhhcnBvb25sZWZ0ID0gXCLihr9cIjtcbnZhciB1cGhhcnBvb25yaWdodCA9IFwi4oa+XCI7XG52YXIgdXBsdXMgPSBcIuKKjlwiO1xudmFyIFVwcGVyTGVmdEFycm93ID0gXCLihpZcIjtcbnZhciBVcHBlclJpZ2h0QXJyb3cgPSBcIuKGl1wiO1xudmFyIHVwc2kgPSBcIs+FXCI7XG52YXIgVXBzaSA9IFwiz5JcIjtcbnZhciB1cHNpaCA9IFwiz5JcIjtcbnZhciBVcHNpbG9uID0gXCLOpVwiO1xudmFyIHVwc2lsb24gPSBcIs+FXCI7XG52YXIgVXBUZWVBcnJvdyA9IFwi4oalXCI7XG52YXIgVXBUZWUgPSBcIuKKpVwiO1xudmFyIHVwdXBhcnJvd3MgPSBcIuKHiFwiO1xudmFyIHVyY29ybiA9IFwi4oydXCI7XG52YXIgdXJjb3JuZXIgPSBcIuKMnVwiO1xudmFyIHVyY3JvcCA9IFwi4oyOXCI7XG52YXIgVXJpbmcgPSBcIsWuXCI7XG52YXIgdXJpbmcgPSBcIsWvXCI7XG52YXIgdXJ0cmkgPSBcIuKXuVwiO1xudmFyIFVzY3IgPSBcIvCdkrBcIjtcbnZhciB1c2NyID0gXCLwnZOKXCI7XG52YXIgdXRkb3QgPSBcIuKLsFwiO1xudmFyIFV0aWxkZSA9IFwixahcIjtcbnZhciB1dGlsZGUgPSBcIsWpXCI7XG52YXIgdXRyaSA9IFwi4pa1XCI7XG52YXIgdXRyaWYgPSBcIuKWtFwiO1xudmFyIHV1YXJyID0gXCLih4hcIjtcbnZhciBVdW1sJDEgPSBcIsOcXCI7XG52YXIgdXVtbCQxID0gXCLDvFwiO1xudmFyIHV3YW5nbGUgPSBcIuKmp1wiO1xudmFyIHZhbmdydCA9IFwi4qacXCI7XG52YXIgdmFyZXBzaWxvbiA9IFwiz7VcIjtcbnZhciB2YXJrYXBwYSA9IFwiz7BcIjtcbnZhciB2YXJub3RoaW5nID0gXCLiiIVcIjtcbnZhciB2YXJwaGkgPSBcIs+VXCI7XG52YXIgdmFycGkgPSBcIs+WXCI7XG52YXIgdmFycHJvcHRvID0gXCLiiJ1cIjtcbnZhciB2YXJyID0gXCLihpVcIjtcbnZhciB2QXJyID0gXCLih5VcIjtcbnZhciB2YXJyaG8gPSBcIs+xXCI7XG52YXIgdmFyc2lnbWEgPSBcIs+CXCI7XG52YXIgdmFyc3Vic2V0bmVxID0gXCLiiorvuIBcIjtcbnZhciB2YXJzdWJzZXRuZXFxID0gXCLiq4vvuIBcIjtcbnZhciB2YXJzdXBzZXRuZXEgPSBcIuKKi++4gFwiO1xudmFyIHZhcnN1cHNldG5lcXEgPSBcIuKrjO+4gFwiO1xudmFyIHZhcnRoZXRhID0gXCLPkVwiO1xudmFyIHZhcnRyaWFuZ2xlbGVmdCA9IFwi4oqyXCI7XG52YXIgdmFydHJpYW5nbGVyaWdodCA9IFwi4oqzXCI7XG52YXIgdkJhciA9IFwi4quoXCI7XG52YXIgVmJhciA9IFwi4qurXCI7XG52YXIgdkJhcnYgPSBcIuKrqVwiO1xudmFyIFZjeSA9IFwi0JJcIjtcbnZhciB2Y3kgPSBcItCyXCI7XG52YXIgdmRhc2ggPSBcIuKKolwiO1xudmFyIHZEYXNoID0gXCLiiqhcIjtcbnZhciBWZGFzaCA9IFwi4oqpXCI7XG52YXIgVkRhc2ggPSBcIuKKq1wiO1xudmFyIFZkYXNobCA9IFwi4qumXCI7XG52YXIgdmVlYmFyID0gXCLiirtcIjtcbnZhciB2ZWUgPSBcIuKIqFwiO1xudmFyIFZlZSA9IFwi4ouBXCI7XG52YXIgdmVlZXEgPSBcIuKJmlwiO1xudmFyIHZlbGxpcCA9IFwi4ouuXCI7XG52YXIgdmVyYmFyID0gXCJ8XCI7XG52YXIgVmVyYmFyID0gXCLigJZcIjtcbnZhciB2ZXJ0ID0gXCJ8XCI7XG52YXIgVmVydCA9IFwi4oCWXCI7XG52YXIgVmVydGljYWxCYXIgPSBcIuKIo1wiO1xudmFyIFZlcnRpY2FsTGluZSA9IFwifFwiO1xudmFyIFZlcnRpY2FsU2VwYXJhdG9yID0gXCLinZhcIjtcbnZhciBWZXJ0aWNhbFRpbGRlID0gXCLiiYBcIjtcbnZhciBWZXJ5VGhpblNwYWNlID0gXCLigIpcIjtcbnZhciBWZnIgPSBcIvCdlJlcIjtcbnZhciB2ZnIgPSBcIvCdlLNcIjtcbnZhciB2bHRyaSA9IFwi4oqyXCI7XG52YXIgdm5zdWIgPSBcIuKKguKDklwiO1xudmFyIHZuc3VwID0gXCLiioPig5JcIjtcbnZhciBWb3BmID0gXCLwnZWNXCI7XG52YXIgdm9wZiA9IFwi8J2Vp1wiO1xudmFyIHZwcm9wID0gXCLiiJ1cIjtcbnZhciB2cnRyaSA9IFwi4oqzXCI7XG52YXIgVnNjciA9IFwi8J2SsVwiO1xudmFyIHZzY3IgPSBcIvCdk4tcIjtcbnZhciB2c3VibkUgPSBcIuKri++4gFwiO1xudmFyIHZzdWJuZSA9IFwi4oqK77iAXCI7XG52YXIgdnN1cG5FID0gXCLiq4zvuIBcIjtcbnZhciB2c3VwbmUgPSBcIuKKi++4gFwiO1xudmFyIFZ2ZGFzaCA9IFwi4oqqXCI7XG52YXIgdnppZ3phZyA9IFwi4qaaXCI7XG52YXIgV2NpcmMgPSBcIsW0XCI7XG52YXIgd2NpcmMgPSBcIsW1XCI7XG52YXIgd2VkYmFyID0gXCLiqZ9cIjtcbnZhciB3ZWRnZSA9IFwi4oinXCI7XG52YXIgV2VkZ2UgPSBcIuKLgFwiO1xudmFyIHdlZGdlcSA9IFwi4omZXCI7XG52YXIgd2VpZXJwID0gXCLihJhcIjtcbnZhciBXZnIgPSBcIvCdlJpcIjtcbnZhciB3ZnIgPSBcIvCdlLRcIjtcbnZhciBXb3BmID0gXCLwnZWOXCI7XG52YXIgd29wZiA9IFwi8J2VqFwiO1xudmFyIHdwID0gXCLihJhcIjtcbnZhciB3ciA9IFwi4omAXCI7XG52YXIgd3JlYXRoID0gXCLiiYBcIjtcbnZhciBXc2NyID0gXCLwnZKyXCI7XG52YXIgd3NjciA9IFwi8J2TjFwiO1xudmFyIHhjYXAgPSBcIuKLglwiO1xudmFyIHhjaXJjID0gXCLil69cIjtcbnZhciB4Y3VwID0gXCLii4NcIjtcbnZhciB4ZHRyaSA9IFwi4pa9XCI7XG52YXIgWGZyID0gXCLwnZSbXCI7XG52YXIgeGZyID0gXCLwnZS1XCI7XG52YXIgeGhhcnIgPSBcIuKft1wiO1xudmFyIHhoQXJyID0gXCLin7pcIjtcbnZhciBYaSA9IFwizp5cIjtcbnZhciB4aSA9IFwizr5cIjtcbnZhciB4bGFyciA9IFwi4p+1XCI7XG52YXIgeGxBcnIgPSBcIuKfuFwiO1xudmFyIHhtYXAgPSBcIuKfvFwiO1xudmFyIHhuaXMgPSBcIuKLu1wiO1xudmFyIHhvZG90ID0gXCLiqIBcIjtcbnZhciBYb3BmID0gXCLwnZWPXCI7XG52YXIgeG9wZiA9IFwi8J2VqVwiO1xudmFyIHhvcGx1cyA9IFwi4qiBXCI7XG52YXIgeG90aW1lID0gXCLiqIJcIjtcbnZhciB4cmFyciA9IFwi4p+2XCI7XG52YXIgeHJBcnIgPSBcIuKfuVwiO1xudmFyIFhzY3IgPSBcIvCdkrNcIjtcbnZhciB4c2NyID0gXCLwnZONXCI7XG52YXIgeHNxY3VwID0gXCLiqIZcIjtcbnZhciB4dXBsdXMgPSBcIuKohFwiO1xudmFyIHh1dHJpID0gXCLilrNcIjtcbnZhciB4dmVlID0gXCLii4FcIjtcbnZhciB4d2VkZ2UgPSBcIuKLgFwiO1xudmFyIFlhY3V0ZSQxID0gXCLDnVwiO1xudmFyIHlhY3V0ZSQxID0gXCLDvVwiO1xudmFyIFlBY3kgPSBcItCvXCI7XG52YXIgeWFjeSA9IFwi0Y9cIjtcbnZhciBZY2lyYyA9IFwixbZcIjtcbnZhciB5Y2lyYyA9IFwixbdcIjtcbnZhciBZY3kgPSBcItCrXCI7XG52YXIgeWN5ID0gXCLRi1wiO1xudmFyIHllbiQxID0gXCLCpVwiO1xudmFyIFlmciA9IFwi8J2UnFwiO1xudmFyIHlmciA9IFwi8J2UtlwiO1xudmFyIFlJY3kgPSBcItCHXCI7XG52YXIgeWljeSA9IFwi0ZdcIjtcbnZhciBZb3BmID0gXCLwnZWQXCI7XG52YXIgeW9wZiA9IFwi8J2VqlwiO1xudmFyIFlzY3IgPSBcIvCdkrRcIjtcbnZhciB5c2NyID0gXCLwnZOOXCI7XG52YXIgWVVjeSA9IFwi0K5cIjtcbnZhciB5dWN5ID0gXCLRjlwiO1xudmFyIHl1bWwkMSA9IFwiw79cIjtcbnZhciBZdW1sID0gXCLFuFwiO1xudmFyIFphY3V0ZSA9IFwixblcIjtcbnZhciB6YWN1dGUgPSBcIsW6XCI7XG52YXIgWmNhcm9uID0gXCLFvVwiO1xudmFyIHpjYXJvbiA9IFwixb5cIjtcbnZhciBaY3kgPSBcItCXXCI7XG52YXIgemN5ID0gXCLQt1wiO1xudmFyIFpkb3QgPSBcIsW7XCI7XG52YXIgemRvdCA9IFwixbxcIjtcbnZhciB6ZWV0cmYgPSBcIuKEqFwiO1xudmFyIFplcm9XaWR0aFNwYWNlID0gXCLigItcIjtcbnZhciBaZXRhID0gXCLOllwiO1xudmFyIHpldGEgPSBcIs62XCI7XG52YXIgemZyID0gXCLwnZS3XCI7XG52YXIgWmZyID0gXCLihKhcIjtcbnZhciBaSGN5ID0gXCLQllwiO1xudmFyIHpoY3kgPSBcItC2XCI7XG52YXIgemlncmFyciA9IFwi4oedXCI7XG52YXIgem9wZiA9IFwi8J2Vq1wiO1xudmFyIFpvcGYgPSBcIuKEpFwiO1xudmFyIFpzY3IgPSBcIvCdkrVcIjtcbnZhciB6c2NyID0gXCLwnZOPXCI7XG52YXIgendqID0gXCLigI1cIjtcbnZhciB6d25qID0gXCLigIxcIjtcbnZhciByZXF1aXJlJCQxJDEgPSB7XG5cdEFhY3V0ZTogQWFjdXRlJDEsXG5cdGFhY3V0ZTogYWFjdXRlJDEsXG5cdEFicmV2ZTogQWJyZXZlLFxuXHRhYnJldmU6IGFicmV2ZSxcblx0YWM6IGFjLFxuXHRhY2Q6IGFjZCxcblx0YWNFOiBhY0UsXG5cdEFjaXJjOiBBY2lyYyQxLFxuXHRhY2lyYzogYWNpcmMkMSxcblx0YWN1dGU6IGFjdXRlJDEsXG5cdEFjeTogQWN5LFxuXHRhY3k6IGFjeSxcblx0QUVsaWc6IEFFbGlnJDEsXG5cdGFlbGlnOiBhZWxpZyQxLFxuXHRhZjogYWYsXG5cdEFmcjogQWZyLFxuXHRhZnI6IGFmcixcblx0QWdyYXZlOiBBZ3JhdmUkMSxcblx0YWdyYXZlOiBhZ3JhdmUkMSxcblx0YWxlZnN5bTogYWxlZnN5bSxcblx0YWxlcGg6IGFsZXBoLFxuXHRBbHBoYTogQWxwaGEsXG5cdGFscGhhOiBhbHBoYSxcblx0QW1hY3I6IEFtYWNyLFxuXHRhbWFjcjogYW1hY3IsXG5cdGFtYWxnOiBhbWFsZyxcblx0YW1wOiBhbXAkMixcblx0QU1QOiBBTVAkMSxcblx0YW5kYW5kOiBhbmRhbmQsXG5cdEFuZDogQW5kLFxuXHRhbmQ6IGFuZCxcblx0YW5kZDogYW5kZCxcblx0YW5kc2xvcGU6IGFuZHNsb3BlLFxuXHRhbmR2OiBhbmR2LFxuXHRhbmc6IGFuZyxcblx0YW5nZTogYW5nZSxcblx0YW5nbGU6IGFuZ2xlLFxuXHRhbmdtc2RhYTogYW5nbXNkYWEsXG5cdGFuZ21zZGFiOiBhbmdtc2RhYixcblx0YW5nbXNkYWM6IGFuZ21zZGFjLFxuXHRhbmdtc2RhZDogYW5nbXNkYWQsXG5cdGFuZ21zZGFlOiBhbmdtc2RhZSxcblx0YW5nbXNkYWY6IGFuZ21zZGFmLFxuXHRhbmdtc2RhZzogYW5nbXNkYWcsXG5cdGFuZ21zZGFoOiBhbmdtc2RhaCxcblx0YW5nbXNkOiBhbmdtc2QsXG5cdGFuZ3J0OiBhbmdydCxcblx0YW5ncnR2YjogYW5ncnR2Yixcblx0YW5ncnR2YmQ6IGFuZ3J0dmJkLFxuXHRhbmdzcGg6IGFuZ3NwaCxcblx0YW5nc3Q6IGFuZ3N0LFxuXHRhbmd6YXJyOiBhbmd6YXJyLFxuXHRBb2dvbjogQW9nb24sXG5cdGFvZ29uOiBhb2dvbixcblx0QW9wZjogQW9wZixcblx0YW9wZjogYW9wZixcblx0YXBhY2lyOiBhcGFjaXIsXG5cdGFwOiBhcCxcblx0YXBFOiBhcEUsXG5cdGFwZTogYXBlLFxuXHRhcGlkOiBhcGlkLFxuXHRhcG9zOiBhcG9zJDEsXG5cdEFwcGx5RnVuY3Rpb246IEFwcGx5RnVuY3Rpb24sXG5cdGFwcHJveDogYXBwcm94LFxuXHRhcHByb3hlcTogYXBwcm94ZXEsXG5cdEFyaW5nOiBBcmluZyQxLFxuXHRhcmluZzogYXJpbmckMSxcblx0QXNjcjogQXNjcixcblx0YXNjcjogYXNjcixcblx0QXNzaWduOiBBc3NpZ24sXG5cdGFzdDogYXN0LFxuXHRhc3ltcDogYXN5bXAsXG5cdGFzeW1wZXE6IGFzeW1wZXEsXG5cdEF0aWxkZTogQXRpbGRlJDEsXG5cdGF0aWxkZTogYXRpbGRlJDEsXG5cdEF1bWw6IEF1bWwkMSxcblx0YXVtbDogYXVtbCQxLFxuXHRhd2NvbmludDogYXdjb25pbnQsXG5cdGF3aW50OiBhd2ludCxcblx0YmFja2Nvbmc6IGJhY2tjb25nLFxuXHRiYWNrZXBzaWxvbjogYmFja2Vwc2lsb24sXG5cdGJhY2twcmltZTogYmFja3ByaW1lLFxuXHRiYWNrc2ltOiBiYWNrc2ltLFxuXHRiYWNrc2ltZXE6IGJhY2tzaW1lcSxcblx0QmFja3NsYXNoOiBCYWNrc2xhc2gsXG5cdEJhcnY6IEJhcnYsXG5cdGJhcnZlZTogYmFydmVlLFxuXHRiYXJ3ZWQ6IGJhcndlZCxcblx0QmFyd2VkOiBCYXJ3ZWQsXG5cdGJhcndlZGdlOiBiYXJ3ZWRnZSxcblx0YmJyazogYmJyayxcblx0YmJya3Ricms6IGJicmt0YnJrLFxuXHRiY29uZzogYmNvbmcsXG5cdEJjeTogQmN5LFxuXHRiY3k6IGJjeSxcblx0YmRxdW86IGJkcXVvLFxuXHRiZWNhdXM6IGJlY2F1cyxcblx0YmVjYXVzZTogYmVjYXVzZSxcblx0QmVjYXVzZTogQmVjYXVzZSxcblx0YmVtcHR5djogYmVtcHR5dixcblx0YmVwc2k6IGJlcHNpLFxuXHRiZXJub3U6IGJlcm5vdSxcblx0QmVybm91bGxpczogQmVybm91bGxpcyxcblx0QmV0YTogQmV0YSxcblx0YmV0YTogYmV0YSxcblx0YmV0aDogYmV0aCxcblx0YmV0d2VlbjogYmV0d2Vlbixcblx0QmZyOiBCZnIsXG5cdGJmcjogYmZyLFxuXHRiaWdjYXA6IGJpZ2NhcCxcblx0YmlnY2lyYzogYmlnY2lyYyxcblx0YmlnY3VwOiBiaWdjdXAsXG5cdGJpZ29kb3Q6IGJpZ29kb3QsXG5cdGJpZ29wbHVzOiBiaWdvcGx1cyxcblx0Ymlnb3RpbWVzOiBiaWdvdGltZXMsXG5cdGJpZ3NxY3VwOiBiaWdzcWN1cCxcblx0Ymlnc3RhcjogYmlnc3Rhcixcblx0YmlndHJpYW5nbGVkb3duOiBiaWd0cmlhbmdsZWRvd24sXG5cdGJpZ3RyaWFuZ2xldXA6IGJpZ3RyaWFuZ2xldXAsXG5cdGJpZ3VwbHVzOiBiaWd1cGx1cyxcblx0YmlndmVlOiBiaWd2ZWUsXG5cdGJpZ3dlZGdlOiBiaWd3ZWRnZSxcblx0Ymthcm93OiBia2Fyb3csXG5cdGJsYWNrbG96ZW5nZTogYmxhY2tsb3plbmdlLFxuXHRibGFja3NxdWFyZTogYmxhY2tzcXVhcmUsXG5cdGJsYWNrdHJpYW5nbGU6IGJsYWNrdHJpYW5nbGUsXG5cdGJsYWNrdHJpYW5nbGVkb3duOiBibGFja3RyaWFuZ2xlZG93bixcblx0YmxhY2t0cmlhbmdsZWxlZnQ6IGJsYWNrdHJpYW5nbGVsZWZ0LFxuXHRibGFja3RyaWFuZ2xlcmlnaHQ6IGJsYWNrdHJpYW5nbGVyaWdodCxcblx0Ymxhbms6IGJsYW5rLFxuXHRibGsxMjogYmxrMTIsXG5cdGJsazE0OiBibGsxNCxcblx0YmxrMzQ6IGJsazM0LFxuXHRibG9jazogYmxvY2ssXG5cdGJuZTogYm5lLFxuXHRibmVxdWl2OiBibmVxdWl2LFxuXHRiTm90OiBiTm90LFxuXHRibm90OiBibm90LFxuXHRCb3BmOiBCb3BmLFxuXHRib3BmOiBib3BmLFxuXHRib3Q6IGJvdCxcblx0Ym90dG9tOiBib3R0b20sXG5cdGJvd3RpZTogYm93dGllLFxuXHRib3hib3g6IGJveGJveCxcblx0Ym94ZGw6IGJveGRsLFxuXHRib3hkTDogYm94ZEwsXG5cdGJveERsOiBib3hEbCxcblx0Ym94REw6IGJveERMLFxuXHRib3hkcjogYm94ZHIsXG5cdGJveGRSOiBib3hkUixcblx0Ym94RHI6IGJveERyLFxuXHRib3hEUjogYm94RFIsXG5cdGJveGg6IGJveGgsXG5cdGJveEg6IGJveEgsXG5cdGJveGhkOiBib3hoZCxcblx0Ym94SGQ6IGJveEhkLFxuXHRib3hoRDogYm94aEQsXG5cdGJveEhEOiBib3hIRCxcblx0Ym94aHU6IGJveGh1LFxuXHRib3hIdTogYm94SHUsXG5cdGJveGhVOiBib3hoVSxcblx0Ym94SFU6IGJveEhVLFxuXHRib3htaW51czogYm94bWludXMsXG5cdGJveHBsdXM6IGJveHBsdXMsXG5cdGJveHRpbWVzOiBib3h0aW1lcyxcblx0Ym94dWw6IGJveHVsLFxuXHRib3h1TDogYm94dUwsXG5cdGJveFVsOiBib3hVbCxcblx0Ym94VUw6IGJveFVMLFxuXHRib3h1cjogYm94dXIsXG5cdGJveHVSOiBib3h1Uixcblx0Ym94VXI6IGJveFVyLFxuXHRib3hVUjogYm94VVIsXG5cdGJveHY6IGJveHYsXG5cdGJveFY6IGJveFYsXG5cdGJveHZoOiBib3h2aCxcblx0Ym94dkg6IGJveHZILFxuXHRib3hWaDogYm94VmgsXG5cdGJveFZIOiBib3hWSCxcblx0Ym94dmw6IGJveHZsLFxuXHRib3h2TDogYm94dkwsXG5cdGJveFZsOiBib3hWbCxcblx0Ym94Vkw6IGJveFZMLFxuXHRib3h2cjogYm94dnIsXG5cdGJveHZSOiBib3h2Uixcblx0Ym94VnI6IGJveFZyLFxuXHRib3hWUjogYm94VlIsXG5cdGJwcmltZTogYnByaW1lLFxuXHRicmV2ZTogYnJldmUsXG5cdEJyZXZlOiBCcmV2ZSxcblx0YnJ2YmFyOiBicnZiYXIkMSxcblx0YnNjcjogYnNjcixcblx0QnNjcjogQnNjcixcblx0YnNlbWk6IGJzZW1pLFxuXHRic2ltOiBic2ltLFxuXHRic2ltZTogYnNpbWUsXG5cdGJzb2xiOiBic29sYixcblx0YnNvbDogYnNvbCxcblx0YnNvbGhzdWI6IGJzb2xoc3ViLFxuXHRidWxsOiBidWxsLFxuXHRidWxsZXQ6IGJ1bGxldCxcblx0YnVtcDogYnVtcCxcblx0YnVtcEU6IGJ1bXBFLFxuXHRidW1wZTogYnVtcGUsXG5cdEJ1bXBlcTogQnVtcGVxLFxuXHRidW1wZXE6IGJ1bXBlcSxcblx0Q2FjdXRlOiBDYWN1dGUsXG5cdGNhY3V0ZTogY2FjdXRlLFxuXHRjYXBhbmQ6IGNhcGFuZCxcblx0Y2FwYnJjdXA6IGNhcGJyY3VwLFxuXHRjYXBjYXA6IGNhcGNhcCxcblx0Y2FwOiBjYXAsXG5cdENhcDogQ2FwLFxuXHRjYXBjdXA6IGNhcGN1cCxcblx0Y2FwZG90OiBjYXBkb3QsXG5cdENhcGl0YWxEaWZmZXJlbnRpYWxEOiBDYXBpdGFsRGlmZmVyZW50aWFsRCxcblx0Y2FwczogY2Fwcyxcblx0Y2FyZXQ6IGNhcmV0LFxuXHRjYXJvbjogY2Fyb24sXG5cdENheWxleXM6IENheWxleXMsXG5cdGNjYXBzOiBjY2Fwcyxcblx0Q2Nhcm9uOiBDY2Fyb24sXG5cdGNjYXJvbjogY2Nhcm9uLFxuXHRDY2VkaWw6IENjZWRpbCQxLFxuXHRjY2VkaWw6IGNjZWRpbCQxLFxuXHRDY2lyYzogQ2NpcmMsXG5cdGNjaXJjOiBjY2lyYyxcblx0Q2NvbmludDogQ2NvbmludCxcblx0Y2N1cHM6IGNjdXBzLFxuXHRjY3Vwc3NtOiBjY3Vwc3NtLFxuXHRDZG90OiBDZG90LFxuXHRjZG90OiBjZG90LFxuXHRjZWRpbDogY2VkaWwkMSxcblx0Q2VkaWxsYTogQ2VkaWxsYSxcblx0Y2VtcHR5djogY2VtcHR5dixcblx0Y2VudDogY2VudCQxLFxuXHRjZW50ZXJkb3Q6IGNlbnRlcmRvdCxcblx0Q2VudGVyRG90OiBDZW50ZXJEb3QsXG5cdGNmcjogY2ZyLFxuXHRDZnI6IENmcixcblx0Q0hjeTogQ0hjeSxcblx0Y2hjeTogY2hjeSxcblx0Y2hlY2s6IGNoZWNrLFxuXHRjaGVja21hcms6IGNoZWNrbWFyayxcblx0Q2hpOiBDaGksXG5cdGNoaTogY2hpLFxuXHRjaXJjOiBjaXJjLFxuXHRjaXJjZXE6IGNpcmNlcSxcblx0Y2lyY2xlYXJyb3dsZWZ0OiBjaXJjbGVhcnJvd2xlZnQsXG5cdGNpcmNsZWFycm93cmlnaHQ6IGNpcmNsZWFycm93cmlnaHQsXG5cdGNpcmNsZWRhc3Q6IGNpcmNsZWRhc3QsXG5cdGNpcmNsZWRjaXJjOiBjaXJjbGVkY2lyYyxcblx0Y2lyY2xlZGRhc2g6IGNpcmNsZWRkYXNoLFxuXHRDaXJjbGVEb3Q6IENpcmNsZURvdCxcblx0Y2lyY2xlZFI6IGNpcmNsZWRSLFxuXHRjaXJjbGVkUzogY2lyY2xlZFMsXG5cdENpcmNsZU1pbnVzOiBDaXJjbGVNaW51cyxcblx0Q2lyY2xlUGx1czogQ2lyY2xlUGx1cyxcblx0Q2lyY2xlVGltZXM6IENpcmNsZVRpbWVzLFxuXHRjaXI6IGNpcixcblx0Y2lyRTogY2lyRSxcblx0Y2lyZTogY2lyZSxcblx0Y2lyZm5pbnQ6IGNpcmZuaW50LFxuXHRjaXJtaWQ6IGNpcm1pZCxcblx0Y2lyc2NpcjogY2lyc2Npcixcblx0Q2xvY2t3aXNlQ29udG91ckludGVncmFsOiBDbG9ja3dpc2VDb250b3VySW50ZWdyYWwsXG5cdENsb3NlQ3VybHlEb3VibGVRdW90ZTogQ2xvc2VDdXJseURvdWJsZVF1b3RlLFxuXHRDbG9zZUN1cmx5UXVvdGU6IENsb3NlQ3VybHlRdW90ZSxcblx0Y2x1YnM6IGNsdWJzLFxuXHRjbHVic3VpdDogY2x1YnN1aXQsXG5cdGNvbG9uOiBjb2xvbixcblx0Q29sb246IENvbG9uLFxuXHRDb2xvbmU6IENvbG9uZSxcblx0Y29sb25lOiBjb2xvbmUsXG5cdGNvbG9uZXE6IGNvbG9uZXEsXG5cdGNvbW1hOiBjb21tYSxcblx0Y29tbWF0OiBjb21tYXQsXG5cdGNvbXA6IGNvbXAsXG5cdGNvbXBmbjogY29tcGZuLFxuXHRjb21wbGVtZW50OiBjb21wbGVtZW50LFxuXHRjb21wbGV4ZXM6IGNvbXBsZXhlcyxcblx0Y29uZzogY29uZyxcblx0Y29uZ2RvdDogY29uZ2RvdCxcblx0Q29uZ3J1ZW50OiBDb25ncnVlbnQsXG5cdGNvbmludDogY29uaW50LFxuXHRDb25pbnQ6IENvbmludCxcblx0Q29udG91ckludGVncmFsOiBDb250b3VySW50ZWdyYWwsXG5cdGNvcGY6IGNvcGYsXG5cdENvcGY6IENvcGYsXG5cdGNvcHJvZDogY29wcm9kLFxuXHRDb3Byb2R1Y3Q6IENvcHJvZHVjdCxcblx0Y29weTogY29weSQxLFxuXHRDT1BZOiBDT1BZJDEsXG5cdGNvcHlzcjogY29weXNyLFxuXHRDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOiBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsLFxuXHRjcmFycjogY3JhcnIsXG5cdGNyb3NzOiBjcm9zcyxcblx0Q3Jvc3M6IENyb3NzLFxuXHRDc2NyOiBDc2NyLFxuXHRjc2NyOiBjc2NyLFxuXHRjc3ViOiBjc3ViLFxuXHRjc3ViZTogY3N1YmUsXG5cdGNzdXA6IGNzdXAsXG5cdGNzdXBlOiBjc3VwZSxcblx0Y3Rkb3Q6IGN0ZG90LFxuXHRjdWRhcnJsOiBjdWRhcnJsLFxuXHRjdWRhcnJyOiBjdWRhcnJyLFxuXHRjdWVwcjogY3VlcHIsXG5cdGN1ZXNjOiBjdWVzYyxcblx0Y3VsYXJyOiBjdWxhcnIsXG5cdGN1bGFycnA6IGN1bGFycnAsXG5cdGN1cGJyY2FwOiBjdXBicmNhcCxcblx0Y3VwY2FwOiBjdXBjYXAsXG5cdEN1cENhcDogQ3VwQ2FwLFxuXHRjdXA6IGN1cCxcblx0Q3VwOiBDdXAsXG5cdGN1cGN1cDogY3VwY3VwLFxuXHRjdXBkb3Q6IGN1cGRvdCxcblx0Y3Vwb3I6IGN1cG9yLFxuXHRjdXBzOiBjdXBzLFxuXHRjdXJhcnI6IGN1cmFycixcblx0Y3VyYXJybTogY3VyYXJybSxcblx0Y3VybHllcXByZWM6IGN1cmx5ZXFwcmVjLFxuXHRjdXJseWVxc3VjYzogY3VybHllcXN1Y2MsXG5cdGN1cmx5dmVlOiBjdXJseXZlZSxcblx0Y3VybHl3ZWRnZTogY3VybHl3ZWRnZSxcblx0Y3VycmVuOiBjdXJyZW4kMSxcblx0Y3VydmVhcnJvd2xlZnQ6IGN1cnZlYXJyb3dsZWZ0LFxuXHRjdXJ2ZWFycm93cmlnaHQ6IGN1cnZlYXJyb3dyaWdodCxcblx0Y3V2ZWU6IGN1dmVlLFxuXHRjdXdlZDogY3V3ZWQsXG5cdGN3Y29uaW50OiBjd2NvbmludCxcblx0Y3dpbnQ6IGN3aW50LFxuXHRjeWxjdHk6IGN5bGN0eSxcblx0ZGFnZ2VyOiBkYWdnZXIsXG5cdERhZ2dlcjogRGFnZ2VyLFxuXHRkYWxldGg6IGRhbGV0aCxcblx0ZGFycjogZGFycixcblx0RGFycjogRGFycixcblx0ZEFycjogZEFycixcblx0ZGFzaDogZGFzaCxcblx0RGFzaHY6IERhc2h2LFxuXHRkYXNodjogZGFzaHYsXG5cdGRia2Fyb3c6IGRia2Fyb3csXG5cdGRibGFjOiBkYmxhYyxcblx0RGNhcm9uOiBEY2Fyb24sXG5cdGRjYXJvbjogZGNhcm9uLFxuXHREY3k6IERjeSxcblx0ZGN5OiBkY3ksXG5cdGRkYWdnZXI6IGRkYWdnZXIsXG5cdGRkYXJyOiBkZGFycixcblx0REQ6IERELFxuXHRkZDogZGQsXG5cdEREb3RyYWhkOiBERG90cmFoZCxcblx0ZGRvdHNlcTogZGRvdHNlcSxcblx0ZGVnOiBkZWckMSxcblx0RGVsOiBEZWwsXG5cdERlbHRhOiBEZWx0YSxcblx0ZGVsdGE6IGRlbHRhLFxuXHRkZW1wdHl2OiBkZW1wdHl2LFxuXHRkZmlzaHQ6IGRmaXNodCxcblx0RGZyOiBEZnIsXG5cdGRmcjogZGZyLFxuXHRkSGFyOiBkSGFyLFxuXHRkaGFybDogZGhhcmwsXG5cdGRoYXJyOiBkaGFycixcblx0RGlhY3JpdGljYWxBY3V0ZTogRGlhY3JpdGljYWxBY3V0ZSxcblx0RGlhY3JpdGljYWxEb3Q6IERpYWNyaXRpY2FsRG90LFxuXHREaWFjcml0aWNhbERvdWJsZUFjdXRlOiBEaWFjcml0aWNhbERvdWJsZUFjdXRlLFxuXHREaWFjcml0aWNhbEdyYXZlOiBEaWFjcml0aWNhbEdyYXZlLFxuXHREaWFjcml0aWNhbFRpbGRlOiBEaWFjcml0aWNhbFRpbGRlLFxuXHRkaWFtOiBkaWFtLFxuXHRkaWFtb25kOiBkaWFtb25kLFxuXHREaWFtb25kOiBEaWFtb25kLFxuXHRkaWFtb25kc3VpdDogZGlhbW9uZHN1aXQsXG5cdGRpYW1zOiBkaWFtcyxcblx0ZGllOiBkaWUsXG5cdERpZmZlcmVudGlhbEQ6IERpZmZlcmVudGlhbEQsXG5cdGRpZ2FtbWE6IGRpZ2FtbWEsXG5cdGRpc2luOiBkaXNpbixcblx0ZGl2OiBkaXYsXG5cdGRpdmlkZTogZGl2aWRlJDEsXG5cdGRpdmlkZW9udGltZXM6IGRpdmlkZW9udGltZXMsXG5cdGRpdm9ueDogZGl2b254LFxuXHRESmN5OiBESmN5LFxuXHRkamN5OiBkamN5LFxuXHRkbGNvcm46IGRsY29ybixcblx0ZGxjcm9wOiBkbGNyb3AsXG5cdGRvbGxhcjogZG9sbGFyLFxuXHREb3BmOiBEb3BmLFxuXHRkb3BmOiBkb3BmLFxuXHREb3Q6IERvdCxcblx0ZG90OiBkb3QsXG5cdERvdERvdDogRG90RG90LFxuXHRkb3RlcTogZG90ZXEsXG5cdGRvdGVxZG90OiBkb3RlcWRvdCxcblx0RG90RXF1YWw6IERvdEVxdWFsLFxuXHRkb3RtaW51czogZG90bWludXMsXG5cdGRvdHBsdXM6IGRvdHBsdXMsXG5cdGRvdHNxdWFyZTogZG90c3F1YXJlLFxuXHRkb3VibGViYXJ3ZWRnZTogZG91YmxlYmFyd2VkZ2UsXG5cdERvdWJsZUNvbnRvdXJJbnRlZ3JhbDogRG91YmxlQ29udG91ckludGVncmFsLFxuXHREb3VibGVEb3Q6IERvdWJsZURvdCxcblx0RG91YmxlRG93bkFycm93OiBEb3VibGVEb3duQXJyb3csXG5cdERvdWJsZUxlZnRBcnJvdzogRG91YmxlTGVmdEFycm93LFxuXHREb3VibGVMZWZ0UmlnaHRBcnJvdzogRG91YmxlTGVmdFJpZ2h0QXJyb3csXG5cdERvdWJsZUxlZnRUZWU6IERvdWJsZUxlZnRUZWUsXG5cdERvdWJsZUxvbmdMZWZ0QXJyb3c6IERvdWJsZUxvbmdMZWZ0QXJyb3csXG5cdERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdzogRG91YmxlTG9uZ0xlZnRSaWdodEFycm93LFxuXHREb3VibGVMb25nUmlnaHRBcnJvdzogRG91YmxlTG9uZ1JpZ2h0QXJyb3csXG5cdERvdWJsZVJpZ2h0QXJyb3c6IERvdWJsZVJpZ2h0QXJyb3csXG5cdERvdWJsZVJpZ2h0VGVlOiBEb3VibGVSaWdodFRlZSxcblx0RG91YmxlVXBBcnJvdzogRG91YmxlVXBBcnJvdyxcblx0RG91YmxlVXBEb3duQXJyb3c6IERvdWJsZVVwRG93bkFycm93LFxuXHREb3VibGVWZXJ0aWNhbEJhcjogRG91YmxlVmVydGljYWxCYXIsXG5cdERvd25BcnJvd0JhcjogRG93bkFycm93QmFyLFxuXHRkb3duYXJyb3c6IGRvd25hcnJvdyxcblx0RG93bkFycm93OiBEb3duQXJyb3csXG5cdERvd25hcnJvdzogRG93bmFycm93LFxuXHREb3duQXJyb3dVcEFycm93OiBEb3duQXJyb3dVcEFycm93LFxuXHREb3duQnJldmU6IERvd25CcmV2ZSxcblx0ZG93bmRvd25hcnJvd3M6IGRvd25kb3duYXJyb3dzLFxuXHRkb3duaGFycG9vbmxlZnQ6IGRvd25oYXJwb29ubGVmdCxcblx0ZG93bmhhcnBvb25yaWdodDogZG93bmhhcnBvb25yaWdodCxcblx0RG93bkxlZnRSaWdodFZlY3RvcjogRG93bkxlZnRSaWdodFZlY3Rvcixcblx0RG93bkxlZnRUZWVWZWN0b3I6IERvd25MZWZ0VGVlVmVjdG9yLFxuXHREb3duTGVmdFZlY3RvckJhcjogRG93bkxlZnRWZWN0b3JCYXIsXG5cdERvd25MZWZ0VmVjdG9yOiBEb3duTGVmdFZlY3Rvcixcblx0RG93blJpZ2h0VGVlVmVjdG9yOiBEb3duUmlnaHRUZWVWZWN0b3IsXG5cdERvd25SaWdodFZlY3RvckJhcjogRG93blJpZ2h0VmVjdG9yQmFyLFxuXHREb3duUmlnaHRWZWN0b3I6IERvd25SaWdodFZlY3Rvcixcblx0RG93blRlZUFycm93OiBEb3duVGVlQXJyb3csXG5cdERvd25UZWU6IERvd25UZWUsXG5cdGRyYmthcm93OiBkcmJrYXJvdyxcblx0ZHJjb3JuOiBkcmNvcm4sXG5cdGRyY3JvcDogZHJjcm9wLFxuXHREc2NyOiBEc2NyLFxuXHRkc2NyOiBkc2NyLFxuXHREU2N5OiBEU2N5LFxuXHRkc2N5OiBkc2N5LFxuXHRkc29sOiBkc29sLFxuXHREc3Ryb2s6IERzdHJvayxcblx0ZHN0cm9rOiBkc3Ryb2ssXG5cdGR0ZG90OiBkdGRvdCxcblx0ZHRyaTogZHRyaSxcblx0ZHRyaWY6IGR0cmlmLFxuXHRkdWFycjogZHVhcnIsXG5cdGR1aGFyOiBkdWhhcixcblx0ZHdhbmdsZTogZHdhbmdsZSxcblx0RFpjeTogRFpjeSxcblx0ZHpjeTogZHpjeSxcblx0ZHppZ3JhcnI6IGR6aWdyYXJyLFxuXHRFYWN1dGU6IEVhY3V0ZSQxLFxuXHRlYWN1dGU6IGVhY3V0ZSQxLFxuXHRlYXN0ZXI6IGVhc3Rlcixcblx0RWNhcm9uOiBFY2Fyb24sXG5cdGVjYXJvbjogZWNhcm9uLFxuXHRFY2lyYzogRWNpcmMkMSxcblx0ZWNpcmM6IGVjaXJjJDEsXG5cdGVjaXI6IGVjaXIsXG5cdGVjb2xvbjogZWNvbG9uLFxuXHRFY3k6IEVjeSxcblx0ZWN5OiBlY3ksXG5cdGVERG90OiBlRERvdCxcblx0RWRvdDogRWRvdCxcblx0ZWRvdDogZWRvdCxcblx0ZURvdDogZURvdCxcblx0ZWU6IGVlLFxuXHRlZkRvdDogZWZEb3QsXG5cdEVmcjogRWZyLFxuXHRlZnI6IGVmcixcblx0ZWc6IGVnLFxuXHRFZ3JhdmU6IEVncmF2ZSQxLFxuXHRlZ3JhdmU6IGVncmF2ZSQxLFxuXHRlZ3M6IGVncyxcblx0ZWdzZG90OiBlZ3Nkb3QsXG5cdGVsOiBlbCxcblx0RWxlbWVudDogRWxlbWVudCQxLFxuXHRlbGludGVyczogZWxpbnRlcnMsXG5cdGVsbDogZWxsLFxuXHRlbHM6IGVscyxcblx0ZWxzZG90OiBlbHNkb3QsXG5cdEVtYWNyOiBFbWFjcixcblx0ZW1hY3I6IGVtYWNyLFxuXHRlbXB0eTogZW1wdHksXG5cdGVtcHR5c2V0OiBlbXB0eXNldCxcblx0RW1wdHlTbWFsbFNxdWFyZTogRW1wdHlTbWFsbFNxdWFyZSxcblx0ZW1wdHl2OiBlbXB0eXYsXG5cdEVtcHR5VmVyeVNtYWxsU3F1YXJlOiBFbXB0eVZlcnlTbWFsbFNxdWFyZSxcblx0ZW1zcDEzOiBlbXNwMTMsXG5cdGVtc3AxNDogZW1zcDE0LFxuXHRlbXNwOiBlbXNwLFxuXHRFTkc6IEVORyxcblx0ZW5nOiBlbmcsXG5cdGVuc3A6IGVuc3AsXG5cdEVvZ29uOiBFb2dvbixcblx0ZW9nb246IGVvZ29uLFxuXHRFb3BmOiBFb3BmLFxuXHRlb3BmOiBlb3BmLFxuXHRlcGFyOiBlcGFyLFxuXHRlcGFyc2w6IGVwYXJzbCxcblx0ZXBsdXM6IGVwbHVzLFxuXHRlcHNpOiBlcHNpLFxuXHRFcHNpbG9uOiBFcHNpbG9uLFxuXHRlcHNpbG9uOiBlcHNpbG9uLFxuXHRlcHNpdjogZXBzaXYsXG5cdGVxY2lyYzogZXFjaXJjLFxuXHRlcWNvbG9uOiBlcWNvbG9uLFxuXHRlcXNpbTogZXFzaW0sXG5cdGVxc2xhbnRndHI6IGVxc2xhbnRndHIsXG5cdGVxc2xhbnRsZXNzOiBlcXNsYW50bGVzcyxcblx0RXF1YWw6IEVxdWFsLFxuXHRlcXVhbHM6IGVxdWFscyxcblx0RXF1YWxUaWxkZTogRXF1YWxUaWxkZSxcblx0ZXF1ZXN0OiBlcXVlc3QsXG5cdEVxdWlsaWJyaXVtOiBFcXVpbGlicml1bSxcblx0ZXF1aXY6IGVxdWl2LFxuXHRlcXVpdkREOiBlcXVpdkRELFxuXHRlcXZwYXJzbDogZXF2cGFyc2wsXG5cdGVyYXJyOiBlcmFycixcblx0ZXJEb3Q6IGVyRG90LFxuXHRlc2NyOiBlc2NyLFxuXHRFc2NyOiBFc2NyLFxuXHRlc2RvdDogZXNkb3QsXG5cdEVzaW06IEVzaW0sXG5cdGVzaW06IGVzaW0sXG5cdEV0YTogRXRhLFxuXHRldGE6IGV0YSxcblx0RVRIOiBFVEgkMSxcblx0ZXRoOiBldGgkMSxcblx0RXVtbDogRXVtbCQxLFxuXHRldW1sOiBldW1sJDEsXG5cdGV1cm86IGV1cm8sXG5cdGV4Y2w6IGV4Y2wsXG5cdGV4aXN0OiBleGlzdCxcblx0RXhpc3RzOiBFeGlzdHMsXG5cdGV4cGVjdGF0aW9uOiBleHBlY3RhdGlvbixcblx0ZXhwb25lbnRpYWxlOiBleHBvbmVudGlhbGUsXG5cdEV4cG9uZW50aWFsRTogRXhwb25lbnRpYWxFLFxuXHRmYWxsaW5nZG90c2VxOiBmYWxsaW5nZG90c2VxLFxuXHRGY3k6IEZjeSxcblx0ZmN5OiBmY3ksXG5cdGZlbWFsZTogZmVtYWxlLFxuXHRmZmlsaWc6IGZmaWxpZyxcblx0ZmZsaWc6IGZmbGlnLFxuXHRmZmxsaWc6IGZmbGxpZyxcblx0RmZyOiBGZnIsXG5cdGZmcjogZmZyLFxuXHRmaWxpZzogZmlsaWcsXG5cdEZpbGxlZFNtYWxsU3F1YXJlOiBGaWxsZWRTbWFsbFNxdWFyZSxcblx0RmlsbGVkVmVyeVNtYWxsU3F1YXJlOiBGaWxsZWRWZXJ5U21hbGxTcXVhcmUsXG5cdGZqbGlnOiBmamxpZyxcblx0ZmxhdDogZmxhdCxcblx0ZmxsaWc6IGZsbGlnLFxuXHRmbHRuczogZmx0bnMsXG5cdGZub2Y6IGZub2YsXG5cdEZvcGY6IEZvcGYsXG5cdGZvcGY6IGZvcGYsXG5cdGZvcmFsbDogZm9yYWxsLFxuXHRGb3JBbGw6IEZvckFsbCxcblx0Zm9yazogZm9yayxcblx0Zm9ya3Y6IGZvcmt2LFxuXHRGb3VyaWVydHJmOiBGb3VyaWVydHJmLFxuXHRmcGFydGludDogZnBhcnRpbnQsXG5cdGZyYWMxMjogZnJhYzEyJDEsXG5cdGZyYWMxMzogZnJhYzEzLFxuXHRmcmFjMTQ6IGZyYWMxNCQxLFxuXHRmcmFjMTU6IGZyYWMxNSxcblx0ZnJhYzE2OiBmcmFjMTYsXG5cdGZyYWMxODogZnJhYzE4LFxuXHRmcmFjMjM6IGZyYWMyMyxcblx0ZnJhYzI1OiBmcmFjMjUsXG5cdGZyYWMzNDogZnJhYzM0JDEsXG5cdGZyYWMzNTogZnJhYzM1LFxuXHRmcmFjMzg6IGZyYWMzOCxcblx0ZnJhYzQ1OiBmcmFjNDUsXG5cdGZyYWM1NjogZnJhYzU2LFxuXHRmcmFjNTg6IGZyYWM1OCxcblx0ZnJhYzc4OiBmcmFjNzgsXG5cdGZyYXNsOiBmcmFzbCxcblx0ZnJvd246IGZyb3duLFxuXHRmc2NyOiBmc2NyLFxuXHRGc2NyOiBGc2NyLFxuXHRnYWN1dGU6IGdhY3V0ZSxcblx0R2FtbWE6IEdhbW1hLFxuXHRnYW1tYTogZ2FtbWEsXG5cdEdhbW1hZDogR2FtbWFkLFxuXHRnYW1tYWQ6IGdhbW1hZCxcblx0Z2FwOiBnYXAsXG5cdEdicmV2ZTogR2JyZXZlLFxuXHRnYnJldmU6IGdicmV2ZSxcblx0R2NlZGlsOiBHY2VkaWwsXG5cdEdjaXJjOiBHY2lyYyxcblx0Z2NpcmM6IGdjaXJjLFxuXHRHY3k6IEdjeSxcblx0Z2N5OiBnY3ksXG5cdEdkb3Q6IEdkb3QsXG5cdGdkb3Q6IGdkb3QsXG5cdGdlOiBnZSxcblx0Z0U6IGdFLFxuXHRnRWw6IGdFbCxcblx0Z2VsOiBnZWwsXG5cdGdlcTogZ2VxLFxuXHRnZXFxOiBnZXFxLFxuXHRnZXFzbGFudDogZ2Vxc2xhbnQsXG5cdGdlc2NjOiBnZXNjYyxcblx0Z2VzOiBnZXMsXG5cdGdlc2RvdDogZ2VzZG90LFxuXHRnZXNkb3RvOiBnZXNkb3RvLFxuXHRnZXNkb3RvbDogZ2VzZG90b2wsXG5cdGdlc2w6IGdlc2wsXG5cdGdlc2xlczogZ2VzbGVzLFxuXHRHZnI6IEdmcixcblx0Z2ZyOiBnZnIsXG5cdGdnOiBnZyxcblx0R2c6IEdnLFxuXHRnZ2c6IGdnZyxcblx0Z2ltZWw6IGdpbWVsLFxuXHRHSmN5OiBHSmN5LFxuXHRnamN5OiBnamN5LFxuXHRnbGE6IGdsYSxcblx0Z2w6IGdsLFxuXHRnbEU6IGdsRSxcblx0Z2xqOiBnbGosXG5cdGduYXA6IGduYXAsXG5cdGduYXBwcm94OiBnbmFwcHJveCxcblx0Z25lOiBnbmUsXG5cdGduRTogZ25FLFxuXHRnbmVxOiBnbmVxLFxuXHRnbmVxcTogZ25lcXEsXG5cdGduc2ltOiBnbnNpbSxcblx0R29wZjogR29wZixcblx0Z29wZjogZ29wZixcblx0Z3JhdmU6IGdyYXZlLFxuXHRHcmVhdGVyRXF1YWw6IEdyZWF0ZXJFcXVhbCxcblx0R3JlYXRlckVxdWFsTGVzczogR3JlYXRlckVxdWFsTGVzcyxcblx0R3JlYXRlckZ1bGxFcXVhbDogR3JlYXRlckZ1bGxFcXVhbCxcblx0R3JlYXRlckdyZWF0ZXI6IEdyZWF0ZXJHcmVhdGVyLFxuXHRHcmVhdGVyTGVzczogR3JlYXRlckxlc3MsXG5cdEdyZWF0ZXJTbGFudEVxdWFsOiBHcmVhdGVyU2xhbnRFcXVhbCxcblx0R3JlYXRlclRpbGRlOiBHcmVhdGVyVGlsZGUsXG5cdEdzY3I6IEdzY3IsXG5cdGdzY3I6IGdzY3IsXG5cdGdzaW06IGdzaW0sXG5cdGdzaW1lOiBnc2ltZSxcblx0Z3NpbWw6IGdzaW1sLFxuXHRndGNjOiBndGNjLFxuXHRndGNpcjogZ3RjaXIsXG5cdGd0OiBndCQyLFxuXHRHVDogR1QkMSxcblx0R3Q6IEd0LFxuXHRndGRvdDogZ3Rkb3QsXG5cdGd0bFBhcjogZ3RsUGFyLFxuXHRndHF1ZXN0OiBndHF1ZXN0LFxuXHRndHJhcHByb3g6IGd0cmFwcHJveCxcblx0Z3RyYXJyOiBndHJhcnIsXG5cdGd0cmRvdDogZ3RyZG90LFxuXHRndHJlcWxlc3M6IGd0cmVxbGVzcyxcblx0Z3RyZXFxbGVzczogZ3RyZXFxbGVzcyxcblx0Z3RybGVzczogZ3RybGVzcyxcblx0Z3Ryc2ltOiBndHJzaW0sXG5cdGd2ZXJ0bmVxcTogZ3ZlcnRuZXFxLFxuXHRndm5FOiBndm5FLFxuXHRIYWNlazogSGFjZWssXG5cdGhhaXJzcDogaGFpcnNwLFxuXHRoYWxmOiBoYWxmLFxuXHRoYW1pbHQ6IGhhbWlsdCxcblx0SEFSRGN5OiBIQVJEY3ksXG5cdGhhcmRjeTogaGFyZGN5LFxuXHRoYXJyY2lyOiBoYXJyY2lyLFxuXHRoYXJyOiBoYXJyLFxuXHRoQXJyOiBoQXJyLFxuXHRoYXJydzogaGFycncsXG5cdEhhdDogSGF0LFxuXHRoYmFyOiBoYmFyLFxuXHRIY2lyYzogSGNpcmMsXG5cdGhjaXJjOiBoY2lyYyxcblx0aGVhcnRzOiBoZWFydHMsXG5cdGhlYXJ0c3VpdDogaGVhcnRzdWl0LFxuXHRoZWxsaXA6IGhlbGxpcCxcblx0aGVyY29uOiBoZXJjb24sXG5cdGhmcjogaGZyLFxuXHRIZnI6IEhmcixcblx0SGlsYmVydFNwYWNlOiBIaWxiZXJ0U3BhY2UsXG5cdGhrc2Vhcm93OiBoa3NlYXJvdyxcblx0aGtzd2Fyb3c6IGhrc3dhcm93LFxuXHRob2FycjogaG9hcnIsXG5cdGhvbXRodDogaG9tdGh0LFxuXHRob29rbGVmdGFycm93OiBob29rbGVmdGFycm93LFxuXHRob29rcmlnaHRhcnJvdzogaG9va3JpZ2h0YXJyb3csXG5cdGhvcGY6IGhvcGYsXG5cdEhvcGY6IEhvcGYsXG5cdGhvcmJhcjogaG9yYmFyLFxuXHRIb3Jpem9udGFsTGluZTogSG9yaXpvbnRhbExpbmUsXG5cdGhzY3I6IGhzY3IsXG5cdEhzY3I6IEhzY3IsXG5cdGhzbGFzaDogaHNsYXNoLFxuXHRIc3Ryb2s6IEhzdHJvayxcblx0aHN0cm9rOiBoc3Ryb2ssXG5cdEh1bXBEb3duSHVtcDogSHVtcERvd25IdW1wLFxuXHRIdW1wRXF1YWw6IEh1bXBFcXVhbCxcblx0aHlidWxsOiBoeWJ1bGwsXG5cdGh5cGhlbjogaHlwaGVuLFxuXHRJYWN1dGU6IElhY3V0ZSQxLFxuXHRpYWN1dGU6IGlhY3V0ZSQxLFxuXHRpYzogaWMsXG5cdEljaXJjOiBJY2lyYyQxLFxuXHRpY2lyYzogaWNpcmMkMSxcblx0SWN5OiBJY3ksXG5cdGljeTogaWN5LFxuXHRJZG90OiBJZG90LFxuXHRJRWN5OiBJRWN5LFxuXHRpZWN5OiBpZWN5LFxuXHRpZXhjbDogaWV4Y2wkMSxcblx0aWZmOiBpZmYsXG5cdGlmcjogaWZyLFxuXHRJZnI6IElmcixcblx0SWdyYXZlOiBJZ3JhdmUkMSxcblx0aWdyYXZlOiBpZ3JhdmUkMSxcblx0aWk6IGlpLFxuXHRpaWlpbnQ6IGlpaWludCxcblx0aWlpbnQ6IGlpaW50LFxuXHRpaW5maW46IGlpbmZpbixcblx0aWlvdGE6IGlpb3RhLFxuXHRJSmxpZzogSUpsaWcsXG5cdGlqbGlnOiBpamxpZyxcblx0SW1hY3I6IEltYWNyLFxuXHRpbWFjcjogaW1hY3IsXG5cdGltYWdlOiBpbWFnZSxcblx0SW1hZ2luYXJ5STogSW1hZ2luYXJ5SSxcblx0aW1hZ2xpbmU6IGltYWdsaW5lLFxuXHRpbWFncGFydDogaW1hZ3BhcnQsXG5cdGltYXRoOiBpbWF0aCxcblx0SW06IEltLFxuXHRpbW9mOiBpbW9mLFxuXHRpbXBlZDogaW1wZWQsXG5cdEltcGxpZXM6IEltcGxpZXMsXG5cdGluY2FyZTogaW5jYXJlLFxuXHRcImluXCI6IFwi4oiIXCIsXG5cdGluZmluOiBpbmZpbixcblx0aW5maW50aWU6IGluZmludGllLFxuXHRpbm9kb3Q6IGlub2RvdCxcblx0aW50Y2FsOiBpbnRjYWwsXG5cdGludDogaW50LFxuXHRJbnQ6IEludCxcblx0aW50ZWdlcnM6IGludGVnZXJzLFxuXHRJbnRlZ3JhbDogSW50ZWdyYWwsXG5cdGludGVyY2FsOiBpbnRlcmNhbCxcblx0SW50ZXJzZWN0aW9uOiBJbnRlcnNlY3Rpb24sXG5cdGludGxhcmhrOiBpbnRsYXJoayxcblx0aW50cHJvZDogaW50cHJvZCxcblx0SW52aXNpYmxlQ29tbWE6IEludmlzaWJsZUNvbW1hLFxuXHRJbnZpc2libGVUaW1lczogSW52aXNpYmxlVGltZXMsXG5cdElPY3k6IElPY3ksXG5cdGlvY3k6IGlvY3ksXG5cdElvZ29uOiBJb2dvbixcblx0aW9nb246IGlvZ29uLFxuXHRJb3BmOiBJb3BmLFxuXHRpb3BmOiBpb3BmLFxuXHRJb3RhOiBJb3RhLFxuXHRpb3RhOiBpb3RhLFxuXHRpcHJvZDogaXByb2QsXG5cdGlxdWVzdDogaXF1ZXN0JDEsXG5cdGlzY3I6IGlzY3IsXG5cdElzY3I6IElzY3IsXG5cdGlzaW46IGlzaW4sXG5cdGlzaW5kb3Q6IGlzaW5kb3QsXG5cdGlzaW5FOiBpc2luRSxcblx0aXNpbnM6IGlzaW5zLFxuXHRpc2luc3Y6IGlzaW5zdixcblx0aXNpbnY6IGlzaW52LFxuXHRpdDogaXQsXG5cdEl0aWxkZTogSXRpbGRlLFxuXHRpdGlsZGU6IGl0aWxkZSxcblx0SXVrY3k6IEl1a2N5LFxuXHRpdWtjeTogaXVrY3ksXG5cdEl1bWw6IEl1bWwkMSxcblx0aXVtbDogaXVtbCQxLFxuXHRKY2lyYzogSmNpcmMsXG5cdGpjaXJjOiBqY2lyYyxcblx0SmN5OiBKY3ksXG5cdGpjeTogamN5LFxuXHRKZnI6IEpmcixcblx0amZyOiBqZnIsXG5cdGptYXRoOiBqbWF0aCxcblx0Sm9wZjogSm9wZixcblx0am9wZjogam9wZixcblx0SnNjcjogSnNjcixcblx0anNjcjoganNjcixcblx0SnNlcmN5OiBKc2VyY3ksXG5cdGpzZXJjeToganNlcmN5LFxuXHRKdWtjeTogSnVrY3ksXG5cdGp1a2N5OiBqdWtjeSxcblx0S2FwcGE6IEthcHBhLFxuXHRrYXBwYToga2FwcGEsXG5cdGthcHBhdjoga2FwcGF2LFxuXHRLY2VkaWw6IEtjZWRpbCxcblx0a2NlZGlsOiBrY2VkaWwsXG5cdEtjeTogS2N5LFxuXHRrY3k6IGtjeSxcblx0S2ZyOiBLZnIsXG5cdGtmcjoga2ZyLFxuXHRrZ3JlZW46IGtncmVlbixcblx0S0hjeTogS0hjeSxcblx0a2hjeToga2hjeSxcblx0S0pjeTogS0pjeSxcblx0a2pjeToga2pjeSxcblx0S29wZjogS29wZixcblx0a29wZjoga29wZixcblx0S3NjcjogS3Njcixcblx0a3Njcjoga3Njcixcblx0bEFhcnI6IGxBYXJyLFxuXHRMYWN1dGU6IExhY3V0ZSxcblx0bGFjdXRlOiBsYWN1dGUsXG5cdGxhZW1wdHl2OiBsYWVtcHR5dixcblx0bGFncmFuOiBsYWdyYW4sXG5cdExhbWJkYTogTGFtYmRhLFxuXHRsYW1iZGE6IGxhbWJkYSxcblx0bGFuZzogbGFuZyxcblx0TGFuZzogTGFuZyxcblx0bGFuZ2Q6IGxhbmdkLFxuXHRsYW5nbGU6IGxhbmdsZSxcblx0bGFwOiBsYXAsXG5cdExhcGxhY2V0cmY6IExhcGxhY2V0cmYsXG5cdGxhcXVvOiBsYXF1byQxLFxuXHRsYXJyYjogbGFycmIsXG5cdGxhcnJiZnM6IGxhcnJiZnMsXG5cdGxhcnI6IGxhcnIsXG5cdExhcnI6IExhcnIsXG5cdGxBcnI6IGxBcnIsXG5cdGxhcnJmczogbGFycmZzLFxuXHRsYXJyaGs6IGxhcnJoayxcblx0bGFycmxwOiBsYXJybHAsXG5cdGxhcnJwbDogbGFycnBsLFxuXHRsYXJyc2ltOiBsYXJyc2ltLFxuXHRsYXJydGw6IGxhcnJ0bCxcblx0bGF0YWlsOiBsYXRhaWwsXG5cdGxBdGFpbDogbEF0YWlsLFxuXHRsYXQ6IGxhdCxcblx0bGF0ZTogbGF0ZSxcblx0bGF0ZXM6IGxhdGVzLFxuXHRsYmFycjogbGJhcnIsXG5cdGxCYXJyOiBsQmFycixcblx0bGJicms6IGxiYnJrLFxuXHRsYnJhY2U6IGxicmFjZSxcblx0bGJyYWNrOiBsYnJhY2ssXG5cdGxicmtlOiBsYnJrZSxcblx0bGJya3NsZDogbGJya3NsZCxcblx0bGJya3NsdTogbGJya3NsdSxcblx0TGNhcm9uOiBMY2Fyb24sXG5cdGxjYXJvbjogbGNhcm9uLFxuXHRMY2VkaWw6IExjZWRpbCxcblx0bGNlZGlsOiBsY2VkaWwsXG5cdGxjZWlsOiBsY2VpbCxcblx0bGN1YjogbGN1Yixcblx0TGN5OiBMY3ksXG5cdGxjeTogbGN5LFxuXHRsZGNhOiBsZGNhLFxuXHRsZHF1bzogbGRxdW8sXG5cdGxkcXVvcjogbGRxdW9yLFxuXHRsZHJkaGFyOiBsZHJkaGFyLFxuXHRsZHJ1c2hhcjogbGRydXNoYXIsXG5cdGxkc2g6IGxkc2gsXG5cdGxlOiBsZSxcblx0bEU6IGxFLFxuXHRMZWZ0QW5nbGVCcmFja2V0OiBMZWZ0QW5nbGVCcmFja2V0LFxuXHRMZWZ0QXJyb3dCYXI6IExlZnRBcnJvd0Jhcixcblx0bGVmdGFycm93OiBsZWZ0YXJyb3csXG5cdExlZnRBcnJvdzogTGVmdEFycm93LFxuXHRMZWZ0YXJyb3c6IExlZnRhcnJvdyxcblx0TGVmdEFycm93UmlnaHRBcnJvdzogTGVmdEFycm93UmlnaHRBcnJvdyxcblx0bGVmdGFycm93dGFpbDogbGVmdGFycm93dGFpbCxcblx0TGVmdENlaWxpbmc6IExlZnRDZWlsaW5nLFxuXHRMZWZ0RG91YmxlQnJhY2tldDogTGVmdERvdWJsZUJyYWNrZXQsXG5cdExlZnREb3duVGVlVmVjdG9yOiBMZWZ0RG93blRlZVZlY3Rvcixcblx0TGVmdERvd25WZWN0b3JCYXI6IExlZnREb3duVmVjdG9yQmFyLFxuXHRMZWZ0RG93blZlY3RvcjogTGVmdERvd25WZWN0b3IsXG5cdExlZnRGbG9vcjogTGVmdEZsb29yLFxuXHRsZWZ0aGFycG9vbmRvd246IGxlZnRoYXJwb29uZG93bixcblx0bGVmdGhhcnBvb251cDogbGVmdGhhcnBvb251cCxcblx0bGVmdGxlZnRhcnJvd3M6IGxlZnRsZWZ0YXJyb3dzLFxuXHRsZWZ0cmlnaHRhcnJvdzogbGVmdHJpZ2h0YXJyb3csXG5cdExlZnRSaWdodEFycm93OiBMZWZ0UmlnaHRBcnJvdyxcblx0TGVmdHJpZ2h0YXJyb3c6IExlZnRyaWdodGFycm93LFxuXHRsZWZ0cmlnaHRhcnJvd3M6IGxlZnRyaWdodGFycm93cyxcblx0bGVmdHJpZ2h0aGFycG9vbnM6IGxlZnRyaWdodGhhcnBvb25zLFxuXHRsZWZ0cmlnaHRzcXVpZ2Fycm93OiBsZWZ0cmlnaHRzcXVpZ2Fycm93LFxuXHRMZWZ0UmlnaHRWZWN0b3I6IExlZnRSaWdodFZlY3Rvcixcblx0TGVmdFRlZUFycm93OiBMZWZ0VGVlQXJyb3csXG5cdExlZnRUZWU6IExlZnRUZWUsXG5cdExlZnRUZWVWZWN0b3I6IExlZnRUZWVWZWN0b3IsXG5cdGxlZnR0aHJlZXRpbWVzOiBsZWZ0dGhyZWV0aW1lcyxcblx0TGVmdFRyaWFuZ2xlQmFyOiBMZWZ0VHJpYW5nbGVCYXIsXG5cdExlZnRUcmlhbmdsZTogTGVmdFRyaWFuZ2xlLFxuXHRMZWZ0VHJpYW5nbGVFcXVhbDogTGVmdFRyaWFuZ2xlRXF1YWwsXG5cdExlZnRVcERvd25WZWN0b3I6IExlZnRVcERvd25WZWN0b3IsXG5cdExlZnRVcFRlZVZlY3RvcjogTGVmdFVwVGVlVmVjdG9yLFxuXHRMZWZ0VXBWZWN0b3JCYXI6IExlZnRVcFZlY3RvckJhcixcblx0TGVmdFVwVmVjdG9yOiBMZWZ0VXBWZWN0b3IsXG5cdExlZnRWZWN0b3JCYXI6IExlZnRWZWN0b3JCYXIsXG5cdExlZnRWZWN0b3I6IExlZnRWZWN0b3IsXG5cdGxFZzogbEVnLFxuXHRsZWc6IGxlZyxcblx0bGVxOiBsZXEsXG5cdGxlcXE6IGxlcXEsXG5cdGxlcXNsYW50OiBsZXFzbGFudCxcblx0bGVzY2M6IGxlc2NjLFxuXHRsZXM6IGxlcyxcblx0bGVzZG90OiBsZXNkb3QsXG5cdGxlc2RvdG86IGxlc2RvdG8sXG5cdGxlc2RvdG9yOiBsZXNkb3Rvcixcblx0bGVzZzogbGVzZyxcblx0bGVzZ2VzOiBsZXNnZXMsXG5cdGxlc3NhcHByb3g6IGxlc3NhcHByb3gsXG5cdGxlc3Nkb3Q6IGxlc3Nkb3QsXG5cdGxlc3NlcWd0cjogbGVzc2VxZ3RyLFxuXHRsZXNzZXFxZ3RyOiBsZXNzZXFxZ3RyLFxuXHRMZXNzRXF1YWxHcmVhdGVyOiBMZXNzRXF1YWxHcmVhdGVyLFxuXHRMZXNzRnVsbEVxdWFsOiBMZXNzRnVsbEVxdWFsLFxuXHRMZXNzR3JlYXRlcjogTGVzc0dyZWF0ZXIsXG5cdGxlc3NndHI6IGxlc3NndHIsXG5cdExlc3NMZXNzOiBMZXNzTGVzcyxcblx0bGVzc3NpbTogbGVzc3NpbSxcblx0TGVzc1NsYW50RXF1YWw6IExlc3NTbGFudEVxdWFsLFxuXHRMZXNzVGlsZGU6IExlc3NUaWxkZSxcblx0bGZpc2h0OiBsZmlzaHQsXG5cdGxmbG9vcjogbGZsb29yLFxuXHRMZnI6IExmcixcblx0bGZyOiBsZnIsXG5cdGxnOiBsZyxcblx0bGdFOiBsZ0UsXG5cdGxIYXI6IGxIYXIsXG5cdGxoYXJkOiBsaGFyZCxcblx0bGhhcnU6IGxoYXJ1LFxuXHRsaGFydWw6IGxoYXJ1bCxcblx0bGhibGs6IGxoYmxrLFxuXHRMSmN5OiBMSmN5LFxuXHRsamN5OiBsamN5LFxuXHRsbGFycjogbGxhcnIsXG5cdGxsOiBsbCxcblx0TGw6IExsLFxuXHRsbGNvcm5lcjogbGxjb3JuZXIsXG5cdExsZWZ0YXJyb3c6IExsZWZ0YXJyb3csXG5cdGxsaGFyZDogbGxoYXJkLFxuXHRsbHRyaTogbGx0cmksXG5cdExtaWRvdDogTG1pZG90LFxuXHRsbWlkb3Q6IGxtaWRvdCxcblx0bG1vdXN0YWNoZTogbG1vdXN0YWNoZSxcblx0bG1vdXN0OiBsbW91c3QsXG5cdGxuYXA6IGxuYXAsXG5cdGxuYXBwcm94OiBsbmFwcHJveCxcblx0bG5lOiBsbmUsXG5cdGxuRTogbG5FLFxuXHRsbmVxOiBsbmVxLFxuXHRsbmVxcTogbG5lcXEsXG5cdGxuc2ltOiBsbnNpbSxcblx0bG9hbmc6IGxvYW5nLFxuXHRsb2FycjogbG9hcnIsXG5cdGxvYnJrOiBsb2Jyayxcblx0bG9uZ2xlZnRhcnJvdzogbG9uZ2xlZnRhcnJvdyxcblx0TG9uZ0xlZnRBcnJvdzogTG9uZ0xlZnRBcnJvdyxcblx0TG9uZ2xlZnRhcnJvdzogTG9uZ2xlZnRhcnJvdyxcblx0bG9uZ2xlZnRyaWdodGFycm93OiBsb25nbGVmdHJpZ2h0YXJyb3csXG5cdExvbmdMZWZ0UmlnaHRBcnJvdzogTG9uZ0xlZnRSaWdodEFycm93LFxuXHRMb25nbGVmdHJpZ2h0YXJyb3c6IExvbmdsZWZ0cmlnaHRhcnJvdyxcblx0bG9uZ21hcHN0bzogbG9uZ21hcHN0byxcblx0bG9uZ3JpZ2h0YXJyb3c6IGxvbmdyaWdodGFycm93LFxuXHRMb25nUmlnaHRBcnJvdzogTG9uZ1JpZ2h0QXJyb3csXG5cdExvbmdyaWdodGFycm93OiBMb25ncmlnaHRhcnJvdyxcblx0bG9vcGFycm93bGVmdDogbG9vcGFycm93bGVmdCxcblx0bG9vcGFycm93cmlnaHQ6IGxvb3BhcnJvd3JpZ2h0LFxuXHRsb3BhcjogbG9wYXIsXG5cdExvcGY6IExvcGYsXG5cdGxvcGY6IGxvcGYsXG5cdGxvcGx1czogbG9wbHVzLFxuXHRsb3RpbWVzOiBsb3RpbWVzLFxuXHRsb3dhc3Q6IGxvd2FzdCxcblx0bG93YmFyOiBsb3diYXIsXG5cdExvd2VyTGVmdEFycm93OiBMb3dlckxlZnRBcnJvdyxcblx0TG93ZXJSaWdodEFycm93OiBMb3dlclJpZ2h0QXJyb3csXG5cdGxvejogbG96LFxuXHRsb3plbmdlOiBsb3plbmdlLFxuXHRsb3pmOiBsb3pmLFxuXHRscGFyOiBscGFyLFxuXHRscGFybHQ6IGxwYXJsdCxcblx0bHJhcnI6IGxyYXJyLFxuXHRscmNvcm5lcjogbHJjb3JuZXIsXG5cdGxyaGFyOiBscmhhcixcblx0bHJoYXJkOiBscmhhcmQsXG5cdGxybTogbHJtLFxuXHRscnRyaTogbHJ0cmksXG5cdGxzYXF1bzogbHNhcXVvLFxuXHRsc2NyOiBsc2NyLFxuXHRMc2NyOiBMc2NyLFxuXHRsc2g6IGxzaCxcblx0THNoOiBMc2gsXG5cdGxzaW06IGxzaW0sXG5cdGxzaW1lOiBsc2ltZSxcblx0bHNpbWc6IGxzaW1nLFxuXHRsc3FiOiBsc3FiLFxuXHRsc3F1bzogbHNxdW8sXG5cdGxzcXVvcjogbHNxdW9yLFxuXHRMc3Ryb2s6IExzdHJvayxcblx0bHN0cm9rOiBsc3Ryb2ssXG5cdGx0Y2M6IGx0Y2MsXG5cdGx0Y2lyOiBsdGNpcixcblx0bHQ6IGx0JDIsXG5cdExUOiBMVCQxLFxuXHRMdDogTHQsXG5cdGx0ZG90OiBsdGRvdCxcblx0bHRocmVlOiBsdGhyZWUsXG5cdGx0aW1lczogbHRpbWVzLFxuXHRsdGxhcnI6IGx0bGFycixcblx0bHRxdWVzdDogbHRxdWVzdCxcblx0bHRyaTogbHRyaSxcblx0bHRyaWU6IGx0cmllLFxuXHRsdHJpZjogbHRyaWYsXG5cdGx0clBhcjogbHRyUGFyLFxuXHRsdXJkc2hhcjogbHVyZHNoYXIsXG5cdGx1cnVoYXI6IGx1cnVoYXIsXG5cdGx2ZXJ0bmVxcTogbHZlcnRuZXFxLFxuXHRsdm5FOiBsdm5FLFxuXHRtYWNyOiBtYWNyJDEsXG5cdG1hbGU6IG1hbGUsXG5cdG1hbHQ6IG1hbHQsXG5cdG1hbHRlc2U6IG1hbHRlc2UsXG5cdFwiTWFwXCI6IFwi4qSFXCIsXG5cdG1hcDogbWFwLFxuXHRtYXBzdG86IG1hcHN0byxcblx0bWFwc3RvZG93bjogbWFwc3RvZG93bixcblx0bWFwc3RvbGVmdDogbWFwc3RvbGVmdCxcblx0bWFwc3RvdXA6IG1hcHN0b3VwLFxuXHRtYXJrZXI6IG1hcmtlcixcblx0bWNvbW1hOiBtY29tbWEsXG5cdE1jeTogTWN5LFxuXHRtY3k6IG1jeSxcblx0bWRhc2g6IG1kYXNoLFxuXHRtRERvdDogbUREb3QsXG5cdG1lYXN1cmVkYW5nbGU6IG1lYXN1cmVkYW5nbGUsXG5cdE1lZGl1bVNwYWNlOiBNZWRpdW1TcGFjZSxcblx0TWVsbGludHJmOiBNZWxsaW50cmYsXG5cdE1mcjogTWZyLFxuXHRtZnI6IG1mcixcblx0bWhvOiBtaG8sXG5cdG1pY3JvOiBtaWNybyQxLFxuXHRtaWRhc3Q6IG1pZGFzdCxcblx0bWlkY2lyOiBtaWRjaXIsXG5cdG1pZDogbWlkLFxuXHRtaWRkb3Q6IG1pZGRvdCQxLFxuXHRtaW51c2I6IG1pbnVzYixcblx0bWludXM6IG1pbnVzLFxuXHRtaW51c2Q6IG1pbnVzZCxcblx0bWludXNkdTogbWludXNkdSxcblx0TWludXNQbHVzOiBNaW51c1BsdXMsXG5cdG1sY3A6IG1sY3AsXG5cdG1sZHI6IG1sZHIsXG5cdG1ucGx1czogbW5wbHVzLFxuXHRtb2RlbHM6IG1vZGVscyxcblx0TW9wZjogTW9wZixcblx0bW9wZjogbW9wZixcblx0bXA6IG1wLFxuXHRtc2NyOiBtc2NyLFxuXHRNc2NyOiBNc2NyLFxuXHRtc3Rwb3M6IG1zdHBvcyxcblx0TXU6IE11LFxuXHRtdTogbXUsXG5cdG11bHRpbWFwOiBtdWx0aW1hcCxcblx0bXVtYXA6IG11bWFwLFxuXHRuYWJsYTogbmFibGEsXG5cdE5hY3V0ZTogTmFjdXRlLFxuXHRuYWN1dGU6IG5hY3V0ZSxcblx0bmFuZzogbmFuZyxcblx0bmFwOiBuYXAsXG5cdG5hcEU6IG5hcEUsXG5cdG5hcGlkOiBuYXBpZCxcblx0bmFwb3M6IG5hcG9zLFxuXHRuYXBwcm94OiBuYXBwcm94LFxuXHRuYXR1cmFsOiBuYXR1cmFsLFxuXHRuYXR1cmFsczogbmF0dXJhbHMsXG5cdG5hdHVyOiBuYXR1cixcblx0bmJzcDogbmJzcCQxLFxuXHRuYnVtcDogbmJ1bXAsXG5cdG5idW1wZTogbmJ1bXBlLFxuXHRuY2FwOiBuY2FwLFxuXHROY2Fyb246IE5jYXJvbixcblx0bmNhcm9uOiBuY2Fyb24sXG5cdE5jZWRpbDogTmNlZGlsLFxuXHRuY2VkaWw6IG5jZWRpbCxcblx0bmNvbmc6IG5jb25nLFxuXHRuY29uZ2RvdDogbmNvbmdkb3QsXG5cdG5jdXA6IG5jdXAsXG5cdE5jeTogTmN5LFxuXHRuY3k6IG5jeSxcblx0bmRhc2g6IG5kYXNoLFxuXHRuZWFyaGs6IG5lYXJoayxcblx0bmVhcnI6IG5lYXJyLFxuXHRuZUFycjogbmVBcnIsXG5cdG5lYXJyb3c6IG5lYXJyb3csXG5cdG5lOiBuZSxcblx0bmVkb3Q6IG5lZG90LFxuXHROZWdhdGl2ZU1lZGl1bVNwYWNlOiBOZWdhdGl2ZU1lZGl1bVNwYWNlLFxuXHROZWdhdGl2ZVRoaWNrU3BhY2U6IE5lZ2F0aXZlVGhpY2tTcGFjZSxcblx0TmVnYXRpdmVUaGluU3BhY2U6IE5lZ2F0aXZlVGhpblNwYWNlLFxuXHROZWdhdGl2ZVZlcnlUaGluU3BhY2U6IE5lZ2F0aXZlVmVyeVRoaW5TcGFjZSxcblx0bmVxdWl2OiBuZXF1aXYsXG5cdG5lc2VhcjogbmVzZWFyLFxuXHRuZXNpbTogbmVzaW0sXG5cdE5lc3RlZEdyZWF0ZXJHcmVhdGVyOiBOZXN0ZWRHcmVhdGVyR3JlYXRlcixcblx0TmVzdGVkTGVzc0xlc3M6IE5lc3RlZExlc3NMZXNzLFxuXHROZXdMaW5lOiBOZXdMaW5lLFxuXHRuZXhpc3Q6IG5leGlzdCxcblx0bmV4aXN0czogbmV4aXN0cyxcblx0TmZyOiBOZnIsXG5cdG5mcjogbmZyLFxuXHRuZ0U6IG5nRSxcblx0bmdlOiBuZ2UsXG5cdG5nZXE6IG5nZXEsXG5cdG5nZXFxOiBuZ2VxcSxcblx0bmdlcXNsYW50OiBuZ2Vxc2xhbnQsXG5cdG5nZXM6IG5nZXMsXG5cdG5HZzogbkdnLFxuXHRuZ3NpbTogbmdzaW0sXG5cdG5HdDogbkd0LFxuXHRuZ3Q6IG5ndCxcblx0bmd0cjogbmd0cixcblx0bkd0djogbkd0dixcblx0bmhhcnI6IG5oYXJyLFxuXHRuaEFycjogbmhBcnIsXG5cdG5ocGFyOiBuaHBhcixcblx0bmk6IG5pLFxuXHRuaXM6IG5pcyxcblx0bmlzZDogbmlzZCxcblx0bml2OiBuaXYsXG5cdE5KY3k6IE5KY3ksXG5cdG5qY3k6IG5qY3ksXG5cdG5sYXJyOiBubGFycixcblx0bmxBcnI6IG5sQXJyLFxuXHRubGRyOiBubGRyLFxuXHRubEU6IG5sRSxcblx0bmxlOiBubGUsXG5cdG5sZWZ0YXJyb3c6IG5sZWZ0YXJyb3csXG5cdG5MZWZ0YXJyb3c6IG5MZWZ0YXJyb3csXG5cdG5sZWZ0cmlnaHRhcnJvdzogbmxlZnRyaWdodGFycm93LFxuXHRuTGVmdHJpZ2h0YXJyb3c6IG5MZWZ0cmlnaHRhcnJvdyxcblx0bmxlcTogbmxlcSxcblx0bmxlcXE6IG5sZXFxLFxuXHRubGVxc2xhbnQ6IG5sZXFzbGFudCxcblx0bmxlczogbmxlcyxcblx0bmxlc3M6IG5sZXNzLFxuXHRuTGw6IG5MbCxcblx0bmxzaW06IG5sc2ltLFxuXHRuTHQ6IG5MdCxcblx0bmx0OiBubHQsXG5cdG5sdHJpOiBubHRyaSxcblx0bmx0cmllOiBubHRyaWUsXG5cdG5MdHY6IG5MdHYsXG5cdG5taWQ6IG5taWQsXG5cdE5vQnJlYWs6IE5vQnJlYWssXG5cdE5vbkJyZWFraW5nU3BhY2U6IE5vbkJyZWFraW5nU3BhY2UsXG5cdG5vcGY6IG5vcGYsXG5cdE5vcGY6IE5vcGYsXG5cdE5vdDogTm90LFxuXHRub3Q6IG5vdCQxLFxuXHROb3RDb25ncnVlbnQ6IE5vdENvbmdydWVudCxcblx0Tm90Q3VwQ2FwOiBOb3RDdXBDYXAsXG5cdE5vdERvdWJsZVZlcnRpY2FsQmFyOiBOb3REb3VibGVWZXJ0aWNhbEJhcixcblx0Tm90RWxlbWVudDogTm90RWxlbWVudCxcblx0Tm90RXF1YWw6IE5vdEVxdWFsLFxuXHROb3RFcXVhbFRpbGRlOiBOb3RFcXVhbFRpbGRlLFxuXHROb3RFeGlzdHM6IE5vdEV4aXN0cyxcblx0Tm90R3JlYXRlcjogTm90R3JlYXRlcixcblx0Tm90R3JlYXRlckVxdWFsOiBOb3RHcmVhdGVyRXF1YWwsXG5cdE5vdEdyZWF0ZXJGdWxsRXF1YWw6IE5vdEdyZWF0ZXJGdWxsRXF1YWwsXG5cdE5vdEdyZWF0ZXJHcmVhdGVyOiBOb3RHcmVhdGVyR3JlYXRlcixcblx0Tm90R3JlYXRlckxlc3M6IE5vdEdyZWF0ZXJMZXNzLFxuXHROb3RHcmVhdGVyU2xhbnRFcXVhbDogTm90R3JlYXRlclNsYW50RXF1YWwsXG5cdE5vdEdyZWF0ZXJUaWxkZTogTm90R3JlYXRlclRpbGRlLFxuXHROb3RIdW1wRG93bkh1bXA6IE5vdEh1bXBEb3duSHVtcCxcblx0Tm90SHVtcEVxdWFsOiBOb3RIdW1wRXF1YWwsXG5cdG5vdGluOiBub3Rpbixcblx0bm90aW5kb3Q6IG5vdGluZG90LFxuXHRub3RpbkU6IG5vdGluRSxcblx0bm90aW52YTogbm90aW52YSxcblx0bm90aW52Yjogbm90aW52Yixcblx0bm90aW52Yzogbm90aW52Yyxcblx0Tm90TGVmdFRyaWFuZ2xlQmFyOiBOb3RMZWZ0VHJpYW5nbGVCYXIsXG5cdE5vdExlZnRUcmlhbmdsZTogTm90TGVmdFRyaWFuZ2xlLFxuXHROb3RMZWZ0VHJpYW5nbGVFcXVhbDogTm90TGVmdFRyaWFuZ2xlRXF1YWwsXG5cdE5vdExlc3M6IE5vdExlc3MsXG5cdE5vdExlc3NFcXVhbDogTm90TGVzc0VxdWFsLFxuXHROb3RMZXNzR3JlYXRlcjogTm90TGVzc0dyZWF0ZXIsXG5cdE5vdExlc3NMZXNzOiBOb3RMZXNzTGVzcyxcblx0Tm90TGVzc1NsYW50RXF1YWw6IE5vdExlc3NTbGFudEVxdWFsLFxuXHROb3RMZXNzVGlsZGU6IE5vdExlc3NUaWxkZSxcblx0Tm90TmVzdGVkR3JlYXRlckdyZWF0ZXI6IE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyLFxuXHROb3ROZXN0ZWRMZXNzTGVzczogTm90TmVzdGVkTGVzc0xlc3MsXG5cdG5vdG5pOiBub3RuaSxcblx0bm90bml2YTogbm90bml2YSxcblx0bm90bml2Yjogbm90bml2Yixcblx0bm90bml2Yzogbm90bml2Yyxcblx0Tm90UHJlY2VkZXM6IE5vdFByZWNlZGVzLFxuXHROb3RQcmVjZWRlc0VxdWFsOiBOb3RQcmVjZWRlc0VxdWFsLFxuXHROb3RQcmVjZWRlc1NsYW50RXF1YWw6IE5vdFByZWNlZGVzU2xhbnRFcXVhbCxcblx0Tm90UmV2ZXJzZUVsZW1lbnQ6IE5vdFJldmVyc2VFbGVtZW50LFxuXHROb3RSaWdodFRyaWFuZ2xlQmFyOiBOb3RSaWdodFRyaWFuZ2xlQmFyLFxuXHROb3RSaWdodFRyaWFuZ2xlOiBOb3RSaWdodFRyaWFuZ2xlLFxuXHROb3RSaWdodFRyaWFuZ2xlRXF1YWw6IE5vdFJpZ2h0VHJpYW5nbGVFcXVhbCxcblx0Tm90U3F1YXJlU3Vic2V0OiBOb3RTcXVhcmVTdWJzZXQsXG5cdE5vdFNxdWFyZVN1YnNldEVxdWFsOiBOb3RTcXVhcmVTdWJzZXRFcXVhbCxcblx0Tm90U3F1YXJlU3VwZXJzZXQ6IE5vdFNxdWFyZVN1cGVyc2V0LFxuXHROb3RTcXVhcmVTdXBlcnNldEVxdWFsOiBOb3RTcXVhcmVTdXBlcnNldEVxdWFsLFxuXHROb3RTdWJzZXQ6IE5vdFN1YnNldCxcblx0Tm90U3Vic2V0RXF1YWw6IE5vdFN1YnNldEVxdWFsLFxuXHROb3RTdWNjZWVkczogTm90U3VjY2VlZHMsXG5cdE5vdFN1Y2NlZWRzRXF1YWw6IE5vdFN1Y2NlZWRzRXF1YWwsXG5cdE5vdFN1Y2NlZWRzU2xhbnRFcXVhbDogTm90U3VjY2VlZHNTbGFudEVxdWFsLFxuXHROb3RTdWNjZWVkc1RpbGRlOiBOb3RTdWNjZWVkc1RpbGRlLFxuXHROb3RTdXBlcnNldDogTm90U3VwZXJzZXQsXG5cdE5vdFN1cGVyc2V0RXF1YWw6IE5vdFN1cGVyc2V0RXF1YWwsXG5cdE5vdFRpbGRlOiBOb3RUaWxkZSxcblx0Tm90VGlsZGVFcXVhbDogTm90VGlsZGVFcXVhbCxcblx0Tm90VGlsZGVGdWxsRXF1YWw6IE5vdFRpbGRlRnVsbEVxdWFsLFxuXHROb3RUaWxkZVRpbGRlOiBOb3RUaWxkZVRpbGRlLFxuXHROb3RWZXJ0aWNhbEJhcjogTm90VmVydGljYWxCYXIsXG5cdG5wYXJhbGxlbDogbnBhcmFsbGVsLFxuXHRucGFyOiBucGFyLFxuXHRucGFyc2w6IG5wYXJzbCxcblx0bnBhcnQ6IG5wYXJ0LFxuXHRucG9saW50OiBucG9saW50LFxuXHRucHI6IG5wcixcblx0bnByY3VlOiBucHJjdWUsXG5cdG5wcmVjOiBucHJlYyxcblx0bnByZWNlcTogbnByZWNlcSxcblx0bnByZTogbnByZSxcblx0bnJhcnJjOiBucmFycmMsXG5cdG5yYXJyOiBucmFycixcblx0bnJBcnI6IG5yQXJyLFxuXHRucmFycnc6IG5yYXJydyxcblx0bnJpZ2h0YXJyb3c6IG5yaWdodGFycm93LFxuXHRuUmlnaHRhcnJvdzogblJpZ2h0YXJyb3csXG5cdG5ydHJpOiBucnRyaSxcblx0bnJ0cmllOiBucnRyaWUsXG5cdG5zYzogbnNjLFxuXHRuc2NjdWU6IG5zY2N1ZSxcblx0bnNjZTogbnNjZSxcblx0TnNjcjogTnNjcixcblx0bnNjcjogbnNjcixcblx0bnNob3J0bWlkOiBuc2hvcnRtaWQsXG5cdG5zaG9ydHBhcmFsbGVsOiBuc2hvcnRwYXJhbGxlbCxcblx0bnNpbTogbnNpbSxcblx0bnNpbWU6IG5zaW1lLFxuXHRuc2ltZXE6IG5zaW1lcSxcblx0bnNtaWQ6IG5zbWlkLFxuXHRuc3BhcjogbnNwYXIsXG5cdG5zcXN1YmU6IG5zcXN1YmUsXG5cdG5zcXN1cGU6IG5zcXN1cGUsXG5cdG5zdWI6IG5zdWIsXG5cdG5zdWJFOiBuc3ViRSxcblx0bnN1YmU6IG5zdWJlLFxuXHRuc3Vic2V0OiBuc3Vic2V0LFxuXHRuc3Vic2V0ZXE6IG5zdWJzZXRlcSxcblx0bnN1YnNldGVxcTogbnN1YnNldGVxcSxcblx0bnN1Y2M6IG5zdWNjLFxuXHRuc3VjY2VxOiBuc3VjY2VxLFxuXHRuc3VwOiBuc3VwLFxuXHRuc3VwRTogbnN1cEUsXG5cdG5zdXBlOiBuc3VwZSxcblx0bnN1cHNldDogbnN1cHNldCxcblx0bnN1cHNldGVxOiBuc3Vwc2V0ZXEsXG5cdG5zdXBzZXRlcXE6IG5zdXBzZXRlcXEsXG5cdG50Z2w6IG50Z2wsXG5cdE50aWxkZTogTnRpbGRlJDEsXG5cdG50aWxkZTogbnRpbGRlJDEsXG5cdG50bGc6IG50bGcsXG5cdG50cmlhbmdsZWxlZnQ6IG50cmlhbmdsZWxlZnQsXG5cdG50cmlhbmdsZWxlZnRlcTogbnRyaWFuZ2xlbGVmdGVxLFxuXHRudHJpYW5nbGVyaWdodDogbnRyaWFuZ2xlcmlnaHQsXG5cdG50cmlhbmdsZXJpZ2h0ZXE6IG50cmlhbmdsZXJpZ2h0ZXEsXG5cdE51OiBOdSxcblx0bnU6IG51LFxuXHRudW06IG51bSxcblx0bnVtZXJvOiBudW1lcm8sXG5cdG51bXNwOiBudW1zcCxcblx0bnZhcDogbnZhcCxcblx0bnZkYXNoOiBudmRhc2gsXG5cdG52RGFzaDogbnZEYXNoLFxuXHRuVmRhc2g6IG5WZGFzaCxcblx0blZEYXNoOiBuVkRhc2gsXG5cdG52Z2U6IG52Z2UsXG5cdG52Z3Q6IG52Z3QsXG5cdG52SGFycjogbnZIYXJyLFxuXHRudmluZmluOiBudmluZmluLFxuXHRudmxBcnI6IG52bEFycixcblx0bnZsZTogbnZsZSxcblx0bnZsdDogbnZsdCxcblx0bnZsdHJpZTogbnZsdHJpZSxcblx0bnZyQXJyOiBudnJBcnIsXG5cdG52cnRyaWU6IG52cnRyaWUsXG5cdG52c2ltOiBudnNpbSxcblx0bndhcmhrOiBud2FyaGssXG5cdG53YXJyOiBud2Fycixcblx0bndBcnI6IG53QXJyLFxuXHRud2Fycm93OiBud2Fycm93LFxuXHRud25lYXI6IG53bmVhcixcblx0T2FjdXRlOiBPYWN1dGUkMSxcblx0b2FjdXRlOiBvYWN1dGUkMSxcblx0b2FzdDogb2FzdCxcblx0T2NpcmM6IE9jaXJjJDEsXG5cdG9jaXJjOiBvY2lyYyQxLFxuXHRvY2lyOiBvY2lyLFxuXHRPY3k6IE9jeSxcblx0b2N5OiBvY3ksXG5cdG9kYXNoOiBvZGFzaCxcblx0T2RibGFjOiBPZGJsYWMsXG5cdG9kYmxhYzogb2RibGFjLFxuXHRvZGl2OiBvZGl2LFxuXHRvZG90OiBvZG90LFxuXHRvZHNvbGQ6IG9kc29sZCxcblx0T0VsaWc6IE9FbGlnLFxuXHRvZWxpZzogb2VsaWcsXG5cdG9mY2lyOiBvZmNpcixcblx0T2ZyOiBPZnIsXG5cdG9mcjogb2ZyLFxuXHRvZ29uOiBvZ29uLFxuXHRPZ3JhdmU6IE9ncmF2ZSQxLFxuXHRvZ3JhdmU6IG9ncmF2ZSQxLFxuXHRvZ3Q6IG9ndCxcblx0b2hiYXI6IG9oYmFyLFxuXHRvaG06IG9obSxcblx0b2ludDogb2ludCxcblx0b2xhcnI6IG9sYXJyLFxuXHRvbGNpcjogb2xjaXIsXG5cdG9sY3Jvc3M6IG9sY3Jvc3MsXG5cdG9saW5lOiBvbGluZSxcblx0b2x0OiBvbHQsXG5cdE9tYWNyOiBPbWFjcixcblx0b21hY3I6IG9tYWNyLFxuXHRPbWVnYTogT21lZ2EsXG5cdG9tZWdhOiBvbWVnYSxcblx0T21pY3JvbjogT21pY3Jvbixcblx0b21pY3Jvbjogb21pY3Jvbixcblx0b21pZDogb21pZCxcblx0b21pbnVzOiBvbWludXMsXG5cdE9vcGY6IE9vcGYsXG5cdG9vcGY6IG9vcGYsXG5cdG9wYXI6IG9wYXIsXG5cdE9wZW5DdXJseURvdWJsZVF1b3RlOiBPcGVuQ3VybHlEb3VibGVRdW90ZSxcblx0T3BlbkN1cmx5UXVvdGU6IE9wZW5DdXJseVF1b3RlLFxuXHRvcGVycDogb3BlcnAsXG5cdG9wbHVzOiBvcGx1cyxcblx0b3JhcnI6IG9yYXJyLFxuXHRPcjogT3IsXG5cdG9yOiBvcixcblx0b3JkOiBvcmQsXG5cdG9yZGVyOiBvcmRlcixcblx0b3JkZXJvZjogb3JkZXJvZixcblx0b3JkZjogb3JkZiQxLFxuXHRvcmRtOiBvcmRtJDEsXG5cdG9yaWdvZjogb3JpZ29mLFxuXHRvcm9yOiBvcm9yLFxuXHRvcnNsb3BlOiBvcnNsb3BlLFxuXHRvcnY6IG9ydixcblx0b1M6IG9TLFxuXHRPc2NyOiBPc2NyLFxuXHRvc2NyOiBvc2NyLFxuXHRPc2xhc2g6IE9zbGFzaCQxLFxuXHRvc2xhc2g6IG9zbGFzaCQxLFxuXHRvc29sOiBvc29sLFxuXHRPdGlsZGU6IE90aWxkZSQxLFxuXHRvdGlsZGU6IG90aWxkZSQxLFxuXHRvdGltZXNhczogb3RpbWVzYXMsXG5cdE90aW1lczogT3RpbWVzLFxuXHRvdGltZXM6IG90aW1lcyxcblx0T3VtbDogT3VtbCQxLFxuXHRvdW1sOiBvdW1sJDEsXG5cdG92YmFyOiBvdmJhcixcblx0T3ZlckJhcjogT3ZlckJhcixcblx0T3ZlckJyYWNlOiBPdmVyQnJhY2UsXG5cdE92ZXJCcmFja2V0OiBPdmVyQnJhY2tldCxcblx0T3ZlclBhcmVudGhlc2lzOiBPdmVyUGFyZW50aGVzaXMsXG5cdHBhcmE6IHBhcmEkMSxcblx0cGFyYWxsZWw6IHBhcmFsbGVsLFxuXHRwYXI6IHBhcixcblx0cGFyc2ltOiBwYXJzaW0sXG5cdHBhcnNsOiBwYXJzbCxcblx0cGFydDogcGFydCxcblx0UGFydGlhbEQ6IFBhcnRpYWxELFxuXHRQY3k6IFBjeSxcblx0cGN5OiBwY3ksXG5cdHBlcmNudDogcGVyY250LFxuXHRwZXJpb2Q6IHBlcmlvZCxcblx0cGVybWlsOiBwZXJtaWwsXG5cdHBlcnA6IHBlcnAsXG5cdHBlcnRlbms6IHBlcnRlbmssXG5cdFBmcjogUGZyLFxuXHRwZnI6IHBmcixcblx0UGhpOiBQaGksXG5cdHBoaTogcGhpLFxuXHRwaGl2OiBwaGl2LFxuXHRwaG1tYXQ6IHBobW1hdCxcblx0cGhvbmU6IHBob25lLFxuXHRQaTogUGksXG5cdHBpOiBwaSxcblx0cGl0Y2hmb3JrOiBwaXRjaGZvcmssXG5cdHBpdjogcGl2LFxuXHRwbGFuY2s6IHBsYW5jayxcblx0cGxhbmNraDogcGxhbmNraCxcblx0cGxhbmt2OiBwbGFua3YsXG5cdHBsdXNhY2lyOiBwbHVzYWNpcixcblx0cGx1c2I6IHBsdXNiLFxuXHRwbHVzY2lyOiBwbHVzY2lyLFxuXHRwbHVzOiBwbHVzLFxuXHRwbHVzZG86IHBsdXNkbyxcblx0cGx1c2R1OiBwbHVzZHUsXG5cdHBsdXNlOiBwbHVzZSxcblx0UGx1c01pbnVzOiBQbHVzTWludXMsXG5cdHBsdXNtbjogcGx1c21uJDEsXG5cdHBsdXNzaW06IHBsdXNzaW0sXG5cdHBsdXN0d286IHBsdXN0d28sXG5cdHBtOiBwbSxcblx0UG9pbmNhcmVwbGFuZTogUG9pbmNhcmVwbGFuZSxcblx0cG9pbnRpbnQ6IHBvaW50aW50LFxuXHRwb3BmOiBwb3BmLFxuXHRQb3BmOiBQb3BmLFxuXHRwb3VuZDogcG91bmQkMSxcblx0cHJhcDogcHJhcCxcblx0UHI6IFByLFxuXHRwcjogcHIsXG5cdHByY3VlOiBwcmN1ZSxcblx0cHJlY2FwcHJveDogcHJlY2FwcHJveCxcblx0cHJlYzogcHJlYyxcblx0cHJlY2N1cmx5ZXE6IHByZWNjdXJseWVxLFxuXHRQcmVjZWRlczogUHJlY2VkZXMsXG5cdFByZWNlZGVzRXF1YWw6IFByZWNlZGVzRXF1YWwsXG5cdFByZWNlZGVzU2xhbnRFcXVhbDogUHJlY2VkZXNTbGFudEVxdWFsLFxuXHRQcmVjZWRlc1RpbGRlOiBQcmVjZWRlc1RpbGRlLFxuXHRwcmVjZXE6IHByZWNlcSxcblx0cHJlY25hcHByb3g6IHByZWNuYXBwcm94LFxuXHRwcmVjbmVxcTogcHJlY25lcXEsXG5cdHByZWNuc2ltOiBwcmVjbnNpbSxcblx0cHJlOiBwcmUsXG5cdHByRTogcHJFLFxuXHRwcmVjc2ltOiBwcmVjc2ltLFxuXHRwcmltZTogcHJpbWUsXG5cdFByaW1lOiBQcmltZSxcblx0cHJpbWVzOiBwcmltZXMsXG5cdHBybmFwOiBwcm5hcCxcblx0cHJuRTogcHJuRSxcblx0cHJuc2ltOiBwcm5zaW0sXG5cdHByb2Q6IHByb2QsXG5cdFByb2R1Y3Q6IFByb2R1Y3QsXG5cdHByb2ZhbGFyOiBwcm9mYWxhcixcblx0cHJvZmxpbmU6IHByb2ZsaW5lLFxuXHRwcm9mc3VyZjogcHJvZnN1cmYsXG5cdHByb3A6IHByb3AsXG5cdFByb3BvcnRpb25hbDogUHJvcG9ydGlvbmFsLFxuXHRQcm9wb3J0aW9uOiBQcm9wb3J0aW9uLFxuXHRwcm9wdG86IHByb3B0byxcblx0cHJzaW06IHByc2ltLFxuXHRwcnVyZWw6IHBydXJlbCxcblx0UHNjcjogUHNjcixcblx0cHNjcjogcHNjcixcblx0UHNpOiBQc2ksXG5cdHBzaTogcHNpLFxuXHRwdW5jc3A6IHB1bmNzcCxcblx0UWZyOiBRZnIsXG5cdHFmcjogcWZyLFxuXHRxaW50OiBxaW50LFxuXHRxb3BmOiBxb3BmLFxuXHRRb3BmOiBRb3BmLFxuXHRxcHJpbWU6IHFwcmltZSxcblx0UXNjcjogUXNjcixcblx0cXNjcjogcXNjcixcblx0cXVhdGVybmlvbnM6IHF1YXRlcm5pb25zLFxuXHRxdWF0aW50OiBxdWF0aW50LFxuXHRxdWVzdDogcXVlc3QsXG5cdHF1ZXN0ZXE6IHF1ZXN0ZXEsXG5cdHF1b3Q6IHF1b3QkMixcblx0UVVPVDogUVVPVCQxLFxuXHRyQWFycjogckFhcnIsXG5cdHJhY2U6IHJhY2UsXG5cdFJhY3V0ZTogUmFjdXRlLFxuXHRyYWN1dGU6IHJhY3V0ZSxcblx0cmFkaWM6IHJhZGljLFxuXHRyYWVtcHR5djogcmFlbXB0eXYsXG5cdHJhbmc6IHJhbmcsXG5cdFJhbmc6IFJhbmcsXG5cdHJhbmdkOiByYW5nZCxcblx0cmFuZ2U6IHJhbmdlLFxuXHRyYW5nbGU6IHJhbmdsZSxcblx0cmFxdW86IHJhcXVvJDEsXG5cdHJhcnJhcDogcmFycmFwLFxuXHRyYXJyYjogcmFycmIsXG5cdHJhcnJiZnM6IHJhcnJiZnMsXG5cdHJhcnJjOiByYXJyYyxcblx0cmFycjogcmFycixcblx0UmFycjogUmFycixcblx0ckFycjogckFycixcblx0cmFycmZzOiByYXJyZnMsXG5cdHJhcnJoazogcmFycmhrLFxuXHRyYXJybHA6IHJhcnJscCxcblx0cmFycnBsOiByYXJycGwsXG5cdHJhcnJzaW06IHJhcnJzaW0sXG5cdFJhcnJ0bDogUmFycnRsLFxuXHRyYXJydGw6IHJhcnJ0bCxcblx0cmFycnc6IHJhcnJ3LFxuXHRyYXRhaWw6IHJhdGFpbCxcblx0ckF0YWlsOiByQXRhaWwsXG5cdHJhdGlvOiByYXRpbyxcblx0cmF0aW9uYWxzOiByYXRpb25hbHMsXG5cdHJiYXJyOiByYmFycixcblx0ckJhcnI6IHJCYXJyLFxuXHRSQmFycjogUkJhcnIsXG5cdHJiYnJrOiByYmJyayxcblx0cmJyYWNlOiByYnJhY2UsXG5cdHJicmFjazogcmJyYWNrLFxuXHRyYnJrZTogcmJya2UsXG5cdHJicmtzbGQ6IHJicmtzbGQsXG5cdHJicmtzbHU6IHJicmtzbHUsXG5cdFJjYXJvbjogUmNhcm9uLFxuXHRyY2Fyb246IHJjYXJvbixcblx0UmNlZGlsOiBSY2VkaWwsXG5cdHJjZWRpbDogcmNlZGlsLFxuXHRyY2VpbDogcmNlaWwsXG5cdHJjdWI6IHJjdWIsXG5cdFJjeTogUmN5LFxuXHRyY3k6IHJjeSxcblx0cmRjYTogcmRjYSxcblx0cmRsZGhhcjogcmRsZGhhcixcblx0cmRxdW86IHJkcXVvLFxuXHRyZHF1b3I6IHJkcXVvcixcblx0cmRzaDogcmRzaCxcblx0cmVhbDogcmVhbCxcblx0cmVhbGluZTogcmVhbGluZSxcblx0cmVhbHBhcnQ6IHJlYWxwYXJ0LFxuXHRyZWFsczogcmVhbHMsXG5cdFJlOiBSZSxcblx0cmVjdDogcmVjdCxcblx0cmVnOiByZWckMSxcblx0UkVHOiBSRUckMSxcblx0UmV2ZXJzZUVsZW1lbnQ6IFJldmVyc2VFbGVtZW50LFxuXHRSZXZlcnNlRXF1aWxpYnJpdW06IFJldmVyc2VFcXVpbGlicml1bSxcblx0UmV2ZXJzZVVwRXF1aWxpYnJpdW06IFJldmVyc2VVcEVxdWlsaWJyaXVtLFxuXHRyZmlzaHQ6IHJmaXNodCxcblx0cmZsb29yOiByZmxvb3IsXG5cdHJmcjogcmZyLFxuXHRSZnI6IFJmcixcblx0ckhhcjogckhhcixcblx0cmhhcmQ6IHJoYXJkLFxuXHRyaGFydTogcmhhcnUsXG5cdHJoYXJ1bDogcmhhcnVsLFxuXHRSaG86IFJobyxcblx0cmhvOiByaG8sXG5cdHJob3Y6IHJob3YsXG5cdFJpZ2h0QW5nbGVCcmFja2V0OiBSaWdodEFuZ2xlQnJhY2tldCxcblx0UmlnaHRBcnJvd0JhcjogUmlnaHRBcnJvd0Jhcixcblx0cmlnaHRhcnJvdzogcmlnaHRhcnJvdyxcblx0UmlnaHRBcnJvdzogUmlnaHRBcnJvdyxcblx0UmlnaHRhcnJvdzogUmlnaHRhcnJvdyxcblx0UmlnaHRBcnJvd0xlZnRBcnJvdzogUmlnaHRBcnJvd0xlZnRBcnJvdyxcblx0cmlnaHRhcnJvd3RhaWw6IHJpZ2h0YXJyb3d0YWlsLFxuXHRSaWdodENlaWxpbmc6IFJpZ2h0Q2VpbGluZyxcblx0UmlnaHREb3VibGVCcmFja2V0OiBSaWdodERvdWJsZUJyYWNrZXQsXG5cdFJpZ2h0RG93blRlZVZlY3RvcjogUmlnaHREb3duVGVlVmVjdG9yLFxuXHRSaWdodERvd25WZWN0b3JCYXI6IFJpZ2h0RG93blZlY3RvckJhcixcblx0UmlnaHREb3duVmVjdG9yOiBSaWdodERvd25WZWN0b3IsXG5cdFJpZ2h0Rmxvb3I6IFJpZ2h0Rmxvb3IsXG5cdHJpZ2h0aGFycG9vbmRvd246IHJpZ2h0aGFycG9vbmRvd24sXG5cdHJpZ2h0aGFycG9vbnVwOiByaWdodGhhcnBvb251cCxcblx0cmlnaHRsZWZ0YXJyb3dzOiByaWdodGxlZnRhcnJvd3MsXG5cdHJpZ2h0bGVmdGhhcnBvb25zOiByaWdodGxlZnRoYXJwb29ucyxcblx0cmlnaHRyaWdodGFycm93czogcmlnaHRyaWdodGFycm93cyxcblx0cmlnaHRzcXVpZ2Fycm93OiByaWdodHNxdWlnYXJyb3csXG5cdFJpZ2h0VGVlQXJyb3c6IFJpZ2h0VGVlQXJyb3csXG5cdFJpZ2h0VGVlOiBSaWdodFRlZSxcblx0UmlnaHRUZWVWZWN0b3I6IFJpZ2h0VGVlVmVjdG9yLFxuXHRyaWdodHRocmVldGltZXM6IHJpZ2h0dGhyZWV0aW1lcyxcblx0UmlnaHRUcmlhbmdsZUJhcjogUmlnaHRUcmlhbmdsZUJhcixcblx0UmlnaHRUcmlhbmdsZTogUmlnaHRUcmlhbmdsZSxcblx0UmlnaHRUcmlhbmdsZUVxdWFsOiBSaWdodFRyaWFuZ2xlRXF1YWwsXG5cdFJpZ2h0VXBEb3duVmVjdG9yOiBSaWdodFVwRG93blZlY3Rvcixcblx0UmlnaHRVcFRlZVZlY3RvcjogUmlnaHRVcFRlZVZlY3Rvcixcblx0UmlnaHRVcFZlY3RvckJhcjogUmlnaHRVcFZlY3RvckJhcixcblx0UmlnaHRVcFZlY3RvcjogUmlnaHRVcFZlY3Rvcixcblx0UmlnaHRWZWN0b3JCYXI6IFJpZ2h0VmVjdG9yQmFyLFxuXHRSaWdodFZlY3RvcjogUmlnaHRWZWN0b3IsXG5cdHJpbmc6IHJpbmcsXG5cdHJpc2luZ2RvdHNlcTogcmlzaW5nZG90c2VxLFxuXHRybGFycjogcmxhcnIsXG5cdHJsaGFyOiBybGhhcixcblx0cmxtOiBybG0sXG5cdHJtb3VzdGFjaGU6IHJtb3VzdGFjaGUsXG5cdHJtb3VzdDogcm1vdXN0LFxuXHRybm1pZDogcm5taWQsXG5cdHJvYW5nOiByb2FuZyxcblx0cm9hcnI6IHJvYXJyLFxuXHRyb2Jyazogcm9icmssXG5cdHJvcGFyOiByb3Bhcixcblx0cm9wZjogcm9wZixcblx0Um9wZjogUm9wZixcblx0cm9wbHVzOiByb3BsdXMsXG5cdHJvdGltZXM6IHJvdGltZXMsXG5cdFJvdW5kSW1wbGllczogUm91bmRJbXBsaWVzLFxuXHRycGFyOiBycGFyLFxuXHRycGFyZ3Q6IHJwYXJndCxcblx0cnBwb2xpbnQ6IHJwcG9saW50LFxuXHRycmFycjogcnJhcnIsXG5cdFJyaWdodGFycm93OiBScmlnaHRhcnJvdyxcblx0cnNhcXVvOiByc2FxdW8sXG5cdHJzY3I6IHJzY3IsXG5cdFJzY3I6IFJzY3IsXG5cdHJzaDogcnNoLFxuXHRSc2g6IFJzaCxcblx0cnNxYjogcnNxYixcblx0cnNxdW86IHJzcXVvLFxuXHRyc3F1b3I6IHJzcXVvcixcblx0cnRocmVlOiBydGhyZWUsXG5cdHJ0aW1lczogcnRpbWVzLFxuXHRydHJpOiBydHJpLFxuXHRydHJpZTogcnRyaWUsXG5cdHJ0cmlmOiBydHJpZixcblx0cnRyaWx0cmk6IHJ0cmlsdHJpLFxuXHRSdWxlRGVsYXllZDogUnVsZURlbGF5ZWQsXG5cdHJ1bHVoYXI6IHJ1bHVoYXIsXG5cdHJ4OiByeCxcblx0U2FjdXRlOiBTYWN1dGUsXG5cdHNhY3V0ZTogc2FjdXRlLFxuXHRzYnF1bzogc2JxdW8sXG5cdHNjYXA6IHNjYXAsXG5cdFNjYXJvbjogU2Nhcm9uLFxuXHRzY2Fyb246IHNjYXJvbixcblx0U2M6IFNjLFxuXHRzYzogc2MsXG5cdHNjY3VlOiBzY2N1ZSxcblx0c2NlOiBzY2UsXG5cdHNjRTogc2NFLFxuXHRTY2VkaWw6IFNjZWRpbCxcblx0c2NlZGlsOiBzY2VkaWwsXG5cdFNjaXJjOiBTY2lyYyxcblx0c2NpcmM6IHNjaXJjLFxuXHRzY25hcDogc2NuYXAsXG5cdHNjbkU6IHNjbkUsXG5cdHNjbnNpbTogc2Nuc2ltLFxuXHRzY3BvbGludDogc2Nwb2xpbnQsXG5cdHNjc2ltOiBzY3NpbSxcblx0U2N5OiBTY3ksXG5cdHNjeTogc2N5LFxuXHRzZG90Yjogc2RvdGIsXG5cdHNkb3Q6IHNkb3QsXG5cdHNkb3RlOiBzZG90ZSxcblx0c2VhcmhrOiBzZWFyaGssXG5cdHNlYXJyOiBzZWFycixcblx0c2VBcnI6IHNlQXJyLFxuXHRzZWFycm93OiBzZWFycm93LFxuXHRzZWN0OiBzZWN0JDEsXG5cdHNlbWk6IHNlbWksXG5cdHNlc3dhcjogc2Vzd2FyLFxuXHRzZXRtaW51czogc2V0bWludXMsXG5cdHNldG1uOiBzZXRtbixcblx0c2V4dDogc2V4dCxcblx0U2ZyOiBTZnIsXG5cdHNmcjogc2ZyLFxuXHRzZnJvd246IHNmcm93bixcblx0c2hhcnA6IHNoYXJwLFxuXHRTSENIY3k6IFNIQ0hjeSxcblx0c2hjaGN5OiBzaGNoY3ksXG5cdFNIY3k6IFNIY3ksXG5cdHNoY3k6IHNoY3ksXG5cdFNob3J0RG93bkFycm93OiBTaG9ydERvd25BcnJvdyxcblx0U2hvcnRMZWZ0QXJyb3c6IFNob3J0TGVmdEFycm93LFxuXHRzaG9ydG1pZDogc2hvcnRtaWQsXG5cdHNob3J0cGFyYWxsZWw6IHNob3J0cGFyYWxsZWwsXG5cdFNob3J0UmlnaHRBcnJvdzogU2hvcnRSaWdodEFycm93LFxuXHRTaG9ydFVwQXJyb3c6IFNob3J0VXBBcnJvdyxcblx0c2h5OiBzaHkkMSxcblx0U2lnbWE6IFNpZ21hLFxuXHRzaWdtYTogc2lnbWEsXG5cdHNpZ21hZjogc2lnbWFmLFxuXHRzaWdtYXY6IHNpZ21hdixcblx0c2ltOiBzaW0sXG5cdHNpbWRvdDogc2ltZG90LFxuXHRzaW1lOiBzaW1lLFxuXHRzaW1lcTogc2ltZXEsXG5cdHNpbWc6IHNpbWcsXG5cdHNpbWdFOiBzaW1nRSxcblx0c2ltbDogc2ltbCxcblx0c2ltbEU6IHNpbWxFLFxuXHRzaW1uZTogc2ltbmUsXG5cdHNpbXBsdXM6IHNpbXBsdXMsXG5cdHNpbXJhcnI6IHNpbXJhcnIsXG5cdHNsYXJyOiBzbGFycixcblx0U21hbGxDaXJjbGU6IFNtYWxsQ2lyY2xlLFxuXHRzbWFsbHNldG1pbnVzOiBzbWFsbHNldG1pbnVzLFxuXHRzbWFzaHA6IHNtYXNocCxcblx0c21lcGFyc2w6IHNtZXBhcnNsLFxuXHRzbWlkOiBzbWlkLFxuXHRzbWlsZTogc21pbGUsXG5cdHNtdDogc210LFxuXHRzbXRlOiBzbXRlLFxuXHRzbXRlczogc210ZXMsXG5cdFNPRlRjeTogU09GVGN5LFxuXHRzb2Z0Y3k6IHNvZnRjeSxcblx0c29sYmFyOiBzb2xiYXIsXG5cdHNvbGI6IHNvbGIsXG5cdHNvbDogc29sLFxuXHRTb3BmOiBTb3BmLFxuXHRzb3BmOiBzb3BmLFxuXHRzcGFkZXM6IHNwYWRlcyxcblx0c3BhZGVzdWl0OiBzcGFkZXN1aXQsXG5cdHNwYXI6IHNwYXIsXG5cdHNxY2FwOiBzcWNhcCxcblx0c3FjYXBzOiBzcWNhcHMsXG5cdHNxY3VwOiBzcWN1cCxcblx0c3FjdXBzOiBzcWN1cHMsXG5cdFNxcnQ6IFNxcnQsXG5cdHNxc3ViOiBzcXN1Yixcblx0c3FzdWJlOiBzcXN1YmUsXG5cdHNxc3Vic2V0OiBzcXN1YnNldCxcblx0c3FzdWJzZXRlcTogc3FzdWJzZXRlcSxcblx0c3FzdXA6IHNxc3VwLFxuXHRzcXN1cGU6IHNxc3VwZSxcblx0c3FzdXBzZXQ6IHNxc3Vwc2V0LFxuXHRzcXN1cHNldGVxOiBzcXN1cHNldGVxLFxuXHRzcXVhcmU6IHNxdWFyZSxcblx0U3F1YXJlOiBTcXVhcmUsXG5cdFNxdWFyZUludGVyc2VjdGlvbjogU3F1YXJlSW50ZXJzZWN0aW9uLFxuXHRTcXVhcmVTdWJzZXQ6IFNxdWFyZVN1YnNldCxcblx0U3F1YXJlU3Vic2V0RXF1YWw6IFNxdWFyZVN1YnNldEVxdWFsLFxuXHRTcXVhcmVTdXBlcnNldDogU3F1YXJlU3VwZXJzZXQsXG5cdFNxdWFyZVN1cGVyc2V0RXF1YWw6IFNxdWFyZVN1cGVyc2V0RXF1YWwsXG5cdFNxdWFyZVVuaW9uOiBTcXVhcmVVbmlvbixcblx0c3F1YXJmOiBzcXVhcmYsXG5cdHNxdTogc3F1LFxuXHRzcXVmOiBzcXVmLFxuXHRzcmFycjogc3JhcnIsXG5cdFNzY3I6IFNzY3IsXG5cdHNzY3I6IHNzY3IsXG5cdHNzZXRtbjogc3NldG1uLFxuXHRzc21pbGU6IHNzbWlsZSxcblx0c3N0YXJmOiBzc3RhcmYsXG5cdFN0YXI6IFN0YXIsXG5cdHN0YXI6IHN0YXIsXG5cdHN0YXJmOiBzdGFyZixcblx0c3RyYWlnaHRlcHNpbG9uOiBzdHJhaWdodGVwc2lsb24sXG5cdHN0cmFpZ2h0cGhpOiBzdHJhaWdodHBoaSxcblx0c3RybnM6IHN0cm5zLFxuXHRzdWI6IHN1Yixcblx0U3ViOiBTdWIsXG5cdHN1YmRvdDogc3ViZG90LFxuXHRzdWJFOiBzdWJFLFxuXHRzdWJlOiBzdWJlLFxuXHRzdWJlZG90OiBzdWJlZG90LFxuXHRzdWJtdWx0OiBzdWJtdWx0LFxuXHRzdWJuRTogc3VibkUsXG5cdHN1Ym5lOiBzdWJuZSxcblx0c3VicGx1czogc3VicGx1cyxcblx0c3VicmFycjogc3VicmFycixcblx0c3Vic2V0OiBzdWJzZXQsXG5cdFN1YnNldDogU3Vic2V0LFxuXHRzdWJzZXRlcTogc3Vic2V0ZXEsXG5cdHN1YnNldGVxcTogc3Vic2V0ZXFxLFxuXHRTdWJzZXRFcXVhbDogU3Vic2V0RXF1YWwsXG5cdHN1YnNldG5lcTogc3Vic2V0bmVxLFxuXHRzdWJzZXRuZXFxOiBzdWJzZXRuZXFxLFxuXHRzdWJzaW06IHN1YnNpbSxcblx0c3Vic3ViOiBzdWJzdWIsXG5cdHN1YnN1cDogc3Vic3VwLFxuXHRzdWNjYXBwcm94OiBzdWNjYXBwcm94LFxuXHRzdWNjOiBzdWNjLFxuXHRzdWNjY3VybHllcTogc3VjY2N1cmx5ZXEsXG5cdFN1Y2NlZWRzOiBTdWNjZWVkcyxcblx0U3VjY2VlZHNFcXVhbDogU3VjY2VlZHNFcXVhbCxcblx0U3VjY2VlZHNTbGFudEVxdWFsOiBTdWNjZWVkc1NsYW50RXF1YWwsXG5cdFN1Y2NlZWRzVGlsZGU6IFN1Y2NlZWRzVGlsZGUsXG5cdHN1Y2NlcTogc3VjY2VxLFxuXHRzdWNjbmFwcHJveDogc3VjY25hcHByb3gsXG5cdHN1Y2NuZXFxOiBzdWNjbmVxcSxcblx0c3VjY25zaW06IHN1Y2Nuc2ltLFxuXHRzdWNjc2ltOiBzdWNjc2ltLFxuXHRTdWNoVGhhdDogU3VjaFRoYXQsXG5cdHN1bTogc3VtLFxuXHRTdW06IFN1bSxcblx0c3VuZzogc3VuZyxcblx0c3VwMTogc3VwMSQxLFxuXHRzdXAyOiBzdXAyJDEsXG5cdHN1cDM6IHN1cDMkMSxcblx0c3VwOiBzdXAsXG5cdFN1cDogU3VwLFxuXHRzdXBkb3Q6IHN1cGRvdCxcblx0c3VwZHN1Yjogc3VwZHN1Yixcblx0c3VwRTogc3VwRSxcblx0c3VwZTogc3VwZSxcblx0c3VwZWRvdDogc3VwZWRvdCxcblx0U3VwZXJzZXQ6IFN1cGVyc2V0LFxuXHRTdXBlcnNldEVxdWFsOiBTdXBlcnNldEVxdWFsLFxuXHRzdXBoc29sOiBzdXBoc29sLFxuXHRzdXBoc3ViOiBzdXBoc3ViLFxuXHRzdXBsYXJyOiBzdXBsYXJyLFxuXHRzdXBtdWx0OiBzdXBtdWx0LFxuXHRzdXBuRTogc3VwbkUsXG5cdHN1cG5lOiBzdXBuZSxcblx0c3VwcGx1czogc3VwcGx1cyxcblx0c3Vwc2V0OiBzdXBzZXQsXG5cdFN1cHNldDogU3Vwc2V0LFxuXHRzdXBzZXRlcTogc3Vwc2V0ZXEsXG5cdHN1cHNldGVxcTogc3Vwc2V0ZXFxLFxuXHRzdXBzZXRuZXE6IHN1cHNldG5lcSxcblx0c3Vwc2V0bmVxcTogc3Vwc2V0bmVxcSxcblx0c3Vwc2ltOiBzdXBzaW0sXG5cdHN1cHN1Yjogc3Vwc3ViLFxuXHRzdXBzdXA6IHN1cHN1cCxcblx0c3dhcmhrOiBzd2FyaGssXG5cdHN3YXJyOiBzd2Fycixcblx0c3dBcnI6IHN3QXJyLFxuXHRzd2Fycm93OiBzd2Fycm93LFxuXHRzd253YXI6IHN3bndhcixcblx0c3psaWc6IHN6bGlnJDEsXG5cdFRhYjogVGFiLFxuXHR0YXJnZXQ6IHRhcmdldCxcblx0VGF1OiBUYXUsXG5cdHRhdTogdGF1LFxuXHR0YnJrOiB0YnJrLFxuXHRUY2Fyb246IFRjYXJvbixcblx0dGNhcm9uOiB0Y2Fyb24sXG5cdFRjZWRpbDogVGNlZGlsLFxuXHR0Y2VkaWw6IHRjZWRpbCxcblx0VGN5OiBUY3ksXG5cdHRjeTogdGN5LFxuXHR0ZG90OiB0ZG90LFxuXHR0ZWxyZWM6IHRlbHJlYyxcblx0VGZyOiBUZnIsXG5cdHRmcjogdGZyLFxuXHR0aGVyZTQ6IHRoZXJlNCxcblx0dGhlcmVmb3JlOiB0aGVyZWZvcmUsXG5cdFRoZXJlZm9yZTogVGhlcmVmb3JlLFxuXHRUaGV0YTogVGhldGEsXG5cdHRoZXRhOiB0aGV0YSxcblx0dGhldGFzeW06IHRoZXRhc3ltLFxuXHR0aGV0YXY6IHRoZXRhdixcblx0dGhpY2thcHByb3g6IHRoaWNrYXBwcm94LFxuXHR0aGlja3NpbTogdGhpY2tzaW0sXG5cdFRoaWNrU3BhY2U6IFRoaWNrU3BhY2UsXG5cdFRoaW5TcGFjZTogVGhpblNwYWNlLFxuXHR0aGluc3A6IHRoaW5zcCxcblx0dGhrYXA6IHRoa2FwLFxuXHR0aGtzaW06IHRoa3NpbSxcblx0VEhPUk46IFRIT1JOJDEsXG5cdHRob3JuOiB0aG9ybiQxLFxuXHR0aWxkZTogdGlsZGUsXG5cdFRpbGRlOiBUaWxkZSxcblx0VGlsZGVFcXVhbDogVGlsZGVFcXVhbCxcblx0VGlsZGVGdWxsRXF1YWw6IFRpbGRlRnVsbEVxdWFsLFxuXHRUaWxkZVRpbGRlOiBUaWxkZVRpbGRlLFxuXHR0aW1lc2JhcjogdGltZXNiYXIsXG5cdHRpbWVzYjogdGltZXNiLFxuXHR0aW1lczogdGltZXMkMSxcblx0dGltZXNkOiB0aW1lc2QsXG5cdHRpbnQ6IHRpbnQsXG5cdHRvZWE6IHRvZWEsXG5cdHRvcGJvdDogdG9wYm90LFxuXHR0b3BjaXI6IHRvcGNpcixcblx0dG9wOiB0b3AsXG5cdFRvcGY6IFRvcGYsXG5cdHRvcGY6IHRvcGYsXG5cdHRvcGZvcms6IHRvcGZvcmssXG5cdHRvc2E6IHRvc2EsXG5cdHRwcmltZTogdHByaW1lLFxuXHR0cmFkZTogdHJhZGUsXG5cdFRSQURFOiBUUkFERSxcblx0dHJpYW5nbGU6IHRyaWFuZ2xlLFxuXHR0cmlhbmdsZWRvd246IHRyaWFuZ2xlZG93bixcblx0dHJpYW5nbGVsZWZ0OiB0cmlhbmdsZWxlZnQsXG5cdHRyaWFuZ2xlbGVmdGVxOiB0cmlhbmdsZWxlZnRlcSxcblx0dHJpYW5nbGVxOiB0cmlhbmdsZXEsXG5cdHRyaWFuZ2xlcmlnaHQ6IHRyaWFuZ2xlcmlnaHQsXG5cdHRyaWFuZ2xlcmlnaHRlcTogdHJpYW5nbGVyaWdodGVxLFxuXHR0cmlkb3Q6IHRyaWRvdCxcblx0dHJpZTogdHJpZSxcblx0dHJpbWludXM6IHRyaW1pbnVzLFxuXHRUcmlwbGVEb3Q6IFRyaXBsZURvdCxcblx0dHJpcGx1czogdHJpcGx1cyxcblx0dHJpc2I6IHRyaXNiLFxuXHR0cml0aW1lOiB0cml0aW1lLFxuXHR0cnBleml1bTogdHJwZXppdW0sXG5cdFRzY3I6IFRzY3IsXG5cdHRzY3I6IHRzY3IsXG5cdFRTY3k6IFRTY3ksXG5cdHRzY3k6IHRzY3ksXG5cdFRTSGN5OiBUU0hjeSxcblx0dHNoY3k6IHRzaGN5LFxuXHRUc3Ryb2s6IFRzdHJvayxcblx0dHN0cm9rOiB0c3Ryb2ssXG5cdHR3aXh0OiB0d2l4dCxcblx0dHdvaGVhZGxlZnRhcnJvdzogdHdvaGVhZGxlZnRhcnJvdyxcblx0dHdvaGVhZHJpZ2h0YXJyb3c6IHR3b2hlYWRyaWdodGFycm93LFxuXHRVYWN1dGU6IFVhY3V0ZSQxLFxuXHR1YWN1dGU6IHVhY3V0ZSQxLFxuXHR1YXJyOiB1YXJyLFxuXHRVYXJyOiBVYXJyLFxuXHR1QXJyOiB1QXJyLFxuXHRVYXJyb2NpcjogVWFycm9jaXIsXG5cdFVicmN5OiBVYnJjeSxcblx0dWJyY3k6IHVicmN5LFxuXHRVYnJldmU6IFVicmV2ZSxcblx0dWJyZXZlOiB1YnJldmUsXG5cdFVjaXJjOiBVY2lyYyQxLFxuXHR1Y2lyYzogdWNpcmMkMSxcblx0VWN5OiBVY3ksXG5cdHVjeTogdWN5LFxuXHR1ZGFycjogdWRhcnIsXG5cdFVkYmxhYzogVWRibGFjLFxuXHR1ZGJsYWM6IHVkYmxhYyxcblx0dWRoYXI6IHVkaGFyLFxuXHR1ZmlzaHQ6IHVmaXNodCxcblx0VWZyOiBVZnIsXG5cdHVmcjogdWZyLFxuXHRVZ3JhdmU6IFVncmF2ZSQxLFxuXHR1Z3JhdmU6IHVncmF2ZSQxLFxuXHR1SGFyOiB1SGFyLFxuXHR1aGFybDogdWhhcmwsXG5cdHVoYXJyOiB1aGFycixcblx0dWhibGs6IHVoYmxrLFxuXHR1bGNvcm46IHVsY29ybixcblx0dWxjb3JuZXI6IHVsY29ybmVyLFxuXHR1bGNyb3A6IHVsY3JvcCxcblx0dWx0cmk6IHVsdHJpLFxuXHRVbWFjcjogVW1hY3IsXG5cdHVtYWNyOiB1bWFjcixcblx0dW1sOiB1bWwkMSxcblx0VW5kZXJCYXI6IFVuZGVyQmFyLFxuXHRVbmRlckJyYWNlOiBVbmRlckJyYWNlLFxuXHRVbmRlckJyYWNrZXQ6IFVuZGVyQnJhY2tldCxcblx0VW5kZXJQYXJlbnRoZXNpczogVW5kZXJQYXJlbnRoZXNpcyxcblx0VW5pb246IFVuaW9uLFxuXHRVbmlvblBsdXM6IFVuaW9uUGx1cyxcblx0VW9nb246IFVvZ29uLFxuXHR1b2dvbjogdW9nb24sXG5cdFVvcGY6IFVvcGYsXG5cdHVvcGY6IHVvcGYsXG5cdFVwQXJyb3dCYXI6IFVwQXJyb3dCYXIsXG5cdHVwYXJyb3c6IHVwYXJyb3csXG5cdFVwQXJyb3c6IFVwQXJyb3csXG5cdFVwYXJyb3c6IFVwYXJyb3csXG5cdFVwQXJyb3dEb3duQXJyb3c6IFVwQXJyb3dEb3duQXJyb3csXG5cdHVwZG93bmFycm93OiB1cGRvd25hcnJvdyxcblx0VXBEb3duQXJyb3c6IFVwRG93bkFycm93LFxuXHRVcGRvd25hcnJvdzogVXBkb3duYXJyb3csXG5cdFVwRXF1aWxpYnJpdW06IFVwRXF1aWxpYnJpdW0sXG5cdHVwaGFycG9vbmxlZnQ6IHVwaGFycG9vbmxlZnQsXG5cdHVwaGFycG9vbnJpZ2h0OiB1cGhhcnBvb25yaWdodCxcblx0dXBsdXM6IHVwbHVzLFxuXHRVcHBlckxlZnRBcnJvdzogVXBwZXJMZWZ0QXJyb3csXG5cdFVwcGVyUmlnaHRBcnJvdzogVXBwZXJSaWdodEFycm93LFxuXHR1cHNpOiB1cHNpLFxuXHRVcHNpOiBVcHNpLFxuXHR1cHNpaDogdXBzaWgsXG5cdFVwc2lsb246IFVwc2lsb24sXG5cdHVwc2lsb246IHVwc2lsb24sXG5cdFVwVGVlQXJyb3c6IFVwVGVlQXJyb3csXG5cdFVwVGVlOiBVcFRlZSxcblx0dXB1cGFycm93czogdXB1cGFycm93cyxcblx0dXJjb3JuOiB1cmNvcm4sXG5cdHVyY29ybmVyOiB1cmNvcm5lcixcblx0dXJjcm9wOiB1cmNyb3AsXG5cdFVyaW5nOiBVcmluZyxcblx0dXJpbmc6IHVyaW5nLFxuXHR1cnRyaTogdXJ0cmksXG5cdFVzY3I6IFVzY3IsXG5cdHVzY3I6IHVzY3IsXG5cdHV0ZG90OiB1dGRvdCxcblx0VXRpbGRlOiBVdGlsZGUsXG5cdHV0aWxkZTogdXRpbGRlLFxuXHR1dHJpOiB1dHJpLFxuXHR1dHJpZjogdXRyaWYsXG5cdHV1YXJyOiB1dWFycixcblx0VXVtbDogVXVtbCQxLFxuXHR1dW1sOiB1dW1sJDEsXG5cdHV3YW5nbGU6IHV3YW5nbGUsXG5cdHZhbmdydDogdmFuZ3J0LFxuXHR2YXJlcHNpbG9uOiB2YXJlcHNpbG9uLFxuXHR2YXJrYXBwYTogdmFya2FwcGEsXG5cdHZhcm5vdGhpbmc6IHZhcm5vdGhpbmcsXG5cdHZhcnBoaTogdmFycGhpLFxuXHR2YXJwaTogdmFycGksXG5cdHZhcnByb3B0bzogdmFycHJvcHRvLFxuXHR2YXJyOiB2YXJyLFxuXHR2QXJyOiB2QXJyLFxuXHR2YXJyaG86IHZhcnJobyxcblx0dmFyc2lnbWE6IHZhcnNpZ21hLFxuXHR2YXJzdWJzZXRuZXE6IHZhcnN1YnNldG5lcSxcblx0dmFyc3Vic2V0bmVxcTogdmFyc3Vic2V0bmVxcSxcblx0dmFyc3Vwc2V0bmVxOiB2YXJzdXBzZXRuZXEsXG5cdHZhcnN1cHNldG5lcXE6IHZhcnN1cHNldG5lcXEsXG5cdHZhcnRoZXRhOiB2YXJ0aGV0YSxcblx0dmFydHJpYW5nbGVsZWZ0OiB2YXJ0cmlhbmdsZWxlZnQsXG5cdHZhcnRyaWFuZ2xlcmlnaHQ6IHZhcnRyaWFuZ2xlcmlnaHQsXG5cdHZCYXI6IHZCYXIsXG5cdFZiYXI6IFZiYXIsXG5cdHZCYXJ2OiB2QmFydixcblx0VmN5OiBWY3ksXG5cdHZjeTogdmN5LFxuXHR2ZGFzaDogdmRhc2gsXG5cdHZEYXNoOiB2RGFzaCxcblx0VmRhc2g6IFZkYXNoLFxuXHRWRGFzaDogVkRhc2gsXG5cdFZkYXNobDogVmRhc2hsLFxuXHR2ZWViYXI6IHZlZWJhcixcblx0dmVlOiB2ZWUsXG5cdFZlZTogVmVlLFxuXHR2ZWVlcTogdmVlZXEsXG5cdHZlbGxpcDogdmVsbGlwLFxuXHR2ZXJiYXI6IHZlcmJhcixcblx0VmVyYmFyOiBWZXJiYXIsXG5cdHZlcnQ6IHZlcnQsXG5cdFZlcnQ6IFZlcnQsXG5cdFZlcnRpY2FsQmFyOiBWZXJ0aWNhbEJhcixcblx0VmVydGljYWxMaW5lOiBWZXJ0aWNhbExpbmUsXG5cdFZlcnRpY2FsU2VwYXJhdG9yOiBWZXJ0aWNhbFNlcGFyYXRvcixcblx0VmVydGljYWxUaWxkZTogVmVydGljYWxUaWxkZSxcblx0VmVyeVRoaW5TcGFjZTogVmVyeVRoaW5TcGFjZSxcblx0VmZyOiBWZnIsXG5cdHZmcjogdmZyLFxuXHR2bHRyaTogdmx0cmksXG5cdHZuc3ViOiB2bnN1Yixcblx0dm5zdXA6IHZuc3VwLFxuXHRWb3BmOiBWb3BmLFxuXHR2b3BmOiB2b3BmLFxuXHR2cHJvcDogdnByb3AsXG5cdHZydHJpOiB2cnRyaSxcblx0VnNjcjogVnNjcixcblx0dnNjcjogdnNjcixcblx0dnN1Ym5FOiB2c3VibkUsXG5cdHZzdWJuZTogdnN1Ym5lLFxuXHR2c3VwbkU6IHZzdXBuRSxcblx0dnN1cG5lOiB2c3VwbmUsXG5cdFZ2ZGFzaDogVnZkYXNoLFxuXHR2emlnemFnOiB2emlnemFnLFxuXHRXY2lyYzogV2NpcmMsXG5cdHdjaXJjOiB3Y2lyYyxcblx0d2VkYmFyOiB3ZWRiYXIsXG5cdHdlZGdlOiB3ZWRnZSxcblx0V2VkZ2U6IFdlZGdlLFxuXHR3ZWRnZXE6IHdlZGdlcSxcblx0d2VpZXJwOiB3ZWllcnAsXG5cdFdmcjogV2ZyLFxuXHR3ZnI6IHdmcixcblx0V29wZjogV29wZixcblx0d29wZjogd29wZixcblx0d3A6IHdwLFxuXHR3cjogd3IsXG5cdHdyZWF0aDogd3JlYXRoLFxuXHRXc2NyOiBXc2NyLFxuXHR3c2NyOiB3c2NyLFxuXHR4Y2FwOiB4Y2FwLFxuXHR4Y2lyYzogeGNpcmMsXG5cdHhjdXA6IHhjdXAsXG5cdHhkdHJpOiB4ZHRyaSxcblx0WGZyOiBYZnIsXG5cdHhmcjogeGZyLFxuXHR4aGFycjogeGhhcnIsXG5cdHhoQXJyOiB4aEFycixcblx0WGk6IFhpLFxuXHR4aTogeGksXG5cdHhsYXJyOiB4bGFycixcblx0eGxBcnI6IHhsQXJyLFxuXHR4bWFwOiB4bWFwLFxuXHR4bmlzOiB4bmlzLFxuXHR4b2RvdDogeG9kb3QsXG5cdFhvcGY6IFhvcGYsXG5cdHhvcGY6IHhvcGYsXG5cdHhvcGx1czogeG9wbHVzLFxuXHR4b3RpbWU6IHhvdGltZSxcblx0eHJhcnI6IHhyYXJyLFxuXHR4ckFycjogeHJBcnIsXG5cdFhzY3I6IFhzY3IsXG5cdHhzY3I6IHhzY3IsXG5cdHhzcWN1cDogeHNxY3VwLFxuXHR4dXBsdXM6IHh1cGx1cyxcblx0eHV0cmk6IHh1dHJpLFxuXHR4dmVlOiB4dmVlLFxuXHR4d2VkZ2U6IHh3ZWRnZSxcblx0WWFjdXRlOiBZYWN1dGUkMSxcblx0eWFjdXRlOiB5YWN1dGUkMSxcblx0WUFjeTogWUFjeSxcblx0eWFjeTogeWFjeSxcblx0WWNpcmM6IFljaXJjLFxuXHR5Y2lyYzogeWNpcmMsXG5cdFljeTogWWN5LFxuXHR5Y3k6IHljeSxcblx0eWVuOiB5ZW4kMSxcblx0WWZyOiBZZnIsXG5cdHlmcjogeWZyLFxuXHRZSWN5OiBZSWN5LFxuXHR5aWN5OiB5aWN5LFxuXHRZb3BmOiBZb3BmLFxuXHR5b3BmOiB5b3BmLFxuXHRZc2NyOiBZc2NyLFxuXHR5c2NyOiB5c2NyLFxuXHRZVWN5OiBZVWN5LFxuXHR5dWN5OiB5dWN5LFxuXHR5dW1sOiB5dW1sJDEsXG5cdFl1bWw6IFl1bWwsXG5cdFphY3V0ZTogWmFjdXRlLFxuXHR6YWN1dGU6IHphY3V0ZSxcblx0WmNhcm9uOiBaY2Fyb24sXG5cdHpjYXJvbjogemNhcm9uLFxuXHRaY3k6IFpjeSxcblx0emN5OiB6Y3ksXG5cdFpkb3Q6IFpkb3QsXG5cdHpkb3Q6IHpkb3QsXG5cdHplZXRyZjogemVldHJmLFxuXHRaZXJvV2lkdGhTcGFjZTogWmVyb1dpZHRoU3BhY2UsXG5cdFpldGE6IFpldGEsXG5cdHpldGE6IHpldGEsXG5cdHpmcjogemZyLFxuXHRaZnI6IFpmcixcblx0WkhjeTogWkhjeSxcblx0emhjeTogemhjeSxcblx0emlncmFycjogemlncmFycixcblx0em9wZjogem9wZixcblx0Wm9wZjogWm9wZixcblx0WnNjcjogWnNjcixcblx0enNjcjogenNjcixcblx0endqOiB6d2osXG5cdHp3bmo6IHp3bmpcbn07XG5cbnZhciBBYWN1dGUgPSBcIsOBXCI7XG52YXIgYWFjdXRlID0gXCLDoVwiO1xudmFyIEFjaXJjID0gXCLDglwiO1xudmFyIGFjaXJjID0gXCLDolwiO1xudmFyIGFjdXRlID0gXCLCtFwiO1xudmFyIEFFbGlnID0gXCLDhlwiO1xudmFyIGFlbGlnID0gXCLDplwiO1xudmFyIEFncmF2ZSA9IFwiw4BcIjtcbnZhciBhZ3JhdmUgPSBcIsOgXCI7XG52YXIgYW1wJDEgPSBcIiZcIjtcbnZhciBBTVAgPSBcIiZcIjtcbnZhciBBcmluZyA9IFwiw4VcIjtcbnZhciBhcmluZyA9IFwiw6VcIjtcbnZhciBBdGlsZGUgPSBcIsODXCI7XG52YXIgYXRpbGRlID0gXCLDo1wiO1xudmFyIEF1bWwgPSBcIsOEXCI7XG52YXIgYXVtbCA9IFwiw6RcIjtcbnZhciBicnZiYXIgPSBcIsKmXCI7XG52YXIgQ2NlZGlsID0gXCLDh1wiO1xudmFyIGNjZWRpbCA9IFwiw6dcIjtcbnZhciBjZWRpbCA9IFwiwrhcIjtcbnZhciBjZW50ID0gXCLColwiO1xudmFyIGNvcHkgPSBcIsKpXCI7XG52YXIgQ09QWSA9IFwiwqlcIjtcbnZhciBjdXJyZW4gPSBcIsKkXCI7XG52YXIgZGVnID0gXCLCsFwiO1xudmFyIGRpdmlkZSA9IFwiw7dcIjtcbnZhciBFYWN1dGUgPSBcIsOJXCI7XG52YXIgZWFjdXRlID0gXCLDqVwiO1xudmFyIEVjaXJjID0gXCLDilwiO1xudmFyIGVjaXJjID0gXCLDqlwiO1xudmFyIEVncmF2ZSA9IFwiw4hcIjtcbnZhciBlZ3JhdmUgPSBcIsOoXCI7XG52YXIgRVRIID0gXCLDkFwiO1xudmFyIGV0aCA9IFwiw7BcIjtcbnZhciBFdW1sID0gXCLDi1wiO1xudmFyIGV1bWwgPSBcIsOrXCI7XG52YXIgZnJhYzEyID0gXCLCvVwiO1xudmFyIGZyYWMxNCA9IFwiwrxcIjtcbnZhciBmcmFjMzQgPSBcIsK+XCI7XG52YXIgZ3QkMSA9IFwiPlwiO1xudmFyIEdUID0gXCI+XCI7XG52YXIgSWFjdXRlID0gXCLDjVwiO1xudmFyIGlhY3V0ZSA9IFwiw61cIjtcbnZhciBJY2lyYyA9IFwiw45cIjtcbnZhciBpY2lyYyA9IFwiw65cIjtcbnZhciBpZXhjbCA9IFwiwqFcIjtcbnZhciBJZ3JhdmUgPSBcIsOMXCI7XG52YXIgaWdyYXZlID0gXCLDrFwiO1xudmFyIGlxdWVzdCA9IFwiwr9cIjtcbnZhciBJdW1sID0gXCLDj1wiO1xudmFyIGl1bWwgPSBcIsOvXCI7XG52YXIgbGFxdW8gPSBcIsKrXCI7XG52YXIgbHQkMSA9IFwiPFwiO1xudmFyIExUID0gXCI8XCI7XG52YXIgbWFjciA9IFwiwq9cIjtcbnZhciBtaWNybyA9IFwiwrVcIjtcbnZhciBtaWRkb3QgPSBcIsK3XCI7XG52YXIgbmJzcCA9IFwiwqBcIjtcbnZhciBub3QgPSBcIsKsXCI7XG52YXIgTnRpbGRlID0gXCLDkVwiO1xudmFyIG50aWxkZSA9IFwiw7FcIjtcbnZhciBPYWN1dGUgPSBcIsOTXCI7XG52YXIgb2FjdXRlID0gXCLDs1wiO1xudmFyIE9jaXJjID0gXCLDlFwiO1xudmFyIG9jaXJjID0gXCLDtFwiO1xudmFyIE9ncmF2ZSA9IFwiw5JcIjtcbnZhciBvZ3JhdmUgPSBcIsOyXCI7XG52YXIgb3JkZiA9IFwiwqpcIjtcbnZhciBvcmRtID0gXCLCulwiO1xudmFyIE9zbGFzaCA9IFwiw5hcIjtcbnZhciBvc2xhc2ggPSBcIsO4XCI7XG52YXIgT3RpbGRlID0gXCLDlVwiO1xudmFyIG90aWxkZSA9IFwiw7VcIjtcbnZhciBPdW1sID0gXCLDllwiO1xudmFyIG91bWwgPSBcIsO2XCI7XG52YXIgcGFyYSA9IFwiwrZcIjtcbnZhciBwbHVzbW4gPSBcIsKxXCI7XG52YXIgcG91bmQgPSBcIsKjXCI7XG52YXIgcXVvdCQxID0gXCJcXFwiXCI7XG52YXIgUVVPVCA9IFwiXFxcIlwiO1xudmFyIHJhcXVvID0gXCLCu1wiO1xudmFyIHJlZyA9IFwiwq5cIjtcbnZhciBSRUcgPSBcIsKuXCI7XG52YXIgc2VjdCA9IFwiwqdcIjtcbnZhciBzaHkgPSBcIsKtXCI7XG52YXIgc3VwMSA9IFwiwrlcIjtcbnZhciBzdXAyID0gXCLCslwiO1xudmFyIHN1cDMgPSBcIsKzXCI7XG52YXIgc3psaWcgPSBcIsOfXCI7XG52YXIgVEhPUk4gPSBcIsOeXCI7XG52YXIgdGhvcm4gPSBcIsO+XCI7XG52YXIgdGltZXMgPSBcIsOXXCI7XG52YXIgVWFjdXRlID0gXCLDmlwiO1xudmFyIHVhY3V0ZSA9IFwiw7pcIjtcbnZhciBVY2lyYyA9IFwiw5tcIjtcbnZhciB1Y2lyYyA9IFwiw7tcIjtcbnZhciBVZ3JhdmUgPSBcIsOZXCI7XG52YXIgdWdyYXZlID0gXCLDuVwiO1xudmFyIHVtbCA9IFwiwqhcIjtcbnZhciBVdW1sID0gXCLDnFwiO1xudmFyIHV1bWwgPSBcIsO8XCI7XG52YXIgWWFjdXRlID0gXCLDnVwiO1xudmFyIHlhY3V0ZSA9IFwiw71cIjtcbnZhciB5ZW4gPSBcIsKlXCI7XG52YXIgeXVtbCA9IFwiw79cIjtcbnZhciByZXF1aXJlJCQxID0ge1xuXHRBYWN1dGU6IEFhY3V0ZSxcblx0YWFjdXRlOiBhYWN1dGUsXG5cdEFjaXJjOiBBY2lyYyxcblx0YWNpcmM6IGFjaXJjLFxuXHRhY3V0ZTogYWN1dGUsXG5cdEFFbGlnOiBBRWxpZyxcblx0YWVsaWc6IGFlbGlnLFxuXHRBZ3JhdmU6IEFncmF2ZSxcblx0YWdyYXZlOiBhZ3JhdmUsXG5cdGFtcDogYW1wJDEsXG5cdEFNUDogQU1QLFxuXHRBcmluZzogQXJpbmcsXG5cdGFyaW5nOiBhcmluZyxcblx0QXRpbGRlOiBBdGlsZGUsXG5cdGF0aWxkZTogYXRpbGRlLFxuXHRBdW1sOiBBdW1sLFxuXHRhdW1sOiBhdW1sLFxuXHRicnZiYXI6IGJydmJhcixcblx0Q2NlZGlsOiBDY2VkaWwsXG5cdGNjZWRpbDogY2NlZGlsLFxuXHRjZWRpbDogY2VkaWwsXG5cdGNlbnQ6IGNlbnQsXG5cdGNvcHk6IGNvcHksXG5cdENPUFk6IENPUFksXG5cdGN1cnJlbjogY3VycmVuLFxuXHRkZWc6IGRlZyxcblx0ZGl2aWRlOiBkaXZpZGUsXG5cdEVhY3V0ZTogRWFjdXRlLFxuXHRlYWN1dGU6IGVhY3V0ZSxcblx0RWNpcmM6IEVjaXJjLFxuXHRlY2lyYzogZWNpcmMsXG5cdEVncmF2ZTogRWdyYXZlLFxuXHRlZ3JhdmU6IGVncmF2ZSxcblx0RVRIOiBFVEgsXG5cdGV0aDogZXRoLFxuXHRFdW1sOiBFdW1sLFxuXHRldW1sOiBldW1sLFxuXHRmcmFjMTI6IGZyYWMxMixcblx0ZnJhYzE0OiBmcmFjMTQsXG5cdGZyYWMzNDogZnJhYzM0LFxuXHRndDogZ3QkMSxcblx0R1Q6IEdULFxuXHRJYWN1dGU6IElhY3V0ZSxcblx0aWFjdXRlOiBpYWN1dGUsXG5cdEljaXJjOiBJY2lyYyxcblx0aWNpcmM6IGljaXJjLFxuXHRpZXhjbDogaWV4Y2wsXG5cdElncmF2ZTogSWdyYXZlLFxuXHRpZ3JhdmU6IGlncmF2ZSxcblx0aXF1ZXN0OiBpcXVlc3QsXG5cdEl1bWw6IEl1bWwsXG5cdGl1bWw6IGl1bWwsXG5cdGxhcXVvOiBsYXF1byxcblx0bHQ6IGx0JDEsXG5cdExUOiBMVCxcblx0bWFjcjogbWFjcixcblx0bWljcm86IG1pY3JvLFxuXHRtaWRkb3Q6IG1pZGRvdCxcblx0bmJzcDogbmJzcCxcblx0bm90OiBub3QsXG5cdE50aWxkZTogTnRpbGRlLFxuXHRudGlsZGU6IG50aWxkZSxcblx0T2FjdXRlOiBPYWN1dGUsXG5cdG9hY3V0ZTogb2FjdXRlLFxuXHRPY2lyYzogT2NpcmMsXG5cdG9jaXJjOiBvY2lyYyxcblx0T2dyYXZlOiBPZ3JhdmUsXG5cdG9ncmF2ZTogb2dyYXZlLFxuXHRvcmRmOiBvcmRmLFxuXHRvcmRtOiBvcmRtLFxuXHRPc2xhc2g6IE9zbGFzaCxcblx0b3NsYXNoOiBvc2xhc2gsXG5cdE90aWxkZTogT3RpbGRlLFxuXHRvdGlsZGU6IG90aWxkZSxcblx0T3VtbDogT3VtbCxcblx0b3VtbDogb3VtbCxcblx0cGFyYTogcGFyYSxcblx0cGx1c21uOiBwbHVzbW4sXG5cdHBvdW5kOiBwb3VuZCxcblx0cXVvdDogcXVvdCQxLFxuXHRRVU9UOiBRVU9ULFxuXHRyYXF1bzogcmFxdW8sXG5cdHJlZzogcmVnLFxuXHRSRUc6IFJFRyxcblx0c2VjdDogc2VjdCxcblx0c2h5OiBzaHksXG5cdHN1cDE6IHN1cDEsXG5cdHN1cDI6IHN1cDIsXG5cdHN1cDM6IHN1cDMsXG5cdHN6bGlnOiBzemxpZyxcblx0VEhPUk46IFRIT1JOLFxuXHR0aG9ybjogdGhvcm4sXG5cdHRpbWVzOiB0aW1lcyxcblx0VWFjdXRlOiBVYWN1dGUsXG5cdHVhY3V0ZTogdWFjdXRlLFxuXHRVY2lyYzogVWNpcmMsXG5cdHVjaXJjOiB1Y2lyYyxcblx0VWdyYXZlOiBVZ3JhdmUsXG5cdHVncmF2ZTogdWdyYXZlLFxuXHR1bWw6IHVtbCxcblx0VXVtbDogVXVtbCxcblx0dXVtbDogdXVtbCxcblx0WWFjdXRlOiBZYWN1dGUsXG5cdHlhY3V0ZTogeWFjdXRlLFxuXHR5ZW46IHllbixcblx0eXVtbDogeXVtbFxufTtcblxudmFyIGFtcCA9IFwiJlwiO1xudmFyIGFwb3MgPSBcIidcIjtcbnZhciBndCA9IFwiPlwiO1xudmFyIGx0ID0gXCI8XCI7XG52YXIgcXVvdCA9IFwiXFxcIlwiO1xudmFyIHJlcXVpcmUkJDAkMSA9IHtcblx0YW1wOiBhbXAsXG5cdGFwb3M6IGFwb3MsXG5cdGd0OiBndCxcblx0bHQ6IGx0LFxuXHRxdW90OiBxdW90XG59O1xuXG52YXIgZGVjb2RlX2NvZGVwb2ludCA9IHt9O1xuXG52YXIgcmVxdWlyZSQkMCA9IHtcblx0XCIwXCI6IDY1NTMzLFxuXHRcIjEyOFwiOiA4MzY0LFxuXHRcIjEzMFwiOiA4MjE4LFxuXHRcIjEzMVwiOiA0MDIsXG5cdFwiMTMyXCI6IDgyMjIsXG5cdFwiMTMzXCI6IDgyMzAsXG5cdFwiMTM0XCI6IDgyMjQsXG5cdFwiMTM1XCI6IDgyMjUsXG5cdFwiMTM2XCI6IDcxMCxcblx0XCIxMzdcIjogODI0MCxcblx0XCIxMzhcIjogMzUyLFxuXHRcIjEzOVwiOiA4MjQ5LFxuXHRcIjE0MFwiOiAzMzgsXG5cdFwiMTQyXCI6IDM4MSxcblx0XCIxNDVcIjogODIxNixcblx0XCIxNDZcIjogODIxNyxcblx0XCIxNDdcIjogODIyMCxcblx0XCIxNDhcIjogODIyMSxcblx0XCIxNDlcIjogODIyNixcblx0XCIxNTBcIjogODIxMSxcblx0XCIxNTFcIjogODIxMixcblx0XCIxNTJcIjogNzMyLFxuXHRcIjE1M1wiOiA4NDgyLFxuXHRcIjE1NFwiOiAzNTMsXG5cdFwiMTU1XCI6IDgyNTAsXG5cdFwiMTU2XCI6IDMzOSxcblx0XCIxNThcIjogMzgyLFxuXHRcIjE1OVwiOiAzNzZcbn07XG5cbnZhciBfX2ltcG9ydERlZmF1bHQkMiA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZGVjb2RlX2NvZGVwb2ludCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGVjb2RlX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdCQyKHJlcXVpcmUkJDApO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL2hlL2Jsb2IvbWFzdGVyL3NyYy9oZS5qcyNMOTQtTDExOVxudmFyIGZyb21Db2RlUG9pbnQkMiA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cblN0cmluZy5mcm9tQ29kZVBvaW50IHx8XG4gICAgZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4ZmZmZikge1xuICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4ZGMwMCB8IChjb2RlUG9pbnQgJiAweDNmZik7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuICAgIGlmICgoY29kZVBvaW50ID49IDB4ZDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhkZmZmKSB8fCBjb2RlUG9pbnQgPiAweDEwZmZmZikge1xuICAgICAgICByZXR1cm4gXCJcXHVGRkZEXCI7XG4gICAgfVxuICAgIGlmIChjb2RlUG9pbnQgaW4gZGVjb2RlX2pzb25fMS5kZWZhdWx0KSB7XG4gICAgICAgIGNvZGVQb2ludCA9IGRlY29kZV9qc29uXzEuZGVmYXVsdFtjb2RlUG9pbnRdO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludCQyKGNvZGVQb2ludCk7XG59XG5kZWNvZGVfY29kZXBvaW50LmRlZmF1bHQgPSBkZWNvZGVDb2RlUG9pbnQ7XG5cbnZhciBfX2ltcG9ydERlZmF1bHQkMSA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZGVjb2RlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmRlY29kZS5kZWNvZGVIVE1MID0gZGVjb2RlLmRlY29kZUhUTUxTdHJpY3QgPSBkZWNvZGUuZGVjb2RlWE1MID0gdm9pZCAwO1xudmFyIGVudGl0aWVzX2pzb25fMSQxID0gX19pbXBvcnREZWZhdWx0JDEocmVxdWlyZSQkMSQxKTtcbnZhciBsZWdhY3lfanNvbl8xID0gX19pbXBvcnREZWZhdWx0JDEocmVxdWlyZSQkMSk7XG52YXIgeG1sX2pzb25fMSQxID0gX19pbXBvcnREZWZhdWx0JDEocmVxdWlyZSQkMCQxKTtcbnZhciBkZWNvZGVfY29kZXBvaW50XzEgPSBfX2ltcG9ydERlZmF1bHQkMShkZWNvZGVfY29kZXBvaW50KTtcbnZhciBzdHJpY3RFbnRpdHlSZSA9IC8mKD86W2EtekEtWjAtOV0rfCNbeFhdW1xcZGEtZkEtRl0rfCNcXGQrKTsvZztcbmRlY29kZS5kZWNvZGVYTUwgPSBnZXRTdHJpY3REZWNvZGVyKHhtbF9qc29uXzEkMS5kZWZhdWx0KTtcbmRlY29kZS5kZWNvZGVIVE1MU3RyaWN0ID0gZ2V0U3RyaWN0RGVjb2RlcihlbnRpdGllc19qc29uXzEkMS5kZWZhdWx0KTtcbmZ1bmN0aW9uIGdldFN0cmljdERlY29kZXIobWFwKSB7XG4gICAgdmFyIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihtYXApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHN0cmljdEVudGl0eVJlLCByZXBsYWNlKTsgfTtcbn1cbnZhciBzb3J0ZXIgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPCBiID8gMSA6IC0xKTsgfTtcbmRlY29kZS5kZWNvZGVIVE1MID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVnYWN5ID0gT2JqZWN0LmtleXMobGVnYWN5X2pzb25fMS5kZWZhdWx0KS5zb3J0KHNvcnRlcik7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbnRpdGllc19qc29uXzEkMS5kZWZhdWx0KS5zb3J0KHNvcnRlcik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGVnYWN5W2pdID09PSBrZXlzW2ldKSB7XG4gICAgICAgICAgICBrZXlzW2ldICs9IFwiOz9cIjtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIiYoPzpcIiArIGtleXMuam9pbihcInxcIikgKyBcInwjW3hYXVtcXFxcZGEtZkEtRl0rOz98I1xcXFxkKzs/KVwiLCBcImdcIik7XG4gICAgdmFyIHJlcGxhY2UgPSBnZXRSZXBsYWNlcihlbnRpdGllc19qc29uXzEkMS5kZWZhdWx0KTtcbiAgICBmdW5jdGlvbiByZXBsYWNlcihzdHIpIHtcbiAgICAgICAgaWYgKHN0ci5zdWJzdHIoLTEpICE9PSBcIjtcIilcbiAgICAgICAgICAgIHN0ciArPSBcIjtcIjtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2Uoc3RyKTtcbiAgICB9XG4gICAgLy8gVE9ETyBjb25zaWRlciBjcmVhdGluZyBhIG1lcmdlZCBtYXBcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShyZSwgcmVwbGFjZXIpOyB9O1xufSkoKTtcbmZ1bmN0aW9uIGdldFJlcGxhY2VyKG1hcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgxKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRDaGFyID0gc3RyLmNoYXJBdCgyKTtcbiAgICAgICAgICAgIGlmIChzZWNvbmRDaGFyID09PSBcIlhcIiB8fCBzZWNvbmRDaGFyID09PSBcInhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVfY29kZXBvaW50XzEuZGVmYXVsdChwYXJzZUludChzdHIuc3Vic3RyKDMpLCAxNikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlSW50KHN0ci5zdWJzdHIoMiksIDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgIHJldHVybiBtYXBbc3RyLnNsaWNlKDEsIC0xKV0gfHwgc3RyO1xuICAgIH07XG59XG5cbnZhciBlbmNvZGUgPSB7fTtcblxudmFyIF9faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW5jb2RlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmVuY29kZS5lc2NhcGVVVEY4ID0gZW5jb2RlLmVzY2FwZSA9IGVuY29kZS5lbmNvZGVOb25Bc2NpaUhUTUwgPSBlbmNvZGUuZW5jb2RlSFRNTCA9IGVuY29kZS5lbmNvZGVYTUwgPSB2b2lkIDA7XG52YXIgeG1sX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlJCQwJDEpO1xudmFyIGludmVyc2VYTUwgPSBnZXRJbnZlcnNlT2JqKHhtbF9qc29uXzEuZGVmYXVsdCk7XG52YXIgeG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZVhNTCk7XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTFxuICogZG9jdW1lbnRzIHVzaW5nIFhNTCBlbnRpdGllcy5cbiAqXG4gKiBJZiBhIGNoYXJhY3RlciBoYXMgbm8gZXF1aXZhbGVudCBlbnRpdHksIGFcbiAqIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApIHdpbGwgYmUgdXNlZC5cbiAqL1xuZW5jb2RlLmVuY29kZVhNTCA9IGdldEFTQ0lJRW5jb2RlcihpbnZlcnNlWE1MKTtcbnZhciBlbnRpdGllc19qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZSQkMSQxKTtcbnZhciBpbnZlcnNlSFRNTCA9IGdldEludmVyc2VPYmooZW50aXRpZXNfanNvbl8xLmRlZmF1bHQpO1xudmFyIGh0bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlSFRNTCk7XG4vKipcbiAqIEVuY29kZXMgYWxsIGVudGl0aWVzIGFuZCBub24tQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQuXG4gKlxuICogVGhpcyBpbmNsdWRlcyBjaGFyYWN0ZXJzIHRoYXQgYXJlIHZhbGlkIEFTQ0lJIGNoYXJhY3RlcnMgaW4gSFRNTCBkb2N1bWVudHMuXG4gKiBGb3IgZXhhbXBsZSBgI2Agd2lsbCBiZSBlbmNvZGVkIGFzIGAmbnVtO2AuIFRvIGdldCBhIG1vcmUgY29tcGFjdCBvdXRwdXQsXG4gKiBjb25zaWRlciB1c2luZyB0aGUgYGVuY29kZU5vbkFzY2lpSFRNTGAgZnVuY3Rpb24uXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhXG4gKiBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmVuY29kZS5lbmNvZGVIVE1MID0gZ2V0SW52ZXJzZShpbnZlcnNlSFRNTCwgaHRtbFJlcGxhY2VyKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gSFRNTFxuICogZG9jdW1lbnRzIHVzaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogSWYgYSBjaGFyYWN0ZXIgaGFzIG5vIGVxdWl2YWxlbnQgZW50aXR5LCBhXG4gKiBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKSB3aWxsIGJlIHVzZWQuXG4gKi9cbmVuY29kZS5lbmNvZGVOb25Bc2NpaUhUTUwgPSBnZXRBU0NJSUVuY29kZXIoaW52ZXJzZUhUTUwpO1xuZnVuY3Rpb24gZ2V0SW52ZXJzZU9iaihvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGludmVyc2UsIG5hbWUpIHtcbiAgICAgICAgaW52ZXJzZVtvYmpbbmFtZV1dID0gXCImXCIgKyBuYW1lICsgXCI7XCI7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlKSB7XG4gICAgdmFyIHNpbmdsZSA9IFtdO1xuICAgIHZhciBtdWx0aXBsZSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhpbnZlcnNlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgIGlmIChrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gQWRkIHZhbHVlIHRvIHNpbmdsZSBhcnJheVxuICAgICAgICAgICAgc2luZ2xlLnB1c2goXCJcXFxcXCIgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBtdWx0aXBsZSBhcnJheVxuICAgICAgICAgICAgbXVsdGlwbGUucHVzaChrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgcmFuZ2VzIHRvIHNpbmdsZSBjaGFyYWN0ZXJzLlxuICAgIHNpbmdsZS5zb3J0KCk7XG4gICAgZm9yICh2YXIgc3RhcnQgPSAwOyBzdGFydCA8IHNpbmdsZS5sZW5ndGggLSAxOyBzdGFydCsrKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiBhIHJ1biBvZiBjaGFyYWN0ZXJzXG4gICAgICAgIHZhciBlbmQgPSBzdGFydDtcbiAgICAgICAgd2hpbGUgKGVuZCA8IHNpbmdsZS5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICBzaW5nbGVbZW5kXS5jaGFyQ29kZUF0KDEpICsgMSA9PT0gc2luZ2xlW2VuZCArIDFdLmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgICAgIGVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3VudCA9IDEgKyBlbmQgLSBzdGFydDtcbiAgICAgICAgLy8gV2Ugd2FudCB0byByZXBsYWNlIGF0IGxlYXN0IHRocmVlIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKGNvdW50IDwgMylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzaW5nbGUuc3BsaWNlKHN0YXJ0LCBjb3VudCwgc2luZ2xlW3N0YXJ0XSArIFwiLVwiICsgc2luZ2xlW2VuZF0pO1xuICAgIH1cbiAgICBtdWx0aXBsZS51bnNoaWZ0KFwiW1wiICsgc2luZ2xlLmpvaW4oXCJcIikgKyBcIl1cIik7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAobXVsdGlwbGUuam9pbihcInxcIiksIFwiZ1wiKTtcbn1cbi8vIC9bXlxcMC1cXHg3Rl0vZ3VcbnZhciByZU5vbkFTQ0lJID0gLyg/OltcXHg4MC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS9nO1xudmFyIGdldENvZGVQb2ludCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cblN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQgIT0gbnVsbFxuICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLmNvZGVQb2ludEF0KDApOyB9XG4gICAgOiAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIChjLmNoYXJDb2RlQXQoMCkgLSAweGQ4MDApICogMHg0MDAgK1xuICAgICAgICAgICAgICAgIGMuY2hhckNvZGVBdCgxKSAtXG4gICAgICAgICAgICAgICAgMHhkYzAwICtcbiAgICAgICAgICAgICAgICAweDEwMDAwO1xuICAgICAgICB9O1xuZnVuY3Rpb24gc2luZ2xlQ2hhclJlcGxhY2VyKGMpIHtcbiAgICByZXR1cm4gXCImI3hcIiArIChjLmxlbmd0aCA+IDEgPyBnZXRDb2RlUG9pbnQoYykgOiBjLmNoYXJDb2RlQXQoMCkpXG4gICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgLnRvVXBwZXJDYXNlKCkgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIGdldEludmVyc2UoaW52ZXJzZSwgcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gaW52ZXJzZVtuYW1lXTsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlTm9uQVNDSUksIHNpbmdsZUNoYXJSZXBsYWNlcik7XG4gICAgfTtcbn1cbnZhciByZUVzY2FwZUNoYXJzID0gbmV3IFJlZ0V4cCh4bWxSZXBsYWNlci5zb3VyY2UgKyBcInxcIiArIHJlTm9uQVNDSUkuc291cmNlLCBcImdcIik7XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTFxuICogZG9jdW1lbnRzIHVzaW5nIG51bWVyaWMgaGV4YWRlY2ltYWwgcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApLlxuICpcbiAqIEhhdmUgYSBsb29rIGF0IGBlc2NhcGVVVEY4YCBpZiB5b3Ugd2FudCBhIG1vcmUgY29uY2lzZSBvdXRwdXQgYXQgdGhlIGV4cGVuc2VcbiAqIG9mIHJlZHVjZWQgdHJhbnNwb3J0YWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZXNjYXBlLlxuICovXG5mdW5jdGlvbiBlc2NhcGUoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UocmVFc2NhcGVDaGFycywgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbn1cbmVuY29kZS5lc2NhcGUgPSBlc2NhcGU7XG4vKipcbiAqIEVuY29kZXMgYWxsIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTCBkb2N1bWVudHMgdXNpbmcgbnVtZXJpYyBoZXhhZGVjaW1hbFxuICogcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb3V0cHV0IHdpbGwgYmUgY2hhcmFjdGVyLXNldCBkZXBlbmRlbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVVRGOChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSh4bWxSZXBsYWNlciwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbn1cbmVuY29kZS5lc2NhcGVVVEY4ID0gZXNjYXBlVVRGODtcbmZ1bmN0aW9uIGdldEFTQ0lJRW5jb2RlcihvYmopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gb2JqW2NdIHx8IHNpbmdsZUNoYXJSZXBsYWNlcihjKTsgfSk7XG4gICAgfTtcbn1cblxuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDVTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw0U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNSA9IGV4cG9ydHMuZGVjb2RlSFRNTDQgPSBleHBvcnRzLmRlY29kZUhUTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUwgPSBleHBvcnRzLmRlY29kZVhNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTDUgPSBleHBvcnRzLmVuY29kZUhUTUw0ID0gZXhwb3J0cy5lc2NhcGVVVEY4ID0gZXhwb3J0cy5lc2NhcGUgPSBleHBvcnRzLmVuY29kZU5vbkFzY2lpSFRNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTCA9IGV4cG9ydHMuZW5jb2RlWE1MID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZVN0cmljdCA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xudmFyIGRlY29kZV8xID0gZGVjb2RlO1xudmFyIGVuY29kZV8xID0gZW5jb2RlO1xuLyoqXG4gKiBEZWNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBsZXZlbCBPcHRpb25hbCBsZXZlbCB0byBkZWNvZGUgYXQuIDAgPSBYTUwsIDEgPSBIVE1MLiBEZWZhdWx0IGlzIDAuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZVhNTGAgb3IgYGRlY29kZUhUTUxgIGRpcmVjdGx5LlxuICovXG5mdW5jdGlvbiBkZWNvZGUkMShkYXRhLCBsZXZlbCkge1xuICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGVfMS5kZWNvZGVYTUwgOiBkZWNvZGVfMS5kZWNvZGVIVE1MKShkYXRhKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlJDE7XG4vKipcbiAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy4gRG9lcyBub3QgYWxsb3cgbWlzc2luZyB0cmFpbGluZyBzZW1pY29sb25zIGZvciBlbnRpdGllcy5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTdHJpbmcgdG8gZGVjb2RlLlxuICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlSFRNTFN0cmljdGAgb3IgYGRlY29kZVhNTGAgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVN0cmljdChkYXRhLCBsZXZlbCkge1xuICAgIHJldHVybiAoIWxldmVsIHx8IGxldmVsIDw9IDAgPyBkZWNvZGVfMS5kZWNvZGVYTUwgOiBkZWNvZGVfMS5kZWNvZGVIVE1MU3RyaWN0KShkYXRhKTtcbn1cbmV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZGVjb2RlU3RyaWN0O1xuLyoqXG4gKiBFbmNvZGVzIGEgc3RyaW5nIHdpdGggZW50aXRpZXMuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBsZXZlbCBPcHRpb25hbCBsZXZlbCB0byBlbmNvZGUgYXQuIDAgPSBYTUwsIDEgPSBIVE1MLiBEZWZhdWx0IGlzIDAuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGVuY29kZUhUTUxgLCBgZW5jb2RlWE1MYCBvciBgZW5jb2RlTm9uQXNjaWlIVE1MYCBkaXJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlJDEoZGF0YSwgbGV2ZWwpIHtcbiAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZW5jb2RlXzEuZW5jb2RlWE1MIDogZW5jb2RlXzEuZW5jb2RlSFRNTCkoZGF0YSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZSQxO1xudmFyIGVuY29kZV8yID0gZW5jb2RlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlWE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVYTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlTm9uQXNjaWlIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVOb25Bc2NpaUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVzY2FwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVzY2FwZVVURjhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVzY2FwZVVURjg7IH0gfSk7XG4vLyBMZWdhY3kgYWxpYXNlcyAoZGVwcmVjYXRlZClcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlSFRNTDVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG52YXIgZGVjb2RlXzIgPSBkZWNvZGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVYTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZVhNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuLy8gTGVnYWN5IGFsaWFzZXMgKGRlcHJlY2F0ZWQpXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTDRTdHJpY3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZV8yLmRlY29kZUhUTUxTdHJpY3Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MNVN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTFN0cmljdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlWE1MOyB9IH0pO1xufShsaWIpKTtcblxudmFyIEVOVElUWSA9ICcmKD86I3hbYS1mMC05XXsxLDZ9fCNbMC05XXsxLDd9fFthLXpdW2EtejAtOV17MSwzMX0pOyc7XG52YXIgQ19CQUNLU0xBU0gkMSA9IDkyO1xudmFyIHJlQmFja3NsYXNoT3JBbXAgPSAvW1xcXFwmXS87XG52YXIgRVNDQVBBQkxFID0gJ1shXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXFxcXFxcXFxcXFxcXV5fYHt8fX4tXSc7XG52YXIgcmVFbnRpdHlPckVzY2FwZWRDaGFyID0gbmV3IFJlZ0V4cChcIlxcXFxcXFxcXCIgKyBFU0NBUEFCTEUgKyBcInxcIiArIEVOVElUWSwgJ2dpJyk7XG52YXIgWE1MU1BFQ0lBTCA9ICdbJjw+XCJdJztcbnZhciByZVhtbFNwZWNpYWwgPSBuZXcgUmVnRXhwKFhNTFNQRUNJQUwsICdnJyk7XG52YXIgdW5lc2NhcGVDaGFyID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KDApID09PSBDX0JBQ0tTTEFTSCQxKSB7XG4gICAgICAgIHJldHVybiBzLmNoYXJBdCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpYi5kZWNvZGVIVE1MKHMpO1xufTtcbi8vIFJlcGxhY2UgZW50aXRpZXMgYW5kIGJhY2tzbGFzaCBlc2NhcGVzIHdpdGggbGl0ZXJhbCBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdW5lc2NhcGVTdHJpbmcocykge1xuICAgIGlmIChyZUJhY2tzbGFzaE9yQW1wLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyZUVudGl0eU9yRXNjYXBlZENoYXIsIHVuZXNjYXBlQ2hhcik7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVVJJKHVyaSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVfMSh1cmkpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnJmFtcDsnO1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgIHJldHVybiAnJmx0Oyc7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgcmV0dXJuICcmcXVvdDsnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlWG1sKHMpIHtcbiAgICBpZiAocmVYbWxTcGVjaWFsLnRlc3QocykpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyZVhtbFNwZWNpYWwsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiByZXBlYXQoc3RyLCBjb3VudCkge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2goc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5qb2luKCcnKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHkoc3RyKSB7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhL1teIFxcdF0rLy50ZXN0KHN0cik7XG59XG5cbnZhciBOb2RlV2Fsa2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGVXYWxrZXIocm9vdCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSByb290O1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLmVudGVyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgTm9kZVdhbGtlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gdGhpcy5lbnRlcmluZztcbiAgICAgICAgaWYgKGN1ciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGlzQ29udGFpbmVyJDEoY3VyKTtcbiAgICAgICAgaWYgKGVudGVyaW5nICYmIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGN1ci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF5IG9uIG5vZGUgYnV0IGV4aXRcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIubmV4dDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVudGVyaW5nOiBlbnRlcmluZywgbm9kZTogY3VyIH07XG4gICAgfTtcbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5yZXN1bWVBdCA9IGZ1bmN0aW9uIChub2RlLCBlbnRlcmluZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICB0aGlzLmVudGVyaW5nID0gZW50ZXJpbmcgPT09IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZVdhbGtlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlzQ29udGFpbmVyJDEobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAnYmxvY2tRdW90ZSc6XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlSGVhZCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQm9keSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlUm93JzpcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgY2FzZSAndGFibGVEZWxpbVJvdyc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG52YXIgbGFzdE5vZGVJZCA9IDE7XG52YXIgbm9kZU1hcCA9IHt9O1xuZnVuY3Rpb24gZ2V0Tm9kZUJ5SWQoaWQpIHtcbiAgICByZXR1cm4gbm9kZU1hcFtpZF07XG59XG5mdW5jdGlvbiByZW1vdmVOb2RlQnlJZChpZCkge1xuICAgIGRlbGV0ZSBub2RlTWFwW2lkXTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUFsbE5vZGUoKSB7XG4gICAgbm9kZU1hcCA9IHt9O1xufVxudmFyIE5vZGUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKG5vZGVUeXBlLCBzb3VyY2Vwb3MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICAvLyBvbmx5IGZvciBjb250YWluZXIgbm9kZVxuICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIC8vIG9ubHkgZm9yIGxlYWYgbm9kZVxuICAgICAgICB0aGlzLmxpdGVyYWwgPSBudWxsO1xuICAgICAgICBpZiAobm9kZVR5cGUgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBsYXN0Tm9kZUlkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gbm9kZVR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlcG9zID0gc291cmNlcG9zO1xuICAgICAgICBub2RlTWFwW3RoaXMuaWRdID0gdGhpcztcbiAgICB9XG4gICAgTm9kZS5wcm90b3R5cGUuaXNDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnRhaW5lciQxKHRoaXMpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2KSB7XG4gICAgICAgICAgICB0aGlzLnByZXYubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZmlyc3RDaGlsZCA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQucHJldiA9IHRoaXMucHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubGFzdENoaWxkID0gdGhpcy5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIHRoaXMudW5saW5rKCk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChzaWJsaW5nKSB7XG4gICAgICAgIHNpYmxpbmcudW5saW5rKCk7XG4gICAgICAgIHNpYmxpbmcubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKHNpYmxpbmcubmV4dCkge1xuICAgICAgICAgICAgc2libGluZy5uZXh0LnByZXYgPSBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHNpYmxpbmcucHJldiA9IHRoaXM7XG4gICAgICAgIHRoaXMubmV4dCA9IHNpYmxpbmc7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIGlmICghc2libGluZy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgc2libGluZy5wYXJlbnQubGFzdENoaWxkID0gc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgc2libGluZy51bmxpbmsoKTtcbiAgICAgICAgc2libGluZy5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICBpZiAoc2libGluZy5wcmV2KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnByZXYubmV4dCA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5uZXh0ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcmV2ID0gc2libGluZztcbiAgICAgICAgc2libGluZy5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKCFzaWJsaW5nLnByZXYpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50LmZpcnN0Q2hpbGQgPSBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC51bmxpbmsoKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZC5uZXh0ID0gY2hpbGQ7XG4gICAgICAgICAgICBjaGlsZC5wcmV2ID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5wcmVwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQudW5saW5rKCk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZC5wcmV2ID0gY2hpbGQ7XG4gICAgICAgICAgICBjaGlsZC5uZXh0ID0gdGhpcy5maXJzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLndhbGtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlV2Fsa2VyKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xudmFyIEJsb2NrTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrTm9kZShub2RlVHlwZSwgc291cmNlcG9zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5vZGVUeXBlLCBzb3VyY2Vwb3MpIHx8IHRoaXM7XG4gICAgICAgIC8vIHRlbXBvcmFsIGRhdGEgKGZvciBwYXJzaW5nKVxuICAgICAgICBfdGhpcy5vcGVuID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMubGluZU9mZnNldHMgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdHJpbmdDb250ZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdExpbmVCbGFuayA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5sYXN0TGluZUNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudHlwZSA9IG5vZGVUeXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCbG9ja05vZGU7XG59KE5vZGUkMSkpO1xudmFyIExpc3ROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXN0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaXN0Tm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxpc3REYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdE5vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIEhlYWRpbmdOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkaW5nTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxldmVsID0gMDtcbiAgICAgICAgX3RoaXMuaGVhZGluZ1R5cGUgPSAnYXR4JztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGluZ05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIENvZGVCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvZGVCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZUJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzRmVuY2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmZlbmNlQ2hhciA9IG51bGw7XG4gICAgICAgIF90aGlzLmZlbmNlTGVuZ3RoID0gMDtcbiAgICAgICAgX3RoaXMuZmVuY2VPZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIF90aGlzLmluZm9QYWRkaW5nID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29kZUJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJsZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJsZU5vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIFRhYmxlQ2VsbE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhYmxlQ2VsbE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXJ0SWR4ID0gMDtcbiAgICAgICAgX3RoaXMuZW5kSWR4ID0gMDtcbiAgICAgICAgX3RoaXMucGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICBfdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICBfdGhpcy5pZ25vcmVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlQ2VsbE5vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIFJlZkRlZk5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZkRlZk5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmRGVmTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpdGxlID0gJyc7XG4gICAgICAgIF90aGlzLmRlc3QgPSAnJztcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVmRGVmTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgQ3VzdG9tQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDdXN0b21CbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3ludGF4TGVuZ3RoID0gMDtcbiAgICAgICAgX3RoaXMub2Zmc2V0ID0gLTE7XG4gICAgICAgIF90aGlzLmluZm8gPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ3VzdG9tQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBIdG1sQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIdG1sQmxvY2tOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0bWxCbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5odG1sQmxvY2tUeXBlID0gLTE7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0bWxCbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIExpbmtOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5rTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMudGl0bGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5leHRlbmRlZEF1dG9saW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpbmtOb2RlO1xufShOb2RlJDEpKTtcbnZhciBDb2RlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29kZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aWNrQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb2RlTm9kZTtcbn0oTm9kZSQxKSk7XG52YXIgQ3VzdG9tSW5saW5lTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ3VzdG9tSW5saW5lTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21JbmxpbmVOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5mbyA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDdXN0b21JbmxpbmVOb2RlO1xufShOb2RlJDEpKTtcbmZ1bmN0aW9uIGNyZWF0ZU5vZGUkMSh0eXBlLCBzb3VyY2Vwb3MpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRpbmdOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdE5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlua05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnY29kZUJsb2NrJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZUJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdodG1sQmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdG1sQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ3RhYmxlQ2VsbCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlQ2VsbE5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAndGhlbWF0aWNCcmVhayc6XG4gICAgICAgIGNhc2UgJ3RhYmxlUm93JzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAnZnJvbnRNYXR0ZXInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvZGVOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ3JlZkRlZic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZkRlZk5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnY3VzdG9tQmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21CbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tSW5saW5lTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlJDEodHlwZSwgc291cmNlcG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0NvZGVCbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2NvZGVCbG9jayc7XG59XG5mdW5jdGlvbiBpc0h0bWxCbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2h0bWxCbG9jayc7XG59XG5mdW5jdGlvbiBpc0hlYWRpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdoZWFkaW5nJztcbn1cbmZ1bmN0aW9uIGlzTGlzdChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2xpc3QnO1xufVxuZnVuY3Rpb24gaXNUYWJsZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3RhYmxlJztcbn1cbmZ1bmN0aW9uIGlzUmVmRGVmKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAncmVmRGVmJztcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjdXN0b21CbG9jayc7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUlubGluZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ2N1c3RvbUlubGluZSc7XG59XG5mdW5jdGlvbiB0ZXh0JDEocywgc291cmNlcG9zKSB7XG4gICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ3RleHQnLCBzb3VyY2Vwb3MpO1xuICAgIG5vZGUubGl0ZXJhbCA9IHM7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbnZhciBUQUdOQU1FID0gJ1tBLVphLXpdW0EtWmEtejAtOS1dKic7XG52YXIgQVRUUklCVVRFTkFNRSA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG52YXIgVU5RVU9URURWQUxVRSA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBTSU5HTEVRVU9URURWQUxVRSA9IFwiJ1teJ10qJ1wiO1xudmFyIERPVUJMRVFVT1RFRFZBTFVFID0gJ1wiW15cIl0qXCInO1xudmFyIEFUVFJJQlVURVZBTFVFID0gXCIoPzpcIiArIFVOUVVPVEVEVkFMVUUgKyBcInxcIiArIFNJTkdMRVFVT1RFRFZBTFVFICsgXCJ8XCIgKyBET1VCTEVRVU9URURWQUxVRSArIFwiKVwiO1xudmFyIEFUVFJJQlVURVZBTFVFU1BFQyA9IFwiXCIgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBBVFRSSUJVVEVWQUxVRSArIFwiKVwiO1xudmFyIEFUVFJJQlVURSA9IFwiXCIgKyAnKD86XFxcXHMrJyArIEFUVFJJQlVURU5BTUUgKyBBVFRSSUJVVEVWQUxVRVNQRUMgKyBcIj8pXCI7XG52YXIgT1BFTlRBRyA9IFwiPFwiICsgVEFHTkFNRSArIEFUVFJJQlVURSArIFwiKlxcXFxzKi8/PlwiO1xudmFyIENMT1NFVEFHID0gXCI8L1wiICsgVEFHTkFNRSArIFwiXFxcXHMqWz5dXCI7XG52YXIgSFRNTENPTU1FTlQgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgUFJPQ0VTU0lOR0lOU1RSVUNUSU9OID0gJ1s8XVs/XS4qP1s/XVs+XSc7XG52YXIgREVDTEFSQVRJT04gPSAnPCFbQS1aXStcXFxccytbXj5dKj4nO1xudmFyIENEQVRBID0gJzwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPic7XG52YXIgSFRNTFRBRyA9IFwiKD86XCIgKyBPUEVOVEFHICsgXCJ8XCIgKyBDTE9TRVRBRyArIFwifFwiICsgSFRNTENPTU1FTlQgKyBcInxcIiArIFBST0NFU1NJTkdJTlNUUlVDVElPTiArIFwifFwiICsgREVDTEFSQVRJT04gKyBcInxcIiArIENEQVRBICsgXCIpXCI7XG52YXIgcmVIdG1sVGFnID0gbmV3IFJlZ0V4cChcIl5cIiArIEhUTUxUQUcsICdpJyk7XG5cbi8vIGRlcml2ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcuZnJvbUNvZGVQb2ludFxuLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMi4xIGJ5IEBtYXRoaWFzICovXG52YXIgZnJvbUNvZGVQb2ludDtcbmlmIChTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KF8pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5lbHNlIHtcbiAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlXzEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIHZhciBmbG9vcl8xID0gTWF0aC5mbG9vcjtcbiAgICBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdO1xuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwZmZmZiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBmbG9vcl8xKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZmZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMDtcbiAgICAgICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhkYzAwO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZV8xLmFwcGx5KHZvaWQgMCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG52YXIgZnJvbUNvZGVQb2ludCQxID0gZnJvbUNvZGVQb2ludDtcblxudmFyIERPTUFJTiA9ICcoPzpbdy1dKy4pKltBLVphLXowLTktXSsuW0EtWmEtejAtOS1dKyc7XG52YXIgUEFUSCA9ICdbXjxcXFxcc10qW148PyEuLDoqXz9+XFxcXHNdJztcbnZhciBFTUFJTCA9ICdbXFxcXHcuKy1dK0AoPzpbXFxcXHctXStcXFxcLikrW1xcXFx3LV0rJztcbmZ1bmN0aW9uIHRyaW1Vbm1hdGNoZWRUcmFpbGluZ1BhcmVucyhzb3VyY2UpIHtcbiAgICB2YXIgdHJhaWxpbmdQYXJlbiA9IC9cXCkrJC8uZXhlYyhzb3VyY2UpO1xuICAgIGlmICh0cmFpbGluZ1BhcmVuKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgc291cmNlXzEgPSBzb3VyY2U7IF9pIDwgc291cmNlXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2ggPSBzb3VyY2VfMVtfaV07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcoJykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICB2YXIgdHJpbUNvdW50ID0gTWF0aC5taW4oLWNvdW50LCB0cmFpbGluZ1BhcmVuWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnN0cmluZygwLCBzb3VyY2UubGVuZ3RoIC0gdHJpbUNvdW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gdHJpbVRyYWlsaW5nRW50aXR5KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvJltBLVphLXowLTldKzskLywgJycpO1xufVxuZnVuY3Rpb24gcGFyc2VFbWFpbExpbmsoc291cmNlKSB7XG4gICAgdmFyIHJlRW1haWxMaW5rID0gbmV3IFJlZ0V4cChFTUFJTCwgJ2cnKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG07XG4gICAgd2hpbGUgKChtID0gcmVFbWFpbExpbmsuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICB2YXIgdGV4dF8xID0gbVswXTtcbiAgICAgICAgaWYgKCEvW18tXSskLy50ZXN0KHRleHRfMSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XzEsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFttLmluZGV4LCBtLmluZGV4ICsgdGV4dF8xLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIHVybDogXCJtYWlsdG86XCIgKyB0ZXh0XzEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VVcmxMaW5rKHNvdXJjZSkge1xuICAgIHZhciByZVd3d0F1dG9saW5rID0gbmV3IFJlZ0V4cChcIih3d3d8aHR0cHM/Oi8vKS5cIiArIERPTUFJTiArIFBBVEgsICdnJyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBtO1xuICAgIHdoaWxlICgobSA9IHJlV3d3QXV0b2xpbmsuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICB2YXIgdGV4dF8yID0gdHJpbVRyYWlsaW5nRW50aXR5KHRyaW1Vbm1hdGNoZWRUcmFpbGluZ1BhcmVucyhtWzBdKSk7XG4gICAgICAgIHZhciBzY2hlbWUgPSBtWzFdID09PSAnd3d3JyA/ICdodHRwOi8vJyA6ICcnO1xuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XzIsXG4gICAgICAgICAgICByYW5nZTogW20uaW5kZXgsIG0uaW5kZXggKyB0ZXh0XzIubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICB1cmw6IFwiXCIgKyBzY2hlbWUgKyB0ZXh0XzIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmFzZUF1dG9saW5rUGFyc2VyKHNvdXJjZSkge1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHBhcnNlVXJsTGluayhzb3VyY2UpKSwgcGFyc2VFbWFpbExpbmsoc291cmNlKSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5yYW5nZVswXSAtIGIucmFuZ2VbMF07IH0pO1xufVxuZnVuY3Rpb24gY29udmVydEV4dEF1dG9MaW5rcyh3YWxrZXIsIGF1dG9saW5rUGFyc2VyKSB7XG4gICAgaWYgKHR5cGVvZiBhdXRvbGlua1BhcnNlciA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGF1dG9saW5rUGFyc2VyID0gYmFzZUF1dG9saW5rUGFyc2VyO1xuICAgIH1cbiAgICB2YXIgZXZlbnQ7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nLCBub2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKGVudGVyaW5nICYmIG5vZGUudHlwZSA9PT0gJ3RleHQnICYmIG5vZGUucGFyZW50LnR5cGUgIT09ICdsaW5rJykge1xuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgICAgICB2YXIgbGlua0luZm9zID0gYXV0b2xpbmtQYXJzZXIobGl0ZXJhbCk7XG4gICAgICAgICAgICBpZiAoIWxpbmtJbmZvcyB8fCAhbGlua0luZm9zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGFzdElkeCA9IDA7XG4gICAgICAgICAgICB2YXIgX2EgPSBub2RlLnNvdXJjZXBvc1swXSwgbGluZU51bV8xID0gX2FbMF0sIGNoUG9zXzEgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBzb3VyY2Vwb3MgPSBmdW5jdGlvbiAoc3RhcnRJZHgsIGVuZElkeCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgICAgIFtsaW5lTnVtXzEsIGNoUG9zXzEgKyBzdGFydElkeF0sXG4gICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIGVuZElkeF0sXG4gICAgICAgICAgICBdOyB9O1xuICAgICAgICAgICAgdmFyIG5ld05vZGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxpbmtJbmZvc18xID0gbGlua0luZm9zOyBfaSA8IGxpbmtJbmZvc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGxpbmtJbmZvc18xW19pXSwgcmFuZ2UgPSBfYi5yYW5nZSwgdXJsID0gX2IudXJsLCBsaW5rVGV4dCA9IF9iLnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlWzBdID4gbGFzdElkeCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKHRleHQkMShsaXRlcmFsLnN1YnN0cmluZyhsYXN0SWR4LCByYW5nZVswXSksIHNvdXJjZXBvcyhsYXN0SWR4LCByYW5nZVswXSAtIDEpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5rTm9kZSA9IGNyZWF0ZU5vZGUkMSgnbGluaycsIHNvdXJjZXBvcy5hcHBseSh2b2lkIDAsIHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuYXBwZW5kQ2hpbGQodGV4dCQxKGxpbmtUZXh0LCBzb3VyY2Vwb3MuYXBwbHkodm9pZCAwLCByYW5nZSkpKTtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5kZXN0aW5hdGlvbiA9IHVybDtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5leHRlbmRlZEF1dG9saW5rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGxpbmtOb2RlKTtcbiAgICAgICAgICAgICAgICBsYXN0SWR4ID0gcmFuZ2VbMV0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RJZHggPCBsaXRlcmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2godGV4dCQxKGxpdGVyYWwuc3Vic3RyaW5nKGxhc3RJZHgpLCBzb3VyY2Vwb3MobGFzdElkeCwgbGl0ZXJhbC5sZW5ndGggLSAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBuZXdOb2Rlc18xID0gbmV3Tm9kZXM7IF9jIDwgbmV3Tm9kZXNfMS5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ld05vZGVzXzFbX2NdO1xuICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIF9sb29wXzEoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxhc3QoYXJyKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG4vLyBub3JtYWxpemUgYSByZWZlcmVuY2UgaW4gcmVmZXJlbmNlIGxpbmsgKHJlbW92ZSBbXXMsIHRyaW0sXG4vLyBjb2xsYXBzZSBpbnRlcm5hbCBzcGFjZSwgdW5pY29kZSBjYXNlIGZvbGQuXG4vLyBTZWUgY29tbW9ubWFyay9jb21tb25tYXJrLmpzIzE2OC5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5zbGljZSgxLCBzdHIubGVuZ3RoIC0gMSlcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvWyBcXHRcXHJcXG5dKy8sICcgJylcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBpdGVyYXRlT2JqZWN0KG9iaiwgaXRlcmF0ZWUpIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpdGVyYXRlZShrZXksIG9ialtrZXldKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9taXQob2JqKSB7XG4gICAgdmFyIHByb3BOYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHByb3BOYW1lc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdE1hcCA9IF9fYXNzaWduKHt9LCBvYmopO1xuICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdE1hcFtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG59XG5mdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgIHJldHVybiAhT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGVhck9iaihvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgfSk7XG59XG5cbnZhciBDX05FV0xJTkUgPSAxMDtcbnZhciBDX0FTVEVSSVNLID0gNDI7XG52YXIgQ19VTkRFUlNDT1JFID0gOTU7XG52YXIgQ19CQUNLVElDSyA9IDk2O1xudmFyIENfT1BFTl9CUkFDS0VUJDEgPSA5MTtcbnZhciBDX0NMT1NFX0JSQUNLRVQgPSA5MztcbnZhciBDX1RJTERFID0gMTI2O1xudmFyIENfTEVTU1RIQU4kMSA9IDYwO1xudmFyIENfQkFORyA9IDMzO1xudmFyIENfQkFDS1NMQVNIID0gOTI7XG52YXIgQ19BTVBFUlNBTkQgPSAzODtcbnZhciBDX09QRU5fUEFSRU4gPSA0MDtcbnZhciBDX0NMT1NFX1BBUkVOID0gNDE7XG52YXIgQ19DT0xPTiA9IDU4O1xudmFyIENfU0lOR0xFUVVPVEUgPSAzOTtcbnZhciBDX0RPVUJMRVFVT1RFID0gMzQ7XG52YXIgQ19ET0xMQVIgPSAzNjtcbi8vIFNvbWUgcmVnZXhwcyB1c2VkIGluIGlubGluZSBwYXJzZXI6XG52YXIgRVNDQVBFRF9DSEFSID0gXCJcXFxcXFxcXFwiICsgRVNDQVBBQkxFO1xudmFyIHJlUHVuY3R1YXRpb24gPSBuZXcgUmVnRXhwKC9bIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XFx4QTFcXHhBN1xceEFCXFx4QjZcXHhCN1xceEJCXFx4QkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMDgtXFx1MjMwQlxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkU0MlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdfFxcdUQ4MDBbXFx1REQwMC1cXHVERDAyXFx1REY5RlxcdURGRDBdfFxcdUQ4MDFcXHVERDZGfFxcdUQ4MDJbXFx1REM1N1xcdUREMUZcXHVERDNGXFx1REU1MC1cXHVERTU4XFx1REU3RlxcdURFRjAtXFx1REVGNlxcdURGMzktXFx1REYzRlxcdURGOTktXFx1REY5Q118XFx1RDgwNFtcXHVEQzQ3LVxcdURDNERcXHVEQ0JCXFx1RENCQ1xcdURDQkUtXFx1RENDMVxcdURENDAtXFx1REQ0M1xcdURENzRcXHVERDc1XFx1RERDNS1cXHVEREM5XFx1RERDRFxcdUREREJcXHVERERELVxcdUREREZcXHVERTM4LVxcdURFM0RcXHVERUE5XXxcXHVEODA1W1xcdURDQzZcXHVEREMxLVxcdURERDdcXHVERTQxLVxcdURFNDNcXHVERjNDLVxcdURGM0VdfFxcdUQ4MDlbXFx1REM3MC1cXHVEQzc0XXxcXHVEODFBW1xcdURFNkVcXHVERTZGXFx1REVGNVxcdURGMzctXFx1REYzQlxcdURGNDRdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXS8pO1xudmFyIHJlTGlua1RpdGxlID0gbmV3IFJlZ0V4cChcIl4oPzpcXFwiKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W15cXFwiXFxcXHgwMF0pKlxcXCJcIiArXG4gICAgXCJ8XCIgK1xuICAgIChcIicoXCIgKyBFU0NBUEVEX0NIQVIgKyBcInxbXidcXFxceDAwXSkqJ1wiKSArXG4gICAgXCJ8XCIgK1xuICAgIChcIlxcXFwoKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W14oKVxcXFx4MDBdKSpcXFxcKSlcIikpO1xudmFyIHJlTGlua0Rlc3RpbmF0aW9uQnJhY2VzID0gL14oPzo8KD86W148PlxcblxcXFxcXHgwMF18XFxcXC4pKj4pLztcbnZhciByZUVzY2FwYWJsZSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBFU0NBUEFCTEUpO1xudmFyIHJlRW50aXR5SGVyZSA9IG5ldyBSZWdFeHAoXCJeXCIgKyBFTlRJVFksICdpJyk7XG52YXIgcmVUaWNrcyA9IC9gKy87XG52YXIgcmVUaWNrc0hlcmUgPSAvXmArLztcbnZhciByZUVsbGlwc2VzID0gL1xcLlxcLlxcLi9nO1xudmFyIHJlRGFzaCA9IC8tLSsvZztcbnZhciByZUVtYWlsQXV0b2xpbmsgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciByZUF1dG9saW5rID0gL148W0EtWmEtel1bQS1aYS16MC05ListXXsxLDMxfTpbXjw+XFx4MDAtXFx4MjBdKj4vaTtcbnZhciByZVNwbmwgPSAvXiAqKD86XFxuICopPy87XG52YXIgcmVXaGl0ZXNwYWNlQ2hhciA9IC9eWyBcXHRcXG5cXHgwYlxceDBjXFx4MGRdLztcbnZhciByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhciA9IC9eXFxzLztcbnZhciByZUZpbmFsU3BhY2UgPSAvICokLztcbnZhciByZUluaXRpYWxTcGFjZSA9IC9eICovO1xudmFyIHJlU3BhY2VBdEVuZE9mTGluZSA9IC9eICooPzpcXG58JCkvO1xudmFyIHJlTGlua0xhYmVsID0gL15cXFsoPzpbXlxcXFxcXFtcXF1dfFxcXFwuKXswLDEwMDB9XFxdLztcbi8vIE1hdGNoZXMgYSBzdHJpbmcgb2Ygbm9uLXNwZWNpYWwgY2hhcmFjdGVycy5cbnZhciByZU1haW4gPSAvXlteXFxuYFxcW1xcXVxcXFwhPCYqXydcIn4kXSsvbTtcbnZhciBJbmxpbmVQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5saW5lUGFyc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQW4gSW5saW5lUGFyc2VyIGtlZXBzIHRyYWNrIG9mIGEgc3ViamVjdCAoYSBzdHJpbmcgdG8gYmUgcGFyc2VkKVxuICAgICAgICAvLyBhbmQgYSBwb3NpdGlvbiBpbiB0aGF0IHN1YmplY3QuXG4gICAgICAgIHRoaXMuc3ViamVjdCA9ICcnO1xuICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSBudWxsOyAvLyB1c2VkIGJ5IGhhbmRsZURlbGltIG1ldGhvZFxuICAgICAgICB0aGlzLmJyYWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVTdGFydE51bSA9IDA7XG4gICAgICAgIHRoaXMubGluZUlkeCA9IDA7XG4gICAgICAgIHRoaXMubGluZU9mZnNldHMgPSBbMF07XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucmVmTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNvdXJjZXBvcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBsaW5lUG9zT2Zmc2V0ID0gdGhpcy5saW5lUG9zT2Zmc2V0ICsgdGhpcy5saW5lT2Zmc2V0c1t0aGlzLmxpbmVJZHhdO1xuICAgICAgICB2YXIgbGluZU51bSA9IHRoaXMubGluZVN0YXJ0TnVtICsgdGhpcy5saW5lSWR4O1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSBbbGluZU51bSwgc3RhcnQgKyBsaW5lUG9zT2Zmc2V0XTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0cG9zLCBbbGluZU51bSwgZW5kICsgbGluZVBvc09mZnNldF1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydHBvcztcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubmV4dExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGluZUlkeCArPSAxO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAtdGhpcy5wb3M7XG4gICAgfTtcbiAgICAvLyBJZiByZSBtYXRjaGVzIGF0IGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHN1YmplY3QsIGFkdmFuY2VcbiAgICAvLyBwb3NpdGlvbiBpbiBzdWJqZWN0IGFuZCByZXR1cm4gdGhlIG1hdGNoOyBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChyZSkge1xuICAgICAgICB2YXIgbSA9IHJlLmV4ZWModGhpcy5zdWJqZWN0LnNsaWNlKHRoaXMucG9zKSk7XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyArPSBtLmluZGV4ICsgbVswXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBtWzBdO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyB0aGUgY29kZSBmb3IgdGhlIGNoYXJhY3RlciBhdCB0aGUgY3VycmVudCBzdWJqZWN0IHBvc2l0aW9uLCBvciAtMVxuICAgIC8vIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN1YmplY3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHplcm8gb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgYXQgbW9zdCBvbmUgbmV3bGluZVxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuc3BubCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXRjaChyZVNwbmwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEFsbCBvZiB0aGUgcGFyc2VycyBiZWxvdyB0cnkgdG8gbWF0Y2ggc29tZXRoaW5nIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgLy8gaW4gdGhlIHN1YmplY3QuICBJZiB0aGV5IHN1Y2NlZWQgaW4gbWF0Y2hpbmcgYW55dGhpbmcsIHRoZXlcbiAgICAvLyByZXR1cm4gdGhlIGlubGluZSBtYXRjaGVkLCBhZHZhbmNpbmcgdGhlIHN1YmplY3QuXG4gICAgLy8gQXR0ZW1wdCB0byBwYXJzZSBiYWNrdGlja3MsIGFkZGluZyBlaXRoZXIgYSBiYWNrdGljayBjb2RlIHNwYW4gb3IgYVxuICAgIC8vIGxpdGVyYWwgc2VxdWVuY2Ugb2YgYmFja3RpY2tzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYWNrdGlja3MgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgdGlja3MgPSB0aGlzLm1hdGNoKHJlVGlja3NIZXJlKTtcbiAgICAgICAgaWYgKHRpY2tzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFmdGVyT3BlblRpY2tzID0gdGhpcy5wb3M7XG4gICAgICAgIHZhciBtYXRjaGVkO1xuICAgICAgICB3aGlsZSAoKG1hdGNoZWQgPSB0aGlzLm1hdGNoKHJlVGlja3MpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQgPT09IHRpY2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gdGhpcy5zdWJqZWN0LnNsaWNlKGFmdGVyT3BlblRpY2tzLCB0aGlzLnBvcyAtIHRpY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZXBvcyA9IHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY29udGVudHMuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0TGluZSA9IGxhc3QobGluZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVJZHggKz0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gLSh0aGlzLnBvcyAtIGxhc3RMaW5lLmxlbmd0aCAtIHRpY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZXBvc1sxXSA9IHRoaXMuc291cmNlcG9zKHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgPSBsaW5lcy5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gY3JlYXRlTm9kZSQxKCdjb2RlJywgc291cmNlcG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy5tYXRjaCgvW14gXS8pICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzWzBdID09ICcgJyAmJlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50c1tjb250ZW50cy5sZW5ndGggLSAxXSA9PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saXRlcmFsID0gY29udGVudHMuc2xpY2UoMSwgY29udGVudHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpdGVyYWwgPSBjb250ZW50cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50aWNrQ291bnQgPSB0aWNrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHdlIGRpZG4ndCBtYXRjaCBhIGNsb3NpbmcgYmFja3RpY2sgc2VxdWVuY2UuXG4gICAgICAgIHRoaXMucG9zID0gYWZ0ZXJPcGVuVGlja3M7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMSh0aWNrcywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBhIGJhY2tzbGFzaC1lc2NhcGVkIHNwZWNpYWwgY2hhcmFjdGVyLCBhZGRpbmcgZWl0aGVyIHRoZSBlc2NhcGVkXG4gICAgLy8gY2hhcmFjdGVyLCBhIGhhcmQgbGluZSBicmVhayAoaWYgdGhlIGJhY2tzbGFzaCBpcyBmb2xsb3dlZCBieSBhIG5ld2xpbmUpLFxuICAgIC8vIG9yIGEgbGl0ZXJhbCBiYWNrc2xhc2ggdG8gdGhlIGJsb2NrJ3MgY2hpbGRyZW4uICBBc3N1bWVzIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgLy8gaXMgYSBiYWNrc2xhc2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJhY2tzbGFzaCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3ViaiA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfTkVXTElORSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlJDEoJ2xpbmVicmVhaycsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zIC0gMSwgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlRXNjYXBhYmxlLnRlc3Qoc3Viai5jaGFyQXQodGhpcy5wb3MpKSkge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKHN1YmouY2hhckF0KHRoaXMucG9zKSwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMSgnXFxcXCcsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gYXV0b2xpbmsgKFVSTCBvciBlbWFpbCBpbiBwb2ludHkgYnJhY2tldHMpLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VBdXRvbGluayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIGRlc3Q7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVFbWFpbEF1dG9saW5rKSkpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSQxKCdsaW5rJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gbm9ybWFsaXplVVJJKFwibWFpbHRvOlwiICsgZGVzdCk7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gJyc7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHQkMShkZXN0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcyArIDEsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUF1dG9saW5rKSkpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSQxKCdsaW5rJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBub2RlLmRlc3RpbmF0aW9uID0gbm9ybWFsaXplVVJJKGRlc3QpO1xuICAgICAgICAgICAgbm9kZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0ZXh0JDEoZGVzdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MgKyAxLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSByYXcgSFRNTCB0YWcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUh0bWxUYWcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVIdG1sVGFnKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMSgnaHRtbElubGluZScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICBub2RlLmxpdGVyYWwgPSBtO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBTY2FuIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB3aXRoIGNvZGUgY2MsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGRlbGltaXRlcnMgYW5kIHdoZXRoZXIgdGhleSBhcmUgcG9zaXRpb25lZCBzdWNoIHRoYXRcbiAgICAvLyB0aGV5IGNhbiBvcGVuIGFuZC9vciBjbG9zZSBlbXBoYXNpcyBvciBzdHJvbmcgZW1waGFzaXMuICBBIHV0aWxpdHlcbiAgICAvLyBmdW5jdGlvbiBmb3Igc3Ryb25nL2VtcGggcGFyc2luZy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoY2MpIHtcbiAgICAgICAgdmFyIG51bWRlbGltcyA9IDA7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAoY2MgPT09IENfU0lOR0xFUVVPVEUgfHwgY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIG51bWRlbGltcysrO1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gY2MpIHtcbiAgICAgICAgICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW1kZWxpbXMgPT09IDAgfHwgKG51bWRlbGltcyA8IDIgJiYgKGNjID09PSBDX1RJTERFIHx8IGNjID09PSBDX0RPTExBUikpKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYXJCZWZvcmUgPSBzdGFydHBvcyA9PT0gMCA/ICdcXG4nIDogdGhpcy5zdWJqZWN0LmNoYXJBdChzdGFydHBvcyAtIDEpO1xuICAgICAgICB2YXIgY2NBZnRlciA9IHRoaXMucGVlaygpO1xuICAgICAgICB2YXIgY2hhckFmdGVyO1xuICAgICAgICBpZiAoY2NBZnRlciA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNoYXJBZnRlciA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhckFmdGVyID0gZnJvbUNvZGVQb2ludCQxKGNjQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlcklzV2hpdGVzcGFjZSA9IHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyLnRlc3QoY2hhckFmdGVyKTtcbiAgICAgICAgdmFyIGFmdGVySXNQdW5jdHVhdGlvbiA9IHJlUHVuY3R1YXRpb24udGVzdChjaGFyQWZ0ZXIpO1xuICAgICAgICB2YXIgYmVmb3JlSXNXaGl0ZXNwYWNlID0gcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIudGVzdChjaGFyQmVmb3JlKTtcbiAgICAgICAgdmFyIGJlZm9yZUlzUHVuY3R1YXRpb24gPSByZVB1bmN0dWF0aW9uLnRlc3QoY2hhckJlZm9yZSk7XG4gICAgICAgIHZhciBsZWZ0RmxhbmtpbmcgPSAhYWZ0ZXJJc1doaXRlc3BhY2UgJiYgKCFhZnRlcklzUHVuY3R1YXRpb24gfHwgYmVmb3JlSXNXaGl0ZXNwYWNlIHx8IGJlZm9yZUlzUHVuY3R1YXRpb24pO1xuICAgICAgICB2YXIgcmlnaHRGbGFua2luZyA9ICFiZWZvcmVJc1doaXRlc3BhY2UgJiYgKCFiZWZvcmVJc1B1bmN0dWF0aW9uIHx8IGFmdGVySXNXaGl0ZXNwYWNlIHx8IGFmdGVySXNQdW5jdHVhdGlvbik7XG4gICAgICAgIHZhciBjYW5PcGVuO1xuICAgICAgICB2YXIgY2FuQ2xvc2U7XG4gICAgICAgIGlmIChjYyA9PT0gQ19VTkRFUlNDT1JFKSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nICYmICghcmlnaHRGbGFua2luZyB8fCBiZWZvcmVJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZyAmJiAoIWxlZnRGbGFua2luZyB8fCBhZnRlcklzUHVuY3R1YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFIHx8IGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nICYmICFyaWdodEZsYW5raW5nO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgY2FuT3BlbiA9ICFhZnRlcklzV2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGNhbkNsb3NlID0gIWJlZm9yZUlzV2hpdGVzcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSBsZWZ0Rmxhbmtpbmc7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0Rmxhbmtpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgcmV0dXJuIHsgbnVtZGVsaW1zOiBudW1kZWxpbXMsIGNhbk9wZW46IGNhbk9wZW4sIGNhbkNsb3NlOiBjYW5DbG9zZSB9O1xuICAgIH07XG4gICAgLy8gSGFuZGxlIGEgZGVsaW1pdGVyIG1hcmtlciBmb3IgZW1waGFzaXMgb3IgYSBxdW90ZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmhhbmRsZURlbGltID0gZnVuY3Rpb24gKGNjLCBibG9jaykge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5zY2FuRGVsaW1zKGNjKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtZGVsaW1zID0gcmVzLm51bWRlbGltcztcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgY29udGVudHM7XG4gICAgICAgIHRoaXMucG9zICs9IG51bWRlbGltcztcbiAgICAgICAgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFKSB7XG4gICAgICAgICAgICBjb250ZW50cyA9ICdcXHUyMDE5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgY29udGVudHMgPSAnXFx1MjAxQyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50cyA9IHRoaXMuc3ViamVjdC5zbGljZShzdGFydHBvcyAtIDEsIHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IHRleHQkMShjb250ZW50cywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAvLyBBZGQgZW50cnkgdG8gc3RhY2sgZm9yIHRoaXMgb3BlbmVyXG4gICAgICAgIGlmICgocmVzLmNhbk9wZW4gfHwgcmVzLmNhbkNsb3NlKSAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5zbWFydCB8fCAoY2MgIT09IENfU0lOR0xFUVVPVEUgJiYgY2MgIT09IENfRE9VQkxFUVVPVEUpKSkge1xuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICBudW1kZWxpbXM6IG51bWRlbGltcyxcbiAgICAgICAgICAgICAgICBvcmlnZGVsaW1zOiBudW1kZWxpbXMsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2FuT3BlbjogcmVzLmNhbk9wZW4sXG4gICAgICAgICAgICAgICAgY2FuQ2xvc2U6IHJlcy5jYW5DbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxpbWl0ZXJzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzLnByZXZpb3VzLm5leHQgPSB0aGlzLmRlbGltaXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZURlbGltaXRlciA9IGZ1bmN0aW9uIChkZWxpbSkge1xuICAgICAgICBpZiAoZGVsaW0ucHJldmlvdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltLnByZXZpb3VzLm5leHQgPSBkZWxpbS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxpbS5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0b3Agb2Ygc3RhY2tcbiAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IGRlbGltLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsaW0ubmV4dC5wcmV2aW91cyA9IGRlbGltLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZURlbGltaXRlcnNCZXR3ZWVuID0gZnVuY3Rpb24gKGJvdHRvbSwgdG9wKSB7XG4gICAgICAgIGlmIChib3R0b20ubmV4dCAhPT0gdG9wKSB7XG4gICAgICAgICAgICBib3R0b20ubmV4dCA9IHRvcDtcbiAgICAgICAgICAgIHRvcC5wcmV2aW91cyA9IGJvdHRvbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwgZGVsaW1pdGVycyAtIGVtcGhhc2lzLCBzdHJvbmcgZW1waGFzaXMsIHN0cmlrZXRocm91Z2goZ2ZtKVxuICAgICAqIElmIHRoZSBzbWFydCBwdW5jdHVhdGlvbiBvcHRpb25zIGlzIHRydWUsXG4gICAgICogY29udmVydCBzaW5nbGUvZG91YmxlIHF1b3RlcyB0byBjb3JyZXNwb25kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAgKiovXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzRW1waGFzaXMgPSBmdW5jdGlvbiAoc3RhY2tCb3R0b20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgb3BlbmVyO1xuICAgICAgICB2YXIgY2xvc2VyO1xuICAgICAgICB2YXIgb2xkQ2xvc2VyO1xuICAgICAgICB2YXIgb3BlbmVySW5sLCBjbG9zZXJJbmw7XG4gICAgICAgIHZhciBvcGVuZXJGb3VuZDtcbiAgICAgICAgdmFyIG9kZE1hdGNoID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuZXJzQm90dG9tID0gKF9hID0ge30sXG4gICAgICAgICAgICBfYVtDX1VOREVSU0NPUkVdID0gW3N0YWNrQm90dG9tLCBzdGFja0JvdHRvbSwgc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19BU1RFUklTS10gPSBbc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tLCBzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX1NJTkdMRVFVT1RFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0RPVUJMRVFVT1RFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX1RJTERFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0RPTExBUl0gPSBbc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IGNsb3NlciBhYm92ZSBzdGFja0JvdHRvbTpcbiAgICAgICAgY2xvc2VyID0gdGhpcy5kZWxpbWl0ZXJzO1xuICAgICAgICB3aGlsZSAoY2xvc2VyICE9PSBudWxsICYmIGNsb3Nlci5wcmV2aW91cyAhPT0gc3RhY2tCb3R0b20pIHtcbiAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIGZvcndhcmQsIGxvb2tpbmcgZm9yIGNsb3NlcnMsIGFuZCBoYW5kbGluZyBlYWNoXG4gICAgICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZXJjYyA9IGNsb3Nlci5jYztcbiAgICAgICAgICAgIHZhciBjbG9zZXJFbXBoID0gY2xvc2VyY2MgPT09IENfVU5ERVJTQ09SRSB8fCBjbG9zZXJjYyA9PT0gQ19BU1RFUklTSztcbiAgICAgICAgICAgIGlmICghY2xvc2VyLmNhbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbXBoYXNpcyBjbG9zZXIuIG5vdyBsb29rIGJhY2sgZm9yIGZpcnN0IG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgICAgICBvcGVuZXIgPSBjbG9zZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgb3BlbmVyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlbmVyICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZW5lciAhPT0gc3RhY2tCb3R0b20gJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyICE9PSBvcGVuZXJzQm90dG9tW2Nsb3NlcmNjXVtjbG9zZXJFbXBoID8gY2xvc2VyLm9yaWdkZWxpbXMgJSAzIDogMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2RkTWF0Y2ggPVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyRW1waCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbG9zZXIuY2FuT3BlbiB8fCBvcGVuZXIuY2FuQ2xvc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm9yaWdkZWxpbXMgJSAzICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wZW5lci5vcmlnZGVsaW1zICsgY2xvc2VyLm9yaWdkZWxpbXMpICUgMyA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5jYyA9PT0gY2xvc2VyLmNjICYmIG9wZW5lci5jYW5PcGVuICYmICFvZGRNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRDbG9zZXIgPSBjbG9zZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlckVtcGggfHwgY2xvc2VyY2MgPT09IENfVElMREUgfHwgY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG51bGwgb3BlbmVyIGNoZWNrIGZvciB0eXBlIG5hcnJvd2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgbnVtYmVyIG9mIGRlbGltaXRlcnMgdXNlZCBmcm9tIGNsb3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZURlbGltcyA9IGNsb3Nlci5udW1kZWxpbXMgPj0gMiAmJiBvcGVuZXIubnVtZGVsaW1zID49IDIgPyAyIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbXB0eURlbGltcyA9IGNsb3NlckVtcGggPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubCA9IG9wZW5lci5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sID0gY2xvc2VyLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjb250ZW50cyBmb3IgbmV3IGVtcGggZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gY2xvc2VyRW1waFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXNlRGVsaW1zID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VtcGgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0cm9uZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzdHJpa2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlcmNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gJ2N1c3RvbUlubGluZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUkMShub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbmVyRW5kUG9zID0gb3BlbmVySW5sLnNvdXJjZXBvc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZXJTdGFydFBvcyA9IGNsb3NlcklubC5zb3VyY2Vwb3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnNvdXJjZXBvcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlbmVyRW5kUG9zWzBdLCBvcGVuZXJFbmRQb3NbMV0gLSB1c2VEZWxpbXMgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xvc2VyU3RhcnRQb3NbMF0sIGNsb3NlclN0YXJ0UG9zWzFdICsgdXNlRGVsaW1zIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLnNvdXJjZXBvc1sxXVsxXSAtPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwuc291cmNlcG9zWzBdWzFdICs9IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5saXRlcmFsID0gb3BlbmVySW5sLmxpdGVyYWwuc2xpY2UodXNlRGVsaW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubC5saXRlcmFsID0gY2xvc2VySW5sLmxpdGVyYWwuc2xpY2UodXNlRGVsaW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5udW1kZWxpbXMgLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm51bWRlbGltcyAtPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdXNlZCBkZWxpbWl0ZXJzIGZyb20gc3RhY2sgZWx0cyBhbmQgaW5saW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IG9wZW5lcklubC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodG1wICYmIHRtcCAhPT0gY2xvc2VySW5sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRtcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKHRtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGN1c3RvbSBpbmxpbmUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlcmNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5ld05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRleHROb2RlLmxpdGVyYWwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBsaXRlcmFsLnNwbGl0KC9cXHMvKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmluZm8gPSBpbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaXRlcmFsLmxlbmd0aCA8PSBpbmZvLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnNvdXJjZXBvc1swXVsxXSArPSBpbmZvLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUubGl0ZXJhbCA9IGxpdGVyYWwucmVwbGFjZShpbmZvICsgXCIgXCIsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwuaW5zZXJ0QWZ0ZXIobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWx0cyBiZXR3ZWVuIG9wZW5lciBhbmQgY2xvc2VyIGluIGRlbGltaXRlcnMgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyc0JldHdlZW4ob3BlbmVyLCBjbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3BlbmVyIGhhcyAwIGRlbGltcywgcmVtb3ZlIGl0IGFuZCB0aGUgaW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBvcGVuZXIgaGFzIDEgZGVsaW1zIGFuZCBjaGFyYWN0ZXIgaXMgdGlsZGUsIHJlbW92ZSBkZWxpbWl0ZXIgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5udW1kZWxpbXMgPD0gZW1wdHlEZWxpbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKG9wZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbG9zZXIgaGFzIDAgZGVsaW1zLCByZW1vdmUgaXQgYW5kIHRoZSBpbmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNsb3NlciBoYXMgMSBkZWxpbXMgYW5kIGNoYXJhY3RlciBpcyB0aWxkZSwgcmVtb3ZlIGRlbGltaXRlciBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyLm51bWRlbGltcyA8PSBlbXB0eURlbGltcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXIubnVtZGVsaW1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlcklubC51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBzdGFjayA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKGNsb3Nlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gdGVtcHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX1NJTkdMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxOSc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDE4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VyY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDFEJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMUMnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5lckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBmb3IgZnV0dXJlIHNlYXJjaGVzIGZvciBvcGVuZXJzOlxuICAgICAgICAgICAgICAgICAgICBvcGVuZXJzQm90dG9tW2Nsb3NlcmNjXVtjbG9zZXJFbXBoID8gb2xkQ2xvc2VyLm9yaWdkZWxpbXMgJSAzIDogMF0gPSBvbGRDbG9zZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2xvc2VyLmNhbk9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiByZW1vdmUgYSBjbG9zZXIgdGhhdCBjYW4ndCBiZSBhbiBvcGVuZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmNlIHdlJ3ZlIHNlZW4gdGhlcmUncyBubyBtYXRjaGluZyBvcGVuZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihvbGRDbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZGVsaW1pdGVyc1xuICAgICAgICB3aGlsZSAodGhpcy5kZWxpbWl0ZXJzICE9PSBudWxsICYmIHRoaXMuZGVsaW1pdGVycyAhPT0gc3RhY2tCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRGVsaW1pdGVyKHRoaXMuZGVsaW1pdGVycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgbGluayB0aXRsZSAoc2FucyBxdW90ZXMpLCByZXR1cm5pbmcgdGhlIHN0cmluZ1xuICAgIC8vIG9yIG51bGwgaWYgbm8gbWF0Y2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpdGxlID0gdGhpcy5tYXRjaChyZUxpbmtUaXRsZSk7XG4gICAgICAgIGlmICh0aXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hvcCBvZmYgcXVvdGVzIGZyb20gdGl0bGUgYW5kIHVuZXNjYXBlOlxuICAgICAgICByZXR1cm4gdW5lc2NhcGVTdHJpbmcodGl0bGUuc3Vic3RyKDEsIHRpdGxlLmxlbmd0aCAtIDIpKTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgbGluayBkZXN0aW5hdGlvbiwgcmV0dXJuaW5nIHRoZSBzdHJpbmcgb3IgbnVsbCBpZiBubyBtYXRjaC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5tYXRjaChyZUxpbmtEZXN0aW5hdGlvbkJyYWNlcyk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19MRVNTVEhBTiQxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAVE9ETyBoYW5kcm9sbGVkIHBhcnNlcjsgcmVzIHNob3VsZCBiZSBudWxsIG9yIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBzYXZlcG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgb3BlbnBhcmVucyA9IDA7XG4gICAgICAgICAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHdoaWxlICgoYyA9IHRoaXMucGVlaygpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gQ19CQUNLU0xBU0ggJiYgcmVFc2NhcGFibGUudGVzdCh0aGlzLnN1YmplY3QuY2hhckF0KHRoaXMucG9zICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5wYXJlbnMgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gQ19DTE9TRV9QQVJFTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbnBhcmVucyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5wYXJlbnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZVdoaXRlc3BhY2VDaGFyLmV4ZWMoZnJvbUNvZGVQb2ludCQxKGMpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBzYXZlcG9zICYmIGMgIT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVucGFyZW5zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSB0aGlzLnN1YmplY3Quc3Vic3RyKHNhdmVwb3MsIHRoaXMucG9zIC0gc2F2ZXBvcyk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcykpO1xuICAgICAgICB9IC8vIGNob3Agb2ZmIHN1cnJvdW5kaW5nIDwuLj46XG4gICAgICAgIHJldHVybiBub3JtYWxpemVVUkkodW5lc2NhcGVTdHJpbmcocmVzLnN1YnN0cigxLCByZXMubGVuZ3RoIC0gMikpKTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSBsaW5rIGxhYmVsLCByZXR1cm5pbmcgbnVtYmVyIG9mIGNoYXJhY3RlcnMgcGFyc2VkLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5tYXRjaChyZUxpbmtMYWJlbCk7XG4gICAgICAgIGlmIChtID09PSBudWxsIHx8IG0ubGVuZ3RoID4gMTAwMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0ubGVuZ3RoO1xuICAgIH07XG4gICAgLy8gQWRkIG9wZW4gYnJhY2tldCB0byBkZWxpbWl0ZXIgc3RhY2sgYW5kIGFkZCBhIHRleHQgbm9kZSB0byBibG9jaydzIGNoaWxkcmVuLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VPcGVuQnJhY2tldCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZXh0JDEoJ1snLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgdGhpcy5hZGRCcmFja2V0KG5vZGUsIHN0YXJ0cG9zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gSUYgbmV4dCBjaGFyYWN0ZXIgaXMgWywgYW5kICEgZGVsaW1pdGVyIHRvIGRlbGltaXRlciBzdGFjayBhbmRcbiAgICAvLyBhZGQgYSB0ZXh0IG5vZGUgdG8gYmxvY2sncyBjaGlsZHJlbi4gIE90aGVyd2lzZSBqdXN0IGFkZCBhIHRleHQgbm9kZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFuZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX09QRU5fQlJBQ0tFVCQxKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0ZXh0JDEoJyFbJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MgLSAxLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAvLyBBZGQgZW50cnkgdG8gc3RhY2sgZm9yIHRoaXMgb3BlbmVyXG4gICAgICAgICAgICB0aGlzLmFkZEJyYWNrZXQobm9kZSwgc3RhcnRwb3MgKyAxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGV4dCQxKCchJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFRyeSB0byBtYXRjaCBjbG9zZSBicmFja2V0IGFnYWluc3QgYW4gb3BlbmluZyBpbiB0aGUgZGVsaW1pdGVyXG4gICAgLy8gc3RhY2suICBBZGQgZWl0aGVyIGEgbGluayBvciBpbWFnZSwgb3IgYSBwbGFpbiBbIGNoYXJhY3RlcixcbiAgICAvLyB0byBibG9jaydzIGNoaWxkcmVuLiAgSWYgdGhlcmUgaXMgYSBtYXRjaGluZyBkZWxpbWl0ZXIsXG4gICAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGRlbGltaXRlciBzdGFjay5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xvc2VCcmFja2V0ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBkZXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIGdldCBsYXN0IFsgb3IgIVtcbiAgICAgICAgdmFyIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG4gICAgICAgIGlmIChvcGVuZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vIG1hdGNoZWQgb3BlbmVyLCBqdXN0IHJldHVybiBhIGxpdGVyYWxcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMSgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BlbmVyLmFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gbm8gbWF0Y2hlZCBvcGVuZXIsIGp1c3QgcmV0dXJuIGEgbGl0ZXJhbFxuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKCddJywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHN0YXJ0cG9zKSkpO1xuICAgICAgICAgICAgLy8gdGFrZSBvcGVuZXIgb2ZmIGJyYWNrZXRzIHN0YWNrXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJyYWNrZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdvdCBoZXJlLCBvcGVuIGlzIGEgcG90ZW50aWFsIG9wZW5lclxuICAgICAgICB2YXIgaXNJbWFnZSA9IG9wZW5lci5pbWFnZTtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBsaW5rL2ltYWdlXG4gICAgICAgIHZhciBzYXZlcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIElubGluZSBsaW5rP1xuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfT1BFTl9QQVJFTikge1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgIGlmICh0aGlzLnNwbmwoKSAmJlxuICAgICAgICAgICAgICAgIChkZXN0ID0gdGhpcy5wYXJzZUxpbmtEZXN0aW5hdGlvbigpKSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgYSBzcGFjZSBiZWZvcmUgdGhlIHRpdGxlOlxuICAgICAgICAgICAgICAgICgocmVXaGl0ZXNwYWNlQ2hhci50ZXN0KHRoaXMuc3ViamVjdC5jaGFyQXQodGhpcy5wb3MgLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRpdGxlID0gdGhpcy5wYXJzZUxpbmtUaXRsZSgpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNwbmwoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMucGVlaygpID09PSBDX0NMT1NFX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc2F2ZXBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmTGFiZWwgPSAnJztcbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICAgICAgICAvLyBOZXh0LCBzZWUgaWYgdGhlcmUncyBhIGxpbmsgbGFiZWxcbiAgICAgICAgICAgIHZhciBiZWZvcmVsYWJlbCA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnBhcnNlTGlua0xhYmVsKCk7XG4gICAgICAgICAgICBpZiAobiA+IDIpIHtcbiAgICAgICAgICAgICAgICByZWZMYWJlbCA9IHRoaXMuc3ViamVjdC5zbGljZShiZWZvcmVsYWJlbCwgYmVmb3JlbGFiZWwgKyBuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFvcGVuZXIuYnJhY2tldEFmdGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgb3IgbWlzc2luZyBzZWNvbmQgbGFiZWwgbWVhbnMgdG8gdXNlIHRoZSBmaXJzdCBsYWJlbCBhcyB0aGUgcmVmZXJlbmNlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZWZlcmVuY2UgbXVzdCBub3QgY29udGFpbiBhIGJyYWNrZXQuIElmIHdlIGtub3cgdGhlcmUncyBhIGJyYWNrZXQsIHdlIGRvbid0IGV2ZW4gYm90aGVyIGNoZWNraW5nIGl0LlxuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gdGhpcy5zdWJqZWN0LnNsaWNlKG9wZW5lci5pbmRleCwgc3RhcnRwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzaG9ydGN1dCByZWZlcmVuY2UgbGluaywgcmV3aW5kIGJlZm9yZSBzcGFjZXMgd2Ugc2tpcHBlZC5cbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHNhdmVwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVmTGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZWZMYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShyZWZMYWJlbCk7XG4gICAgICAgICAgICAgICAgLy8gbG9va3VwIHJhd2xhYmVsIGluIHJlZk1hcFxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5yZWZNYXBbcmVmTGFiZWxdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3QgPSBsaW5rLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGxpbmsudGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlJDEoaXNJbWFnZSA/ICdpbWFnZScgOiAnbGluaycpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IGRlc3Q7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gdGl0bGUgfHwgJyc7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvcyA9IFtvcGVuZXIuc3RhcnRwb3MsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zKV07XG4gICAgICAgICAgICB2YXIgdG1wID0gb3BlbmVyLm5vZGUubmV4dDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKHRtcCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0bXAubmV4dDtcbiAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VtcGhhc2lzKG9wZW5lci5wcmV2aW91c0RlbGltaXRlcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJyYWNrZXQoKTtcbiAgICAgICAgICAgIG9wZW5lci5ub2RlLnVubGluaygpO1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlIHRoaXMgYnJhY2tldCBhbmQgcHJvY2Vzc0VtcGhhc2lzIHdpbGwgcmVtb3ZlIGxhdGVyIGRlbGltaXRlcnMuXG4gICAgICAgICAgICAvLyBOb3csIGZvciBhIGxpbmssIHdlIGFsc28gZGVhY3RpdmF0ZSBlYXJsaWVyIGxpbmsgb3BlbmVycy5cbiAgICAgICAgICAgIC8vIChubyBsaW5rcyBpbiBsaW5rcylcbiAgICAgICAgICAgIGlmICghaXNJbWFnZSkge1xuICAgICAgICAgICAgICAgIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZW5lci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLmFjdGl2ZSA9IGZhbHNlOyAvLyBkZWFjdGl2YXRlIHRoaXMgb3BlbmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcFtibG9jay5pZF0gPSB7IG5vZGU6IGJsb2NrLCByZWZMYWJlbDogcmVmTGFiZWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIG5vIG1hdGNoXG4gICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpOyAvLyByZW1vdmUgdGhpcyBvcGVuZXIgZnJvbSBzdGFja1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZCh0ZXh0JDEoJ10nLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwW2Jsb2NrLmlkXSA9IHsgbm9kZTogYmxvY2ssIHJlZkxhYmVsOiByZWZMYWJlbCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5hZGRCcmFja2V0ID0gZnVuY3Rpb24gKG5vZGUsIGluZGV4LCBpbWFnZSkge1xuICAgICAgICBpZiAodGhpcy5icmFja2V0cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5icmFja2V0cy5icmFja2V0QWZ0ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnJhY2tldHMgPSB7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgc3RhcnRwb3M6IHRoaXMuc291cmNlcG9zKGluZGV4ICsgKGltYWdlID8gMCA6IDEpKSxcbiAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmJyYWNrZXRzLFxuICAgICAgICAgICAgcHJldmlvdXNEZWxpbWl0ZXI6IHRoaXMuZGVsaW1pdGVycyxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucmVtb3ZlQnJhY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnJhY2tldHMpIHtcbiAgICAgICAgICAgIHRoaXMuYnJhY2tldHMgPSB0aGlzLmJyYWNrZXRzLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGFuIGVudGl0eS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlRW50aXR5ID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVFbnRpdHlIZXJlKSkpIHtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKHRleHQkMShsaWIuZGVjb2RlSFRNTChtKSwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBydW4gb2Ygb3JkaW5hcnkgY2hhcmFjdGVycywgb3IgYSBzaW5nbGUgY2hhcmFjdGVyIHdpdGhcbiAgICAvLyBhIHNwZWNpYWwgbWVhbmluZyBpbiBtYXJrZG93biwgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICBpZiAoKG0gPSB0aGlzLm1hdGNoKHJlTWFpbikpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpdCA9IG0ucmVwbGFjZShyZUVsbGlwc2VzLCAnXFx1MjAyNicpLnJlcGxhY2UocmVEYXNoLCBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW1Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFycy5sZW5ndGggJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc2libGUgYnkgMywgdXNlIGFsbCBlbSBkYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSBjaGFycy5sZW5ndGggLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzaWJsZSBieSAyLCB1c2UgYWxsIGVuIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5Db3VudCA9IGNoYXJzLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhcnMubGVuZ3RoICUgMyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgMiBleHRyYSBkYXNoZXMsIHVzZSBlbiBkYXNoIGZvciBsYXN0IDI7IGVtIGRhc2hlcyBmb3IgcmVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gKGNoYXJzLmxlbmd0aCAtIDIpIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBlbiBkYXNoZXMgZm9yIGxhc3QgNCBoeXBoZW5zOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IChjaGFycy5sZW5ndGggLSA0KSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCgnXFx1MjAxNCcsIGVtQ291bnQpICsgcmVwZWF0KCdcXHUyMDEzJywgZW5Db3VudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKGxpdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0ZXh0JDEobSwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBhIG5ld2xpbmUuICBJZiBpdCB3YXMgcHJlY2VkZWQgYnkgdHdvIHNwYWNlcywgcmV0dXJuIGEgaGFyZFxuICAgIC8vIGxpbmUgYnJlYWs7IG90aGVyd2lzZSBhIHNvZnQgbGluZSBicmVhay5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTmV3bGluZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB0aGlzLnBvcyArPSAxOyAvLyBhc3N1bWUgd2UncmUgYXQgYSBcXG5cbiAgICAgICAgLy8gY2hlY2sgcHJldmlvdXMgbm9kZSBmb3IgdHJhaWxpbmcgc3BhY2VzXG4gICAgICAgIHZhciBsYXN0YyA9IGJsb2NrLmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKGxhc3RjICYmIGxhc3RjLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0Yy5saXRlcmFsW2xhc3RjLmxpdGVyYWwubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgICAgICAgdmFyIGhhcmRicmVhayA9IGxhc3RjLmxpdGVyYWxbbGFzdGMubGl0ZXJhbC5sZW5ndGggLSAyXSA9PT0gJyAnO1xuICAgICAgICAgICAgdmFyIGxpdExlbiA9IGxhc3RjLmxpdGVyYWwubGVuZ3RoO1xuICAgICAgICAgICAgbGFzdGMubGl0ZXJhbCA9IGxhc3RjLmxpdGVyYWwucmVwbGFjZShyZUZpbmFsU3BhY2UsICcnKTtcbiAgICAgICAgICAgIHZhciBmaW5hbFNwYWNlTGVuID0gbGl0TGVuIC0gbGFzdGMubGl0ZXJhbC5sZW5ndGg7XG4gICAgICAgICAgICBsYXN0Yy5zb3VyY2Vwb3NbMV1bMV0gLT0gZmluYWxTcGFjZUxlbjtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGNyZWF0ZU5vZGUkMShoYXJkYnJlYWsgPyAnbGluZWJyZWFrJyA6ICdzb2Z0YnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIGZpbmFsU3BhY2VMZW4sIHRoaXMucG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZSQxKCdzb2Z0YnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICB0aGlzLm1hdGNoKHJlSW5pdGlhbFNwYWNlKTsgLy8gZ29iYmxlIGxlYWRpbmcgc3BhY2VzIGluIG5leHQgbGluZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSBsaW5rIHJlZmVyZW5jZSwgbW9kaWZ5aW5nIHJlZm1hcC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24gKGJsb2NrLCByZWZNYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB2YXIgdGl0bGUgPSBudWxsO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gbGFiZWw6XG4gICAgICAgIHZhciBtYXRjaENoYXJzID0gdGhpcy5wYXJzZUxpbmtMYWJlbCgpO1xuICAgICAgICBpZiAobWF0Y2hDaGFycyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhd2xhYmVsID0gdGhpcy5zdWJqZWN0LnN1YnN0cigwLCBtYXRjaENoYXJzKTtcbiAgICAgICAgLy8gY29sb246XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19DT0xPTikge1xuICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyAgbGluayB1cmxcbiAgICAgICAgdGhpcy5zcG5sKCk7XG4gICAgICAgIHZhciBkZXN0ID0gdGhpcy5wYXJzZUxpbmtEZXN0aW5hdGlvbigpO1xuICAgICAgICBpZiAoZGVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWZvcmV0aXRsZSA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnNwbmwoKTtcbiAgICAgICAgaWYgKHRoaXMucG9zICE9PSBiZWZvcmV0aXRsZSkge1xuICAgICAgICAgICAgdGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgLy8gcmV3aW5kIGJlZm9yZSBzcGFjZXNcbiAgICAgICAgICAgIHRoaXMucG9zID0gYmVmb3JldGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlJ3JlIGF0IGxpbmUgZW5kOlxuICAgICAgICB2YXIgYXRMaW5lRW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2gocmVTcGFjZUF0RW5kT2ZMaW5lKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRpdGxlID09PSAnJykge1xuICAgICAgICAgICAgICAgIGF0TGluZUVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBvdGVudGlhbCB0aXRsZSB3ZSBmb3VuZCBpcyBub3QgYXQgdGhlIGxpbmUgZW5kLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpdCBjb3VsZCBzdGlsbCBiZSBhIGxlZ2FsIGxpbmsgcmVmZXJlbmNlIGlmIHdlXG4gICAgICAgICAgICAgICAgLy8gZGlzY2FyZCB0aGUgdGl0bGVcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgICAgIC8vIHJld2luZCBiZWZvcmUgc3BhY2VzXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBiZWZvcmV0aXRsZTtcbiAgICAgICAgICAgICAgICAvLyBhbmQgaW5zdGVhZCBjaGVjayBpZiB0aGUgbGluayBVUkwgaXMgYXQgdGhlIGxpbmUgZW5kXG4gICAgICAgICAgICAgICAgYXRMaW5lRW5kID0gdGhpcy5tYXRjaChyZVNwYWNlQXRFbmRPZkxpbmUpICE9PSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXRMaW5lRW5kKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vcm1hbExhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHJhd2xhYmVsKTtcbiAgICAgICAgaWYgKG5vcm1hbExhYmVsID09PSAnJykge1xuICAgICAgICAgICAgLy8gbGFiZWwgbXVzdCBjb250YWluIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlcG9zID0gdGhpcy5nZXRSZWZlcmVuY2VEZWZTb3VyY2Vwb3MoYmxvY2spO1xuICAgICAgICBibG9jay5zb3VyY2Vwb3NbMF1bMF0gPSBzb3VyY2Vwb3NbMV1bMF0gKyAxO1xuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUkMSgncmVmRGVmJywgc291cmNlcG9zKTtcbiAgICAgICAgbm9kZS50aXRsZSA9IHRpdGxlO1xuICAgICAgICBub2RlLmRlc3QgPSBkZXN0O1xuICAgICAgICBub2RlLmxhYmVsID0gbm9ybWFsTGFiZWw7XG4gICAgICAgIGJsb2NrLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgaWYgKCFyZWZNYXBbbm9ybWFsTGFiZWxdKSB7XG4gICAgICAgICAgICByZWZNYXBbbm9ybWFsTGFiZWxdID0gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcFtub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zIC0gc3RhcnRwb3M7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLm1lcmdlVGV4dE5vZGVzID0gZnVuY3Rpb24gKHdhbGtlcikge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIHZhciB0ZXh0Tm9kZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICB2YXIgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZywgbm9kZSA9IGV2ZW50Lm5vZGU7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcgJiYgbm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZSA9IHRleHROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUuc291cmNlcG9zICYmIGxhc3ROb2RlLnNvdXJjZXBvcykge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vZGUuc291cmNlcG9zWzFdID0gbGFzdE5vZGUuc291cmNlcG9zWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaXJzdE5vZGUubmV4dCA9IGxhc3ROb2RlLm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5uZXh0LnByZXYgPSBmaXJzdE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGV4dE5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5saXRlcmFsICs9IHRleHROb2Rlc1tpXS5saXRlcmFsO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZXNbaV0udW5saW5rKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHROb2RlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmdldFJlZmVyZW5jZURlZlNvdXJjZXBvcyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbGluZXMgPSBibG9jay5zdHJpbmdDb250ZW50LnNwbGl0KC9cXG58XFxyXFxuLyk7XG4gICAgICAgIHZhciBwYXNzZWRVcmxMaW5lID0gZmFsc2U7XG4gICAgICAgIHZhciBxdW90YXRpb25Db3VudCA9IDA7XG4gICAgICAgIHZhciBsYXN0TGluZU9mZnNldCA9IHsgbGluZTogMCwgY2g6IDAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIGlmIChyZVdoaXRlc3BhY2VDaGFyLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvXFw6Ly50ZXN0KGxpbmUpICYmIHF1b3RhdGlvbkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3NlZFVybExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gbGluZS5pbmRleE9mKCc6JykgPT09IGxpbmUubGVuZ3RoIC0gMSA/IGkgKyAxIDogaTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZU9mZnNldCA9IHsgbGluZTogbGluZU9mZnNldCwgY2g6IGxpbmVzW2xpbmVPZmZzZXRdLmxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIHBhc3NlZFVybExpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2hvdWxkIGNvbnNpZGVyIGV4dGVuZGFibGUgdGl0bGVcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gbGluZS5tYXRjaCgvJ3xcIi9nKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgcXVvdGF0aW9uQ291bnQgKz0gbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocXVvdGF0aW9uQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBsYXN0TGluZU9mZnNldCA9IHsgbGluZTogaSwgY2g6IGxpbmUubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtibG9jay5zb3VyY2Vwb3NbMF1bMF0sIGJsb2NrLnNvdXJjZXBvc1swXVsxXV0sXG4gICAgICAgICAgICBbYmxvY2suc291cmNlcG9zWzBdWzBdICsgbGFzdExpbmVPZmZzZXQubGluZSwgbGFzdExpbmVPZmZzZXQuY2hdLFxuICAgICAgICBdO1xuICAgIH07XG4gICAgLy8gUGFyc2UgdGhlIG5leHQgaW5saW5lIGVsZW1lbnQgaW4gc3ViamVjdCwgYWR2YW5jaW5nIHN1YmplY3QgcG9zaXRpb24uXG4gICAgLy8gT24gc3VjY2VzcywgYWRkIHRoZSByZXN1bHQgdG8gYmxvY2sncyBjaGlsZHJlbiBhbmQgcmV0dXJuIHRydWUuXG4gICAgLy8gT24gZmFpbHVyZSwgcmV0dXJuIGZhbHNlLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcmVzID0gZmFsc2U7XG4gICAgICAgIHZhciBjID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChjID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBDX05FV0xJTkU6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZU5ld2xpbmUoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBQ0tTTEFTSDpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQmFja3NsYXNoKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19CQUNLVElDSzpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQmFja3RpY2tzKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19BU1RFUklTSzpcbiAgICAgICAgICAgIGNhc2UgQ19VTkRFUlNDT1JFOlxuICAgICAgICAgICAgY2FzZSBDX1RJTERFOlxuICAgICAgICAgICAgY2FzZSBDX0RPTExBUjpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLmhhbmRsZURlbGltKGMsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19TSU5HTEVRVU9URTpcbiAgICAgICAgICAgIGNhc2UgQ19ET1VCTEVRVU9URTpcbiAgICAgICAgICAgICAgICByZXMgPSAhISgoX2EgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbWFydCkgJiYgdGhpcy5oYW5kbGVEZWxpbShjLCBibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfT1BFTl9CUkFDS0VUJDE6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZU9wZW5CcmFja2V0KGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19CQU5HOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYW5nKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19DTE9TRV9CUkFDS0VUOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VDbG9zZUJyYWNrZXQoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0xFU1NUSEFOJDE6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUF1dG9saW5rKGJsb2NrKSB8fCB0aGlzLnBhcnNlSHRtbFRhZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgIGlmICghYmxvY2suZGlzYWJsZWRFbnRpdHlQYXJzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlRW50aXR5KGJsb2NrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VTdHJpbmcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQodGV4dCQxKGZyb21Db2RlUG9pbnQkMShjKSwgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zICsgMSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIHN0cmluZyBjb250ZW50IGluIGJsb2NrIGludG8gaW5saW5lIGNoaWxkcmVuLFxuICAgIC8vIHVzaW5nIHJlZm1hcCB0byByZXNvbHZlIHJlZmVyZW5jZXMuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBibG9jay5zdHJpbmdDb250ZW50LnRyaW0oKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJyYWNrZXRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5saW5lT2Zmc2V0cyA9IGJsb2NrLmxpbmVPZmZzZXRzIHx8IFswXTtcbiAgICAgICAgdGhpcy5saW5lSWR4ID0gMDtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5saW5lU3RhcnROdW0gPSBibG9jay5zb3VyY2Vwb3NbMF1bMF07XG4gICAgICAgIGlmIChpc0hlYWRpbmcoYmxvY2spKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVPZmZzZXRzWzBdICs9IGJsb2NrLmxldmVsICsgMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5wYXJzZUlubGluZShibG9jaykpIHsgfVxuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgcmF3IHN0cmluZyB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICB0aGlzLnByb2Nlc3NFbXBoYXNpcyhudWxsKTtcbiAgICAgICAgdGhpcy5tZXJnZVRleHROb2RlcyhibG9jay53YWxrZXIoKSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgZXh0ZW5kZWRBdXRvbGlua3MgPSBfYS5leHRlbmRlZEF1dG9saW5rcywgY3VzdG9tUGFyc2VyID0gX2EuY3VzdG9tUGFyc2VyO1xuICAgICAgICBpZiAoZXh0ZW5kZWRBdXRvbGlua3MpIHtcbiAgICAgICAgICAgIGNvbnZlcnRFeHRBdXRvTGlua3MoYmxvY2sud2Fsa2VyKCksIGV4dGVuZGVkQXV0b2xpbmtzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzdG9tUGFyc2VyICYmIGJsb2NrLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBldmVudF8xO1xuICAgICAgICAgICAgdmFyIHdhbGtlciA9IGJsb2NrLmZpcnN0Q2hpbGQud2Fsa2VyKCk7XG4gICAgICAgICAgICB3aGlsZSAoKGV2ZW50XzEgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnRfMS5ub2RlLCBlbnRlcmluZyA9IGV2ZW50XzEuZW50ZXJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbVBhcnNlcltub2RlLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVBhcnNlcltub2RlLnR5cGVdKG5vZGUsIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW5saW5lUGFyc2VyO1xufSgpKTtcblxudmFyIHJlVGFza0xpc3RJdGVtTWFya2VyID0gL15cXFsoWyBcXHR4WF0pXFxdWyBcXHRdKy87XG4vLyBmaW5hbGl6ZSBmb3IgYmxvY2sgaGFuZGxlclxuZnVuY3Rpb24gdGFza0xpc3RJdGVtRmluYWxpemUoXywgYmxvY2spIHtcbiAgICBpZiAoYmxvY2suZmlyc3RDaGlsZCAmJiBibG9jay5maXJzdENoaWxkLnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgIHZhciBwID0gYmxvY2suZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG0gPSBwLnN0cmluZ0NvbnRlbnQubWF0Y2gocmVUYXNrTGlzdEl0ZW1NYXJrZXIpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIG1MZW4gPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHAuc3RyaW5nQ29udGVudCA9IHAuc3RyaW5nQ29udGVudC5zdWJzdHJpbmcobUxlbiAtIDEpO1xuICAgICAgICAgICAgcC5zb3VyY2Vwb3NbMF1bMV0gKz0gbUxlbjtcbiAgICAgICAgICAgIHAubGluZU9mZnNldHNbMF0gKz0gbUxlbjtcbiAgICAgICAgICAgIGJsb2NrLmxpc3REYXRhLnRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgYmxvY2subGlzdERhdGEuY2hlY2tlZCA9IC9beFhdLy50ZXN0KG1bMV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgdGFibGUgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVIZWFkJyB8fCB0ID09PSAndGFibGVCb2R5JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlQm9keSQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlUm93JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlSGVhZCQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVSb3cnIHx8IHQgPT09ICd0YWJsZURlbGltUm93JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlRGVsaW1Sb3cgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZURlbGltQ2VsbCc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZURlbGltQ2VsbCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlUm93ID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVDZWxsJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlQ2VsbCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xuXG52YXIgQ09ERV9JTkRFTlQgPSA0O1xudmFyIENfVEFCID0gOTtcbnZhciBDX0dSRUFURVJUSEFOID0gNjI7XG52YXIgQ19MRVNTVEhBTiA9IDYwO1xudmFyIENfU1BBQ0UgPSAzMjtcbnZhciBDX09QRU5fQlJBQ0tFVCA9IDkxO1xudmFyIHJlTm9uU3BhY2UgPSAvW14gXFx0XFxmXFx2XFxyXFxuXS87XG52YXIgcmVDbG9zaW5nQ29kZUZlbmNlID0gL14oPzpgezMsfXx+ezMsfSkoPz0gKiQpLztcbi8vIFJldHVybnMgdHJ1ZSBpZiBibG9jayBlbmRzIHdpdGggYSBibGFuayBsaW5lLCBkZXNjZW5kaW5nIGlmIG5lZWRlZFxuLy8gaW50byBsaXN0cyBhbmQgc3VibGlzdHMuXG5mdW5jdGlvbiBlbmRzV2l0aEJsYW5rTGluZShibG9jaykge1xuICAgIHZhciBjdXJCbG9jayA9IGJsb2NrO1xuICAgIHdoaWxlIChjdXJCbG9jaykge1xuICAgICAgICBpZiAoY3VyQmxvY2subGFzdExpbmVCbGFuaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSBjdXJCbG9jay50eXBlO1xuICAgICAgICBpZiAoIWN1ckJsb2NrLmxhc3RMaW5lQ2hlY2tlZCAmJiAodCA9PT0gJ2xpc3QnIHx8IHQgPT09ICdpdGVtJykpIHtcbiAgICAgICAgICAgIGN1ckJsb2NrLmxhc3RMaW5lQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBjdXJCbG9jayA9IGN1ckJsb2NrLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ckJsb2NrLmxhc3RMaW5lQ2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwZWVrKGxuLCBwb3MpIHtcbiAgICBpZiAocG9zIDwgbG4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBsbi5jaGFyQ29kZUF0KHBvcyk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJldHVybnMgdHJ1ZSBpZiBzdHJpbmcgY29udGFpbnMgb25seSBzcGFjZSBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gaXNCbGFuayhzKSB7XG4gICAgcmV0dXJuICFyZU5vblNwYWNlLnRlc3Qocyk7XG59XG5mdW5jdGlvbiBpc1NwYWNlT3JUYWIoYykge1xuICAgIHJldHVybiBjID09PSBDX1NQQUNFIHx8IGMgPT09IENfVEFCO1xufVxuXG52YXIgcmVDbG9zaW5nQ3VzdG9tQmxvY2sgPSAvXlxcJFxcJCQvO1xudmFyIGN1c3RvbUJsb2NrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgbGluZSA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChyZUNsb3NpbmdDdXN0b21CbG9jayk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gY2xvc2luZyBjdXN0b20gYmxvY2tcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIEZpbmlzaGVkICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgb3B0aW9uYWwgc3BhY2VzIG9mIGN1c3RvbSBibG9jayBvZmZzZXRcbiAgICAgICAgdmFyIGkgPSBjb250YWluZXIub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoaSA+IDAgJiYgaXNTcGFjZU9yVGFiKHBlZWsobGluZSwgcGFyc2VyLm9mZnNldCkpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCB0cnVlKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJzdCBsaW5lIGJlY29tZXMgaW5mbyBzdHJpbmdcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBibG9jay5zdHJpbmdDb250ZW50O1xuICAgICAgICB2YXIgbmV3bGluZVBvcyA9IGNvbnRlbnQuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBjb250ZW50LnNsaWNlKDAsIG5ld2xpbmVQb3MpO1xuICAgICAgICB2YXIgcmVzdCA9IGNvbnRlbnQuc2xpY2UobmV3bGluZVBvcyArIDEpO1xuICAgICAgICB2YXIgaW5mb1N0cmluZyA9IGZpcnN0TGluZS5tYXRjaCgvXihcXHMqKSguKikvKTtcbiAgICAgICAgYmxvY2suaW5mbyA9IHVuZXNjYXBlU3RyaW5nKGluZm9TdHJpbmdbMl0udHJpbSgpKTtcbiAgICAgICAgYmxvY2subGl0ZXJhbCA9IHJlc3Q7XG4gICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBudWxsO1xuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xuXG52YXIgbm9vcCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgZG9jdW1lbnQkMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGxpc3QgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYmxvY2suZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBub24tZmluYWwgbGlzdCBpdGVtIGVuZGluZyB3aXRoIGJsYW5rIGxpbmU6XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUoaXRlbSkgJiYgaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBjaGlsZHJlbiBvZiBsaXN0IGl0ZW0sIHRvIHNlZSBpZiB0aGVyZSBhcmVcbiAgICAgICAgICAgIC8vIHNwYWNlcyBiZXR3ZWVuIGFueSBvZiB0aGVtOlxuICAgICAgICAgICAgdmFyIHN1Yml0ZW0gPSBpdGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoc3ViaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShzdWJpdGVtKSAmJiAoaXRlbS5uZXh0IHx8IHN1Yml0ZW0ubmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yml0ZW0gPSBzdWJpdGVtLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5uZXh0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgYmxvY2tRdW90ZSQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHZhciBsbiA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhsbiwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfR1JFQVRFUlRIQU4pIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGl0ZW0gPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBCbGFuayBsaW5lIGFmdGVyIGVtcHR5IGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlci5pbmRlbnQgPj0gY29udGFpbmVyLmxpc3REYXRhLm1hcmtlck9mZnNldCArIGNvbnRhaW5lci5saXN0RGF0YS5wYWRkaW5nKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChjb250YWluZXIubGlzdERhdGEubWFya2VyT2Zmc2V0ICsgY29udGFpbmVyLmxpc3REYXRhLnBhZGRpbmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgaGVhZGluZyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIGhlYWRpbmcgY2FuIG5ldmVyIGNvbnRhaW5lciA+IDEgbGluZSwgc28gZmFpbCB0byBtYXRjaDpcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0aGVtYXRpY0JyZWFrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYSB0aGVtYXRpYyBicmVhayBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGNvZGVCbG9jayA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsbiA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGluZGVudCA9IHBhcnNlci5pbmRlbnQ7XG4gICAgICAgIGlmIChjb250YWluZXIuaXNGZW5jZWQpIHtcbiAgICAgICAgICAgIC8vIGZlbmNlZFxuICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5kZW50IDw9IDMgJiZcbiAgICAgICAgICAgICAgICBsbi5jaGFyQXQocGFyc2VyLm5leHROb25zcGFjZSkgPT09IGNvbnRhaW5lci5mZW5jZUNoYXIgJiZcbiAgICAgICAgICAgICAgICBsbi5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNsb3NpbmdDb2RlRmVuY2UpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+PSBjb250YWluZXIuZmVuY2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9zaW5nIGZlbmNlIC0gd2UncmUgYXQgZW5kIG9mIGxpbmUsIHNvIHdlIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBwYXJzZXIub2Zmc2V0ICsgaW5kZW50ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgb3B0aW9uYWwgc3BhY2VzIG9mIGZlbmNlIG9mZnNldFxuICAgICAgICAgICAgdmFyIGkgPSBjb250YWluZXIuZmVuY2VPZmZzZXQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkXG4gICAgICAgICAgICBpZiAoaW5kZW50ID49IENPREVfSU5ERU5UKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoQ09ERV9JTkRFTlQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2suaXNGZW5jZWQpIHtcbiAgICAgICAgICAgIC8vIGZlbmNlZFxuICAgICAgICAgICAgLy8gZmlyc3QgbGluZSBiZWNvbWVzIGluZm8gc3RyaW5nXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbmV3bGluZVBvcyA9IGNvbnRlbnQuaW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gY29udGVudC5zbGljZSgwLCBuZXdsaW5lUG9zKTtcbiAgICAgICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgICAgICB2YXIgaW5mb1N0cmluZyA9IGZpcnN0TGluZS5tYXRjaCgvXihcXHMqKSguKikvKTtcbiAgICAgICAgICAgIGJsb2NrLmluZm9QYWRkaW5nID0gaW5mb1N0cmluZ1sxXS5sZW5ndGg7XG4gICAgICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICAgICAgYmxvY2subGl0ZXJhbCA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbmRlbnRlZFxuICAgICAgICAgICAgYmxvY2subGl0ZXJhbCA9IChfYSA9IGJsb2NrLnN0cmluZ0NvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oXFxuICopKyQvLCAnXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IEdDXG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgaHRtbEJsb2NrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmJsYW5rICYmIChjb250YWluZXIuaHRtbEJsb2NrVHlwZSA9PT0gNiB8fCBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA9PT0gNylcbiAgICAgICAgICAgID8gMSAvKiBTdG9wICovXG4gICAgICAgICAgICA6IDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYmxvY2subGl0ZXJhbCA9ICgoX2EgPSBibG9jay5zdHJpbmdDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvKFxcbiAqKSskLywgJycpKSB8fCBudWxsO1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBwYXJhZ3JhcGggPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5ibGFuayA/IDEgLyogU3RvcCAqLyA6IDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKHBhcnNlciwgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB2YXIgaGFzUmVmZXJlbmNlRGVmcyA9IGZhbHNlO1xuICAgICAgICAvLyB0cnkgcGFyc2luZyB0aGUgYmVnaW5uaW5nIGFzIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25zOlxuICAgICAgICB3aGlsZSAocGVlayhibG9jay5zdHJpbmdDb250ZW50LCAwKSA9PT0gQ19PUEVOX0JSQUNLRVQgJiZcbiAgICAgICAgICAgIChwb3MgPSBwYXJzZXIuaW5saW5lUGFyc2VyLnBhcnNlUmVmZXJlbmNlKGJsb2NrLCBwYXJzZXIucmVmTWFwKSkpIHtcbiAgICAgICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBibG9jay5zdHJpbmdDb250ZW50LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICBoYXNSZWZlcmVuY2VEZWZzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlRGVmcyAmJiBpc0JsYW5rKGJsb2NrLnN0cmluZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICBibG9jay51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIHJlZkRlZiA9IG5vb3A7XG52YXIgZnJvbnRNYXR0ZXIkMiA9IG5vb3A7XG52YXIgYmxvY2tIYW5kbGVycyA9IHtcbiAgICBkb2N1bWVudDogZG9jdW1lbnQkMSxcbiAgICBsaXN0OiBsaXN0LFxuICAgIGJsb2NrUXVvdGU6IGJsb2NrUXVvdGUkMSxcbiAgICBpdGVtOiBpdGVtLFxuICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgdGhlbWF0aWNCcmVhazogdGhlbWF0aWNCcmVhayQxLFxuICAgIGNvZGVCbG9jazogY29kZUJsb2NrLFxuICAgIGh0bWxCbG9jazogaHRtbEJsb2NrJDEsXG4gICAgcGFyYWdyYXBoOiBwYXJhZ3JhcGgsXG4gICAgdGFibGU6IHRhYmxlLFxuICAgIHRhYmxlQm9keTogdGFibGVCb2R5JDEsXG4gICAgdGFibGVIZWFkOiB0YWJsZUhlYWQkMSxcbiAgICB0YWJsZVJvdzogdGFibGVSb3csXG4gICAgdGFibGVDZWxsOiB0YWJsZUNlbGwsXG4gICAgdGFibGVEZWxpbVJvdzogdGFibGVEZWxpbVJvdyxcbiAgICB0YWJsZURlbGltQ2VsbDogdGFibGVEZWxpbUNlbGwsXG4gICAgcmVmRGVmOiByZWZEZWYsXG4gICAgY3VzdG9tQmxvY2s6IGN1c3RvbUJsb2NrJDEsXG4gICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyJDIsXG59O1xuXG5mdW5jdGlvbiBwYXJzZVJvd0NvbnRlbnQoY29udGVudCkge1xuICAgIHZhciBzdGFydElkeCA9IDA7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjb250ZW50W2ldID09PSAnfCcgJiYgY29udGVudFtpIC0gMV0gIT09ICdcXFxcJykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydElkeCwgaSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRJZHggPT09IDAgJiYgaXNFbXB0eShjZWxsKSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0SWR4ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0SWR4IDwgY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBjb250ZW50LnN1YnN0cmluZyhzdGFydElkeCwgY29udGVudC5sZW5ndGgpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoY2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtvZmZzZXQsIGNlbGxzXTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVGFibGVDZWxscyhjZWxsVHlwZSwgY29udGVudHMsIGxpbmVOdW0sIGNoUG9zKSB7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb250ZW50c18xID0gY29udGVudHM7IF9pIDwgY29udGVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c18xW19pXTtcbiAgICAgICAgdmFyIHByZVNwYWNlcyA9IGNvbnRlbnQubWF0Y2goL15bIFxcdF0rLyk7XG4gICAgICAgIHZhciBwYWRkaW5nTGVmdCA9IHByZVNwYWNlcyA/IHByZVNwYWNlc1swXS5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gdm9pZCAwLCB0cmltbWVkID0gdm9pZCAwO1xuICAgICAgICBpZiAocGFkZGluZ0xlZnQgPT09IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICAgICAgdHJpbW1lZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvc3RTcGFjZXMgPSBjb250ZW50Lm1hdGNoKC9bIFxcdF0rJC8pO1xuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gcG9zdFNwYWNlcyA/IHBvc3RTcGFjZXNbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIHRyaW1tZWQgPSBjb250ZW50LnNsaWNlKHBhZGRpbmdMZWZ0LCBjb250ZW50Lmxlbmd0aCAtIHBhZGRpbmdSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoUG9zU3RhcnQgPSBjaFBvcyArIHBhZGRpbmdMZWZ0O1xuICAgICAgICB2YXIgdGFibGVDZWxsID0gY3JlYXRlTm9kZSQxKGNlbGxUeXBlLCBbXG4gICAgICAgICAgICBbbGluZU51bSwgY2hQb3NdLFxuICAgICAgICAgICAgW2xpbmVOdW0sIGNoUG9zICsgY29udGVudC5sZW5ndGggLSAxXSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlQ2VsbC5zdHJpbmdDb250ZW50ID0gdHJpbW1lZC5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7IC8vIHJlcGxhY2UgZXNhY3BlZCBwaXBlKFxcfClcbiAgICAgICAgdGFibGVDZWxsLnN0YXJ0SWR4ID0gY2VsbHMubGVuZ3RoO1xuICAgICAgICB0YWJsZUNlbGwuZW5kSWR4ID0gY2VsbHMubGVuZ3RoO1xuICAgICAgICB0YWJsZUNlbGwubGluZU9mZnNldHMgPSBbY2hQb3NTdGFydCAtIDFdO1xuICAgICAgICB0YWJsZUNlbGwucGFkZGluZ0xlZnQgPSBwYWRkaW5nTGVmdDtcbiAgICAgICAgdGFibGVDZWxsLnBhZGRpbmdSaWdodCA9IHBhZGRpbmdSaWdodDtcbiAgICAgICAgY2VsbHMucHVzaCh0YWJsZUNlbGwpO1xuICAgICAgICBjaFBvcyArPSBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbn1cbmZ1bmN0aW9uIGdldENvbHVtbkZyb21EZWxpbUNlbGwoY2VsbE5vZGUpIHtcbiAgICB2YXIgYWxpZ24gPSBudWxsO1xuICAgIHZhciBjb250ZW50ID0gY2VsbE5vZGUuc3RyaW5nQ29udGVudDtcbiAgICB2YXIgZmlyc3RDaCA9IGNvbnRlbnRbMF07XG4gICAgdmFyIGxhc3RDaCA9IGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoID09PSAnOicpIHtcbiAgICAgICAgYWxpZ24gPSBmaXJzdENoID09PSAnOicgPyAnY2VudGVyJyA6ICdyaWdodCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Q2ggPT09ICc6Jykge1xuICAgICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9XG4gICAgcmV0dXJuIHsgYWxpZ246IGFsaWduIH07XG59XG52YXIgdGFibGVIZWFkID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIHN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudDtcbiAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdwYXJhZ3JhcGgnICYmICFwYXJzZXIuaW5kZW50ZWQgJiYgIXBhcnNlci5ibGFuaykge1xuICAgICAgICB2YXIgbGFzdE5ld0xpbmVJZHggPSBzdHJpbmdDb250ZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBsYXN0TGluZVN0YXJ0SWR4ID0gc3RyaW5nQ29udGVudC5sYXN0SW5kZXhPZignXFxuJywgbGFzdE5ld0xpbmVJZHggLSAxKSArIDE7XG4gICAgICAgIHZhciBoZWFkZXJDb250ZW50ID0gc3RyaW5nQ29udGVudC5zbGljZShsYXN0TGluZVN0YXJ0SWR4LCBsYXN0TmV3TGluZUlkeCk7XG4gICAgICAgIHZhciBkZWxpbUNvbnRlbnQgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIHZhciBfYSA9IHBhcnNlUm93Q29udGVudChoZWFkZXJDb250ZW50KSwgaGVhZGVyT2Zmc2V0ID0gX2FbMF0sIGhlYWRlckNlbGxzID0gX2FbMV07XG4gICAgICAgIHZhciBfYiA9IHBhcnNlUm93Q29udGVudChkZWxpbUNvbnRlbnQpLCBkZWxpbU9mZnNldCA9IF9iWzBdLCBkZWxpbUNlbGxzID0gX2JbMV07XG4gICAgICAgIHZhciByZVZhbGlkRGVsaW1DZWxsXzEgPSAvXlsgXFx0XSo6Py0rOj9bIFxcdF0qJC87XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGNoZWNraW5nIGlmIHRoZSBudW1iZXIgb2YgaGVhZGVyIGNlbGxzIGFuZCBkZWxpbWl0ZXIgY2VsbHMgYXJlIHRoZSBzYW1lXG4gICAgICAgIC8vIHRvIGNvbnNpZGVyIHRoZSBjYXNlIG9mIG1lcmdlZC1jb2x1bW4gKHZpYSBwbHVnaW4pXG4gICAgICAgICFoZWFkZXJDZWxscy5sZW5ndGggfHxcbiAgICAgICAgICAgICFkZWxpbUNlbGxzLmxlbmd0aCB8fFxuICAgICAgICAgICAgZGVsaW1DZWxscy5zb21lKGZ1bmN0aW9uIChjZWxsKSB7IHJldHVybiAhcmVWYWxpZERlbGltQ2VsbF8xLnRlc3QoY2VsbCk7IH0pIHx8XG4gICAgICAgICAgICAvLyB0byBwcmV2ZW50IHRvIHJlZ2FyZCBzZXRUZXh0SGVhZGluZyBhcyB0YWJlbCBkZWxpbSBjZWxsIHdpdGggJ2Rpc2FsbG93RGVlcEhlYWRpbmcnIG9wdGlvblxuICAgICAgICAgICAgKGRlbGltQ2VsbHMubGVuZ3RoID09PSAxICYmIGRlbGltQ29udGVudC5pbmRleE9mKCd8JykgIT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0cyA9IGNvbnRhaW5lci5saW5lT2Zmc2V0cztcbiAgICAgICAgdmFyIGZpcnN0TGluZU51bSA9IHBhcnNlci5saW5lTnVtYmVyIC0gMTtcbiAgICAgICAgdmFyIGZpcnN0TGluZVN0YXJ0ID0gbGFzdChsaW5lT2Zmc2V0cykgKyAxO1xuICAgICAgICB2YXIgdGFibGUgPSBjcmVhdGVOb2RlJDEoJ3RhYmxlJywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgICAgIHRhYmxlLmNvbHVtbnMgPSBkZWxpbUNlbGxzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBhbGlnbjogbnVsbCB9KTsgfSk7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZnRlcih0YWJsZSk7XG4gICAgICAgIGlmIChsaW5lT2Zmc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ID0gc3RyaW5nQ29udGVudC5zbGljZSgwLCBsYXN0TGluZVN0YXJ0SWR4KTtcbiAgICAgICAgICAgIHZhciBwYXJhTGFzdExpbmVTdGFydElkeCA9IHN0cmluZ0NvbnRlbnQubGFzdEluZGV4T2YoJ1xcbicsIGxhc3RMaW5lU3RhcnRJZHggLSAyKSArIDE7XG4gICAgICAgICAgICB2YXIgcGFyYUxhc3RMaW5lTGVuID0gbGFzdExpbmVTdGFydElkeCAtIHBhcmFMYXN0TGluZVN0YXJ0SWR4IC0gMTtcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IGxpbmVPZmZzZXRzW2xpbmVPZmZzZXRzLmxlbmd0aCAtIDJdICsgcGFyYUxhc3RMaW5lTGVuO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgZmlyc3RMaW5lTnVtIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZF8xID0gY3JlYXRlTm9kZSQxKCd0YWJsZUhlYWQnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5vZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGFibGVIZWFkXzEpO1xuICAgICAgICB2YXIgdGFibGVIZWFkUm93XzEgPSBjcmVhdGVOb2RlJDEoJ3RhYmxlUm93JywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnQgKyBoZWFkZXJDb250ZW50Lmxlbmd0aCAtIDFdLFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHRhYmxlRGVsaW1Sb3dfMSA9IGNyZWF0ZU5vZGUkMSgndGFibGVEZWxpbVJvdycsIFtcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDFdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlSGVhZF8xLmFwcGVuZENoaWxkKHRhYmxlSGVhZFJvd18xKTtcbiAgICAgICAgdGFibGVIZWFkXzEuYXBwZW5kQ2hpbGQodGFibGVEZWxpbVJvd18xKTtcbiAgICAgICAgZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZUNlbGwnLCBoZWFkZXJDZWxscywgZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlck9mZnNldCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgIHRhYmxlSGVhZFJvd18xLmFwcGVuZENoaWxkKGNlbGxOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxpbUNlbGxOb2RlcyA9IGdlbmVyYXRlVGFibGVDZWxscygndGFibGVEZWxpbUNlbGwnLCBkZWxpbUNlbGxzLCBwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDEgKyBkZWxpbU9mZnNldCk7XG4gICAgICAgIGRlbGltQ2VsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNlbGxOb2RlKSB7XG4gICAgICAgICAgICB0YWJsZURlbGltUm93XzEuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFibGUuY29sdW1ucyA9IGRlbGltQ2VsbE5vZGVzLm1hcChnZXRDb2x1bW5Gcm9tRGVsaW1DZWxsKTtcbiAgICAgICAgcGFyc2VyLnRpcCA9IHRhYmxlO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciB0YWJsZUJvZHkgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICBpZiAoKGNvbnRhaW5lci50eXBlICE9PSAndGFibGUnICYmIGNvbnRhaW5lci50eXBlICE9PSAndGFibGVCb2R5JykgfHxcbiAgICAgICAgKCFwYXJzZXIuYmxhbmsgJiYgcGFyc2VyLmN1cnJlbnRMaW5lLmluZGV4T2YoJ3wnKSA9PT0gLTEpKSB7XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgaWYgKHBhcnNlci5ibGFuaykge1xuICAgICAgICB2YXIgdGFibGVfMSA9IGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICAgICAgdGFibGVfMSA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5maW5hbGl6ZSh0YWJsZV8xLCBwYXJzZXIubGluZU51bWJlciAtIDEpO1xuICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICB2YXIgdGFibGVCb2R5ID0gY29udGFpbmVyO1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3RhYmxlJykge1xuICAgICAgICB0YWJsZUJvZHkgPSBwYXJzZXIuYWRkQ2hpbGQoJ3RhYmxlQm9keScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB0YWJsZUJvZHkuc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIHZhciB0YWJsZVJvdyA9IGNyZWF0ZU5vZGUkMSgndGFibGVSb3cnLCBbXG4gICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDFdLFxuICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGhdLFxuICAgIF0pO1xuICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZCh0YWJsZVJvdyk7XG4gICAgdmFyIHRhYmxlID0gdGFibGVCb2R5LnBhcmVudDtcbiAgICB2YXIgY29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICB2YXIgX2EgPSBwYXJzZVJvd0NvbnRlbnQoY29udGVudCksIG9mZnNldCA9IF9hWzBdLCBjZWxsQ29udGVudHMgPSBfYVsxXTtcbiAgICBnZW5lcmF0ZVRhYmxlQ2VsbHMoJ3RhYmxlQ2VsbCcsIGNlbGxDb250ZW50cywgcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxICsgb2Zmc2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsTm9kZSwgaWR4KSB7XG4gICAgICAgIGlmIChpZHggPj0gdGFibGUuY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNlbGxOb2RlLmlnbm9yZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlUm93LmFwcGVuZENoaWxkKGNlbGxOb2RlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gMiAvKiBMZWFmICovO1xufTtcblxudmFyIHJlQ3VzdG9tQmxvY2sgPSAvXihcXCRcXCQpKFxccypbYS16QS1aXSkrLztcbnZhciByZUNhbkJlQ3VzdG9tSW5saW5lID0gL14oXFwkXFwkKShcXHMqW2EtekEtWl0pKy4qKFxcJFxcJCkvO1xudmFyIGN1c3RvbUJsb2NrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAhcmVDYW5CZUN1c3RvbUlubGluZS50ZXN0KHBhcnNlci5jdXJyZW50TGluZSkgJiZcbiAgICAgICAgKG1hdGNoID0gcGFyc2VyLmN1cnJlbnRMaW5lLm1hdGNoKHJlQ3VzdG9tQmxvY2spKSkge1xuICAgICAgICB2YXIgc3ludGF4TGVuZ3RoID0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBhcnNlci5hZGRDaGlsZCgnY3VzdG9tQmxvY2snLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgY29udGFpbmVyLnN5bnRheExlbmd0aCA9IHN5bnRheExlbmd0aDtcbiAgICAgICAgY29udGFpbmVyLm9mZnNldCA9IHBhcnNlci5pbmRlbnQ7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHN5bnRheExlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcblxudmFyIHJlQ29kZUZlbmNlID0gL15gezMsfSg/IS4qYCl8Xn57Myx9LztcbnZhciByZUh0bWxCbG9ja09wZW4gPSBbXG4gICAgLy4vLFxuICAgIC9ePCg/OnNjcmlwdHxwcmV8c3R5bGUpKD86XFxzfD58JCkvaSxcbiAgICAvXjwhLS0vLFxuICAgIC9ePFs/XS8sXG4gICAgL148IVtBLVpdLyxcbiAgICAvXjwhXFxbQ0RBVEFcXFsvLFxuICAgIC9ePFsvXT8oPzphZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbnxjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxMjM0NTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9ufHB8cGFyYW18c2VjdGlvbnxzb3VyY2V8c3VtbWFyeXx0YWJsZXx0Ym9keXx0ZHx0Zm9vdHx0aHx0aGVhZHx0aXRsZXx0cnx0cmFja3x1bCkoPzpcXHN8Wy9dP1s+XXwkKS9pLFxuICAgIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBPUEVOVEFHICsgXCJ8XCIgKyBDTE9TRVRBRyArIFwiKVxcXFxzKiRcIiwgJ2knKSxcbl07XG52YXIgcmVTZXRleHRIZWFkaW5nTGluZSA9IC9eKD86PSt8LSspWyBcXHRdKiQvO1xudmFyIHJlQVRYSGVhZGluZ01hcmtlciA9IC9eI3sxLDZ9KD86WyBcXHRdK3wkKS87XG52YXIgcmVUaGVtYXRpY0JyZWFrID0gL14oPzooPzpcXCpbIFxcdF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzotWyBcXHRdKil7Myx9KVsgXFx0XSokLztcbnZhciByZUJ1bGxldExpc3RNYXJrZXIgPSAvXlsqKy1dLztcbnZhciByZU9yZGVyZWRMaXN0TWFya2VyID0gL14oXFxkezEsOX0pKFsuKV0pLztcbi8vIFBhcnNlIGEgbGlzdCBtYXJrZXIgYW5kIHJldHVybiBkYXRhIG9uIHRoZSBtYXJrZXIgKHR5cGUsXG4vLyBzdGFydCwgZGVsaW1pdGVyLCBidWxsZXQgY2hhcmFjdGVyLCBwYWRkaW5nKSBvciBudWxsLlxuZnVuY3Rpb24gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIHJlc3QgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBuZXh0YztcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgdHlwZTogJ2J1bGxldCcsXG4gICAgICAgIHRpZ2h0OiB0cnVlLFxuICAgICAgICBidWxsZXRDaGFyOiAnJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGRlbGltaXRlcjogJycsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmtlck9mZnNldDogcGFyc2VyLmluZGVudCxcbiAgICAgICAgLy8gR0ZNOiBUYXNrIExpc3QgSXRlbVxuICAgICAgICB0YXNrOiBmYWxzZSxcbiAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgfTtcbiAgICBpZiAocGFyc2VyLmluZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZUJ1bGxldExpc3RNYXJrZXIpKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnYnVsbGV0JztcbiAgICAgICAgZGF0YS5idWxsZXRDaGFyID0gbWF0Y2hbMF1bMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2gocmVPcmRlcmVkTGlzdE1hcmtlcikpICYmXG4gICAgICAgIChjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgfHwgbWF0Y2hbMV0gPT09ICcxJykpIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ29yZGVyZWQnO1xuICAgICAgICBkYXRhLnN0YXJ0ID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgZGF0YS5kZWxpbWl0ZXIgPSBtYXRjaFsyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBzcGFjZXMgYWZ0ZXJcbiAgICBuZXh0YyA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBpZiAoIShuZXh0YyA9PT0gLTEgfHwgbmV4dGMgPT09IENfVEFCIHx8IG5leHRjID09PSBDX1NQQUNFKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgaXQgaW50ZXJydXB0cyBwYXJhZ3JhcGgsIG1ha2Ugc3VyZSBmaXJzdCBsaW5lIGlzbid0IGJsYW5rXG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAhcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpLm1hdGNoKHJlTm9uU3BhY2UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3ZSd2ZSBnb3QgYSBtYXRjaCEgYWR2YW5jZSBvZmZzZXQgYW5kIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTsgLy8gdG8gc3RhcnQgb2YgbWFya2VyXG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCB0cnVlKTsgLy8gdG8gZW5kIG9mIG1hcmtlclxuICAgIHZhciBzcGFjZXNTdGFydENvbCA9IHBhcnNlci5jb2x1bW47XG4gICAgdmFyIHNwYWNlc1N0YXJ0T2Zmc2V0ID0gcGFyc2VyLm9mZnNldDtcbiAgICBkbyB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICBuZXh0YyA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KTtcbiAgICB9IHdoaWxlIChwYXJzZXIuY29sdW1uIC0gc3BhY2VzU3RhcnRDb2wgPCA1ICYmIGlzU3BhY2VPclRhYihuZXh0YykpO1xuICAgIHZhciBibGFua0l0ZW0gPSBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkgPT09IC0xO1xuICAgIHZhciBzcGFjZXNBZnRlck1hcmtlciA9IHBhcnNlci5jb2x1bW4gLSBzcGFjZXNTdGFydENvbDtcbiAgICBpZiAoc3BhY2VzQWZ0ZXJNYXJrZXIgPj0gNSB8fCBzcGFjZXNBZnRlck1hcmtlciA8IDEgfHwgYmxhbmtJdGVtKSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIDE7XG4gICAgICAgIHBhcnNlci5jb2x1bW4gPSBzcGFjZXNTdGFydENvbDtcbiAgICAgICAgcGFyc2VyLm9mZnNldCA9IHNwYWNlc1N0YXJ0T2Zmc2V0O1xuICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhLnBhZGRpbmcgPSBtYXRjaFswXS5sZW5ndGggKyBzcGFjZXNBZnRlck1hcmtlcjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBsaXN0IGl0ZW1zIGFyZSBvZiB0aGUgc2FtZSB0eXBlLFxuLy8gd2l0aCB0aGUgc2FtZSBkZWxpbWl0ZXIgYW5kIGJ1bGxldCBjaGFyYWN0ZXIuICBUaGlzIGlzIHVzZWRcbi8vIGluIGFnZ2xvbWVyYXRpbmcgbGlzdCBpdGVtcyBpbnRvIGxpc3RzLlxuZnVuY3Rpb24gbGlzdHNNYXRjaChsaXN0RGF0YSwgaXRlbURhdGEpIHtcbiAgICByZXR1cm4gKGxpc3REYXRhLnR5cGUgPT09IGl0ZW1EYXRhLnR5cGUgJiZcbiAgICAgICAgbGlzdERhdGEuZGVsaW1pdGVyID09PSBpdGVtRGF0YS5kZWxpbWl0ZXIgJiZcbiAgICAgICAgbGlzdERhdGEuYnVsbGV0Q2hhciA9PT0gaXRlbURhdGEuYnVsbGV0Q2hhcik7XG59XG5mdW5jdGlvbiBpc0Rpc2FsbG93ZWREZWVwSGVhZGluZyhwYXJzZXIsIG5vZGUpIHtcbiAgICByZXR1cm4gcGFyc2VyLm9wdGlvbnMuZGlzYWxsb3dEZWVwSGVhZGluZyAmJiAobm9kZS50eXBlID09PSAnYmxvY2tRdW90ZScgfHwgbm9kZS50eXBlID09PSAnaXRlbScpO1xufVxudmFyIGJsb2NrUXVvdGUgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0dSRUFURVJUSEFOKSB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIGZhbHNlKTtcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9sbG93aW5nIHNwYWNlXG4gICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgnYmxvY2tRdW90ZScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICByZXR1cm4gMSAvKiBDb250YWluZXIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGF0eEhlYWRpbmcgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgLy8gVGhlIG5lc3RlZCBIZWFkaW5nIGlzIGRpc2FsbG93ZWQgaW4gbGlzdCBhbmQgYmxvY2txdW90ZSB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgIWlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgY29udGFpbmVyKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVBVFhIZWFkaW5nTWFya2VyKSkpIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgaGVhZGluZyA9IHBhcnNlci5hZGRDaGlsZCgnaGVhZGluZycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBoZWFkaW5nLmxldmVsID0gbWF0Y2hbMF0udHJpbSgpLmxlbmd0aDsgLy8gbnVtYmVyIG9mICNzXG4gICAgICAgIGhlYWRpbmcuaGVhZGluZ1R5cGUgPSAnYXR4JztcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICMjI3M6XG4gICAgICAgIGhlYWRpbmcuc3RyaW5nQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZVxuICAgICAgICAgICAgLnNsaWNlKHBhcnNlci5vZmZzZXQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlsgXFx0XSojK1sgXFx0XSokLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvWyBcXHRdKyMrWyBcXHRdKiQvLCAnJyk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgZmVuY2VkQ29kZUJsb2NrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVDb2RlRmVuY2UpKSkge1xuICAgICAgICB2YXIgZmVuY2VMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjb2RlQmxvY2snLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgY29udGFpbmVyLmlzRmVuY2VkID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlTGVuZ3RoID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lci5mZW5jZUNoYXIgPSBtYXRjaFswXVswXTtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlT2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoZmVuY2VMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgaHRtbEJsb2NrID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0xFU1NUSEFOKSB7XG4gICAgICAgIHZhciBzID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB2YXIgZGlzYWxsb3dlZFRhZ3MgPSBwYXJzZXIub3B0aW9ucy5kaXNhbGxvd2VkSHRtbEJsb2NrVGFncztcbiAgICAgICAgdmFyIGJsb2NrVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChibG9ja1R5cGUgPSAxOyBibG9ja1R5cGUgPD0gNzsgYmxvY2tUeXBlKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gcy5tYXRjaChyZUh0bWxCbG9ja09wZW5bYmxvY2tUeXBlXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1R5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWxsb3dlZFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlRGlzYWxsb3dlZFRhZ3MgPSBuZXcgUmVnRXhwKFwiPC8/KD86XCIgKyBkaXNhbGxvd2VkVGFncy5qb2luKCd8JykgKyBcIilcIiwgJ2knKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZURpc2FsbG93ZWRUYWdzLnRlc3QobWF0Y2hlZFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGFkanVzdCBwYXJzZXIub2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlcyBhcmUgcGFydCBvZiB0aGUgSFRNTCBibG9jazpcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHBhcnNlci5hZGRDaGlsZCgnaHRtbEJsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYi5odG1sQmxvY2tUeXBlID0gYmxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgc2VUZXh0SGVhZGluZyA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgIT09IG51bGwgJiZcbiAgICAgICAgIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgLy8gVGhlIG5lc3RlZCBIZWFkaW5nIGlzIGRpc2FsbG93ZWQgaW4gbGlzdCBhbmQgYmxvY2txdW90ZSB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgIWlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgY29udGFpbmVyLnBhcmVudCkgJiZcbiAgICAgICAgKG1hdGNoID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlU2V0ZXh0SGVhZGluZ0xpbmUpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgLy8gcmVzb2x2ZSByZWZlcmVuY2UgbGluayBkZWZpbml0aW9uc1xuICAgICAgICB2YXIgcG9zID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAocGVlayhjb250YWluZXIuc3RyaW5nQ29udGVudCwgMCkgPT09IENfT1BFTl9CUkFDS0VUICYmXG4gICAgICAgICAgICAocG9zID0gcGFyc2VyLmlubGluZVBhcnNlci5wYXJzZVJlZmVyZW5jZShjb250YWluZXIsIHBhcnNlci5yZWZNYXApKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudC5zbGljZShwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIuc3RyaW5nQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGluZyA9IGNyZWF0ZU5vZGUkMSgnaGVhZGluZycsIGNvbnRhaW5lci5zb3VyY2Vwb3MpO1xuICAgICAgICAgICAgaGVhZGluZy5sZXZlbCA9IG1hdGNoWzBdWzBdID09PSAnPScgPyAxIDogMjtcbiAgICAgICAgICAgIGhlYWRpbmcuaGVhZGluZ1R5cGUgPSAnc2V0ZXh0JztcbiAgICAgICAgICAgIGhlYWRpbmcuc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50O1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFmdGVyKGhlYWRpbmcpO1xuICAgICAgICAgICAgY29udGFpbmVyLnVubGluaygpO1xuICAgICAgICAgICAgcGFyc2VyLnRpcCA9IGhlYWRpbmc7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciB0aGVtYXRpY0JyZWFrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmIHJlVGhlbWF0aWNCcmVhay50ZXN0KHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKSkpIHtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgndGhlbWF0aWNCcmVhaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoIC0gcGFyc2VyLm9mZnNldCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBsaXN0SXRlbSA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBkYXRhO1xuICAgIHZhciBjdXJyTm9kZSA9IGNvbnRhaW5lcjtcbiAgICBpZiAoKCFwYXJzZXIuaW5kZW50ZWQgfHwgY29udGFpbmVyLnR5cGUgPT09ICdsaXN0JykgJiZcbiAgICAgICAgKGRhdGEgPSBwYXJzZUxpc3RNYXJrZXIocGFyc2VyLCBjdXJyTm9kZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAvLyBhZGQgdGhlIGxpc3QgaWYgbmVlZGVkXG4gICAgICAgIGlmIChwYXJzZXIudGlwLnR5cGUgIT09ICdsaXN0JyB8fCAhbGlzdHNNYXRjaChjdXJyTm9kZS5saXN0RGF0YSwgZGF0YSkpIHtcbiAgICAgICAgICAgIGN1cnJOb2RlID0gcGFyc2VyLmFkZENoaWxkKCdsaXN0JywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgICAgICBjdXJyTm9kZS5saXN0RGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBsaXN0IGl0ZW1cbiAgICAgICAgY3Vyck5vZGUgPSBwYXJzZXIuYWRkQ2hpbGQoJ2l0ZW0nLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgY3Vyck5vZGUubGlzdERhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gMSAvKiBDb250YWluZXIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xuLy8gaW5kZW50ZWQgY29kZSBibG9ja1xudmFyIGluZGVudGVkQ29kZUJsb2NrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIGlmIChwYXJzZXIuaW5kZW50ZWQgJiYgcGFyc2VyLnRpcC50eXBlICE9PSAncGFyYWdyYXBoJyAmJiAhcGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIC8vIGluZGVudGVkIGNvZGVcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoQ09ERV9JTkRFTlQsIHRydWUpO1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgcGFyc2VyLmFkZENoaWxkKCdjb2RlQmxvY2snLCBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgYmxvY2tTdGFydHMgPSBbXG4gICAgYmxvY2tRdW90ZSxcbiAgICBhdHhIZWFkaW5nLFxuICAgIGZlbmNlZENvZGVCbG9jayxcbiAgICBodG1sQmxvY2ssXG4gICAgc2VUZXh0SGVhZGluZyxcbiAgICB0aGVtYXRpY0JyZWFrLFxuICAgIGxpc3RJdGVtLFxuICAgIGluZGVudGVkQ29kZUJsb2NrLFxuICAgIHRhYmxlSGVhZCxcbiAgICB0YWJsZUJvZHksXG4gICAgY3VzdG9tQmxvY2ssXG5dO1xuXG4vLyBgLS0tYCBmb3IgWUFNTCwgYCsrK2AgZm9yIFRPTUwsIGA7OztgIGZvciBKU09OXG52YXIgcmVGcm9udE1hdHRlciA9IC9eKC17M318XFwrezN9fDt7M30pJC87XG52YXIgZnJvbnRNYXR0ZXIkMSA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBjdXJyZW50TGluZSA9IHBhcnNlci5jdXJyZW50TGluZSwgbGluZU51bWJlciA9IHBhcnNlci5saW5lTnVtYmVyLCBpbmRlbnRlZCA9IHBhcnNlci5pbmRlbnRlZDtcbiAgICBpZiAobGluZU51bWJlciA9PT0gMSAmJlxuICAgICAgICAhaW5kZW50ZWQgJiZcbiAgICAgICAgY29udGFpbmVyLnR5cGUgPT09ICdkb2N1bWVudCcgJiZcbiAgICAgICAgcmVGcm9udE1hdHRlci50ZXN0KGN1cnJlbnRMaW5lKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgdmFyIGZyb250TWF0dGVyXzEgPSBwYXJzZXIuYWRkQ2hpbGQoJ2Zyb250TWF0dGVyJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGZyb250TWF0dGVyXzEuc3RyaW5nQ29udGVudCA9IGN1cnJlbnRMaW5lO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChjdXJyZW50TGluZS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG5cbnZhciBmcm9udE1hdHRlciA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlRnJvbnRNYXR0ZXIpO1xuICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdmcm9udE1hdHRlcicgJiYgbWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ICs9IGxpbmU7XG4gICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5saXRlcmFsID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG5cbnZhciByZUh0bWxCbG9ja0Nsb3NlID0gW1xuICAgIC8uLyxcbiAgICAvPFxcLyg/OnNjcmlwdHxwcmV8c3R5bGUpPi9pLFxuICAgIC8tLT4vLFxuICAgIC9cXD8+LyxcbiAgICAvPi8sXG4gICAgL1xcXVxcXT4vLFxuXTtcbnZhciByZU1heWJlU3BlY2lhbCA9IC9eWyNgfiorXz08PjAtOS07JF0vO1xudmFyIHJlTGluZUVuZGluZyQxID0gL1xcclxcbnxcXG58XFxyLztcbmZ1bmN0aW9uIGRvY3VtZW50JDIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUkMSgnZG9jdW1lbnQnLCBbXG4gICAgICAgIFsxLCAxXSxcbiAgICAgICAgWzAsIDBdLFxuICAgIF0pO1xufVxudmFyIGRlZmF1bHRPcHRpb25zJDEgPSB7XG4gICAgc21hcnQ6IGZhbHNlLFxuICAgIHRhZ0ZpbHRlcjogZmFsc2UsXG4gICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbXSxcbiAgICByZWZlcmVuY2VEZWZpbml0aW9uOiBmYWxzZSxcbiAgICBkaXNhbGxvd0RlZXBIZWFkaW5nOiBmYWxzZSxcbiAgICBjdXN0b21QYXJzZXI6IG51bGwsXG4gICAgZnJvbnRNYXR0ZXI6IGZhbHNlLFxufTtcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zJDEpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2N1bWVudCQyKCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMub2xkdGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZSA9IDA7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIHRoaXMuaW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibGFuayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mcm9udE1hdHRlcikge1xuICAgICAgICAgICAgYmxvY2tIYW5kbGVycy5mcm9udE1hdHRlciA9IGZyb250TWF0dGVyO1xuICAgICAgICAgICAgYmxvY2tTdGFydHMudW5zaGlmdChmcm9udE1hdHRlciQxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlubGluZVBhcnNlciA9IG5ldyBJbmxpbmVQYXJzZXIodGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZHZhbmNlT2Zmc2V0ID0gZnVuY3Rpb24gKGNvdW50LCBjb2x1bW5zKSB7XG4gICAgICAgIGlmIChjb2x1bW5zID09PSB2b2lkIDApIHsgY29sdW1ucyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjdXJyZW50TGluZSA9IHRoaXMuY3VycmVudExpbmU7XG4gICAgICAgIHZhciBjaGFyc1RvVGFiLCBjaGFyc1RvQWR2YW5jZTtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHdoaWxlIChjb3VudCA+IDAgJiYgKGMgPSBjdXJyZW50TGluZVt0aGlzLm9mZnNldF0pKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBjaGFyc1RvVGFiID0gNCAtICh0aGlzLmNvbHVtbiAlIDQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBjaGFyc1RvVGFiID4gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzVG9BZHZhbmNlID0gY2hhcnNUb1RhYiA+IGNvdW50ID8gY291bnQgOiBjaGFyc1RvVGFiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvQWR2YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSBjaGFyc1RvQWR2YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4gKz0gY2hhcnNUb1RhYjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSAxOyAvLyBhc3N1bWUgYXNjaWk7IGJsb2NrIHN0YXJ0cyBhcmUgYXNjaWlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmFkdmFuY2VOZXh0Tm9uc3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5uZXh0Tm9uc3BhY2U7XG4gICAgICAgIHRoaXMuY29sdW1uID0gdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW47XG4gICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuZmluZE5leHROb25zcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgdmFyIGNvbHMgPSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHdoaWxlICgoYyA9IGN1cnJlbnRMaW5lLmNoYXJBdChpKSkgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbHMgKz0gNCAtIChjb2xzICUgNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsYW5rID0gYyA9PT0gJ1xcbicgfHwgYyA9PT0gJ1xccicgfHwgYyA9PT0gJyc7XG4gICAgICAgIHRoaXMubmV4dE5vbnNwYWNlID0gaTtcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gPSBjb2xzO1xuICAgICAgICB0aGlzLmluZGVudCA9IHRoaXMubmV4dE5vbnNwYWNlQ29sdW1uIC0gdGhpcy5jb2x1bW47XG4gICAgICAgIHRoaXMuaW5kZW50ZWQgPSB0aGlzLmluZGVudCA+PSBDT0RFX0lOREVOVDtcbiAgICB9O1xuICAgIC8vIEFkZCBhIGxpbmUgdG8gdGhlIGJsb2NrIGF0IHRoZSB0aXAuICBXZSBhc3N1bWUgdGhlIHRpcFxuICAgIC8vIGNhbiBhY2NlcHQgbGluZXMgLS0gdGhhdCBjaGVjayBzaG91bGQgYmUgZG9uZSBiZWZvcmUgY2FsbGluZyB0aGlzLlxuICAgIFBhcnNlci5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7IC8vIHNraXAgb3ZlciB0YWJcbiAgICAgICAgICAgIC8vIGFkZCBzcGFjZSBjaGFyYWN0ZXJzOlxuICAgICAgICAgICAgdmFyIGNoYXJzVG9UYWIgPSA0IC0gKHRoaXMuY29sdW1uICUgNCk7XG4gICAgICAgICAgICB0aGlzLnRpcC5zdHJpbmdDb250ZW50ICs9IHJlcGVhdCgnICcsIGNoYXJzVG9UYWIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpcC5saW5lT2Zmc2V0cykge1xuICAgICAgICAgICAgdGhpcy50aXAubGluZU9mZnNldHMucHVzaCh0aGlzLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpcC5saW5lT2Zmc2V0cyA9IFt0aGlzLm9mZnNldF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aXAuc3RyaW5nQ29udGVudCArPSB0aGlzLmN1cnJlbnRMaW5lLnNsaWNlKHRoaXMub2Zmc2V0KSArIFwiXFxuXCI7XG4gICAgfTtcbiAgICAvLyBBZGQgYmxvY2sgb2YgdHlwZSB0YWcgYXMgYSBjaGlsZCBvZiB0aGUgdGlwLiAgSWYgdGhlIHRpcCBjYW4ndFxuICAgIC8vIGFjY2VwdCBjaGlsZHJlbiwgY2xvc2UgYW5kIGZpbmFsaXplIGl0IGFuZCB0cnkgaXRzIHBhcmVudCxcbiAgICAvLyBhbmQgc28gb24gdGlsIHdlIGZpbmQgYSBibG9jayB0aGF0IGNhbiBhY2NlcHQgY2hpbGRyZW4uXG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uICh0YWcsIG9mZnNldCkge1xuICAgICAgICB3aGlsZSAoIWJsb2NrSGFuZGxlcnNbdGhpcy50aXAudHlwZV0uY2FuQ29udGFpbih0YWcpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCB0aGlzLmxpbmVOdW1iZXIgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gb2Zmc2V0ICsgMTsgLy8gb2Zmc2V0IDAgPSBjb2x1bW4gMVxuICAgICAgICB2YXIgbmV3QmxvY2sgPSBjcmVhdGVOb2RlJDEodGFnLCBbXG4gICAgICAgICAgICBbdGhpcy5saW5lTnVtYmVyLCBjb2x1bW5OdW1iZXJdLFxuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICBdKTtcbiAgICAgICAgbmV3QmxvY2suc3RyaW5nQ29udGVudCA9ICcnO1xuICAgICAgICB0aGlzLnRpcC5hcHBlbmRDaGlsZChuZXdCbG9jayk7XG4gICAgICAgIHRoaXMudGlwID0gbmV3QmxvY2s7XG4gICAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICB9O1xuICAgIC8vIEZpbmFsaXplIGFuZCBjbG9zZSBhbnkgdW5tYXRjaGVkIGJsb2Nrcy5cbiAgICBQYXJzZXIucHJvdG90eXBlLmNsb3NlVW5tYXRjaGVkQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5vbGR0aXAgIT09IHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLm9sZHRpcC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLm9sZHRpcCwgdGhpcy5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGR0aXAgPSBwYXJlbnRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRmluYWxpemUgYSBibG9jay4gIENsb3NlIGl0IGFuZCBkbyBhbnkgbmVjZXNzYXJ5IHBvc3Rwcm9jZXNzaW5nLFxuICAgIC8vIGUuZy4gY3JlYXRpbmcgc3RyaW5nQ29udGVudCBmcm9tIHN0cmluZ3MsIHNldHRpbmcgdGhlICd0aWdodCdcbiAgICAvLyBvciAnbG9vc2UnIHN0YXR1cyBvZiBhIGxpc3QsIGFuZCBwYXJzaW5nIHRoZSBiZWdpbm5pbmdzXG4gICAgLy8gb2YgcGFyYWdyYXBocyBmb3IgcmVmZXJlbmNlIGRlZmluaXRpb25zLiAgUmVzZXQgdGhlIHRpcCB0byB0aGVcbiAgICAvLyBwYXJlbnQgb2YgdGhlIGNsb3NlZCBibG9jay5cbiAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGJsb2NrLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHZhciBhYm92ZSA9IGJsb2NrLnBhcmVudDtcbiAgICAgICAgYmxvY2sub3BlbiA9IGZhbHNlO1xuICAgICAgICBibG9jay5zb3VyY2Vwb3NbMV0gPSBbbGluZU51bWJlciwgdGhpcy5sYXN0TGluZUxlbmd0aF07XG4gICAgICAgIGJsb2NrSGFuZGxlcnNbYmxvY2sudHlwZV0uZmluYWxpemUodGhpcywgYmxvY2spO1xuICAgICAgICB0aGlzLnRpcCA9IGFib3ZlO1xuICAgIH07XG4gICAgLy8gV2FsayB0aHJvdWdoIGEgYmxvY2sgJiBjaGlsZHJlbiByZWN1cnNpdmVseSwgcGFyc2luZyBzdHJpbmcgY29udGVudFxuICAgIC8vIGludG8gaW5saW5lIGNvbnRlbnQgd2hlcmUgYXBwcm9wcmlhdGUuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzSW5saW5lcyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIHZhciBjdXN0b21QYXJzZXIgPSB0aGlzLm9wdGlvbnMuY3VzdG9tUGFyc2VyO1xuICAgICAgICB2YXIgd2Fsa2VyID0gYmxvY2sud2Fsa2VyKCk7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZk1hcCA9IHRoaXMucmVmTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZMaW5rQ2FuZGlkYXRlTWFwID0gdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZEZWZDYW5kaWRhdGVNYXAgPSB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgICAgICB2YXIgdCA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJzZXIgJiYgY3VzdG9tUGFyc2VyW3RdKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUGFyc2VyW3RdKG5vZGUsIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVudGVyaW5nICYmXG4gICAgICAgICAgICAgICAgKHQgPT09ICdwYXJhZ3JhcGgnIHx8XG4gICAgICAgICAgICAgICAgICAgIHQgPT09ICdoZWFkaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAodCA9PT0gJ3RhYmxlQ2VsbCcgJiYgIW5vZGUuaWdub3JlZCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucGFyc2Uobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFuYWx5emUgYSBsaW5lIG9mIHRleHQgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgYXBwcm9wcmlhdGVseS5cbiAgICAvLyBXZSBwYXJzZSBtYXJrZG93biB0ZXh0IGJ5IGNhbGxpbmcgdGhpcyBvbiBlYWNoIGxpbmUgb2YgaW5wdXQsXG4gICAgLy8gdGhlbiBmaW5hbGl6aW5nIHRoZSBkb2N1bWVudC5cbiAgICBQYXJzZXIucHJvdG90eXBlLmluY29ycG9yYXRlTGluZSA9IGZ1bmN0aW9uIChsbikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMub2xkdGlwID0gdGhpcy50aXA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmJsYW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyICs9IDE7XG4gICAgICAgIC8vIHJlcGxhY2UgTlVMIGNoYXJhY3RlcnMgZm9yIHNlY3VyaXR5XG4gICAgICAgIGlmIChsbi5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICBsbiA9IGxuLnJlcGxhY2UoL1xcMC9nLCAnXFx1RkZGRCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSBsbjtcbiAgICAgICAgLy8gRm9yIGVhY2ggY29udGFpbmluZyBibG9jaywgdHJ5IHRvIHBhcnNlIHRoZSBhc3NvY2lhdGVkIGxpbmUgc3RhcnQuXG4gICAgICAgIC8vIEJhaWwgb3V0IG9uIGZhaWx1cmU6IGNvbnRhaW5lciB3aWxsIHBvaW50IHRvIHRoZSBsYXN0IG1hdGNoaW5nIGJsb2NrLlxuICAgICAgICAvLyBTZXQgYWxsTWF0Y2hlZCB0byBmYWxzZSBpZiBub3QgYWxsIGNvbnRhaW5lcnMgbWF0Y2guXG4gICAgICAgIHZhciBhbGxNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKChsYXN0Q2hpbGQgPSBjb250YWluZXIubGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3Blbikge1xuICAgICAgICAgICAgY29udGFpbmVyID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGJsb2NrSGFuZGxlcnNbY29udGFpbmVyLnR5cGVdWydjb250aW51ZSddKHRoaXMsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogR28gKi86IC8vIHdlJ3ZlIG1hdGNoZWQsIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFN0b3AgKi86IC8vIHdlJ3ZlIGZhaWxlZCB0byBtYXRjaCBhIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGFsbE1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIEZpbmlzaGVkICovOiAvLyB3ZSd2ZSBoaXQgZW5kIG9mIGxpbmUgZm9yIGZlbmNlZCBjb2RlIGNsb3NlIGFuZCBjYW4gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRpbnVlIHJldHVybmVkIGlsbGVnYWwgdmFsdWUsIG11c3QgYmUgMCwgMSwgb3IgMicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudDsgLy8gYmFjayB1cCB0byBsYXN0IG1hdGNoaW5nIGJsb2NrXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSBjb250YWluZXIgPT09IHRoaXMub2xkdGlwO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB2YXIgbWF0Y2hlZExlYWYgPSBjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiYgYmxvY2tIYW5kbGVyc1tjb250YWluZXIudHlwZV0uYWNjZXB0c0xpbmVzO1xuICAgICAgICB2YXIgYmxvY2tTdGFydHNMZW4gPSBibG9ja1N0YXJ0cy5sZW5ndGg7XG4gICAgICAgIC8vIFVubGVzcyBsYXN0IG1hdGNoZWQgY29udGFpbmVyIGlzIGEgY29kZSBibG9jaywgdHJ5IG5ldyBjb250YWluZXIgc3RhcnRzLFxuICAgICAgICAvLyBhZGRpbmcgY2hpbGRyZW4gdG8gdGhlIGxhc3QgbWF0Y2hlZCBjb250YWluZXI6XG4gICAgICAgIHdoaWxlICghbWF0Y2hlZExlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZE5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGxpdHRsZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZScgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlQm9keScgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pbmRlbnRlZCAmJlxuICAgICAgICAgICAgICAgICFyZU1heWJlU3BlY2lhbC50ZXN0KGxuLnNsaWNlKHRoaXMubmV4dE5vbnNwYWNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYmxvY2tTdGFydHNMZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gYmxvY2tTdGFydHNbaV0odGhpcywgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzID09PSAxIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLnRpcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcyA9PT0gMiAvKiBMZWFmICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkTGVhZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBibG9ja1N0YXJ0c0xlbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoYXQgcmVtYWlucyBhdCB0aGUgb2Zmc2V0IGlzIGEgdGV4dCBsaW5lLiAgQWRkIHRoZSB0ZXh0IHRvIHRoZVxuICAgICAgICAvLyBhcHByb3ByaWF0ZSBjb250YWluZXIuXG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBhIGxhenkgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbjpcbiAgICAgICAgaWYgKCF0aGlzLmFsbENsb3NlZCAmJiAhdGhpcy5ibGFuayAmJiB0aGlzLnRpcC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgLy8gbGF6eSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIGxhenkgY29udGludWF0aW9uXG4gICAgICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgICAgICB0aGlzLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ibGFuayAmJiBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmxhc3RDaGlsZC5sYXN0TGluZUJsYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gY29udGFpbmVyLnR5cGU7XG4gICAgICAgICAgICAvLyBCbG9jayBxdW90ZSBsaW5lcyBhcmUgbmV2ZXIgYmxhbmsgYXMgdGhleSBzdGFydCB3aXRoID5cbiAgICAgICAgICAgIC8vIGFuZCB3ZSBkb24ndCBjb3VudCBibGFua3MgaW4gZmVuY2VkIGNvZGUgZm9yIHB1cnBvc2VzIG9mIHRpZ2h0L2xvb3NlXG4gICAgICAgICAgICAvLyBsaXN0cyBvciBicmVha2luZyBvdXQgb2YgbGlzdHMuIFdlIGFsc28gZG9uJ3Qgc2V0IF9sYXN0TGluZUJsYW5rXG4gICAgICAgICAgICAvLyBvbiBhbiBlbXB0eSBsaXN0IGl0ZW0sIG9yIGlmIHdlIGp1c3QgY2xvc2VkIGEgZmVuY2VkIGJsb2NrLlxuICAgICAgICAgICAgdmFyIGxhc3RMaW5lQmxhbmsgPSB0aGlzLmJsYW5rICYmXG4gICAgICAgICAgICAgICAgISh0ID09PSAnYmxvY2tRdW90ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29kZUJsb2NrKGNvbnRhaW5lcikgJiYgY29udGFpbmVyLmlzRmVuY2VkKSB8fFxuICAgICAgICAgICAgICAgICAgICAodCA9PT0gJ2l0ZW0nICYmICFjb250YWluZXIuZmlyc3RDaGlsZCAmJiBjb250YWluZXIuc291cmNlcG9zWzBdWzBdID09PSB0aGlzLmxpbmVOdW1iZXIpKTtcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBsYXN0TGluZUJsYW5rIHVwIHRocm91Z2ggcGFyZW50czpcbiAgICAgICAgICAgIHZhciBjb250ID0gY29udGFpbmVyO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnQpIHtcbiAgICAgICAgICAgICAgICBjb250Lmxhc3RMaW5lQmxhbmsgPSBsYXN0TGluZUJsYW5rO1xuICAgICAgICAgICAgICAgIGNvbnQgPSBjb250LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhbmRsZXJzW3RdLmFjY2VwdHNMaW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIEh0bWxCbG9jaywgY2hlY2sgZm9yIGVuZCBjb25kaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaXNIdG1sQmxvY2soY29udGFpbmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA+PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5odG1sQmxvY2tUeXBlIDw9IDUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVIdG1sQmxvY2tDbG9zZVtjb250YWluZXIuaHRtbEJsb2NrVHlwZV0udGVzdCh0aGlzLmN1cnJlbnRMaW5lLnNsaWNlKHRoaXMub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShjb250YWluZXIsIHRoaXMubGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vZmZzZXQgPCBsbi5sZW5ndGggJiYgIXRoaXMuYmxhbmspIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcGFyYWdyYXBoIGNvbnRhaW5lciBmb3IgbGluZVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuYWRkQ2hpbGQoJ3BhcmFncmFwaCcsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgIH07XG4gICAgLy8gVGhlIG1haW4gcGFyc2luZyBmdW5jdGlvbi4gIFJldHVybnMgYSBwYXJzZWQgZG9jdW1lbnQgQVNULlxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIGxpbmVUZXh0cykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvY3VtZW50JDIoKTtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSAnJztcbiAgICAgICAgdmFyIGxpbmVzID0gaW5wdXQuc3BsaXQocmVMaW5lRW5kaW5nJDEpO1xuICAgICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZVRleHRzID8gbGluZVRleHRzIDogbGluZXM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jbGVhclJlZk1hcHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gQ19ORVdMSU5FKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgbGFzdCBibGFuayBsaW5lIGNyZWF0ZWQgYnkgZmluYWwgbmV3bGluZVxuICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmNvcnBvcmF0ZUxpbmUobGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnRpcCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NJbmxpbmVzKHRoaXMuZG9jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VTdGFydCA9IGZ1bmN0aW9uIChsaW5lTnVtYmVyLCBsaW5lcykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvY3VtZW50JDIoKTtcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZU51bWJlciAtIDE7XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWF0Y2hlZENvbnRhaW5lciA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lID0gJyc7XG4gICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZUV4dGVuZHMgPSBmdW5jdGlvbiAobGluZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbmNvcnBvcmF0ZUxpbmUobGluZXNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZUZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMudGlwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCB0aGlzLmxpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0lubGluZXModGhpcy5kb2MpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5zZXRSZWZNYXBzID0gZnVuY3Rpb24gKHJlZk1hcCwgcmVmTGlua0NhbmRpZGF0ZU1hcCwgcmVmRGVmQ2FuZGlkYXRlTWFwKSB7XG4gICAgICAgIHRoaXMucmVmTWFwID0gcmVmTWFwO1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSByZWZMaW5rQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCA9IHJlZkRlZkNhbmRpZGF0ZU1hcDtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuY2xlYXJSZWZNYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBbdGhpcy5yZWZNYXAsIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXBdLmZvckVhY2goZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgY2xlYXJPYmoobWFwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcblxuZnVuY3Rpb24gY29tcGFyZVBvcyhwMSwgcDIpIHtcbiAgICBpZiAocDFbMF0gPCBwMlswXSkge1xuICAgICAgICByZXR1cm4gMSAvKiBMVCAqLztcbiAgICB9XG4gICAgaWYgKHAxWzBdID4gcDJbMF0pIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICBpZiAocDFbMV0gPCBwMlsxXSkge1xuICAgICAgICByZXR1cm4gMSAvKiBMVCAqLztcbiAgICB9XG4gICAgaWYgKHAxWzFdID4gcDJbMV0pIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZUFuZFBvcyhfYSwgcG9zKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gX2FbMF0sIGVuZFBvcyA9IF9hWzFdO1xuICAgIGlmIChjb21wYXJlUG9zKGVuZFBvcywgcG9zKSA9PT0gMSAvKiBMVCAqLykge1xuICAgICAgICByZXR1cm4gMSAvKiBMVCAqLztcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVQb3Moc3RhcnRQb3MsIHBvcykgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgIHJldHVybiAtMSAvKiBHVCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogRVEgKi87XG59XG5mdW5jdGlvbiByZW1vdmVOZXh0VW50aWwobm9kZSwgbGFzdCkge1xuICAgIGlmIChub2RlLnBhcmVudCAhPT0gbGFzdC5wYXJlbnQgfHwgbm9kZSA9PT0gbGFzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT09IGxhc3QpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBuZXh0Lm5leHQ7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBbJ3BhcmVudCcsICdwcmV2JywgJ25leHQnXTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX2FbX2ldO1xuICAgICAgICAgICAgaWYgKG5leHRbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlQnlJZChuZXh0W3R5cGVdLmlkKTtcbiAgICAgICAgICAgICAgICBuZXh0W3R5cGVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gdGVtcDtcbiAgICB9XG4gICAgbm9kZS5uZXh0ID0gbGFzdC5uZXh0O1xuICAgIGlmIChsYXN0Lm5leHQpIHtcbiAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5wYXJlbnQubGFzdENoaWxkID0gbm9kZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5vZGVzKHBhcmVudCkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBjdXJyID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1cnIpIHtcbiAgICAgICAgbm9kZXMucHVzaChjdXJyKTtcbiAgICAgICAgY3VyciA9IGN1cnIubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZXNCZWZvcmUodGFyZ2V0LCBub2Rlcykge1xuICAgIGZvciAodmFyIF9pID0gMCwgbm9kZXNfMSA9IG5vZGVzOyBfaSA8IG5vZGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNfMVtfaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJlcGVuZENoaWxkTm9kZXMocGFyZW50LCBub2Rlcykge1xuICAgIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBwYXJlbnQucHJlcGVuZENoaWxkKG5vZGVzW2ldKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVOZXh0TGluZU51bWJlcnMoYmFzZSwgZGlmZikge1xuICAgIGlmICghYmFzZSB8fCAhYmFzZS5wYXJlbnQgfHwgZGlmZiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YWxrZXIgPSBiYXNlLnBhcmVudC53YWxrZXIoKTtcbiAgICB3YWxrZXIucmVzdW1lQXQoYmFzZSwgdHJ1ZSk7XG4gICAgdmFyIGV2ZW50O1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgbm9kZS5zb3VyY2Vwb3NbMF1bMF0gKz0gZGlmZjtcbiAgICAgICAgICAgIG5vZGUuc291cmNlcG9zWzFdWzBdICs9IGRpZmY7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VBbmRMaW5lKF9hLCBsaW5lKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gX2FbMF0sIGVuZFBvcyA9IF9hWzFdO1xuICAgIGlmIChlbmRQb3NbMF0gPCBsaW5lKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAoc3RhcnRQb3NbMF0gPiBsaW5lKSB7XG4gICAgICAgIHJldHVybiAtMSAvKiBHVCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogRVEgKi87XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGROb2RlQXRMaW5lKHBhcmVudCwgbGluZSkge1xuICAgIHZhciBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wYXJlUmFuZ2VBbmRMaW5lKG5vZGUuc291cmNlcG9zLCBsaW5lKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wID09PSAtMSAvKiBHVCAqLykge1xuICAgICAgICAgICAgLy8gVG8gY29uc2lkZXIgdGhhdCB0b3AgbGluZSBpcyBibGFuayBsaW5lXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wcmV2IHx8IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5sYXN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBsYXN0TGVhZk5vZGUobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc2FtZUxpbmVUb3BBbmNlc3Rvcihub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50ICYmXG4gICAgICAgIG5vZGUucGFyZW50LnR5cGUgIT09ICdkb2N1bWVudCcgJiZcbiAgICAgICAgbm9kZS5wYXJlbnQuc291cmNlcG9zWzBdWzBdID09PSBub2RlLnNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZmluZEZpcnN0Tm9kZUF0TGluZShwYXJlbnQsIGxpbmUpIHtcbiAgICB2YXIgbm9kZSA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZExpbmUobm9kZS5zb3VyY2Vwb3MsIGxpbmUpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgaWYgKG5vZGUuc291cmNlcG9zWzBdWzBdID09PSBsaW5lIHx8ICFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wID09PSAtMSAvKiBHVCAqLykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcmV0dXJuIHNhbWVMaW5lVG9wQW5jZXN0b3IobGFzdExlYWZOb2RlKHByZXYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kTm9kZUF0UG9zaXRpb24ocGFyZW50LCBwb3MpIHtcbiAgICB2YXIgbm9kZSA9IHBhcmVudDtcbiAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvbXAgPSBjb21wYXJlUmFuZ2VBbmRQb3Mobm9kZS5zb3VyY2Vwb3MsIHBvcyk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5leHQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlQnlJZChpZCkge1xuICAgIHJldHVybiBnZXROb2RlQnlJZChpZCkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGludm9rZU5leHRVbnRpbChjYWxsYmFjaywgc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBudWxsOyB9XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhciB3YWxrZXIgPSBzdGFydC53YWxrZXIoKTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ICYmIHN0YXJ0ICE9PSBlbmQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBuZXh0Lm5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVW5saW5rZWQoaWQpIHtcbiAgICB2YXIgbm9kZSA9IGZpbmROb2RlQnlJZChpZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBub2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICBpZiAoIW5vZGUucGFyZW50ICYmICFub2RlLnByZXYgJiYgIW5vZGUubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciByZUxpbmVFbmRpbmcgPSAvXFxyXFxufFxcbnxcXHIvO1xuZnVuY3Rpb24gY2FuQmVDb250aW51ZWRMaXN0SXRlbShsaW5lVGV4dCkge1xuICAgIHZhciBzcGFjZU1hdGNoID0gbGluZVRleHQubWF0Y2goL15bIFxcdF0rLyk7XG4gICAgaWYgKHNwYWNlTWF0Y2ggJiYgKHNwYWNlTWF0Y2hbMF0ubGVuZ3RoID49IDIgfHwgL1xcdC8udGVzdChzcGFjZU1hdGNoWzBdKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBsZWZ0VHJpbW1lZCA9IHNwYWNlTWF0Y2ggPyBsaW5lVGV4dC5zbGljZShzcGFjZU1hdGNoLmxlbmd0aCkgOiBsaW5lVGV4dDtcbiAgICByZXR1cm4gcmVCdWxsZXRMaXN0TWFya2VyLnRlc3QobGVmdFRyaW1tZWQpIHx8IHJlT3JkZXJlZExpc3RNYXJrZXIudGVzdChsZWZ0VHJpbW1lZCk7XG59XG5mdW5jdGlvbiBjYW5CZUNvbnRpbnVlZFRhYmxlQm9keShsaW5lVGV4dCkge1xuICAgIHJldHVybiAhaXNCbGFuayhsaW5lVGV4dCkgJiYgbGluZVRleHQuaW5kZXhPZignfCcpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZkRlZlN0YXRlKG5vZGUpIHtcbiAgICB2YXIgaWQgPSBub2RlLmlkLCB0aXRsZSA9IG5vZGUudGl0bGUsIHNvdXJjZXBvcyA9IG5vZGUuc291cmNlcG9zLCBkZXN0ID0gbm9kZS5kZXN0O1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICBzb3VyY2Vwb3M6IHNvdXJjZXBvcyxcbiAgICAgICAgdW5saW5rZWQ6IGZhbHNlLFxuICAgICAgICBkZXN0aW5hdGlvbjogZGVzdCxcbiAgICB9O1xufVxudmFyIFRvYXN0TWFyayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2FzdE1hcmsoY29udGVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZWZNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbiA9ICEhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBhcnNlci5zZXRSZWZNYXBzKHRoaXMucmVmTWFwLCB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwKTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJNYXAgPSB7IGNoYW5nZTogW10gfTtcbiAgICAgICAgY29udGVudHMgPSBjb250ZW50cyB8fCAnJztcbiAgICAgICAgdGhpcy5saW5lVGV4dHMgPSBjb250ZW50cy5zcGxpdChyZUxpbmVFbmRpbmcpO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnBhcnNlci5wYXJzZShjb250ZW50cywgdGhpcy5saW5lVGV4dHMpO1xuICAgIH1cbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnVwZGF0ZUxpbmVUZXh0cyA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0UG9zWzBdLCBzdGFydENvbCA9IHN0YXJ0UG9zWzFdO1xuICAgICAgICB2YXIgZW5kTGluZSA9IGVuZFBvc1swXSwgZW5kQ29sID0gZW5kUG9zWzFdO1xuICAgICAgICB2YXIgbmV3TGluZXMgPSBuZXdUZXh0LnNwbGl0KHJlTGluZUVuZGluZyk7XG4gICAgICAgIHZhciBuZXdMaW5lTGVuID0gbmV3TGluZXMubGVuZ3RoO1xuICAgICAgICB2YXIgc3RhcnRMaW5lVGV4dCA9IHRoaXMubGluZVRleHRzW3N0YXJ0TGluZSAtIDFdO1xuICAgICAgICB2YXIgZW5kTGluZVRleHQgPSB0aGlzLmxpbmVUZXh0c1tlbmRMaW5lIC0gMV07XG4gICAgICAgIG5ld0xpbmVzWzBdID0gc3RhcnRMaW5lVGV4dC5zbGljZSgwLCBzdGFydENvbCAtIDEpICsgbmV3TGluZXNbMF07XG4gICAgICAgIG5ld0xpbmVzW25ld0xpbmVMZW4gLSAxXSA9IG5ld0xpbmVzW25ld0xpbmVMZW4gLSAxXSArIGVuZExpbmVUZXh0LnNsaWNlKGVuZENvbCAtIDEpO1xuICAgICAgICB2YXIgcmVtb3ZlZExpbmVMZW4gPSBlbmRMaW5lIC0gc3RhcnRMaW5lICsgMTtcbiAgICAgICAgKF9hID0gdGhpcy5saW5lVGV4dHMpLnNwbGljZS5hcHBseShfYSwgX19zcHJlYWRBcnJheShbc3RhcnRMaW5lIC0gMSwgcmVtb3ZlZExpbmVMZW5dLCBuZXdMaW5lcykpO1xuICAgICAgICByZXR1cm4gbmV3TGluZUxlbiAtIHJlbW92ZWRMaW5lTGVuO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS51cGRhdGVSb290Tm9kZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lVGV4dHMubGVuZ3RoID09PSAxICYmIHRoaXMubGluZVRleHRzWzBdID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5yb290Lmxhc3RMaW5lQmxhbmsgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yb290LnNvdXJjZXBvcyA9IFtcbiAgICAgICAgICAgICAgICBbMSwgMV0sXG4gICAgICAgICAgICAgICAgWzEsIDBdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb290Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5yb290Lmxhc3RMaW5lQmxhbmsgPSB0aGlzLnJvb3QubGFzdENoaWxkLmxhc3RMaW5lQmxhbms7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRoaXMubGluZVRleHRzO1xuICAgICAgICB2YXIgaWR4ID0gbGluZVRleHRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsaW5lVGV4dHNbaWR4XSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lVGV4dHMubGVuZ3RoIC0gMiA+IGlkeCkge1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LnNvdXJjZXBvc1sxXSA9IFtpZHggKyAxLCBsaW5lVGV4dHNbaWR4XS5sZW5ndGhdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZXBsYWNlUmFuZ2VOb2RlcyA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIG5ld05vZGVzKSB7XG4gICAgICAgIGlmICghc3RhcnROb2RlKSB7XG4gICAgICAgICAgICBpZiAoZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGluc2VydE5vZGVzQmVmb3JlKGVuZE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlQnlJZChlbmROb2RlLmlkKTtcbiAgICAgICAgICAgICAgICBlbmROb2RlLnVubGluaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlcGVuZENoaWxkTm9kZXModGhpcy5yb290LCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnROb2Rlc0JlZm9yZShzdGFydE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgIHJlbW92ZU5leHRVbnRpbChzdGFydE5vZGUsIGVuZE5vZGUpO1xuICAgICAgICAgICAgW3N0YXJ0Tm9kZS5pZCwgZW5kTm9kZS5pZF0uZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlbW92ZU5vZGVCeUlkKGlkKTsgfSk7XG4gICAgICAgICAgICBzdGFydE5vZGUudW5saW5rKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0Tm9kZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBzdGFydFBvc1swXSk7XG4gICAgICAgIHZhciBlbmROb2RlID0gZmluZENoaWxkTm9kZUF0TGluZSh0aGlzLnJvb3QsIGVuZFBvc1swXSk7XG4gICAgICAgIC8vIGV4dGVuZCBub2RlIHJhbmdlIHRvIGluY2x1ZGUgYSBmb2xsb3dpbmcgYmxvY2sgd2hpY2ggZG9lc24ndCBoYXZlIHByZWNlZGluZyBibGFuayBsaW5lXG4gICAgICAgIGlmIChlbmROb2RlICYmIGVuZE5vZGUubmV4dCAmJiBlbmRQb3NbMF0gKyAxID09PSBlbmROb2RlLm5leHQuc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgICAgICBlbmROb2RlID0gZW5kTm9kZS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnROb2RlLCBlbmROb2RlXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIHBhcmFtKSB7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyTWFwW2V2ZW50TmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlcihwYXJhbSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5leHRlbmRFbmRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubGluZVRleHRzW2xpbmVdID09PSAnJykge1xuICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZVJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgc3RhcnRMaW5lLCBlbmRMaW5lKSB7XG4gICAgICAgIC8vIGV4dGVuZHMgc3RhcnRpbmcgcmFuZ2UgaWYgdGhlIGZpcnN0IG5vZGUgY2FuIGJlIGEgY29udGludWVkIGxpc3QgaXRlbVxuICAgICAgICBpZiAoc3RhcnROb2RlICYmXG4gICAgICAgICAgICBzdGFydE5vZGUucHJldiAmJlxuICAgICAgICAgICAgKChpc0xpc3Qoc3RhcnROb2RlLnByZXYpICYmIGNhbkJlQ29udGludWVkTGlzdEl0ZW0odGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV0pKSB8fFxuICAgICAgICAgICAgICAgIChpc1RhYmxlKHN0YXJ0Tm9kZS5wcmV2KSAmJiBjYW5CZUNvbnRpbnVlZFRhYmxlQm9keSh0aGlzLmxpbmVUZXh0c1tzdGFydExpbmUgLSAxXSkpKSkge1xuICAgICAgICAgICAgc3RhcnROb2RlID0gc3RhcnROb2RlLnByZXY7XG4gICAgICAgICAgICBzdGFydExpbmUgPSBzdGFydE5vZGUuc291cmNlcG9zWzBdWzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZGl0ZWRMaW5lcyA9IHRoaXMubGluZVRleHRzLnNsaWNlKHN0YXJ0TGluZSAtIDEsIGVuZExpbmUpO1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZVN0YXJ0KHN0YXJ0TGluZSwgZWRpdGVkTGluZXMpO1xuICAgICAgICAvLyBleHRlbmRzIGVuZGluZyByYW5nZSBpZiB0aGUgZm9sbG93aW5nIG5vZGUgY2FuIGJlIGEgZmVuY2VkIGNvZGUgYmxvY2sgb3IgYSBjb250aW51ZWQgbGlzdCBpdGVtXG4gICAgICAgIHZhciBuZXh0Tm9kZSA9IGVuZE5vZGUgPyBlbmROb2RlLm5leHQgOiB0aGlzLnJvb3QuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIGxhc3RDaGlsZCA9IHJvb3QubGFzdENoaWxkO1xuICAgICAgICB2YXIgaXNPcGVuZWRMYXN0Q2hpbGRDb2RlQmxvY2sgPSBsYXN0Q2hpbGQgJiYgaXNDb2RlQmxvY2sobGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3BlbjtcbiAgICAgICAgdmFyIGlzT3BlbmVkTGFzdENoaWxkQ3VzdG9tQmxvY2sgPSBsYXN0Q2hpbGQgJiYgaXNDdXN0b21CbG9jayhsYXN0Q2hpbGQpICYmIGxhc3RDaGlsZC5vcGVuO1xuICAgICAgICB2YXIgaXNMYXN0Q2hpbGRMaXN0ID0gbGFzdENoaWxkICYmIGlzTGlzdChsYXN0Q2hpbGQpO1xuICAgICAgICB3aGlsZSAoKChpc09wZW5lZExhc3RDaGlsZENvZGVCbG9jayB8fCBpc09wZW5lZExhc3RDaGlsZEN1c3RvbUJsb2NrKSAmJiBuZXh0Tm9kZSkgfHxcbiAgICAgICAgICAgIChpc0xhc3RDaGlsZExpc3QgJiYgbmV4dE5vZGUgJiYgKG5leHROb2RlLnR5cGUgPT09ICdsaXN0JyB8fCBuZXh0Tm9kZS5zb3VyY2Vwb3NbMF1bMV0gPj0gMikpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZShuZXh0Tm9kZS5zb3VyY2Vwb3NbMV1bMF0pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlRXh0ZW5kcyh0aGlzLmxpbmVUZXh0cy5zbGljZShlbmRMaW5lLCBuZXdFbmRMaW5lKSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IGVuZE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmROb2RlID0gbmV4dE5vZGU7XG4gICAgICAgICAgICBlbmRMaW5lID0gbmV3RW5kTGluZTtcbiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VGaW5pc2goKTtcbiAgICAgICAgdmFyIG5ld05vZGVzID0gZ2V0Q2hpbGROb2Rlcyhyb290KTtcbiAgICAgICAgcmV0dXJuIHsgbmV3Tm9kZXM6IG5ld05vZGVzLCBleHRTdGFydE5vZGU6IHN0YXJ0Tm9kZSwgZXh0RW5kTm9kZTogZW5kTm9kZSB9O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSZW1vdmVkTm9kZVJhbmdlID0gZnVuY3Rpb24gKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSkge1xuICAgICAgICBpZiAoIWV4dFN0YXJ0Tm9kZSB8fFxuICAgICAgICAgICAgKGV4dFN0YXJ0Tm9kZSAmJiBpc1JlZkRlZihleHRTdGFydE5vZGUpKSB8fFxuICAgICAgICAgICAgKGV4dEVuZE5vZGUgJiYgaXNSZWZEZWYoZXh0RW5kTm9kZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IFtleHRTdGFydE5vZGUuaWQsIGV4dEVuZE5vZGUuaWRdLFxuICAgICAgICAgICAgbGluZTogW2V4dFN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF0gLSAxLCBleHRFbmROb2RlLnNvdXJjZXBvc1sxXVswXSAtIDFdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5tYXJrRGVsZXRlZFJlZk1hcCA9IGZ1bmN0aW9uIChleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmTWFwKSkge1xuICAgICAgICAgICAgdmFyIG1hcmtEZWxldGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZEZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW25vZGUubGFiZWxdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmRGVmU3RhdGUgJiYgbm9kZS5pZCA9PT0gcmVmRGVmU3RhdGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnVubGlua2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXh0U3RhcnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKG1hcmtEZWxldGVkLCBleHRTdGFydE5vZGUucGFyZW50LCBleHRFbmROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRFbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKG1hcmtEZWxldGVkLCBleHRFbmROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZXBsYWNlV2l0aE5ld1JlZkRlZlN0YXRlID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlV2l0aF8xID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZEZWYobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gbm9kZS5sYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZEZWZTdGF0ZSB8fCByZWZEZWZTdGF0ZS51bmxpbmtlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmTWFwW2xhYmVsXSA9IGNyZWF0ZVJlZkRlZlN0YXRlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VOZXh0VW50aWwocmVwbGFjZVdpdGhfMSwgbm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZXBsYWNlV2l0aFJlZkRlZkNhbmRpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwKSkge1xuICAgICAgICAgICAgaXRlcmF0ZU9iamVjdCh0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKF8sIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGNhbmRpZGF0ZS5sYWJlbCwgc291cmNlcG9zID0gY2FuZGlkYXRlLnNvdXJjZXBvcztcbiAgICAgICAgICAgICAgICB2YXIgcmVmRGVmU3RhdGUgPSBfdGhpcy5yZWZNYXBbbGFiZWxdO1xuICAgICAgICAgICAgICAgIGlmICghcmVmRGVmU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVmRGVmU3RhdGUudW5saW5rZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVmRGVmU3RhdGUuc291cmNlcG9zWzBdWzBdID4gc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZk1hcFtsYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldFJhbmdlV2l0aFJlZkRlZiA9IGZ1bmN0aW9uIChzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZURpZmYpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbiAmJiAhaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBzdGFydExpbmUgLSAxKTtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBlbmRMaW5lICsgMSk7XG4gICAgICAgICAgICBpZiAocHJldk5vZGUgJiYgaXNSZWZEZWYocHJldk5vZGUpICYmIHByZXZOb2RlICE9PSBzdGFydE5vZGUgJiYgcHJldk5vZGUgIT09IGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBwcmV2Tm9kZTtcbiAgICAgICAgICAgICAgICBzdGFydExpbmUgPSBzdGFydE5vZGUuc291cmNlcG9zWzBdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHROb2RlICYmIGlzUmVmRGVmKG5leHROb2RlKSAmJiBuZXh0Tm9kZSAhPT0gc3RhcnROb2RlICYmIG5leHROb2RlICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgZW5kTm9kZSA9IG5leHROb2RlO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSB0aGlzLmV4dGVuZEVuZExpbmUoZW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0gKyBsaW5lRGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGFydE5vZGUsIGVuZE5vZGUsIHN0YXJ0TGluZSwgZW5kTGluZV07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIGxpbmVEaWZmKSB7XG4gICAgICAgIGlmIChsaW5lRGlmZiA9PT0gdm9pZCAwKSB7IGxpbmVEaWZmID0gMDsgfVxuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldE5vZGVSYW5nZShzdGFydFBvcywgZW5kUG9zKTtcbiAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHJhbmdlWzBdLCBlbmROb2RlID0gcmFuZ2VbMV07XG4gICAgICAgIHZhciBzdGFydExpbmUgPSBzdGFydE5vZGUgPyBNYXRoLm1pbihzdGFydE5vZGUuc291cmNlcG9zWzBdWzBdLCBzdGFydFBvc1swXSkgOiBzdGFydFBvc1swXTtcbiAgICAgICAgdmFyIGVuZExpbmUgPSB0aGlzLmV4dGVuZEVuZExpbmUoKGVuZE5vZGUgPyBNYXRoLm1heChlbmROb2RlLnNvdXJjZXBvc1sxXVswXSwgZW5kUG9zWzBdKSA6IGVuZFBvc1swXSkgKyBsaW5lRGlmZik7XG4gICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VSYW5nZS5hcHBseSh0aGlzLCB0aGlzLmdldFJhbmdlV2l0aFJlZkRlZihzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbGluZURpZmYpKTtcbiAgICAgICAgdmFyIG5ld05vZGVzID0gcGFyc2VSZXN1bHQubmV3Tm9kZXMsIGV4dFN0YXJ0Tm9kZSA9IHBhcnNlUmVzdWx0LmV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSA9IHBhcnNlUmVzdWx0LmV4dEVuZE5vZGU7XG4gICAgICAgIHZhciByZW1vdmVkTm9kZVJhbmdlID0gdGhpcy5nZXRSZW1vdmVkTm9kZVJhbmdlKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSk7XG4gICAgICAgIHZhciBuZXh0Tm9kZSA9IGV4dEVuZE5vZGUgPyBleHRFbmROb2RlLm5leHQgOiB0aGlzLnJvb3QuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXJrRGVsZXRlZFJlZk1hcChleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VOb2RlcyhleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUsIG5ld05vZGVzKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGhOZXdSZWZEZWZTdGF0ZShuZXdOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGVzOiBuZXdOb2RlcywgcmVtb3ZlZE5vZGVSYW5nZTogcmVtb3ZlZE5vZGVSYW5nZSwgbmV4dE5vZGU6IG5leHROb2RlIH07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnBhcnNlUmVmTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICBpdGVyYXRlT2JqZWN0KHRoaXMucmVmTWFwLCBmdW5jdGlvbiAobGFiZWwsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnVubGlua2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZWZNYXBbbGFiZWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVyYXRlT2JqZWN0KF90aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChfLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBjYW5kaWRhdGUubm9kZSwgcmVmTGFiZWwgPSBjYW5kaWRhdGUucmVmTGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZMYWJlbCA9PT0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKF90aGlzLnBhcnNlKG5vZGUuc291cmNlcG9zWzBdLCBub2RlLnNvdXJjZXBvc1sxXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZW1vdmVVbmxpbmtlZENhbmRpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc0VtcHR5T2JqKHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwKSkge1xuICAgICAgICAgICAgW3RoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXBdLmZvckVhY2goZnVuY3Rpb24gKGNhbmRpZGF0ZU1hcCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QoY2FuZGlkYXRlTWFwLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5saW5rZWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FuZGlkYXRlTWFwW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZWRpdE1hcmtkb3duID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpIHtcbiAgICAgICAgdmFyIGxpbmVEaWZmID0gdGhpcy51cGRhdGVMaW5lVGV4dHMoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCk7XG4gICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2Uoc3RhcnRQb3MsIGVuZFBvcywgbGluZURpZmYpO1xuICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IG9taXQocGFyc2VSZXN1bHQsICduZXh0Tm9kZScpO1xuICAgICAgICB1cGRhdGVOZXh0TGluZU51bWJlcnMocGFyc2VSZXN1bHQubmV4dE5vZGUsIGxpbmVEaWZmKTtcbiAgICAgICAgdGhpcy51cGRhdGVSb290Tm9kZVN0YXRlKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbZWRpdFJlc3VsdF07XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVW5saW5rZWRDYW5kaWRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGhSZWZEZWZDYW5kaWRhdGUoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5wYXJzZVJlZkxpbmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRMaW5lVGV4dHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVUZXh0cztcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0Um9vdE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmZpbmROb2RlQXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmaW5kTm9kZUF0UG9zaXRpb24odGhpcy5yb290LCBwb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZSA9PT0gdGhpcy5yb290KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZmluZEZpcnN0Tm9kZUF0TGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiBmaW5kRmlyc3ROb2RlQXRMaW5lKHRoaXMucm9vdCwgbGluZSk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJNYXBbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5ldmVudEhhbmRsZXJNYXBbZXZlbnROYW1lXTtcbiAgICAgICAgdmFyIGlkeCA9IGhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICBoYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZmluZE5vZGVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBmaW5kTm9kZUJ5SWQoaWQpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5yZW1vdmVBbGxOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVBbGxOb2RlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9hc3RNYXJrO1xufSgpKTtcblxudmFyIGRpc2FsbG93ZWRUYWdzID0gW1xuICAgICd0aXRsZScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnc3R5bGUnLFxuICAgICd4bXAnLFxuICAgICdpZnJhbWUnLFxuICAgICdub2VtYmVkJyxcbiAgICAnbm9mcmFtZXMnLFxuICAgICdzY3JpcHQnLFxuICAgICdwbGFpbnRleHQnLFxuXTtcbnZhciByZURpc2FsbG93ZWRUYWcgPSBuZXcgUmVnRXhwKFwiPCgvPyg/OlwiICsgZGlzYWxsb3dlZFRhZ3Muam9pbignfCcpICsgXCIpW14+XSo+KVwiLCAnaWcnKTtcbmZ1bmN0aW9uIGZpbHRlckRpc2FsbG93ZWRUYWdzKHN0cikge1xuICAgIGlmIChyZURpc2FsbG93ZWRUYWcudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZURpc2FsbG93ZWRUYWcsIGZ1bmN0aW9uIChfLCBncm91cCkgeyByZXR1cm4gXCImbHQ7XCIgKyBncm91cDsgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbnZhciBiYXNlQ29udmVydG9ycyQxID0ge1xuICAgIGhlYWRpbmc6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IFwiaFwiICsgbm9kZS5sZXZlbCxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBjb250ZW50OiBub2RlLmxpdGVyYWwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzb2Z0YnJlYWs6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICBjb250ZW50OiBvcHRpb25zLnNvZnRicmVhayxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxpbmVicmVhazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgY29udGVudDogJzxiciAvPlxcbicsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBlbXBoOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnZW0nLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgc3Ryb25nOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnc3Ryb25nJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBncmFuZHBhcmVudCA9IChfYiA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFyZW50O1xuICAgICAgICBpZiAoZ3JhbmRwYXJlbnQgJiYgZ3JhbmRwYXJlbnQudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICBpZiAoZ3JhbmRwYXJlbnQubGlzdERhdGEudGlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3AnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGhlbWF0aWNCcmVhazogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2hyJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIHNlbGZDbG9zZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGJsb2NrUXVvdGU6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIGlubmVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGxpc3Q6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIF9iID0gbm9kZS5saXN0RGF0YSwgdHlwZSA9IF9iLnR5cGUsIHN0YXJ0ID0gX2Iuc3RhcnQ7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdHlwZSA9PT0gJ2J1bGxldCcgPyAndWwnIDogJ29sJztcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdvbCcgJiYgc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IDEpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3RhcnQgPSBzdGFydC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBodG1sSW5saW5lOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgY29udGVudCA9IG9wdGlvbnMudGFnRmlsdGVyID8gZmlsdGVyRGlzYWxsb3dlZFRhZ3Mobm9kZS5saXRlcmFsKSA6IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50IH07XG4gICAgfSxcbiAgICBodG1sQmxvY2s6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy50YWdGaWx0ZXIgPyBmaWx0ZXJEaXNhbGxvd2VkVGFncyhub2RlLmxpdGVyYWwpIDogbm9kZS5saXRlcmFsO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQsIG91dGVyTmV3TGluZTogdHJ1ZSB9O1xuICAgIH0sXG4gICAgY29kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjb2RlQmxvY2s6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbmZvU3RyID0gbm9kZS5pbmZvO1xuICAgICAgICB2YXIgaW5mb1dvcmRzID0gaW5mb1N0ciA/IGluZm9TdHIuc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgICB2YXIgY29kZUNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKGluZm9Xb3Jkcy5sZW5ndGggPiAwICYmIGluZm9Xb3Jkc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb2RlQ2xhc3NOYW1lcy5wdXNoKFwibGFuZ3VhZ2UtXCIgKyBlc2NhcGVYbWwoaW5mb1dvcmRzWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAncHJlJywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBjbGFzc05hbWVzOiBjb2RlQ2xhc3NOYW1lcyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3ByZScsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IG5vZGUsIHRpdGxlID0gX2IudGl0bGUsIGRlc3RpbmF0aW9uID0gX2IuZGVzdGluYXRpb247XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnYScsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogX19hc3NpZ24oeyBocmVmOiBlc2NhcGVYbWwoZGVzdGluYXRpb24pIH0sICh0aXRsZSAmJiB7IHRpdGxlOiBlc2NhcGVYbWwodGl0bGUpIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2EnIH07XG4gICAgfSxcbiAgICBpbWFnZTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBnZXRDaGlsZHJlblRleHQgPSBfYS5nZXRDaGlsZHJlblRleHQsIHNraXBDaGlsZHJlbiA9IF9hLnNraXBDaGlsZHJlbjtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgdGl0bGUgPSBfYi50aXRsZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbjtcbiAgICAgICAgc2tpcENoaWxkcmVuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnaW1nJyxcbiAgICAgICAgICAgIHNlbGZDbG9zZTogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9fYXNzaWduKHsgc3JjOiBlc2NhcGVYbWwoZGVzdGluYXRpb24pLCBhbHQ6IGdldENoaWxkcmVuVGV4dChub2RlKSB9LCAodGl0bGUgJiYgeyB0aXRsZTogZXNjYXBlWG1sKHRpdGxlKSB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgdmFyIGluZm8gPSBub2RlLmluZm8udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3IgPSBjb252ZXJ0b3JzW2luZm9dO1xuICAgICAgICBpZiAoY3VzdG9tQ29udmVydG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltAdG9hc3QtdWkvZWRpdG9yXSAtIFRoZSBlcnJvciBvY2N1cnJlZCB3aGVuIFwiICsgaW5mbyArIFwiIGJsb2NrIG5vZGUgd2FzIHBhcnNlZCBpbiBtYXJrZG93biByZW5kZXJlcjogXCIgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGZyb250IG1hdHRlciBpcyBtZXRhZGF0YSwgaXQgc2hvdWxkIG5vdCBiZSByZW5kZXIuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogJ3doaXRlLXNwYWNlOiBwcmU7IGRpc3BsYXk6IG5vbmU7JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY3VzdG9tSW5saW5lOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBpbmZvID0gX2EuaW5mbywgZmlyc3RDaGlsZCA9IF9hLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBub21hbGl6ZWRJbmZvID0gaW5mby50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9tYWxpemVkSW5mb107XG4gICAgICAgIHZhciBlbnRlcmluZyA9IGNvbnRleHQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChjdXN0b21Db252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0B0b2FzdC11aS9lZGl0b3JdIC0gVGhlIGVycm9yIG9jY3VycmVkIHdoZW4gXCIgKyBub21hbGl6ZWRJbmZvICsgXCIgaW5saW5lIG5vZGUgd2FzIHBhcnNlZCBpbiBtYXJrZG93biByZW5kZXJlcjogXCIgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50ZXJpbmdcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogXCIkJFwiICsgaW5mbyArIChmaXJzdENoaWxkID8gJyAnIDogJycpIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogJyQkJyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3NwYW4nIH0sXG4gICAgICAgICAgICBdO1xuICAgIH0sXG59O1xuXG52YXIgZ2ZtQ29udmVydG9ycyA9IHtcbiAgICBzdHJpa2U6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdkZWwnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCBjaGVja2VkID0gX2IuY2hlY2tlZCwgdGFzayA9IF9iLnRhc2s7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIGl0ZW1UYWcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRhZyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ2lucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGZDbG9zZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCAoY2hlY2tlZCAmJiB7IGNoZWNrZWQ6ICcnIH0pKSwgeyBkaXNhYmxlZDogJycsIHR5cGU6ICdjaGVja2JveCcgfSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcgJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1UYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGU6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0YWJsZScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUhlYWQ6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0aGVhZCcsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUJvZHk6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0Ym9keScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZVJvdzogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICd0cicsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChub2RlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbkxlbiA9IG5vZGUucGFyZW50LnBhcmVudC5jb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsYXN0Q29sSWR4ID0gbm9kZS5sYXN0Q2hpbGQuZW5kSWR4O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxhc3RDb2xJZHggKyAxOyBpIDwgY29sdW1uTGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAndHInLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHRhYmxlQ2VsbDogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAobm9kZS5pZ25vcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhYmxlUGFydCA9IG5vZGUucGFyZW50LnBhcmVudDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0YWJsZVBhcnQudHlwZSA9PT0gJ3RhYmxlSGVhZCcgPyAndGgnIDogJ3RkJztcbiAgICAgICAgdmFyIHRhYmxlID0gdGFibGVQYXJ0LnBhcmVudDtcbiAgICAgICAgdmFyIGNvbHVtbkluZm8gPSB0YWJsZS5jb2x1bW5zW25vZGUuc3RhcnRJZHhdO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IChjb2x1bW5JbmZvID09PSBudWxsIHx8IGNvbHVtbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbkluZm8uYWxpZ24pID8geyBhbGlnbjogY29sdW1uSW5mby5hbGlnbiB9IDogbnVsbDtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6IHRhZ05hbWUsIG91dGVyTmV3TGluZTogdHJ1ZSB9LCAoYXR0cmlidXRlcyAmJiB7IGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHNvZnRicmVhazogJ1xcbicsXG4gICAgZ2ZtOiBmYWxzZSxcbiAgICB0YWdGaWx0ZXI6IGZhbHNlLFxuICAgIG5vZGVJZDogZmFsc2UsXG59O1xuZnVuY3Rpb24gZ2V0Q2hpbGRyZW5UZXh0KG5vZGUpIHtcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIHdhbGtlciA9IG5vZGUud2Fsa2VyKCk7XG4gICAgdmFyIGV2ZW50ID0gbnVsbDtcbiAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgdmFyIG5vZGVfMSA9IGV2ZW50Lm5vZGU7XG4gICAgICAgIGlmIChub2RlXzEudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBidWZmZXIucHVzaChub2RlXzEubGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKCcnKTtcbn1cbnZhciBSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcihjdXN0b21PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIGN1c3RvbU9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbnZlcnRvcnMgPSB0aGlzLmNyZWF0ZUNvbnZlcnRvcnMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzO1xuICAgIH1cbiAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29udmVydG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRvcnMgPSBfX2Fzc2lnbih7fSwgYmFzZUNvbnZlcnRvcnMkMSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBjb252ZXJ0b3JzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbnZlcnRvcnMpLCBnZm1Db252ZXJ0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnZlcnRvcnMpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3JzXzEgPSB0aGlzLm9wdGlvbnMuY29udmVydG9ycztcbiAgICAgICAgICAgIHZhciBub2RlVHlwZXMgPSBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzXzEpO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRDb252ZXJ0b3JzXzEgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFzZUNvbnZlcnRvcnMkMSksIGdmbUNvbnZlcnRvcnMpO1xuICAgICAgICAgICAgbm9kZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JzXzFbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3JUeXBlID0gT2JqZWN0LmtleXMoZGVmYXVsdENvbnZlcnRvcnNfMSkuaW5kZXhPZihub2RlVHlwZSkgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZVR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChvcmdDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydG9yc1tjb252ZXJ0b3JUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcihub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW2NvbnZlcnRvclR5cGVdID0gY29udmVydG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0b3JzO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdldENvbnZlcnRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRvcnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocm9vdE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIHdhbGtlciA9IHJvb3ROb2RlLndhbGtlcigpO1xuICAgICAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzXzEuY29udmVydG9yc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGVudGVyaW5nOiBlbnRlcmluZyxcbiAgICAgICAgICAgICAgICBsZWFmOiAhaXNDb250YWluZXIkMShub2RlKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzXzEub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblRleHQ6IGdldENoaWxkcmVuVGV4dCxcbiAgICAgICAgICAgICAgICBza2lwQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY29udmVydGVkID0gaXNDdXN0b21CbG9jayhub2RlKSB8fCBpc0N1c3RvbUlubGluZShub2RlKVxuICAgICAgICAgICAgICAgID8gY29udmVydG9yKG5vZGUsIGNvbnRleHQsIHRoaXNfMS5jb252ZXJ0b3JzKVxuICAgICAgICAgICAgICAgIDogY29udmVydG9yKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciBodG1sTm9kZXMgPSBBcnJheS5pc0FycmF5KGNvbnZlcnRlZCkgPyBjb252ZXJ0ZWQgOiBbY29udmVydGVkXTtcbiAgICAgICAgICAgICAgICBodG1sTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaHRtbE5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChodG1sTm9kZS50eXBlID09PSAnb3BlblRhZycgJiYgX3RoaXMub3B0aW9ucy5ub2RlSWQgJiYgaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaHRtbE5vZGUuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxOb2RlLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxOb2RlLmF0dHJpYnV0ZXNbJ2RhdGEtbm9kZWlkJ10gPSBTdHJpbmcobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVySFRNTE5vZGUoaHRtbE5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5yZXN1bWVBdChub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5qb2luKCcnKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJIVE1MTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvcGVuVGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ2Nsb3NlVGFnJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUmF3SHRtbE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBuby1kZWZhdWx0LWNhc2VcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlT3BlblRhZ1N0cmluZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YWdOYW1lID0gbm9kZS50YWdOYW1lLCBjbGFzc05hbWVzID0gbm9kZS5jbGFzc05hbWVzLCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiPFwiICsgdGFnTmFtZSk7XG4gICAgICAgIGlmIChjbGFzc05hbWVzICYmIGNsYXNzTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIiBjbGFzcz1cXFwiXCIgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmZmVyLnB1c2goXCIgXCIgKyBhdHRyTmFtZSArIFwiPVxcXCJcIiArIGF0dHJWYWx1ZSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnNlbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnIC8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCc+Jyk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2VuZXJhdGVDbG9zZVRhZ1N0cmluZyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IF9hLnRhZ05hbWU7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hZGROZXdMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoICYmIGxhc3QobGFzdCh0aGlzLmJ1ZmZlcikpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnXFxuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hZGRPdXRlck5ld0xpbmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5vdXRlck5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkSW5uZXJOZXdMaW5lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaW5uZXJOZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRleHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChlc2NhcGVYbWwobm9kZS5jb250ZW50KSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyUmF3SHRtbE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChub2RlLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdvcGVuVGFnJykge1xuICAgICAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlT3BlblRhZ1N0cmluZyhub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnNlbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbm5lck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZElubmVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVDbG9zZVRhZ1N0cmluZyhub2RlKTtcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVyZXI7XG59KCkpO1xuXG4vKiEgQGxpY2Vuc2UgRE9NUHVyaWZ5IDIuMy4zIHwgKGMpIEN1cmU1MyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlIDIuMCBhbmQgTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjAgfCBnaXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi8yLjMuMy9MSUNFTlNFICovXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QuaGFzT3duUHJvcGVydHksXG4gICAgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsXG4gICAgaXNGcm96ZW4gPSBPYmplY3QuaXNGcm96ZW4sXG4gICAgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBmcmVlemUgPSBPYmplY3QuZnJlZXplLFxuICAgIHNlYWwgPSBPYmplY3Quc2VhbCxcbiAgICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcblxudmFyIF9yZWYgPSB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgUmVmbGVjdCxcbiAgICBhcHBseSA9IF9yZWYuYXBwbHksXG4gICAgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7XG5cbmlmICghYXBwbHkpIHtcbiAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmdW4sIHRoaXNWYWx1ZSwgYXJncykge1xuICAgIHJldHVybiBmdW4uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgfTtcbn1cblxuaWYgKCFmcmVlemUpIHtcbiAgZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuaWYgKCFzZWFsKSB7XG4gIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuaWYgKCFjb25zdHJ1Y3QpIHtcbiAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShGdW5jLCBbbnVsbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkpKSgpO1xuICB9O1xufVxuXG52YXIgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG52YXIgYXJyYXlQb3AgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wb3ApO1xudmFyIGFycmF5UHVzaCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuXG52YXIgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xudmFyIHN0cmluZ01hdGNoID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLm1hdGNoKTtcbnZhciBzdHJpbmdSZXBsYWNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG52YXIgc3RyaW5nVHJpbSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50cmltKTtcblxudmFyIHJlZ0V4cFRlc3QgPSB1bmFwcGx5KFJlZ0V4cC5wcm90b3R5cGUudGVzdCk7XG5cbnZhciB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuXG5mdW5jdGlvbiB1bmFwcGx5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zdHJ1Y3QoZnVuYywgYXJncyk7XG4gIH07XG59XG5cbi8qIEFkZCBwcm9wZXJ0aWVzIHRvIGEgbG9va3VwIHRhYmxlICovXG5mdW5jdGlvbiBhZGRUb1NldChzZXQsIGFycmF5KSB7XG4gIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgIC8vIE1ha2UgJ2luJyBhbmQgdHJ1dGh5IGNoZWNrcyBsaWtlIEJvb2xlYW4oc2V0LmNvbnN0cnVjdG9yKVxuICAgIC8vIGluZGVwZW5kZW50IG9mIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gT2JqZWN0LnByb3RvdHlwZS5cbiAgICAvLyBQcmV2ZW50IHByb3RvdHlwZSBzZXR0ZXJzIGZyb20gaW50ZXJjZXB0aW5nIHNldCBhcyBhIHRoaXMgdmFsdWUuXG4gICAgc2V0UHJvdG90eXBlT2Yoc2V0LCBudWxsKTtcbiAgfVxuXG4gIHZhciBsID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobC0tKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbGNFbGVtZW50ID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudCk7XG4gICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgIC8vIENvbmZpZyBwcmVzZXRzIChlLmcuIHRhZ3MuanMsIGF0dHJzLmpzKSBhcmUgaW1tdXRhYmxlLlxuICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudCA9IGxjRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRbZWxlbWVudF0gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuLyogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3QgKi9cbmZ1bmN0aW9uIGNsb25lKG9iamVjdCkge1xuICB2YXIgbmV3T2JqZWN0ID0gY3JlYXRlKG51bGwpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IHZvaWQgMDtcbiAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICBpZiAoYXBwbHkoaGFzT3duUHJvcGVydHksIG9iamVjdCwgW3Byb3BlcnR5XSkpIHtcbiAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG5cbi8qIElFMTAgZG9lc24ndCBzdXBwb3J0IF9fbG9va3VwR2V0dGVyX18gc28gbGV0cydcbiAqIHNpbXVsYXRlIGl0LiBJdCBhbHNvIGF1dG9tYXRpY2FsbHkgY2hlY2tzXG4gKiBpZiB0aGUgcHJvcCBpcyBmdW5jdGlvbiBvciBnZXR0ZXIgYW5kIGJlaGF2ZXNcbiAqIGFjY29yZGluZ2x5LiAqL1xuZnVuY3Rpb24gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcCkge1xuICB3aGlsZSAob2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcbiAgICBpZiAoZGVzYykge1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MuZ2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB1bmFwcGx5KGRlc2MudmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIH1cblxuICBmdW5jdGlvbiBmYWxsYmFja1ZhbHVlKGVsZW1lbnQpIHtcbiAgICBjb25zb2xlLndhcm4oJ2ZhbGxiYWNrIHZhbHVlIGZvcicsIGVsZW1lbnQpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG59XG5cbnZhciBodG1sJDIgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5cbi8vIFNWR1xudmFyIHN2ZyA9IGZyZWV6ZShbJ3N2ZycsICdhJywgJ2FsdGdseXBoJywgJ2FsdGdseXBoZGVmJywgJ2FsdGdseXBoaXRlbScsICdhbmltYXRlY29sb3InLCAnYW5pbWF0ZW1vdGlvbicsICdhbmltYXRldHJhbnNmb3JtJywgJ2NpcmNsZScsICdjbGlwcGF0aCcsICdkZWZzJywgJ2Rlc2MnLCAnZWxsaXBzZScsICdmaWx0ZXInLCAnZm9udCcsICdnJywgJ2dseXBoJywgJ2dseXBocmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyZ3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbXBhdGgnLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsZ3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N0eWxlJywgJ3N3aXRjaCcsICdzeW1ib2wnLCAndGV4dCcsICd0ZXh0cGF0aCcsICd0aXRsZScsICd0cmVmJywgJ3RzcGFuJywgJ3ZpZXcnLCAndmtlcm4nXSk7XG5cbnZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuXG4vLyBMaXN0IG9mIFNWRyBlbGVtZW50cyB0aGF0IGFyZSBkaXNhbGxvd2VkIGJ5IGRlZmF1bHQuXG4vLyBXZSBzdGlsbCBuZWVkIHRvIGtub3cgdGhlbSBzbyB0aGF0IHdlIGNhbiBkbyBuYW1lc3BhY2Vcbi8vIGNoZWNrcyBwcm9wZXJseSBpbiBjYXNlIG9uZSB3YW50cyB0byBhZGQgdGhlbSB0b1xuLy8gYWxsb3ctbGlzdC5cbnZhciBzdmdEaXNhbGxvd2VkID0gZnJlZXplKFsnYW5pbWF0ZScsICdjb2xvci1wcm9maWxlJywgJ2N1cnNvcicsICdkaXNjYXJkJywgJ2ZlZHJvcHNoYWRvdycsICdmZWltYWdlJywgJ2ZvbnQtZmFjZScsICdmb250LWZhY2UtZm9ybWF0JywgJ2ZvbnQtZmFjZS1uYW1lJywgJ2ZvbnQtZmFjZS1zcmMnLCAnZm9udC1mYWNlLXVyaScsICdmb3JlaWdub2JqZWN0JywgJ2hhdGNoJywgJ2hhdGNocGF0aCcsICdtZXNoJywgJ21lc2hncmFkaWVudCcsICdtZXNocGF0Y2gnLCAnbWVzaHJvdycsICdtaXNzaW5nLWdseXBoJywgJ3NjcmlwdCcsICdzZXQnLCAnc29saWRjb2xvcicsICd1bmtub3duJywgJ3VzZSddKTtcblxudmFyIG1hdGhNbCA9IGZyZWV6ZShbJ21hdGgnLCAnbWVuY2xvc2UnLCAnbWVycm9yJywgJ21mZW5jZWQnLCAnbWZyYWMnLCAnbWdseXBoJywgJ21pJywgJ21sYWJlbGVkdHInLCAnbW11bHRpc2NyaXB0cycsICdtbicsICdtbycsICdtb3ZlcicsICdtcGFkZGVkJywgJ21waGFudG9tJywgJ21yb290JywgJ21yb3cnLCAnbXMnLCAnbXNwYWNlJywgJ21zcXJ0JywgJ21zdHlsZScsICdtc3ViJywgJ21zdXAnLCAnbXN1YnN1cCcsICdtdGFibGUnLCAnbXRkJywgJ210ZXh0JywgJ210cicsICdtdW5kZXInLCAnbXVuZGVyb3ZlciddKTtcblxuLy8gU2ltaWxhcmx5IHRvIFNWRywgd2Ugd2FudCB0byBrbm93IGFsbCBNYXRoTUwgZWxlbWVudHMsXG4vLyBldmVuIHRob3NlIHRoYXQgd2UgZGlzYWxsb3cgYnkgZGVmYXVsdC5cbnZhciBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFsnbWFjdGlvbicsICdtYWxpZ25ncm91cCcsICdtYWxpZ25tYXJrJywgJ21sb25nZGl2JywgJ21zY2FycmllcycsICdtc2NhcnJ5JywgJ21zZ3JvdXAnLCAnbXN0YWNrJywgJ21zbGluZScsICdtc3JvdycsICdzZW1hbnRpY3MnLCAnYW5ub3RhdGlvbicsICdhbm5vdGF0aW9uLXhtbCcsICdtcHJlc2NyaXB0cycsICdub25lJ10pO1xuXG52YXIgdGV4dCA9IGZyZWV6ZShbJyN0ZXh0J10pO1xuXG52YXIgaHRtbCQxJDEgPSBmcmVlemUoWydhY2NlcHQnLCAnYWN0aW9uJywgJ2FsaWduJywgJ2FsdCcsICdhdXRvY2FwaXRhbGl6ZScsICdhdXRvY29tcGxldGUnLCAnYXV0b3BpY3R1cmVpbnBpY3R1cmUnLCAnYXV0b3BsYXknLCAnYmFja2dyb3VuZCcsICdiZ2NvbG9yJywgJ2JvcmRlcicsICdjYXB0dXJlJywgJ2NlbGxwYWRkaW5nJywgJ2NlbGxzcGFjaW5nJywgJ2NoZWNrZWQnLCAnY2l0ZScsICdjbGFzcycsICdjbGVhcicsICdjb2xvcicsICdjb2xzJywgJ2NvbHNwYW4nLCAnY29udHJvbHMnLCAnY29udHJvbHNsaXN0JywgJ2Nvb3JkcycsICdjcm9zc29yaWdpbicsICdkYXRldGltZScsICdkZWNvZGluZycsICdkZWZhdWx0JywgJ2RpcicsICdkaXNhYmxlZCcsICdkaXNhYmxlcGljdHVyZWlucGljdHVyZScsICdkaXNhYmxlcmVtb3RlcGxheWJhY2snLCAnZG93bmxvYWQnLCAnZHJhZ2dhYmxlJywgJ2VuY3R5cGUnLCAnZW50ZXJrZXloaW50JywgJ2ZhY2UnLCAnZm9yJywgJ2hlYWRlcnMnLCAnaGVpZ2h0JywgJ2hpZGRlbicsICdoaWdoJywgJ2hyZWYnLCAnaHJlZmxhbmcnLCAnaWQnLCAnaW5wdXRtb2RlJywgJ2ludGVncml0eScsICdpc21hcCcsICdraW5kJywgJ2xhYmVsJywgJ2xhbmcnLCAnbGlzdCcsICdsb2FkaW5nJywgJ2xvb3AnLCAnbG93JywgJ21heCcsICdtYXhsZW5ndGgnLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21pbicsICdtaW5sZW5ndGgnLCAnbXVsdGlwbGUnLCAnbXV0ZWQnLCAnbmFtZScsICdub3NoYWRlJywgJ25vdmFsaWRhdGUnLCAnbm93cmFwJywgJ29wZW4nLCAnb3B0aW11bScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3BsYXlzaW5saW5lJywgJ3Bvc3RlcicsICdwcmVsb2FkJywgJ3B1YmRhdGUnLCAncmFkaW9ncm91cCcsICdyZWFkb25seScsICdyZWwnLCAncmVxdWlyZWQnLCAncmV2JywgJ3JldmVyc2VkJywgJ3JvbGUnLCAncm93cycsICdyb3dzcGFuJywgJ3NwZWxsY2hlY2snLCAnc2NvcGUnLCAnc2VsZWN0ZWQnLCAnc2hhcGUnLCAnc2l6ZScsICdzaXplcycsICdzcGFuJywgJ3NyY2xhbmcnLCAnc3RhcnQnLCAnc3JjJywgJ3NyY3NldCcsICdzdGVwJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFiaW5kZXgnLCAndGl0bGUnLCAndHJhbnNsYXRlJywgJ3R5cGUnLCAndXNlbWFwJywgJ3ZhbGlnbicsICd2YWx1ZScsICd3aWR0aCcsICd4bWxucycsICdzbG90J10pO1xuXG52YXIgc3ZnJDEgPSBmcmVlemUoWydhY2NlbnQtaGVpZ2h0JywgJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FzY2VudCcsICdhdHRyaWJ1dGVuYW1lJywgJ2F0dHJpYnV0ZXR5cGUnLCAnYXppbXV0aCcsICdiYXNlZnJlcXVlbmN5JywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2JlZ2luJywgJ2JpYXMnLCAnYnknLCAnY2xhc3MnLCAnY2xpcCcsICdjbGlwcGF0aHVuaXRzJywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3InLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnY3gnLCAnY3knLCAnZCcsICdkeCcsICdkeScsICdkaWZmdXNlY29uc3RhbnQnLCAnZGlyZWN0aW9uJywgJ2Rpc3BsYXknLCAnZGl2aXNvcicsICdkdXInLCAnZWRnZW1vZGUnLCAnZWxldmF0aW9uJywgJ2VuZCcsICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmlsdGVyJywgJ2ZpbHRlcnVuaXRzJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2Z4JywgJ2Z5JywgJ2cxJywgJ2cyJywgJ2dseXBoLW5hbWUnLCAnZ2x5cGhyZWYnLCAnZ3JhZGllbnR1bml0cycsICdncmFkaWVudHRyYW5zZm9ybScsICdoZWlnaHQnLCAnaHJlZicsICdpZCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnaW4nLCAnaW4yJywgJ2snLCAnazEnLCAnazInLCAnazMnLCAnazQnLCAna2VybmluZycsICdrZXlwb2ludHMnLCAna2V5c3BsaW5lcycsICdrZXl0aW1lcycsICdsYW5nJywgJ2xlbmd0aGFkanVzdCcsICdsZXR0ZXItc3BhY2luZycsICdrZXJuZWxtYXRyaXgnLCAna2VybmVsdW5pdGxlbmd0aCcsICdsaWdodGluZy1jb2xvcicsICdsb2NhbCcsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ21hcmtlcmhlaWdodCcsICdtYXJrZXJ1bml0cycsICdtYXJrZXJ3aWR0aCcsICdtYXNrY29udGVudHVuaXRzJywgJ21hc2t1bml0cycsICdtYXgnLCAnbWFzaycsICdtZWRpYScsICdtZXRob2QnLCAnbW9kZScsICdtaW4nLCAnbmFtZScsICdudW1vY3RhdmVzJywgJ29mZnNldCcsICdvcGVyYXRvcicsICdvcGFjaXR5JywgJ29yZGVyJywgJ29yaWVudCcsICdvcmllbnRhdGlvbicsICdvcmlnaW4nLCAnb3ZlcmZsb3cnLCAncGFpbnQtb3JkZXInLCAncGF0aCcsICdwYXRobGVuZ3RoJywgJ3BhdHRlcm5jb250ZW50dW5pdHMnLCAncGF0dGVybnRyYW5zZm9ybScsICdwYXR0ZXJudW5pdHMnLCAncG9pbnRzJywgJ3ByZXNlcnZlYWxwaGEnLCAncHJlc2VydmVhc3BlY3RyYXRpbycsICdwcmltaXRpdmV1bml0cycsICdyJywgJ3J4JywgJ3J5JywgJ3JhZGl1cycsICdyZWZ4JywgJ3JlZnknLCAncmVwZWF0Y291bnQnLCAncmVwZWF0ZHVyJywgJ3Jlc3RhcnQnLCAncmVzdWx0JywgJ3JvdGF0ZScsICdzY2FsZScsICdzZWVkJywgJ3NoYXBlLXJlbmRlcmluZycsICdzcGVjdWxhcmNvbnN0YW50JywgJ3NwZWN1bGFyZXhwb25lbnQnLCAnc3ByZWFkbWV0aG9kJywgJ3N0YXJ0b2Zmc2V0JywgJ3N0ZGRldmlhdGlvbicsICdzdGl0Y2h0aWxlcycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlLXdpZHRoJywgJ3N0eWxlJywgJ3N1cmZhY2VzY2FsZScsICdzeXN0ZW1sYW5ndWFnZScsICd0YWJpbmRleCcsICd0YXJnZXR4JywgJ3RhcmdldHknLCAndHJhbnNmb3JtJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd0ZXh0bGVuZ3RoJywgJ3R5cGUnLCAndTEnLCAndTInLCAndW5pY29kZScsICd2YWx1ZXMnLCAndmlld2JveCcsICd2aXNpYmlsaXR5JywgJ3ZlcnNpb24nLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd2lkdGgnLCAnd29yZC1zcGFjaW5nJywgJ3dyYXAnLCAnd3JpdGluZy1tb2RlJywgJ3hjaGFubmVsc2VsZWN0b3InLCAneWNoYW5uZWxzZWxlY3RvcicsICd4JywgJ3gxJywgJ3gyJywgJ3htbG5zJywgJ3knLCAneTEnLCAneTInLCAneicsICd6b29tYW5kcGFuJ10pO1xuXG52YXIgbWF0aE1sJDEgPSBmcmVlemUoWydhY2NlbnQnLCAnYWNjZW50dW5kZXInLCAnYWxpZ24nLCAnYmV2ZWxsZWQnLCAnY2xvc2UnLCAnY29sdW1uc2FsaWduJywgJ2NvbHVtbmxpbmVzJywgJ2NvbHVtbnNwYW4nLCAnZGVub21hbGlnbicsICdkZXB0aCcsICdkaXInLCAnZGlzcGxheScsICdkaXNwbGF5c3R5bGUnLCAnZW5jb2RpbmcnLCAnZmVuY2UnLCAnZnJhbWUnLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnbGFyZ2VvcCcsICdsZW5ndGgnLCAnbGluZXRoaWNrbmVzcycsICdsc3BhY2UnLCAnbHF1b3RlJywgJ21hdGhiYWNrZ3JvdW5kJywgJ21hdGhjb2xvcicsICdtYXRoc2l6ZScsICdtYXRodmFyaWFudCcsICdtYXhzaXplJywgJ21pbnNpemUnLCAnbW92YWJsZWxpbWl0cycsICdub3RhdGlvbicsICdudW1hbGlnbicsICdvcGVuJywgJ3Jvd2FsaWduJywgJ3Jvd2xpbmVzJywgJ3Jvd3NwYWNpbmcnLCAncm93c3BhbicsICdyc3BhY2UnLCAncnF1b3RlJywgJ3NjcmlwdGxldmVsJywgJ3NjcmlwdG1pbnNpemUnLCAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnc2VsZWN0aW9uJywgJ3NlcGFyYXRvcicsICdzZXBhcmF0b3JzJywgJ3N0cmV0Y2h5JywgJ3N1YnNjcmlwdHNoaWZ0JywgJ3N1cHNjcmlwdHNoaWZ0JywgJ3N5bW1ldHJpYycsICd2b2Zmc2V0JywgJ3dpZHRoJywgJ3htbG5zJ10pO1xuXG52YXIgeG1sID0gZnJlZXplKFsneGxpbms6aHJlZicsICd4bWw6aWQnLCAneGxpbms6dGl0bGUnLCAneG1sOnNwYWNlJywgJ3htbG5zOnhsaW5rJ10pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9iZXR0ZXItcmVnZXhcbnZhciBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXFx7XFx7W1xcc1xcU10qfFtcXHNcXFNdKlxcfVxcfS9nbSk7IC8vIFNwZWNpZnkgdGVtcGxhdGUgZGV0ZWN0aW9uIHJlZ2V4IGZvciBTQUZFX0ZPUl9URU1QTEFURVMgbW9kZVxudmFyIEVSQl9FWFBSID0gc2VhbCgvPCVbXFxzXFxTXSp8W1xcc1xcU10qJT4vZ20pO1xudmFyIERBVEFfQVRUUiA9IHNlYWwoL15kYXRhLVtcXC1cXHcuXFx1MDBCNy1cXHVGRkZGXS8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG52YXIgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1xcLVxcd10rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG52YXIgSVNfQUxMT1dFRF9VUkkgPSBzZWFsKC9eKD86KD86KD86ZnxodCl0cHM/fG1haWx0b3x0ZWx8Y2FsbHRvfGNpZHx4bXBwKTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbik7XG52YXIgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XFx3K3NjcmlwdHxkYXRhKTovaSk7XG52YXIgQVRUUl9XSElURVNQQUNFID0gc2VhbCgvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkkMShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgZ2V0R2xvYmFsID0gZnVuY3Rpb24gZ2V0R2xvYmFsKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIERvbid0IGV4cG9ydCB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUhXG4gKiBAcGFyYW0gez9UcnVzdGVkVHlwZVBvbGljeUZhY3Rvcnl9IHRydXN0ZWRUeXBlcyBUaGUgcG9saWN5IGZhY3RvcnkuXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgb2JqZWN0ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KVxuICogQHJldHVybiB7P1RydXN0ZWRUeXBlUG9saWN5fSBUaGUgcG9saWN5IGNyZWF0ZWQgKG9yIG51bGwsIGlmIFRydXN0ZWQgVHlwZXNcbiAqIGFyZSBub3Qgc3VwcG9ydGVkKS5cbiAqL1xudmFyIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kgPSBmdW5jdGlvbiBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgZG9jdW1lbnQpIHtcbiAgaWYgKCh0eXBlb2YgdHJ1c3RlZFR5cGVzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0cnVzdGVkVHlwZXMpKSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbG93IHRoZSBjYWxsZXJzIHRvIGNvbnRyb2wgdGhlIHVuaXF1ZSBwb2xpY3kgbmFtZVxuICAvLyBieSBhZGRpbmcgYSBkYXRhLXR0LXBvbGljeS1zdWZmaXggdG8gdGhlIHNjcmlwdCBlbGVtZW50IHdpdGggdGhlIERPTVB1cmlmeS5cbiAgLy8gUG9saWN5IGNyZWF0aW9uIHdpdGggZHVwbGljYXRlIG5hbWVzIHRocm93cyBpbiBUcnVzdGVkIFR5cGVzLlxuICB2YXIgc3VmZml4ID0gbnVsbDtcbiAgdmFyIEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKSB7XG4gICAgc3VmZml4ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKTtcbiAgfVxuXG4gIHZhciBwb2xpY3lOYW1lID0gJ2RvbXB1cmlmeScgKyAoc3VmZml4ID8gJyMnICsgc3VmZml4IDogJycpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgY3JlYXRlSFRNTDogZnVuY3Rpb24gY3JlYXRlSFRNTChodG1sJCQxKSB7XG4gICAgICAgIHJldHVybiBodG1sJCQxO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gUG9saWN5IGNyZWF0aW9uIGZhaWxlZCAobW9zdCBsaWtlbHkgYW5vdGhlciBET01QdXJpZnkgc2NyaXB0IGhhc1xuICAgIC8vIGFscmVhZHkgcnVuKS4gU2tpcCBjcmVhdGluZyB0aGUgcG9saWN5LCBhcyB0aGlzIHdpbGwgb25seSBjYXVzZSBlcnJvcnNcbiAgICAvLyBpZiBUVCBhcmUgZW5mb3JjZWQuXG4gICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NUHVyaWZ5KCkge1xuICB2YXIgd2luZG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBnZXRHbG9iYWwoKTtcblxuICB2YXIgRE9NUHVyaWZ5ID0gZnVuY3Rpb24gRE9NUHVyaWZ5KHJvb3QpIHtcbiAgICByZXR1cm4gY3JlYXRlRE9NUHVyaWZ5KHJvb3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJzaW9uIGxhYmVsLCBleHBvc2VkIGZvciBlYXNpZXIgY2hlY2tzXG4gICAqIGlmIERPTVB1cmlmeSBpcyB1cCB0byBkYXRlIG9yIG5vdFxuICAgKi9cbiAgRE9NUHVyaWZ5LnZlcnNpb24gPSAnMi4zLjMnO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBlbGVtZW50cyB0aGF0IERPTVB1cmlmeSByZW1vdmVkIGR1cmluZyBzYW5pdGF0aW9uLlxuICAgKiBFbXB0eSBpZiBub3RoaW5nIHdhcyByZW1vdmVkLlxuICAgKi9cbiAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcblxuICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudC5ub2RlVHlwZSAhPT0gOSkge1xuICAgIC8vIE5vdCBydW5uaW5nIGluIGEgYnJvd3NlciwgcHJvdmlkZSBhIGZhY3RvcnkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IHlvdSBjYW4gcGFzcyB5b3VyIG93biBXaW5kb3dcbiAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiBET01QdXJpZnk7XG4gIH1cblxuICB2YXIgb3JpZ2luYWxEb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICB2YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIHZhciBEb2N1bWVudEZyYWdtZW50ID0gd2luZG93LkRvY3VtZW50RnJhZ21lbnQsXG4gICAgICBIVE1MVGVtcGxhdGVFbGVtZW50ID0gd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gICAgICBOb2RlID0gd2luZG93Lk5vZGUsXG4gICAgICBFbGVtZW50ID0gd2luZG93LkVsZW1lbnQsXG4gICAgICBOb2RlRmlsdGVyID0gd2luZG93Lk5vZGVGaWx0ZXIsXG4gICAgICBfd2luZG93JE5hbWVkTm9kZU1hcCA9IHdpbmRvdy5OYW1lZE5vZGVNYXAsXG4gICAgICBOYW1lZE5vZGVNYXAgPSBfd2luZG93JE5hbWVkTm9kZU1hcCA9PT0gdW5kZWZpbmVkID8gd2luZG93Lk5hbWVkTm9kZU1hcCB8fCB3aW5kb3cuTW96TmFtZWRBdHRyTWFwIDogX3dpbmRvdyROYW1lZE5vZGVNYXAsXG4gICAgICBUZXh0ID0gd2luZG93LlRleHQsXG4gICAgICBDb21tZW50ID0gd2luZG93LkNvbW1lbnQsXG4gICAgICBET01QYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyLFxuICAgICAgdHJ1c3RlZFR5cGVzID0gd2luZG93LnRydXN0ZWRUeXBlcztcblxuXG4gIHZhciBFbGVtZW50UHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgdmFyIGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2xvbmVOb2RlJyk7XG4gIHZhciBnZXROZXh0U2libGluZyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKTtcbiAgdmFyIGdldENoaWxkTm9kZXMgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2NoaWxkTm9kZXMnKTtcbiAgdmFyIGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3BhcmVudE5vZGUnKTtcblxuICAvLyBBcyBwZXIgaXNzdWUgIzQ3LCB0aGUgd2ViLWNvbXBvbmVudHMgcmVnaXN0cnkgaXMgaW5oZXJpdGVkIGJ5IGFcbiAgLy8gbmV3IGRvY3VtZW50IGNyZWF0ZWQgdmlhIGNyZWF0ZUhUTUxEb2N1bWVudC4gQXMgcGVyIHRoZSBzcGVjXG4gIC8vIChodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjcmVhdGluZy1hbmQtcGFzc2luZy1yZWdpc3RyaWVzKVxuICAvLyBhIG5ldyBlbXB0eSByZWdpc3RyeSBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgYSB0ZW1wbGF0ZSBjb250ZW50cyBvd25lclxuICAvLyBkb2N1bWVudCwgc28gd2UgdXNlIHRoYXQgYXMgb3VyIHBhcmVudCBkb2N1bWVudCB0byBlbnN1cmUgbm90aGluZ1xuICAvLyBpcyBpbmhlcml0ZWQuXG4gIGlmICh0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICBkb2N1bWVudCA9IHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudDtcbiAgICB9XG4gIH1cblxuICB2YXIgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIG9yaWdpbmFsRG9jdW1lbnQpO1xuICB2YXIgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTCgnJykgOiAnJztcblxuICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQsXG4gICAgICBpbXBsZW1lbnRhdGlvbiA9IF9kb2N1bWVudC5pbXBsZW1lbnRhdGlvbixcbiAgICAgIGNyZWF0ZU5vZGVJdGVyYXRvciA9IF9kb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3IsXG4gICAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG4gICAgICBnZXRFbGVtZW50c0J5VGFnTmFtZSA9IF9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZTtcbiAgdmFyIGltcG9ydE5vZGUgPSBvcmlnaW5hbERvY3VtZW50LmltcG9ydE5vZGU7XG5cblxuICB2YXIgZG9jdW1lbnRNb2RlID0ge307XG4gIHRyeSB7XG4gICAgZG9jdW1lbnRNb2RlID0gY2xvbmUoZG9jdW1lbnQpLmRvY3VtZW50TW9kZSA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IHt9O1xuICB9IGNhdGNoIChfKSB7fVxuXG4gIHZhciBob29rcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBFeHBvc2Ugd2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcnVubmluZyB0aGUgZnVsbCBET01QdXJpZnkuXG4gICAqL1xuICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZ2V0UGFyZW50Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbXBsZW1lbnRhdGlvbiAmJiB0eXBlb2YgaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudE1vZGUgIT09IDk7XG5cbiAgdmFyIE1VU1RBQ0hFX0VYUFIkJDEgPSBNVVNUQUNIRV9FWFBSLFxuICAgICAgRVJCX0VYUFIkJDEgPSBFUkJfRVhQUixcbiAgICAgIERBVEFfQVRUUiQkMSA9IERBVEFfQVRUUixcbiAgICAgIEFSSUFfQVRUUiQkMSA9IEFSSUFfQVRUUixcbiAgICAgIElTX1NDUklQVF9PUl9EQVRBJCQxID0gSVNfU0NSSVBUX09SX0RBVEEsXG4gICAgICBBVFRSX1dISVRFU1BBQ0UkJDEgPSBBVFRSX1dISVRFU1BBQ0U7XG4gIHZhciBJU19BTExPV0VEX1VSSSQkMSA9IElTX0FMTE9XRURfVVJJO1xuXG4gIC8qKlxuICAgKiBXZSBjb25zaWRlciB0aGUgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgYmVsb3cgdG8gYmUgc2FmZS4gSWRlYWxseVxuICAgKiBkb24ndCBhZGQgYW55IG5ldyBvbmVzIGJ1dCBmZWVsIGZyZWUgdG8gcmVtb3ZlIHVud2FudGVkIG9uZXMuXG4gICAqL1xuXG4gIC8qIGFsbG93ZWQgZWxlbWVudCBuYW1lcyAqL1xuXG4gIHZhciBBTExPV0VEX1RBR1MgPSBudWxsO1xuICB2YXIgREVGQVVMVF9BTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKGh0bWwkMiksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2ZyksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2Z0ZpbHRlcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShtYXRoTWwpLCBfdG9Db25zdW1hYmxlQXJyYXkkMSh0ZXh0KSkpO1xuXG4gIC8qIEFsbG93ZWQgYXR0cmlidXRlIG5hbWVzICovXG4gIHZhciBBTExPV0VEX0FUVFIgPSBudWxsO1xuICB2YXIgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKGh0bWwkMSQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoc3ZnJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShtYXRoTWwkMSksIF90b0NvbnN1bWFibGVBcnJheSQxKHhtbCkpKTtcblxuICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuICB2YXIgRk9SQklEX1RBR1MgPSBudWxsO1xuXG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIGF0dHJpYnV0ZXMgKG92ZXJyaWRlcyBBTExPV0VEX0FUVFIvQUREX0FUVFIpICovXG4gIHZhciBGT1JCSURfQVRUUiA9IG51bGw7XG5cbiAgLyogRGVjaWRlIGlmIEFSSUEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICB2YXIgQUxMT1dfQVJJQV9BVFRSID0gdHJ1ZTtcblxuICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICB2YXIgQUxMT1dfREFUQV9BVFRSID0gdHJ1ZTtcblxuICAvKiBEZWNpZGUgaWYgdW5rbm93biBwcm90b2NvbHMgYXJlIG9rYXkgKi9cbiAgdmFyIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gZmFsc2U7XG5cbiAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGZvciBjb21tb24gdGVtcGxhdGUgZW5naW5lcy5cbiAgICogVGhpcyBtZWFucywgRE9NUHVyaWZ5IHJlbW92ZXMgZGF0YSBhdHRyaWJ1dGVzLCBtdXN0YWNoZXMgYW5kIEVSQlxuICAgKi9cbiAgdmFyIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuXG4gIC8qIERlY2lkZSBpZiBkb2N1bWVudCB3aXRoIDxodG1sPi4uLiBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgdmFyIFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG5cbiAgLyogVHJhY2sgd2hldGhlciBjb25maWcgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyBpbnN0YW5jZSBvZiBET01QdXJpZnkuICovXG4gIHZhciBTRVRfQ09ORklHID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAqIGRvY3VtZW50LmJvZHkuIEJ5IGRlZmF1bHQsIGJyb3dzZXJzIG1pZ2h0IG1vdmUgdGhlbSB0byBkb2N1bWVudC5oZWFkICovXG4gIHZhciBGT1JDRV9CT0RZID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpLlxuICAgKiBJZiBgV0hPTEVfRE9DVU1FTlRgIGlzIGVuYWJsZWQgYSBgSFRNTEh0bWxFbGVtZW50YCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWRcbiAgICovXG4gIHZhciBSRVRVUk5fRE9NID0gZmFsc2U7XG5cbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBEb2N1bWVudEZyYWdtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cbiAgdmFyIFJFVFVSTl9ET01fRlJBR01FTlQgPSBmYWxzZTtcblxuICAvKiBJZiBgUkVUVVJOX0RPTWAgb3IgYFJFVFVSTl9ET01fRlJBR01FTlRgIGlzIGVuYWJsZWQsIGRlY2lkZSBpZiB0aGUgcmV0dXJuZWQgRE9NXG4gICAqIGBOb2RlYCBpcyBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGBEb2N1bWVudGAuIElmIHRoaXMgZmxhZyBpcyBub3QgZW5hYmxlZCB0aGVcbiAgICogYE5vZGVgIHdpbGwgYmVsb25nIChpdHMgb3duZXJEb2N1bWVudCkgdG8gYSBmcmVzaCBgSFRNTERvY3VtZW50YCwgY3JlYXRlZCBieVxuICAgKiBET01QdXJpZnkuXG4gICAqXG4gICAqIFRoaXMgZGVmYXVsdHMgdG8gYHRydWVgIHN0YXJ0aW5nIERPTVB1cmlmeSAyLjIuMC4gTm90ZSB0aGF0IHNldHRpbmcgaXQgdG8gYGZhbHNlYFxuICAgKiBtaWdodCBjYXVzZSBYU1MgZnJvbSBhdHRhY2tzIGhpZGRlbiBpbiBjbG9zZWQgc2hhZG93cm9vdHMgaW4gY2FzZSB0aGUgYnJvd3NlclxuICAgKiBzdXBwb3J0cyBEZWNsYXJhdGl2ZSBTaGFkb3c6IERPTSBodHRwczovL3dlYi5kZXYvZGVjbGFyYXRpdmUtc2hhZG93LWRvbS9cbiAgICovXG4gIHZhciBSRVRVUk5fRE9NX0lNUE9SVCA9IHRydWU7XG5cbiAgLyogVHJ5IHRvIHJldHVybiBhIFRydXN0ZWQgVHlwZSBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZywgcmV0dXJuIGEgc3RyaW5nIGluXG4gICAqIGNhc2UgVHJ1c3RlZCBUeXBlcyBhcmUgbm90IHN1cHBvcnRlZCAgKi9cbiAgdmFyIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBmYWxzZTtcblxuICAvKiBPdXRwdXQgc2hvdWxkIGJlIGZyZWUgZnJvbSBET00gY2xvYmJlcmluZyBhdHRhY2tzPyAqL1xuICB2YXIgU0FOSVRJWkVfRE9NID0gdHJ1ZTtcblxuICAvKiBLZWVwIGVsZW1lbnQgY29udGVudCB3aGVuIHJlbW92aW5nIGVsZW1lbnQ/ICovXG4gIHZhciBLRUVQX0NPTlRFTlQgPSB0cnVlO1xuXG4gIC8qIElmIGEgYE5vZGVgIGlzIHBhc3NlZCB0byBzYW5pdGl6ZSgpLCB0aGVuIHBlcmZvcm1zIHNhbml0aXphdGlvbiBpbi1wbGFjZSBpbnN0ZWFkXG4gICAqIG9mIGltcG9ydGluZyBpdCBpbnRvIGEgbmV3IERvY3VtZW50IGFuZCByZXR1cm5pbmcgYSBzYW5pdGl6ZWQgY29weSAqL1xuICB2YXIgSU5fUExBQ0UgPSBmYWxzZTtcblxuICAvKiBBbGxvdyB1c2FnZSBvZiBwcm9maWxlcyBsaWtlIGh0bWwsIHN2ZyBhbmQgbWF0aE1sICovXG4gIHZhciBVU0VfUFJPRklMRVMgPSB7fTtcblxuICAvKiBUYWdzIHRvIGlnbm9yZSBjb250ZW50IG9mIHdoZW4gS0VFUF9DT05URU5UIGlzIHRydWUgKi9cbiAgdmFyIEZPUkJJRF9DT05URU5UUyA9IG51bGw7XG4gIHZhciBERUZBVUxUX0ZPUkJJRF9DT05URU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2Fubm90YXRpb24teG1sJywgJ2F1ZGlvJywgJ2NvbGdyb3VwJywgJ2Rlc2MnLCAnZm9yZWlnbm9iamVjdCcsICdoZWFkJywgJ2lmcmFtZScsICdtYXRoJywgJ21pJywgJ21uJywgJ21vJywgJ21zJywgJ210ZXh0JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAncGxhaW50ZXh0JywgJ3NjcmlwdCcsICdzdHlsZScsICdzdmcnLCAndGVtcGxhdGUnLCAndGhlYWQnLCAndGl0bGUnLCAndmlkZW8nLCAneG1wJ10pO1xuXG4gIC8qIFRhZ3MgdGhhdCBhcmUgc2FmZSBmb3IgZGF0YTogVVJJcyAqL1xuICB2YXIgREFUQV9VUklfVEFHUyA9IG51bGw7XG4gIHZhciBERUZBVUxUX0RBVEFfVVJJX1RBR1MgPSBhZGRUb1NldCh7fSwgWydhdWRpbycsICd2aWRlbycsICdpbWcnLCAnc291cmNlJywgJ2ltYWdlJywgJ3RyYWNrJ10pO1xuXG4gIC8qIEF0dHJpYnV0ZXMgc2FmZSBmb3IgdmFsdWVzIGxpa2UgXCJqYXZhc2NyaXB0OlwiICovXG4gIHZhciBVUklfU0FGRV9BVFRSSUJVVEVTID0gbnVsbDtcbiAgdmFyIERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyA9IGFkZFRvU2V0KHt9LCBbJ2FsdCcsICdjbGFzcycsICdmb3InLCAnaWQnLCAnbGFiZWwnLCAnbmFtZScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3JvbGUnLCAnc3VtbWFyeScsICd0aXRsZScsICd2YWx1ZScsICdzdHlsZScsICd4bWxucyddKTtcblxuICB2YXIgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgdmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICB2YXIgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG4gIC8qIERvY3VtZW50IG5hbWVzcGFjZSAqL1xuICB2YXIgTkFNRVNQQUNFID0gSFRNTF9OQU1FU1BBQ0U7XG4gIHZhciBJU19FTVBUWV9JTlBVVCA9IGZhbHNlO1xuXG4gIC8qIFBhcnNpbmcgb2Ygc3RyaWN0IFhIVE1MIGRvY3VtZW50cyAqL1xuICB2YXIgUEFSU0VSX01FRElBX1RZUEUgPSB2b2lkIDA7XG4gIHZhciBTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTID0gWydhcHBsaWNhdGlvbi94aHRtbCt4bWwnLCAndGV4dC9odG1sJ107XG4gIHZhciBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gIHZhciB0cmFuc2Zvcm1DYXNlRnVuYyA9IHZvaWQgMDtcblxuICAvKiBLZWVwIGEgcmVmZXJlbmNlIHRvIGNvbmZpZyB0byBwYXNzIHRvIGhvb2tzICovXG4gIHZhciBDT05GSUcgPSBudWxsO1xuXG4gIC8qIElkZWFsbHksIGRvIG5vdCB0b3VjaCBhbnl0aGluZyBiZWxvdyB0aGlzIGxpbmUgKi9cbiAgLyogX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAqL1xuXG4gIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblxuICAvKipcbiAgICogX3BhcnNlQ29uZmlnXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2ZnIG9wdGlvbmFsIGNvbmZpZyBsaXRlcmFsXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICB2YXIgX3BhcnNlQ29uZmlnID0gZnVuY3Rpb24gX3BhcnNlQ29uZmlnKGNmZykge1xuICAgIGlmIChDT05GSUcgJiYgQ09ORklHID09PSBjZmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0YW1wZXJpbmcgKi9cbiAgICBpZiAoIWNmZyB8fCAodHlwZW9mIGNmZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2ZnKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSBwcm90b3R5cGUgcG9sbHV0aW9uICovXG4gICAgY2ZnID0gY2xvbmUoY2ZnKTtcblxuICAgIC8qIFNldCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICBBTExPV0VEX1RBR1MgPSAnQUxMT1dFRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfVEFHUykgOiBERUZBVUxUX0FMTE9XRURfVEFHUztcbiAgICBBTExPV0VEX0FUVFIgPSAnQUxMT1dFRF9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfQVRUUikgOiBERUZBVUxUX0FMTE9XRURfQVRUUjtcbiAgICBVUklfU0FGRV9BVFRSSUJVVEVTID0gJ0FERF9VUklfU0FGRV9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpIDogREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTO1xuICAgIERBVEFfVVJJX1RBR1MgPSAnQUREX0RBVEFfVVJJX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfREFUQV9VUklfVEFHUyksIGNmZy5BRERfREFUQV9VUklfVEFHUykgOiBERUZBVUxUX0RBVEFfVVJJX1RBR1M7XG4gICAgRk9SQklEX0NPTlRFTlRTID0gJ0ZPUkJJRF9DT05URU5UUycgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfQ09OVEVOVFMpIDogREVGQVVMVF9GT1JCSURfQ09OVEVOVFM7XG4gICAgRk9SQklEX1RBR1MgPSAnRk9SQklEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX1RBR1MpIDoge307XG4gICAgRk9SQklEX0FUVFIgPSAnRk9SQklEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIpIDoge307XG4gICAgVVNFX1BST0ZJTEVTID0gJ1VTRV9QUk9GSUxFUycgaW4gY2ZnID8gY2ZnLlVTRV9QUk9GSUxFUyA6IGZhbHNlO1xuICAgIEFMTE9XX0FSSUFfQVRUUiA9IGNmZy5BTExPV19BUklBX0FUVFIgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgPSBjZmcuQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBTQUZFX0ZPUl9URU1QTEFURVMgPSBjZmcuU0FGRV9GT1JfVEVNUExBVEVTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NID0gY2ZnLlJFVFVSTl9ET00gfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NX0lNUE9SVCA9IGNmZy5SRVRVUk5fRE9NX0lNUE9SVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIFJFVFVSTl9UUlVTVEVEX1RZUEUgPSBjZmcuUkVUVVJOX1RSVVNURURfVFlQRSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIEZPUkNFX0JPRFkgPSBjZmcuRk9SQ0VfQk9EWSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICBLRUVQX0NPTlRFTlQgPSBjZmcuS0VFUF9DT05URU5UICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgSU5fUExBQ0UgPSBjZmcuSU5fUExBQ0UgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBJU19BTExPV0VEX1VSSSQkMSA9IGNmZy5BTExPV0VEX1VSSV9SRUdFWFAgfHwgSVNfQUxMT1dFRF9VUkkkJDE7XG4gICAgTkFNRVNQQUNFID0gY2ZnLk5BTUVTUEFDRSB8fCBIVE1MX05BTUVTUEFDRTtcblxuICAgIFBBUlNFUl9NRURJQV9UWVBFID1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICBTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTLmluZGV4T2YoY2ZnLlBBUlNFUl9NRURJQV9UWVBFKSA9PT0gLTEgPyBQQVJTRVJfTUVESUFfVFlQRSA9IERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgOiBQQVJTRVJfTUVESUFfVFlQRSA9IGNmZy5QQVJTRVJfTUVESUFfVFlQRTtcblxuICAgIC8vIEhUTUwgdGFncyBhbmQgYXR0cmlidXRlcyBhcmUgbm90IGNhc2Utc2Vuc2l0aXZlLCBjb252ZXJ0aW5nIHRvIGxvd2VyY2FzZS4gS2VlcGluZyBYSFRNTCBhcyBpcy5cbiAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9IDogc3RyaW5nVG9Mb3dlckNhc2U7XG5cbiAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgUkVUVVJOX0RPTSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG4gICAgaWYgKFVTRV9QUk9GSUxFUykge1xuICAgICAgQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMSh0ZXh0KSkpO1xuICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLmh0bWwgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBodG1sJDIpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGh0bWwkMSQxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmcgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmcpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLnN2Z0ZpbHRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmckMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgeG1sKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5tYXRoTWwgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBtYXRoTWwpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCQxKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE1lcmdlIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyAqL1xuICAgIGlmIChjZmcuQUREX1RBR1MpIHtcbiAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9IGNsb25lKEFMTE9XRURfVEFHUyk7XG4gICAgICB9XG5cbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTKTtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLkFERF9BVFRSKSB7XG4gICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICBBTExPV0VEX0FUVFIgPSBjbG9uZShBTExPV0VEX0FUVFIpO1xuICAgICAgfVxuXG4gICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUik7XG4gICAgfVxuXG4gICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSKTtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLkZPUkJJRF9DT05URU5UUykge1xuICAgICAgaWYgKEZPUkJJRF9DT05URU5UUyA9PT0gREVGQVVMVF9GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gY2xvbmUoRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgIH1cblxuICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTKTtcbiAgICB9XG5cbiAgICAvKiBBZGQgI3RleHQgaW4gY2FzZSBLRUVQX0NPTlRFTlQgaXMgc2V0IHRvIHRydWUgKi9cbiAgICBpZiAoS0VFUF9DT05URU5UKSB7XG4gICAgICBBTExPV0VEX1RBR1NbJyN0ZXh0J10gPSB0cnVlO1xuICAgIH1cblxuICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQpIHtcbiAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgWydodG1sJywgJ2hlYWQnLCAnYm9keSddKTtcbiAgICB9XG5cbiAgICAvKiBBZGQgdGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgdGFibGVzIGFyZSBwZXJtaXR0ZWQsIHNlZSAjMjg2LCAjMzY1ICovXG4gICAgaWYgKEFMTE9XRURfVEFHUy50YWJsZSkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgZGVsZXRlIEZPUkJJRF9UQUdTLnRib2R5O1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZnVydGhlciBtYW5pcHVsYXRpb24gb2YgY29uZmlndXJhdGlvbi5cbiAgICAvLyBOb3QgYXZhaWxhYmxlIGluIElFOCwgU2FmYXJpIDUsIGV0Yy5cbiAgICBpZiAoZnJlZXplKSB7XG4gICAgICBmcmVlemUoY2ZnKTtcbiAgICB9XG5cbiAgICBDT05GSUcgPSBjZmc7XG4gIH07XG5cbiAgdmFyIE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ21pJywgJ21vJywgJ21uJywgJ21zJywgJ210ZXh0J10pO1xuXG4gIHZhciBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2ZvcmVpZ25vYmplY3QnLCAnZGVzYycsICd0aXRsZScsICdhbm5vdGF0aW9uLXhtbCddKTtcblxuICAvKiBLZWVwIHRyYWNrIG9mIGFsbCBwb3NzaWJsZSBTVkcgYW5kIE1hdGhNTCB0YWdzXG4gICAqIHNvIHRoYXQgd2UgY2FuIHBlcmZvcm0gdGhlIG5hbWVzcGFjZSBjaGVja3NcbiAgICogY29ycmVjdGx5LiAqL1xuICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2Zyk7XG4gIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRmlsdGVycyk7XG4gIGFkZFRvU2V0KEFMTF9TVkdfVEFHUywgc3ZnRGlzYWxsb3dlZCk7XG5cbiAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwpO1xuICBhZGRUb1NldChBTExfTUFUSE1MX1RBR1MsIG1hdGhNbERpc2FsbG93ZWQpO1xuXG4gIC8qKlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtZW50IGEgRE9NIGVsZW1lbnQgd2hvc2UgbmFtZXNwYWNlIGlzIGJlaW5nIGNoZWNrZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYVxuICAgKiAgbmFtZXNwYWNlIHRoYXQgYSBzcGVjLWNvbXBsaWFudCBwYXJzZXIgd291bGQgbmV2ZXJcbiAgICogIHJldHVybi4gUmV0dXJuIHRydWUgb3RoZXJ3aXNlLlxuICAgKi9cbiAgdmFyIF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gICAgLy8gSW4gSlNET00sIGlmIHdlJ3JlIGluc2lkZSBzaGFkb3cgRE9NLCB0aGVuIHBhcmVudE5vZGVcbiAgICAvLyBjYW4gYmUgbnVsbC4gV2UganVzdCBzaW11bGF0ZSBwYXJlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQudGFnTmFtZSkge1xuICAgICAgcGFyZW50ID0ge1xuICAgICAgICBuYW1lc3BhY2VVUkk6IEhUTUxfTkFNRVNQQUNFLFxuICAgICAgICB0YWdOYW1lOiAndGVtcGxhdGUnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoZWxlbWVudC50YWdOYW1lKTtcbiAgICB2YXIgcGFyZW50VGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKHBhcmVudC50YWdOYW1lKTtcblxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIFNWR1xuICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIE1hdGhNTCB0byBTVkcgaXMgdmlhXG4gICAgICAvLyBzdmcgaWYgcGFyZW50IGlzIGVpdGhlciA8YW5ub3RhdGlvbi14bWw+IG9yIE1hdGhNTFxuICAgICAgLy8gdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHMuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ3N2ZycgJiYgKHBhcmVudFRhZ05hbWUgPT09ICdhbm5vdGF0aW9uLXhtbCcgfHwgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIFNWR1xuICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBNYXRoTUxcbiAgICAgIC8vIGlzIHZpYSA8bWF0aD4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJztcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBNYXRoTUwgaXMgdmlhXG4gICAgICAvLyA8bWF0aD4gYW5kIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnICYmIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gTWF0aE1MXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIE1hdGhNTCBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfTUFUSE1MX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gSFRNTCBpcyB2aWFcbiAgICAgIC8vIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzLCBhbmQgZnJvbSBNYXRoTUwgdG8gSFRNTFxuICAgICAgLy8gaXMgdmlhIE1hdGhNTCB0ZXh0IGludGVncmF0aW9uIHBvaW50c1xuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UgJiYgIU1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENlcnRhaW4gZWxlbWVudHMgYXJlIGFsbG93ZWQgaW4gYm90aCBTVkcgYW5kIEhUTUxcbiAgICAgIC8vIG5hbWVzcGFjZS4gV2UgbmVlZCB0byBzcGVjaWZ5IHRoZW0gZXhwbGljaXRseVxuICAgICAgLy8gc28gdGhhdCB0aGV5IGRvbid0IGdldCBlcnJvbm91c2x5IGRlbGV0ZWQgZnJvbVxuICAgICAgLy8gSFRNTCBuYW1lc3BhY2UuXG4gICAgICB2YXIgY29tbW9uU3ZnQW5kSFRNTEVsZW1lbnRzID0gYWRkVG9TZXQoe30sIFsndGl0bGUnLCAnc3R5bGUnLCAnZm9udCcsICdhJywgJ3NjcmlwdCddKTtcblxuICAgICAgLy8gV2UgZGlzYWxsb3cgdGFncyB0aGF0IGFyZSBzcGVjaWZpYyBmb3IgTWF0aE1MXG4gICAgICAvLyBvciBTVkcgYW5kIHNob3VsZCBuZXZlciBhcHBlYXIgaW4gSFRNTCBuYW1lc3BhY2VcbiAgICAgIHJldHVybiAhQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdICYmIChjb21tb25TdmdBbmRIVE1MRWxlbWVudHNbdGFnTmFtZV0gfHwgIUFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGNvZGUgc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGxhY2UgKHRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBlbGVtZW50IHNvbWVob3cgZ290IG5hbWVzcGFjZSB0aGF0IGlzIG5vdFxuICAgIC8vIEhUTUwsIFNWRyBvciBNYXRoTUwpLiBSZXR1cm4gZmFsc2UganVzdCBpbiBjYXNlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogX2ZvcmNlUmVtb3ZlXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgKi9cbiAgdmFyIF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZShub2RlKSB7XG4gICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7IGVsZW1lbnQ6IG5vZGUgfSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICB0cnkge1xuICAgICAgICBub2RlLm91dGVySFRNTCA9IGVtcHR5SFRNTDtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIGFuIEF0dHJpYnV0ZSBuYW1lXG4gICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgKi9cbiAgdmFyIF9yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgIGF0dHJpYnV0ZTogbm9kZS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpLFxuICAgICAgICBmcm9tOiBub2RlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICBmcm9tOiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblxuICAgIC8vIFdlIHZvaWQgYXR0cmlidXRlIHZhbHVlcyBmb3IgdW5yZW1vdmFibGUgXCJpc1wiXCIgYXR0cmlidXRlc1xuICAgIGlmIChuYW1lID09PSAnaXMnICYmICFBTExPV0VEX0FUVFJbbmFtZV0pIHtcbiAgICAgIGlmIChSRVRVUk5fRE9NIHx8IFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfZm9yY2VSZW1vdmUobm9kZSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pbml0RG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJ0eSBhIHN0cmluZyBvZiBkaXJ0eSBtYXJrdXBcbiAgICogQHJldHVybiB7RG9jdW1lbnR9IGEgRE9NLCBmaWxsZWQgd2l0aCB0aGUgZGlydHkgbWFya3VwXG4gICAqL1xuICB2YXIgX2luaXREb2N1bWVudCA9IGZ1bmN0aW9uIF9pbml0RG9jdW1lbnQoZGlydHkpIHtcbiAgICAvKiBDcmVhdGUgYSBIVE1MIGRvY3VtZW50ICovXG4gICAgdmFyIGRvYyA9IHZvaWQgMDtcbiAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSB2b2lkIDA7XG5cbiAgICBpZiAoRk9SQ0VfQk9EWSkge1xuICAgICAgZGlydHkgPSAnPHJlbW92ZT48L3JlbW92ZT4nICsgZGlydHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIElmIEZPUkNFX0JPRFkgaXNuJ3QgdXNlZCwgbGVhZGluZyB3aGl0ZXNwYWNlIG5lZWRzIHRvIGJlIHByZXNlcnZlZCBtYW51YWxseSAqL1xuICAgICAgdmFyIG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgICB9XG5cbiAgICBpZiAoUEFSU0VSX01FRElBX1RZUEUgPT09ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnKSB7XG4gICAgICAvLyBSb290IG9mIFhIVE1MIGRvYyBtdXN0IGNvbnRhaW4geG1sbnMgZGVjbGFyYXRpb24gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveGh0bWwxL25vcm1hdGl2ZS5odG1sI3N0cmljdClcbiAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgIH1cblxuICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAvKlxuICAgICAqIFVzZSB0aGUgRE9NUGFyc2VyIEFQSSBieSBkZWZhdWx0LCBmYWxsYmFjayBsYXRlciBpZiBuZWVkcyBiZVxuICAgICAqIERPTVBhcnNlciBub3Qgd29yayBmb3Igc3ZnIHdoZW4gaGFzIG11bHRpcGxlIHJvb3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuXG4gICAgLyogVXNlIGNyZWF0ZUhUTUxEb2N1bWVudCBpbiBjYXNlIERPTVBhcnNlciBpcyBub3QgYXZhaWxhYmxlICovXG4gICAgaWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGRvYyA9IGltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KE5BTUVTUEFDRSwgJ3RlbXBsYXRlJywgbnVsbCk7XG4gICAgICB0cnkge1xuICAgICAgICBkb2MuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTCA9IElTX0VNUFRZX0lOUFVUID8gJycgOiBkaXJ0eVBheWxvYWQ7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIC8vIFN5bnRheCBlcnJvciBpZiBkaXJ0eVBheWxvYWQgaXMgaW52YWxpZCB4bWxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IGRvYy5ib2R5IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxlYWRpbmdXaGl0ZXNwYWNlKSwgYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGwpO1xuICAgIH1cblxuICAgIC8qIFdvcmsgb24gd2hvbGUgZG9jdW1lbnQgb3IganVzdCBpdHMgYm9keSAqL1xuICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICByZXR1cm4gZ2V0RWxlbWVudHNCeVRhZ05hbWUuY2FsbChkb2MsIFdIT0xFX0RPQ1VNRU5UID8gJ2h0bWwnIDogJ2JvZHknKVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgfTtcblxuICAvKipcbiAgICogX2NyZWF0ZUl0ZXJhdG9yXG4gICAqXG4gICAqIEBwYXJhbSAge0RvY3VtZW50fSByb290IGRvY3VtZW50L2ZyYWdtZW50IHRvIGNyZWF0ZSBpdGVyYXRvciBmb3JcbiAgICogQHJldHVybiB7SXRlcmF0b3J9IGl0ZXJhdG9yIGluc3RhbmNlXG4gICAqL1xuICB2YXIgX2NyZWF0ZUl0ZXJhdG9yID0gZnVuY3Rpb24gX2NyZWF0ZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfaXNDbG9iYmVyZWRcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gZWxtIGVsZW1lbnQgdG8gY2hlY2sgZm9yIGNsb2JiZXJpbmcgYXR0YWNrc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNsb2JiZXJlZCwgZmFsc2UgaWYgc2FmZVxuICAgKi9cbiAgdmFyIF9pc0Nsb2JiZXJlZCA9IGZ1bmN0aW9uIF9pc0Nsb2JiZXJlZChlbG0pIHtcbiAgICBpZiAoZWxtIGluc3RhbmNlb2YgVGV4dCB8fCBlbG0gaW5zdGFuY2VvZiBDb21tZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0udGV4dENvbnRlbnQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsbS5yZW1vdmVBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0uaW5zZXJ0QmVmb3JlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9pc05vZGVcbiAgICpcbiAgICogQHBhcmFtICB7Tm9kZX0gb2JqIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAqL1xuICB2YXIgX2lzTm9kZSA9IGZ1bmN0aW9uIF9pc05vZGUob2JqZWN0KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgTm9kZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoTm9kZSkpID09PSAnb2JqZWN0JyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgfTtcblxuICAvKipcbiAgICogX2V4ZWN1dGVIb29rXG4gICAqIEV4ZWN1dGUgdXNlciBjb25maWd1cmFibGUgaG9va3NcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50ICBOYW1lIG9mIHRoZSBob29rJ3MgZW50cnkgcG9pbnRcbiAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgbm9kZSB0byB3b3JrIG9uIHdpdGggdGhlIGhvb2tcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgaG9vayBwYXJhbWV0ZXJzXG4gICAqL1xuICB2YXIgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gX2V4ZWN1dGVIb29rKGVudHJ5UG9pbnQsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgaWYgKCFob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFycmF5Rm9yRWFjaChob29rc1tlbnRyeVBvaW50XSwgZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBfc2FuaXRpemVFbGVtZW50c1xuICAgKlxuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCB0ZXh0Q29udGVudFxuICAgKiBAcHJvdGVjdCByZW1vdmVDaGlsZFxuICAgKlxuICAgKiBAcGFyYW0gICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb24gdG8gZXhpc3RcbiAgICogQHJldHVybiAge0Jvb2xlYW59IHRydWUgaWYgbm9kZSB3YXMga2lsbGVkLCBmYWxzZSBpZiBsZWZ0IGFsaXZlXG4gICAqL1xuICB2YXIgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgIHZhciBjb250ZW50ID0gdm9pZCAwO1xuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIC8qIENoZWNrIGlmIGVsZW1lbnQgaXMgY2xvYmJlcmVkIG9yIGNhbiBjbG9iYmVyICovXG4gICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBDaGVjayBpZiB0YWduYW1lIGNvbnRhaW5zIFVuaWNvZGUgKi9cbiAgICBpZiAoc3RyaW5nTWF0Y2goY3VycmVudE5vZGUubm9kZU5hbWUsIC9bXFx1MDA4MC1cXHVGRkZGXS8pKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogTm93IGxldCdzIGNoZWNrIHRoZSBlbGVtZW50J3MgdHlwZSBhbmQgbmFtZSAqL1xuICAgIHZhciB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplRWxlbWVudCcsIGN1cnJlbnROb2RlLCB7XG4gICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgYWxsb3dlZFRhZ3M6IEFMTE9XRURfVEFHU1xuICAgIH0pO1xuXG4gICAgLyogRGV0ZWN0IG1YU1MgYXR0ZW1wdHMgYWJ1c2luZyBuYW1lc3BhY2UgY29uZnVzaW9uICovXG4gICAgaWYgKCFfaXNOb2RlKGN1cnJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKSAmJiAoIV9pc05vZGUoY3VycmVudE5vZGUuY29udGVudCkgfHwgIV9pc05vZGUoY3VycmVudE5vZGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZCkpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUuaW5uZXJIVE1MKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLnRleHRDb250ZW50KSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qIE1pdGlnYXRlIGEgcHJvYmxlbSB3aXRoIHRlbXBsYXRlcyBpbnNpZGUgc2VsZWN0ICovXG4gICAgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnICYmIHJlZ0V4cFRlc3QoLzx0ZW1wbGF0ZS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogUmVtb3ZlIGVsZW1lbnQgaWYgYW55dGhpbmcgZm9yYmlkcyBpdHMgcHJlc2VuY2UgKi9cbiAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgLyogS2VlcCBjb250ZW50IGV4Y2VwdCBmb3IgYmFkLWxpc3RlZCBlbGVtZW50cyAqL1xuICAgICAgaWYgKEtFRVBfQ09OVEVOVCAmJiAhRk9SQklEX0NPTlRFTlRTW3RhZ05hbWVdKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBnZXRDaGlsZE5vZGVzKGN1cnJlbnROb2RlKSB8fCBjdXJyZW50Tm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICAgIGlmIChjaGlsZE5vZGVzICYmIHBhcmVudE5vZGUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGNoaWxkQ291bnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmVOb2RlKGNoaWxkTm9kZXNbaV0sIHRydWUpLCBnZXROZXh0U2libGluZyhjdXJyZW50Tm9kZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyogQ2hlY2sgd2hldGhlciBlbGVtZW50IGhhcyBhIHZhbGlkIG5hbWVzcGFjZSAqL1xuICAgIGlmIChjdXJyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIV9jaGVja1ZhbGlkTmFtZXNwYWNlKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICgodGFnTmFtZSA9PT0gJ25vc2NyaXB0JyB8fCB0YWdOYW1lID09PSAnbm9lbWJlZCcpICYmIHJlZ0V4cFRlc3QoLzxcXC9ubyhzY3JpcHR8ZW1iZWQpL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiBTYW5pdGl6ZSBlbGVtZW50IGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIC8qIEdldCB0aGUgZWxlbWVudCdzIHRleHQgY29udGVudCAqL1xuICAgICAgY29udGVudCA9IGN1cnJlbnROb2RlLnRleHRDb250ZW50O1xuICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgIGNvbnRlbnQgPSBzdHJpbmdSZXBsYWNlKGNvbnRlbnQsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwgeyBlbGVtZW50OiBjdXJyZW50Tm9kZS5jbG9uZU5vZGUoKSB9KTtcbiAgICAgICAgY3VycmVudE5vZGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogX2lzVmFsaWRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSBsY1RhZyBMb3dlcmNhc2UgdGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxjTmFtZSBMb3dlcmNhc2UgYXR0cmlidXRlIG5hbWUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgdmFyIF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAvKiBNYWtlIHN1cmUgYXR0cmlidXRlIGNhbm5vdCBjbG9iYmVyICovXG4gICAgaWYgKFNBTklUSVpFX0RPTSAmJiAobGNOYW1lID09PSAnaWQnIHx8IGxjTmFtZSA9PT0gJ25hbWUnKSAmJiAodmFsdWUgaW4gZG9jdW1lbnQgfHwgdmFsdWUgaW4gZm9ybUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyogQWxsb3cgdmFsaWQgZGF0YS0qIGF0dHJpYnV0ZXM6IEF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgYWZ0ZXIgXCItXCJcbiAgICAgICAgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2VtYmVkZGluZy1jdXN0b20tbm9uLXZpc2libGUtZGF0YS13aXRoLXRoZS1kYXRhLSotYXR0cmlidXRlcylcbiAgICAgICAgWE1MLWNvbXBhdGlibGUgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjeG1sLWNvbXBhdGlibGUgYW5kIGh0dHA6Ly93d3cudzMub3JnL1RSL3htbC8jZDBlODA0KVxuICAgICAgICBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoZSB2YWx1ZTsgaXQncyBhbHdheXMgVVJJIHNhZmUuICovXG4gICAgaWYgKEFMTE9XX0RBVEFfQVRUUiAmJiAhRk9SQklEX0FUVFJbbGNOYW1lXSAmJiByZWdFeHBUZXN0KERBVEFfQVRUUiQkMSwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIkJDEsIGxjTmFtZSkpIDsgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgLyogQ2hlY2sgdmFsdWUgaXMgc2FmZS4gRmlyc3QsIGlzIGF0dHIgaW5lcnQ/IElmIHNvLCBpcyBzYWZlICovXG4gICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKSA7IGVsc2UgaWYgKChsY05hbWUgPT09ICdzcmMnIHx8IGxjTmFtZSA9PT0gJ3hsaW5rOmhyZWYnIHx8IGxjTmFtZSA9PT0gJ2hyZWYnKSAmJiBsY1RhZyAhPT0gJ3NjcmlwdCcgJiYgc3RyaW5nSW5kZXhPZih2YWx1ZSwgJ2RhdGE6JykgPT09IDAgJiYgREFUQV9VUklfVEFHU1tsY1RhZ10pIDsgZWxzZSBpZiAoQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgJiYgIXJlZ0V4cFRlc3QoSVNfU0NSSVBUX09SX0RBVEEkJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSQkMSwgJycpKSkgOyBlbHNlIGlmICghdmFsdWUpIDsgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByb3RlY3QgYXR0cmlidXRlc1xuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCByZW1vdmVBdHRyaWJ1dGVcbiAgICogQHByb3RlY3Qgc2V0QXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIHRvIHNhbml0aXplXG4gICAqL1xuICB2YXIgX3Nhbml0aXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpIHtcbiAgICB2YXIgYXR0ciA9IHZvaWQgMDtcbiAgICB2YXIgdmFsdWUgPSB2b2lkIDA7XG4gICAgdmFyIGxjTmFtZSA9IHZvaWQgMDtcbiAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IGN1cnJlbnROb2RlLmF0dHJpYnV0ZXM7XG5cbiAgICAvKiBDaGVjayBpZiB3ZSBoYXZlIGF0dHJpYnV0ZXM7IGlmIG5vdCB3ZSBtaWdodCBoYXZlIGEgdGV4dCBub2RlICovXG5cbiAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaG9va0V2ZW50ID0ge1xuICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgYXR0clZhbHVlOiAnJyxcbiAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgIH07XG4gICAgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuXG4gICAgLyogR28gYmFja3dhcmRzIG92ZXIgYWxsIGF0dHJpYnV0ZXM7IHNhZmVseSByZW1vdmUgYmFkIG9uZXMgKi9cbiAgICB3aGlsZSAobC0tKSB7XG4gICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgIHZhciBfYXR0ciA9IGF0dHIsXG4gICAgICAgICAgbmFtZSA9IF9hdHRyLm5hbWUsXG4gICAgICAgICAgbmFtZXNwYWNlVVJJID0gX2F0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICB2YWx1ZSA9IHN0cmluZ1RyaW0oYXR0ci52YWx1ZSk7XG4gICAgICBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhuYW1lKTtcblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgaG9va0V2ZW50LmF0dHJWYWx1ZSA9IHZhbHVlO1xuICAgICAgaG9va0V2ZW50LmtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkOyAvLyBBbGxvd3MgZGV2ZWxvcGVycyB0byBzZWUgdGhpcyBpcyBhIHByb3BlcnR5IHRoZXkgY2FuIHNldFxuICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVBdHRyaWJ1dGUnLCBjdXJyZW50Tm9kZSwgaG9va0V2ZW50KTtcbiAgICAgIHZhbHVlID0gaG9va0V2ZW50LmF0dHJWYWx1ZTtcbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBSZW1vdmUgYXR0cmlidXRlICovXG4gICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcblxuICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICBpZiAoIWhvb2tFdmVudC5rZWVwQXR0cikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogV29yayBhcm91bmQgYSBzZWN1cml0eSBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG4gICAgICBpZiAocmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBTYW5pdGl6ZSBhdHRyaWJ1dGUgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgIH1cblxuICAgICAgLyogSXMgYHZhbHVlYCB2YWxpZCBmb3IgdGhpcyBhdHRyaWJ1dGU/ICovXG4gICAgICB2YXIgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG4gICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLyogSGFuZGxlIGludmFsaWQgZGF0YS0qIGF0dHJpYnV0ZSBzZXQgYnkgdHJ5LWNhdGNoaW5nIGl0ICovXG4gICAgICB0cnkge1xuICAgICAgICBpZiAobmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogRmFsbGJhY2sgdG8gc2V0QXR0cmlidXRlKCkgZm9yIGJyb3dzZXItdW5yZWNvZ25pemVkIG5hbWVzcGFjZXMgZS5nLiBcIngtc2NoZW1hXCIuICovXG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5UG9wKERPTVB1cmlmeS5yZW1vdmVkKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZVNoYWRvd0RPTVxuICAgKlxuICAgKiBAcGFyYW0gIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnbWVudCB0byBpdGVyYXRlIG92ZXIgcmVjdXJzaXZlbHlcbiAgICovXG4gIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICB2YXIgc2hhZG93Tm9kZSA9IHZvaWQgMDtcbiAgICB2YXIgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoZnJhZ21lbnQpO1xuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG5cbiAgICB3aGlsZSAoc2hhZG93Tm9kZSA9IHNoYWRvd0l0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplU2hhZG93Tm9kZScsIHNoYWRvd05vZGUsIG51bGwpO1xuXG4gICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBEZWVwIHNoYWRvdyBET00gZGV0ZWN0ZWQgKi9cbiAgICAgIGlmIChzaGFkb3dOb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShzaGFkb3dOb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayBhdHRyaWJ1dGVzLCBzYW5pdGl6ZSBpZiBuZWNlc3NhcnkgKi9cbiAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoc2hhZG93Tm9kZSk7XG4gICAgfVxuXG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogU2FuaXRpemVcbiAgICogUHVibGljIG1ldGhvZCBwcm92aWRpbmcgY29yZSBzYW5pdGF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gZGlydHkgc3RyaW5nIG9yIERPTSBub2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5LCBjZmcpIHtcbiAgICB2YXIgYm9keSA9IHZvaWQgMDtcbiAgICB2YXIgaW1wb3J0ZWROb2RlID0gdm9pZCAwO1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IHZvaWQgMDtcbiAgICB2YXIgb2xkTm9kZSA9IHZvaWQgMDtcbiAgICB2YXIgcmV0dXJuTm9kZSA9IHZvaWQgMDtcbiAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICAgIERPIE5PVCByZXR1cm4gZWFybHksIGFzIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdyb25nIHR5cGUgaWZcbiAgICAgIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWQgYSBET00gb2JqZWN0IHJhdGhlciB0aGFuIGEgc3RyaW5nICovXG4gICAgSVNfRU1QVFlfSU5QVVQgPSAhZGlydHk7XG4gICAgaWYgKElTX0VNUFRZX0lOUFVUKSB7XG4gICAgICBkaXJ0eSA9ICc8IS0tPic7XG4gICAgfVxuXG4gICAgLyogU3RyaW5naWZ5LCBpbiBjYXNlIGRpcnR5IGlzIGFuIG9iamVjdCAqL1xuICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnICYmICFfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICBpZiAodHlwZW9mIGRpcnR5LnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgndG9TdHJpbmcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5ID0gZGlydHkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIENoZWNrIHdlIGNhbiBydW4uIE90aGVyd2lzZSBmYWxsIGJhY2sgb3IgaWdub3JlICovXG4gICAgaWYgKCFET01QdXJpZnkuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy50b1N0YXRpY0hUTUwpID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygd2luZG93LnRvU3RhdGljSFRNTCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cudG9TdGF0aWNIVE1MKGRpcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cudG9TdGF0aWNIVE1MKGRpcnR5Lm91dGVySFRNTCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cblxuICAgIC8qIEFzc2lnbiBjb25maWcgdmFycyAqL1xuICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgfVxuXG4gICAgLyogQ2xlYW4gdXAgcmVtb3ZlZCBlbGVtZW50cyAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG5cbiAgICAvKiBDaGVjayBpZiBkaXJ0eSBpcyBjb3JyZWN0bHkgdHlwZWQgZm9yIElOX1BMQUNFICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIElOX1BMQUNFID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKElOX1BMQUNFKSA7IGVsc2UgaWYgKGRpcnR5IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgLyogSWYgZGlydHkgaXMgYSBET00gZWxlbWVudCwgYXBwZW5kIHRvIGFuIGVtcHR5IGRvY3VtZW50IHRvIGF2b2lkXG4gICAgICAgICBlbGVtZW50cyBiZWluZyBzdHJpcHBlZCBieSB0aGUgcGFyc2VyICovXG4gICAgICBib2R5ID0gX2luaXREb2N1bWVudCgnPCEtLS0tPicpO1xuICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgaWYgKGltcG9ydGVkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAvKiBOb2RlIGlzIGFscmVhZHkgYSBib2R5LCB1c2UgYXMgaXMgKi9cbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpbXBvcnRlZE5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBFeGl0IGRpcmVjdGx5IGlmIHdlIGhhdmUgbm90aGluZyB0byBkbyAqL1xuICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICAgIGRpcnR5LmluZGV4T2YoJzwnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICB9XG5cbiAgICAgIC8qIEluaXRpYWxpemUgdGhlIGRvY3VtZW50IHRvIHdvcmsgb24gKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcblxuICAgICAgLyogQ2hlY2sgd2UgaGF2ZSBhIERPTSBub2RlIGZyb20gdGhlIGRhdGEgKi9cbiAgICAgIGlmICghYm9keSkge1xuICAgICAgICByZXR1cm4gUkVUVVJOX0RPTSA/IG51bGwgOiBlbXB0eUhUTUw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cbiAgICBpZiAoYm9keSAmJiBGT1JDRV9CT0RZKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoYm9keS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvKiBHZXQgbm9kZSBpdGVyYXRvciAqL1xuICAgIHZhciBub2RlSXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuXG4gICAgLyogTm93IHN0YXJ0IGl0ZXJhdGluZyBvdmVyIHRoZSBjcmVhdGVkIGRvY3VtZW50ICovXG4gICAgd2hpbGUgKGN1cnJlbnROb2RlID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgIC8qIEZpeCBJRSdzIHN0cmFuZ2UgYmVoYXZpb3Igd2l0aCBtYW5pcHVsYXRlZCB0ZXh0Tm9kZXMgIzg5ICovXG4gICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMgJiYgY3VycmVudE5vZGUgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBTaGFkb3cgRE9NIGRldGVjdGVkLCBzYW5pdGl6ZSBpdCAqL1xuICAgICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcywgc2FuaXRpemUgaWYgbmVjZXNzYXJ5ICovXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTtcblxuICAgICAgb2xkTm9kZSA9IGN1cnJlbnROb2RlO1xuICAgIH1cblxuICAgIG9sZE5vZGUgPSBudWxsO1xuXG4gICAgLyogSWYgd2Ugc2FuaXRpemVkIGBkaXJ0eWAgaW4tcGxhY2UsIHJldHVybiBpdC4gKi9cbiAgICBpZiAoSU5fUExBQ0UpIHtcbiAgICAgIHJldHVybiBkaXJ0eTtcbiAgICB9XG5cbiAgICAvKiBSZXR1cm4gc2FuaXRpemVkIHN0cmluZyBvciBET00gKi9cbiAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAgIHdoaWxlIChib2R5LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItZG9tLW5vZGUtYXBwZW5kXG4gICAgICAgICAgcmV0dXJuTm9kZS5hcHBlbmRDaGlsZChib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm5Ob2RlID0gYm9keTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJFVFVSTl9ET01fSU1QT1JUKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgQWRvcHROb2RlKCkgaXMgbm90IHVzZWQgYmVjYXVzZSBpbnRlcm5hbCBzdGF0ZSBpcyBub3QgcmVzZXRcbiAgICAgICAgICAoZS5nLiB0aGUgcGFzdCBuYW1lcyBtYXAgb2YgYSBIVE1MRm9ybUVsZW1lbnQpLCB0aGlzIGlzIHNhZmVcbiAgICAgICAgICBpbiB0aGVvcnkgYnV0IHdlIHdvdWxkIHJhdGhlciBub3QgcmlzayBhbm90aGVyIGF0dGFjayB2ZWN0b3IuXG4gICAgICAgICAgVGhlIHN0YXRlIHRoYXQgaXMgY2xvbmVkIGJ5IGltcG9ydE5vZGUoKSBpcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICBieSB0aGUgc3BlY3MuXG4gICAgICAgICovXG4gICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgIH1cblxuICAgIHZhciBzZXJpYWxpemVkSFRNTCA9IFdIT0xFX0RPQ1VNRU5UID8gYm9keS5vdXRlckhUTUwgOiBib2R5LmlubmVySFRNTDtcblxuICAgIC8qIFNhbml0aXplIGZpbmFsIHN0cmluZyB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChzZXJpYWxpemVkSFRNTCkgOiBzZXJpYWxpemVkSFRNTDtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byBzZXQgdGhlIGNvbmZpZ3VyYXRpb24gb25jZVxuICAgKiBzZXRDb25maWdcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICBfcGFyc2VDb25maWcoY2ZnKTtcbiAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICogY2xlYXJDb25maWdcbiAgICpcbiAgICovXG4gIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBDT05GSUcgPSBudWxsO1xuICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byBjaGVjayBpZiBhbiBhdHRyaWJ1dGUgdmFsdWUgaXMgdmFsaWQuXG4gICAqIFVzZXMgbGFzdCBzZXQgY29uZmlnLCBpZiBhbnkuIE90aGVyd2lzZSwgdXNlcyBjb25maWcgZGVmYXVsdHMuXG4gICAqIGlzVmFsaWRBdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGF0dHIgQXR0cmlidXRlIG5hbWUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICAgKi9cbiAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgIC8qIEluaXRpYWxpemUgc2hhcmVkIGNvbmZpZyB2YXJzIGlmIG5lY2Vzc2FyeS4gKi9cbiAgICBpZiAoIUNPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICB9XG5cbiAgICB2YXIgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyh0YWcpO1xuICAgIHZhciBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTtcbiAgICByZXR1cm4gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRIb29rXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gYWRkIERPTVB1cmlmeSBob29rc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gYWRkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhvb2tGdW5jdGlvbiBmdW5jdGlvbiB0byBleGVjdXRlXG4gICAqL1xuICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIGhvb2tGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gaG9va3NbZW50cnlQb2ludF0gfHwgW107XG4gICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVIb29rXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGEgRE9NUHVyaWZ5IGhvb2sgYXQgYSBnaXZlbiBlbnRyeVBvaW50XG4gICAqIChwb3BzIGl0IGZyb20gdGhlIHN0YWNrIG9mIGhvb2tzIGlmIG1vcmUgYXJlIHByZXNlbnQpXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byByZW1vdmVcbiAgICovXG4gIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgIGFycmF5UG9wKGhvb2tzW2VudHJ5UG9pbnRdKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZUhvb2tzXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGFsbCBET01QdXJpZnkgaG9va3MgYXQgYSBnaXZlbiBlbnRyeVBvaW50XG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2tzIHRvIHJlbW92ZVxuICAgKi9cbiAgRE9NUHVyaWZ5LnJlbW92ZUhvb2tzID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVBbGxIb29rc1xuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhbGwgRE9NUHVyaWZ5IGhvb2tzXG4gICAqXG4gICAqL1xuICBET01QdXJpZnkucmVtb3ZlQWxsSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaG9va3MgPSB7fTtcbiAgfTtcblxuICByZXR1cm4gRE9NUHVyaWZ5O1xufVxuXG52YXIgcHVyaWZ5ID0gY3JlYXRlRE9NUHVyaWZ5KCk7XG5cbnZhciBDQU5fQkVfV0hJVEVfVEFHX0xJU1QgPSBbJ2lmcmFtZScsICdlbWJlZCddO1xudmFyIHdoaXRlVGFnTGlzdCA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHRhZ05hbWUpIHtcbiAgICBpZiAoaW5jbHVkZXMoQ0FOX0JFX1dISVRFX1RBR19MSVNULCB0YWdOYW1lKSkge1xuICAgICAgICB3aGl0ZVRhZ0xpc3QucHVzaCh0YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbml0aXplSFRNTChodG1sLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHB1cmlmeS5zYW5pdGl6ZShodG1sLCBfX2Fzc2lnbiQxKHsgQUREX1RBR1M6IHdoaXRlVGFnTGlzdCwgQUREX0FUVFI6IFsncmVsJywgJ3RhcmdldCcsICdocmVmbGFuZycsICd0eXBlJ10sIEZPUkJJRF9UQUdTOiBbXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgICAgICAndGV4dGFyZWEnLFxuICAgICAgICAgICAgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAnc2VsZWN0JyxcbiAgICAgICAgICAgICdtZXRhJyxcbiAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICAnbGluaycsXG4gICAgICAgICAgICAndGl0bGUnLFxuICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAnYmFzZScsXG4gICAgICAgIF0gfSwgb3B0aW9ucykpO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbkhUTUwobm9kZSwgdHlwZU5hbWUpIHtcbiAgICByZXR1cm4gbm9kZVxuICAgICAgICAubGl0ZXJhbC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPFxcXFxzKlwiICsgdHlwZU5hbWUgKyBcIltePl0qPil8KDwvXCIgKyB0eXBlTmFtZSArIFwiXFxcXHMqWz5dKVwiLCAnaWcnKSwgJycpXG4gICAgICAgIC50cmltKCk7XG59XG5mdW5jdGlvbiBnZXRIVE1MQXR0cnNCeUhUTUxTdHJpbmcoaHRtbCkge1xuICAgIGh0bWwgPSBodG1sLm1hdGNoKHJlSFRNTFRhZylbMF07XG4gICAgdmFyIGF0dHJzID0gaHRtbC5tYXRjaChuZXcgUmVnRXhwKEFUVFJJQlVURSQxLCAnZycpKTtcbiAgICByZXR1cm4gYXR0cnNcbiAgICAgICAgPyBhdHRycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikge1xuICAgICAgICAgICAgdmFyIF9hID0gYXR0ci50cmltKCkuc3BsaXQoJz0nKSwgbmFtZSA9IF9hWzBdLCB2YWx1ZXMgPSBfYS5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gdmFsdWVzLmpvaW4oJz0nKS5yZXBsYWNlKC8nfFwiL2csICcnKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiB7fTtcbn1cbmZ1bmN0aW9uIGdldEhUTUxBdHRycyhkb20pIHtcbiAgICByZXR1cm4gdG9BcnJheV8xKGRvbS5hdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikge1xuICAgICAgICBhY2NbYXR0ci5ub2RlTmFtZV0gPSBhdHRyLm5vZGVWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZURPTShub2RlLCB0eXBlTmFtZSwgc2FuaXRpemVyLCB3d1RvRE9NQWRhcHRvcikge1xuICAgIHZhciBkb20gPSB3d1RvRE9NQWRhcHRvci5nZXRUb0RPTU5vZGUodHlwZU5hbWUpKG5vZGUpO1xuICAgIHZhciBodG1sID0gc2FuaXRpemVyKGRvbS5vdXRlckhUTUwpO1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBkb20gPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB2YXIgaHRtbEF0dHJzID0gZ2V0SFRNTEF0dHJzKGRvbSk7XG4gICAgcmV0dXJuIHsgZG9tOiBkb20sIGh0bWxBdHRyczogaHRtbEF0dHJzIH07XG59XG52YXIgc2NoZW1hRmFjdG9yeSA9IHtcbiAgICBodG1sQmxvY2s6IGZ1bmN0aW9uICh0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXRvbTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGh0bWxBdHRyczogeyBkZWZhdWx0OiB7fSB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuSFRNTDogeyBkZWZhdWx0OiAnJyB9LFxuICAgICAgICAgICAgICAgIGh0bWxCbG9jazogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyczogZ2V0SFRNTEF0dHJzKGRvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IVE1MOiBkb20uaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSwgZG9tID0gX2EuZG9tLCBodG1sQXR0cnMgPSBfYS5odG1sQXR0cnM7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzLmNsYXNzID0gaHRtbEF0dHJzLmNsYXNzID8gaHRtbEF0dHJzLmNsYXNzICsgXCIgaHRtbC1ibG9ja1wiIDogJ2h0bWwtYmxvY2snO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5JDEoW3R5cGVOYW1lLCBodG1sQXR0cnNdLCB0b0FycmF5XzEoZG9tLmNoaWxkTm9kZXMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBodG1sSW5saW5lOiBmdW5jdGlvbiAodHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IHt9IH0sXG4gICAgICAgICAgICAgICAgaHRtbElubGluZTogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyczogZ2V0SFRNTEF0dHJzKGRvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxBdHRycyA9IHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKS5odG1sQXR0cnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlTmFtZSwgaHRtbEF0dHJzLCAwXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVIVE1MU2NoZW1hTWFwKGNvbnZlcnRvck1hcCwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgIHZhciBodG1sU2NoZW1hTWFwID0geyBub2Rlczoge30sIG1hcmtzOiB7fSB9O1xuICAgIFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sVHlwZSkge1xuICAgICAgICBpZiAoY29udmVydG9yTWFwW2h0bWxUeXBlXSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udmVydG9yTWFwW2h0bWxUeXBlXSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUeXBlID0gaHRtbFR5cGUgPT09ICdodG1sQmxvY2snID8gJ25vZGVzJyA6ICdtYXJrcyc7XG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGFnIHdoaXRlIGxpc3QgZm9yIHByZXZlbnRpbmcgdG8gcmVtb3ZlIHRoZSBodG1sIGluIHNhbml0aXplclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBodG1sU2NoZW1hTWFwW3RhcmdldFR5cGVdW3R5cGVdID0gc2NoZW1hRmFjdG9yeVtodG1sVHlwZV0odHlwZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBodG1sU2NoZW1hTWFwO1xufVxuXG52YXIgcmVDbG9zZVRhZyA9IC9eXFxzKjxcXHMqXFwvLztcbnZhciBiYXNlQ29udmVydG9ycyA9IHtcbiAgICBwYXJhZ3JhcGg6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZywgb3JpZ2luID0gX2Eub3JpZ2luLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMubm9kZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3AnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luKCk7XG4gICAgfSxcbiAgICBzb2Z0YnJlYWs6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpc1ByZXZOb2RlSFRNTCA9IG5vZGUucHJldiAmJiBub2RlLnByZXYudHlwZSA9PT0gJ2h0bWxJbmxpbmUnO1xuICAgICAgICB2YXIgaXNQcmV2QlIgPSBpc1ByZXZOb2RlSFRNTCAmJiAvPGJyID9cXC8/Pi8udGVzdChub2RlLnByZXYubGl0ZXJhbCk7XG4gICAgICAgIHZhciBjb250ZW50ID0gaXNQcmV2QlIgPyAnXFxuJyA6ICc8YnI+XFxuJztcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50IH07XG4gICAgfSxcbiAgICBpdGVtOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gW107XG4gICAgICAgICAgICBpZiAobm9kZS5saXN0RGF0YS50YXNrKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1snZGF0YS10YXNrJ10gPSAnJztcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ3Rhc2stbGlzdC1pdGVtJyk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGlzdERhdGEuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1snZGF0YS10YXNrLWNoZWNrZWQnXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lczogY2xhc3NOYW1lcyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7ICdkYXRhLWJhY2t0aWNrcyc6IFN0cmluZyhub2RlLnRpY2tDb3VudCkgfTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjb2RlQmxvY2s6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfYSA9IG5vZGUsIGZlbmNlTGVuZ3RoID0gX2EuZmVuY2VMZW5ndGgsIGluZm8gPSBfYS5pbmZvO1xuICAgICAgICB2YXIgaW5mb1dvcmRzID0gaW5mbyA/IGluZm8uc3BsaXQoL1xccysvKSA6IFtdO1xuICAgICAgICB2YXIgcHJlQ2xhc3NlcyA9IFtdO1xuICAgICAgICB2YXIgY29kZUF0dHJzID0ge307XG4gICAgICAgIGlmIChmZW5jZUxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIGNvZGVBdHRyc1snZGF0YS1iYWNrdGlja3MnXSA9IGZlbmNlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmZvV29yZHMubGVuZ3RoID4gMCAmJiBpbmZvV29yZHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGxhbmcgPSBpbmZvV29yZHNbMF07XG4gICAgICAgICAgICBwcmVDbGFzc2VzLnB1c2goXCJsYW5nLVwiICsgbGFuZyk7XG4gICAgICAgICAgICBjb2RlQXR0cnNbJ2RhdGEtbGFuZ3VhZ2UnXSA9IGxhbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAncHJlJywgY2xhc3NOYW1lczogcHJlQ2xhc3NlcyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgYXR0cmlidXRlczogY29kZUF0dHJzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAncHJlJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY3VzdG9tSW5saW5lOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IF9hLm9yaWdpbiwgZW50ZXJpbmcgPSBfYS5lbnRlcmluZywgc2tpcENoaWxkcmVuID0gX2Euc2tpcENoaWxkcmVuO1xuICAgICAgICB2YXIgaW5mbyA9IG5vZGUuaW5mbztcbiAgICAgICAgaWYgKGluZm8uaW5kZXhPZignd2lkZ2V0JykgIT09IC0xICYmIGVudGVyaW5nKSB7XG4gICAgICAgICAgICBza2lwQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gZ2V0V2lkZ2V0Q29udGVudChub2RlKTtcbiAgICAgICAgICAgIHZhciBodG1sSW5saW5lID0gd2lkZ2V0VG9ET00oaW5mbywgY29udGVudCkub3V0ZXJIVE1MO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ3NwYW4nLCBjbGFzc05hbWVzOiBbJ3R1aS13aWRnZXQnXSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBodG1sSW5saW5lIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbigpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZ2V0SFRNTFJlbmRlckNvbnZlcnRvcnMobGlua0F0dHJpYnV0ZXMsIGN1c3RvbUNvbnZlcnRvcnMpIHtcbiAgICB2YXIgY29udmVydG9ycyA9IF9fYXNzaWduJDEoe30sIGJhc2VDb252ZXJ0b3JzKTtcbiAgICBpZiAobGlua0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29udmVydG9ycy5saW5rID0gZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZywgb3JpZ2luID0gX2Eub3JpZ2luO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbigpO1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF0dHJpYnV0ZXMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHJlc3VsdC5hdHRyaWJ1dGVzKSwgbGlua0F0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbUNvbnZlcnRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoY3VzdG9tQ29udmVydG9ycykuZm9yRWFjaChmdW5jdGlvbiAobm9kZVR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvcmdDb252ZXJ0b3IgPSBjb252ZXJ0b3JzW25vZGVUeXBlXTtcbiAgICAgICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JzW25vZGVUeXBlXTtcbiAgICAgICAgICAgIGlmIChvcmdDb252ZXJ0b3IgJiYgaXNGdW5jdGlvbl8xKGN1c3RvbUNvbnZlcnRvcikpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gX19hc3NpZ24kMSh7fSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQub3JpZ2luID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JnQ29udmVydG9yKG5vZGUsIGNvbnRleHQpOyB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VzdG9tQ29udmVydG9yKG5vZGUsIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmNsdWRlcyhbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10sIG5vZGVUeXBlKSAmJiAhaXNGdW5jdGlvbl8xKGN1c3RvbUNvbnZlcnRvcikpIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gbm9kZS5saXRlcmFsLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdEhUTUwgPSBtYXRjaGVkWzBdLCBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSAob3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWxDb252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JbdHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuSFRNTCA9IGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbENvbnZlcnRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcHkgZm9yIHByZXZlbnRpbmcgdG8gb3ZlcndyaXRlIHRoZSBvcmlnaW5pYWwgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IF9fYXNzaWduJDEoe30sIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuYXR0cnMgPSBnZXRIVE1MQXR0cnNCeUhUTUxTdHJpbmcocm9vdEhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuY2hpbGRyZW5IVE1MID0gY2hpbGRyZW5IVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUudHlwZSA9IHR5cGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW50ZXJpbmcgPSAhcmVDbG9zZVRhZy50ZXN0KG5vZGUubGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGh0bWxDb252ZXJ0b3IobmV3Tm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQub3JpZ2luKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnZlcnRvcnNbbm9kZVR5cGVdID0gY3VzdG9tQ29udmVydG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRvcnM7XG59XG5cbnZhciBuZXN0YWJsZVR5cGVzID0gWydsaXN0JywgJ2l0ZW0nLCAnYmxvY2tRdW90ZSddO1xudmFyIG5lc3RhYmxlVGFnTmFtZXMgPSBbJ1VMJywgJ09MJywgJ0JMT0NLUVVPVEUnXTtcbmZ1bmN0aW9uIGlzQmxhbmtMaW5lKGRvYywgaW5kZXgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHBtTm9kZSA9IGRvYy5jaGlsZChpbmRleCk7XG4gICAgcmV0dXJuICFwbU5vZGUuY2hpbGRDb3VudCB8fCAocG1Ob2RlLmNoaWxkQ291bnQgPT09IDEgJiYgISgoX2EgPSBwbU5vZGUuZmlyc3RDaGlsZC50ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJpbSgpKSk7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JSYW5nZUhlaWdodEluZm8oZG9jLCBtZE5vZGUsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHN0YXJ0ID0gZ2V0TWRTdGFydExpbmUobWROb2RlKSAtIDE7XG4gICAgdmFyIGVuZCA9IGdldE1kRW5kTGluZShtZE5vZGUpIC0gMTtcbiAgICB2YXIgcmVjdCA9IGNoaWxkcmVuW3N0YXJ0XS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2hpbGRyZW5bZW5kXS5vZmZzZXRUb3AgLVxuICAgICAgICBjaGlsZHJlbltzdGFydF0ub2Zmc2V0VG9wICtcbiAgICAgICAgY2hpbGRyZW5bZW5kXS5jbGllbnRIZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgPD0gMFxuICAgICAgICAgICAgPyBjaGlsZHJlbltzdGFydF0uY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICA6IGhlaWdodCArIGdldEJsYW5rTGluZXNIZWlnaHQoZG9jLCBjaGlsZHJlbiwgTWF0aC5taW4oZW5kICsgMSwgZG9jLmNoaWxkQ291bnQgLSAxKSksXG4gICAgICAgIHJlY3Q6IHJlY3QsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEJsYW5rTGluZXNIZWlnaHQoZG9jLCBjaGlsZHJlbiwgc3RhcnQpIHtcbiAgICB2YXIgZW5kID0gZG9jLmNoaWxkQ291bnQgLSAxO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIHdoaWxlIChzdGFydCA8PSBlbmQgJiYgaXNCbGFua0xpbmUoZG9jLCBzdGFydCkpIHtcbiAgICAgICAgaGVpZ2h0ICs9IGNoaWxkcmVuW3N0YXJ0XS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHN0YXJ0ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQ7XG59XG5mdW5jdGlvbiBmaW5kQW5jZXN0b3JIYXZpbmdJZChlbCwgcm9vdCkge1xuICAgIHdoaWxlICghZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpICYmIGVsLnBhcmVudEVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG59XG5mdW5jdGlvbiBnZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gcm9vdCkge1xuICAgICAgICBpZiAoIWluY2x1ZGVzKG5lc3RhYmxlVGFnTmFtZXMsIGVsLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgKz0gZWwub2Zmc2V0VG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5vZmZzZXRQYXJlbnQgPT09IHJvb3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXRUb3A7XG59XG5mdW5jdGlvbiBmaW5kQWRqYWNlbnRFbGVtZW50VG9TY3JvbGxUb3Aoc2Nyb2xsVG9wLCByb290KSB7XG4gICAgdmFyIGVsID0gcm9vdDtcbiAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAgIHZhciBmaXJzdEVsZW1lbnRDaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICBpZiAoIWZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdFNpYmxpbmcgPSBmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZmlyc3RFbGVtZW50Q2hpbGQsIHNjcm9sbFRvcCwgZ2V0VG90YWxPZmZzZXRUb3AoZWwsIHJvb3QpKTtcbiAgICAgICAgcHJldiA9IGVsO1xuICAgICAgICBlbCA9IGxhc3RTaWJsaW5nO1xuICAgIH1cbiAgICB2YXIgYWRqYWNlbnRFbCA9IGVsIHx8IHByZXY7XG4gICAgcmV0dXJuIGFkamFjZW50RWwgPT09IHJvb3QgPyBudWxsIDogYWRqYWNlbnRFbDtcbn1cbmZ1bmN0aW9uIGZpbmRMYXN0U2libGluZ0VsZW1lbnRUb1Njcm9sbFRvcChlbCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3ApIHtcbiAgICBpZiAoZWwgJiYgc2Nyb2xsVG9wID4gb2Zmc2V0VG9wICsgZWwub2Zmc2V0VG9wKSB7XG4gICAgICAgIHJldHVybiAoZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGVsLm5leHRFbGVtZW50U2libGluZywgc2Nyb2xsVG9wLCBvZmZzZXRUb3ApIHx8IGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRBZGRpdGlvbmFsUG9zKHNjcm9sbFRvcCwgb2Zmc2V0VG9wLCBoZWlnaHQsIHRhcmdldE5vZGVIZWlnaHQpIHtcbiAgICB2YXIgcmF0aW8gPSBNYXRoLm1pbigoc2Nyb2xsVG9wIC0gb2Zmc2V0VG9wKSAvIGhlaWdodCwgMSk7XG4gICAgcmV0dXJuIHJhdGlvICogdGFyZ2V0Tm9kZUhlaWdodDtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGVPYmoocHJldmlld0NvbnRlbnQsIG1kTm9kZSkge1xuICAgIHZhciBlbCA9IHByZXZpZXdDb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlaWQ9XFxcIlwiICsgbWROb2RlLmlkICsgXCJcXFwiXVwiKTtcbiAgICB3aGlsZSAoIWVsIHx8IGlzU3R5bGVkSW5saW5lTm9kZShtZE5vZGUpKSB7XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgICAgIGVsID0gcHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBtZE5vZGUuaWQgKyBcIlxcXCJdXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Tm9uTmVzdGFibGVOb2RlT2JqKHsgbWROb2RlOiBtZE5vZGUsIGVsOiBlbCB9KTtcbn1cbmZ1bmN0aW9uIGdldE5vbk5lc3RhYmxlTm9kZU9iaihfYSkge1xuICAgIHZhciBtZE5vZGUgPSBfYS5tZE5vZGUsIGVsID0gX2EuZWw7XG4gICAgd2hpbGUgKChpbmNsdWRlcyhuZXN0YWJsZVR5cGVzLCBtZE5vZGUudHlwZSkgfHwgbWROb2RlLnR5cGUgPT09ICd0YWJsZScpICYmIG1kTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5maXJzdENoaWxkO1xuICAgICAgICBlbCA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4geyBtZE5vZGU6IG1kTm9kZSwgZWw6IGVsIH07XG59XG5cbnZhciBvZmZzZXRJbmZvTWFwID0ge307XG5mdW5jdGlvbiBzZXRIZWlnaHQoaWQsIGhlaWdodCkge1xuICAgIG9mZnNldEluZm9NYXBbaWRdID0gb2Zmc2V0SW5mb01hcFtpZF0gfHwge307XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0uaGVpZ2h0ID0gaGVpZ2h0O1xufVxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9wKGlkLCBvZmZzZXRUb3ApIHtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXSA9IG9mZnNldEluZm9NYXBbaWRdIHx8IHt9O1xuICAgIG9mZnNldEluZm9NYXBbaWRdLm9mZnNldFRvcCA9IG9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIGdldEhlaWdodChpZCkge1xuICAgIHJldHVybiBvZmZzZXRJbmZvTWFwW2lkXSAmJiBvZmZzZXRJbmZvTWFwW2lkXS5oZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRUb3AoaWQpIHtcbiAgICByZXR1cm4gb2Zmc2V0SW5mb01hcFtpZF0gJiYgb2Zmc2V0SW5mb01hcFtpZF0ub2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgZGVsZXRlIG9mZnNldEluZm9NYXBbTnVtYmVyKG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLW5vZGVpZCcpKV07XG4gICAgICAgIHRvQXJyYXlfMShub2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFuZFNhdmVPZmZzZXRJbmZvKG5vZGUsIHJvb3QsIG1kTm9kZUlkKSB7XG4gICAgdmFyIGNhY2hlZEhlaWdodCA9IGdldEhlaWdodChtZE5vZGVJZCk7XG4gICAgdmFyIGNhY2hlZFRvcCA9IGdldE9mZnNldFRvcChtZE5vZGVJZCk7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBjYWNoZWRIZWlnaHQgfHwgbm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFRvcCA9IGNhY2hlZFRvcCB8fCBnZXRUb3RhbE9mZnNldFRvcChub2RlLCByb290KSB8fCBub2RlLm9mZnNldFRvcDtcbiAgICBpZiAoIWNhY2hlZEhlaWdodCkge1xuICAgICAgICBzZXRIZWlnaHQobWROb2RlSWQsIG5vZGVIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlZFRvcCkge1xuICAgICAgICBzZXRPZmZzZXRUb3AobWROb2RlSWQsIG9mZnNldFRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVIZWlnaHQ6IG5vZGVIZWlnaHQsIG9mZnNldFRvcDogb2Zmc2V0VG9wIH07XG59XG5cbnZhciBDTEFTU19ISUdITElHSFQgPSBjbHMoJ21kLXByZXZpZXctaGlnaGxpZ2h0Jyk7XG5mdW5jdGlvbiBmaW5kVGFibGVDZWxsKHRhYmxlUm93LCBjaE9mZnNldCkge1xuICAgIHZhciBjZWxsID0gdGFibGVSb3cuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2VsbCAmJiBjZWxsLm5leHQpIHtcbiAgICAgICAgaWYgKGdldE1kU3RhcnRDaChjZWxsLm5leHQpID4gY2hPZmZzZXQgKyAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjZWxsID0gY2VsbC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbn1cbi8qKlxuICogQ2xhc3MgTWFya2Rvd24gUHJldmlld1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBiYXNlIGVsZW1lbnRcbiAqIEBwYXJhbSB7ZXZlbnRFbWl0dGVyfSBldmVudEVtaXR0ZXIgLSBldmVudCBtYW5hZ2VyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmlzVmlld2VyIC0gdHJ1ZSBmb3Igdmlldy1vbmx5IG1vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5oaWdobGlnaHQgLSB0cnVlIGZvciB1c2luZyBsaXZlLWhpZ2hsaWdodCBmZWF0dXJlXG4gKiBAcGFyYW0ge29iamVjdH0gb3BpdG9ucy5saW5rQXR0cmlidXRlcyAtIGF0dHJpYnV0ZXMgZm9yIGxpbmsgZWxlbWVudFxuICogQHBhcmFtIHtvYmplY3R9IG9waXRvbnMuY3VzdG9tSFRNTFJlbmRlcmVyIC0gbWFwIG9mIGN1c3RvbSBIVE1MIHJlbmRlciBmdW5jdGlvbnNcbiAqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBNYXJrZG93blByZXZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFya2Rvd25QcmV2aWV3KGV2ZW50RW1pdHRlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5pc1ZpZXdlciA9ICEhb3B0aW9ucy5pc1ZpZXdlcjtcbiAgICAgICAgdGhpcy5lbC5jbGFzc05hbWUgPSBjbHMoJ21kLXByZXZpZXcnKTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gb3B0aW9ucy5saW5rQXR0cmlidXRlcywgY3VzdG9tSFRNTFJlbmRlcmVyID0gb3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIsIHNhbml0aXplciA9IG9wdGlvbnMuc2FuaXRpemVyLCBfYSA9IG9wdGlvbnMuaGlnaGxpZ2h0LCBoaWdobGlnaHQgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih7XG4gICAgICAgICAgICBnZm06IHRydWUsXG4gICAgICAgICAgICBub2RlSWQ6IHRydWUsXG4gICAgICAgICAgICBjb252ZXJ0b3JzOiBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tSFRNTFJlbmRlcmVyKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3Vyc29yTm9kZUlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50KGhpZ2hsaWdodCk7XG4gICAgICAgIHRoaXMuaW5pdENvbnRlbnRTZWN0aW9uKCk7XG4gICAgICAgIC8vIFRvIHByZXZlbnQgb3ZlcmZsb3dpbmcgY29udGVudHMgaW4gdGhlIHZpZXdlclxuICAgICAgICBpZiAodGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3Q29udGVudC5zdHlsZS5vdmVyZmxvd1dyYXAgPSAnYnJlYWstd29yZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5pbml0Q29udGVudFNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQgPSBjcmVhdGVFbGVtZW50V2l0aChcIjxkaXYgY2xhc3M9XFxcIlwiICsgY2xzKCdjb250ZW50cycpICsgXCJcXFwiPjwvZGl2PlwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmlld2VyKSB7XG4gICAgICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMucHJldmlld0NvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnRvZ2dsZUFjdGl2ZSA9IGZ1bmN0aW9uIChhY3RpdmUpIHtcbiAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5lbCwgJ2FjdGl2ZScsIGFjdGl2ZSk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uIChoaWdobGlnaHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCd1cGRhdGVQcmV2aWV3JywgdGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLmlzVmlld2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hsaWdodCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VUb29sYmFyU3RhdGUnLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWROb2RlID0gX2EubWROb2RlLCBjdXJzb3JQb3MgPSBfYS5jdXJzb3JQb3M7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlQ3Vyc29yTm9kZShtZE5vZGUsIGN1cnNvclBvcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignYmx1cicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVIaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9uXzEodGhpcy5lbCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbCcsICdwcmV2aWV3JywgZmluZEFkamFjZW50RWxlbWVudFRvU2Nyb2xsVG9wKGV2ZW50LnRhcmdldC5zY3JvbGxUb3AsIF90aGlzLnByZXZpZXdDb250ZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG9nZ2xlQWN0aXZlKHRydWUpOyB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUoZmFsc2UpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JOb2RlSWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZCh0aGlzLmN1cnNvck5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShjdXJyZW50RWwsIENMQVNTX0hJR0hMSUdIVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUudXBkYXRlQ3Vyc29yTm9kZSA9IGZ1bmN0aW9uIChjdXJzb3JOb2RlLCBjdXJzb3JQb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvck5vZGUpIHtcbiAgICAgICAgICAgIGN1cnNvck5vZGUgPSBmaW5kQ2xvc2VzdE5vZGUoY3Vyc29yTm9kZSwgZnVuY3Rpb24gKG1kTm9kZSkgeyByZXR1cm4gIWlzSW5saW5lTm9kZSQxKG1kTm9kZSk7IH0pO1xuICAgICAgICAgICAgaWYgKGN1cnNvck5vZGUudHlwZSA9PT0gJ3RhYmxlUm93Jykge1xuICAgICAgICAgICAgICAgIGN1cnNvck5vZGUgPSBmaW5kVGFibGVDZWxsKGN1cnNvck5vZGUsIGN1cnNvclBvc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJzb3JOb2RlLnR5cGUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgbGluZSBuZXh0IHRvIHRhYmxlXG4gICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvck5vZGVJZCA9IGN1cnNvck5vZGUgPyBjdXJzb3JOb2RlLmlkIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yTm9kZUlkID09PSBjdXJzb3JOb2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkRUwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZCh0aGlzLmN1cnNvck5vZGVJZCk7XG4gICAgICAgIHZhciBuZXdFTCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKGN1cnNvck5vZGVJZCk7XG4gICAgICAgIGlmIChvbGRFTCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfMShvbGRFTCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3RUwpIHtcbiAgICAgICAgICAgIGFkZENsYXNzXzEobmV3RUwsIENMQVNTX0hJR0hMSUdIVCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJzb3JOb2RlSWQgPSBjdXJzb3JOb2RlSWQ7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldEVsZW1lbnRCeU5vZGVJZCA9IGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVJZFxuICAgICAgICAgICAgPyB0aGlzLnByZXZpZXdDb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1ub2RlaWQ9XFxcIlwiICsgbm9kZUlkICsgXCJcXFwiXVwiKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoY2hhbmdlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKGVkaXRSZXN1bHQpIHsgcmV0dXJuIF90aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGVkaXRSZXN1bHQpOyB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnYWZ0ZXJQcmV2aWV3UmVuZGVyJywgdGhpcyk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnJlcGxhY2VSYW5nZU5vZGVzID0gZnVuY3Rpb24gKGVkaXRSZXN1bHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGVzID0gZWRpdFJlc3VsdC5ub2RlcywgcmVtb3ZlZE5vZGVSYW5nZSA9IGVkaXRSZXN1bHQucmVtb3ZlZE5vZGVSYW5nZTtcbiAgICAgICAgdmFyIGNvbnRlbnRFbCA9IHRoaXMucHJldmlld0NvbnRlbnQ7XG4gICAgICAgIHZhciBuZXdIdG1sID0gdGhpcy5ldmVudEVtaXR0ZXIuZW1pdFJlZHVjZSgnYmVmb3JlUHJldmlld1JlbmRlcicsIHRoaXMuc2FuaXRpemVyKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gX3RoaXMucmVuZGVyZXIucmVuZGVyKG5vZGUpOyB9KS5qb2luKCcnKSkpO1xuICAgICAgICBpZiAoIXJlbW92ZWROb2RlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnRlbnRFbC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCBuZXdIdG1sKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHJlbW92ZWROb2RlUmFuZ2UuaWQsIHN0YXJ0Tm9kZUlkID0gX2FbMF0sIGVuZE5vZGVJZCA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZChzdGFydE5vZGVJZCk7XG4gICAgICAgICAgICB2YXIgZW5kRWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZChlbmROb2RlSWQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0RWwpIHtcbiAgICAgICAgICAgICAgICBzdGFydEVsLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCBuZXdIdG1sKTtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBzdGFydEVsO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZW5kRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRFbCA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSQxKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIGVsID0gbmV4dEVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZSQxKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmXzEodGhpcy5lbCwgJ3Njcm9sbCcpO1xuICAgICAgICB0aGlzLmVsID0gbnVsbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWw7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldEhUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQcm9zZU1pcnJvckhhY2tOb2Rlcyh0aGlzLnByZXZpZXdDb250ZW50LmlubmVySFRNTCk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnNldEhUTUwgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICB0aGlzLnByZXZpZXdDb250ZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgY3NzXzEodGhpcy5lbCwgeyBoZWlnaHQ6IGhlaWdodCArIFwicHhcIiB9KTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0TWluSGVpZ2h0ID0gZnVuY3Rpb24gKG1pbkhlaWdodCkge1xuICAgICAgICBjc3NfMSh0aGlzLmVsLCB7IG1pbkhlaWdodDogbWluSGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtkb3duUHJldmlldztcbn0oKSk7XG5cbmZ1bmN0aW9uIGZpbmROb2RlQnkocG9zLCBjb25kaXRpb24pIHtcbiAgICB2YXIgZGVwdGggPSBwb3MuZGVwdGg7XG4gICAgd2hpbGUgKGRlcHRoKSB7XG4gICAgICAgIHZhciBub2RlID0gcG9zLm5vZGUoZGVwdGgpO1xuICAgICAgICBpZiAoY29uZGl0aW9uKG5vZGUsIGRlcHRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGRlcHRoID4gMCA/IHBvcy5iZWZvcmUoZGVwdGgpIDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0luTGlzdE5vZGUocG9zKSB7XG4gICAgcmV0dXJuICEhZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaXN0SXRlbScgfHwgdHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgdHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNJblRhYmxlTm9kZShwb3MpIHtcbiAgICByZXR1cm4gISFmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZENlbGwnIHx8IHR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZmluZExpc3RJdGVtKHBvcykge1xuICAgIHJldHVybiBmaW5kTm9kZUJ5KHBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ2xpc3RJdGVtJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKHRhZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2VsbEF0dHJzKGF0dHJzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0ck5hbWUpIHtcbiAgICAgICAgaWYgKGF0dHJOYW1lICE9PSAncmF3SFRNTCcgJiYgYXR0cnNbYXR0ck5hbWVdKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHJOYW1lID09PSAnY2xhc3NOYW1lJyA/ICdjbGFzcycgOiBhdHRyTmFtZTtcbiAgICAgICAgICAgIGFjY1thdHRyTmFtZV0gPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZWRDZWxsRE9NKHRhZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgcmV0dXJuIFsncmF3SFRNTCcsICdjb2xzcGFuJywgJ3Jvd3NwYW4nLCAnZXh0ZW5kZWQnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWVJbkRPTSA9IGF0dHJOYW1lID09PSAncmF3SFRNTCcgPyAnZGF0YS1yYXctaHRtbCcgOiBhdHRyTmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gZG9tLmdldEF0dHJpYnV0ZShhdHRyTmFtZUluRE9NKTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY1thdHRyTmFtZV0gPSBpbmNsdWRlcyhbJ3Jhd0hUTUwnLCAnZXh0ZW5kZWQnXSwgYXR0ck5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGF0dHJWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBOdW1iZXIoYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGh0bWxBdHRyczogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgIGNsYXNzTmFtZXM6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDdXN0b21BdHRycyhhdHRycykge1xuICAgIHZhciBodG1sQXR0cnMgPSBhdHRycy5odG1sQXR0cnMsIGNsYXNzTmFtZXMgPSBhdHRycy5jbGFzc05hbWVzO1xuICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGh0bWxBdHRycyksIHsgY2xhc3M6IGNsYXNzTmFtZXMgPyBjbGFzc05hbWVzLmpvaW4oJyAnKSA6IG51bGwgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICB2YXIgcGFyZW50ID0gcmFuZ2UucGFyZW50LCBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleCwgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgICB2YXIgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoYXJvdW5kKSB7XG4gICAgICAgIHZhciBvdXRlciA9IGFyb3VuZC5sZW5ndGggPyBhcm91bmRbMF0gOiB0eXBlO1xuICAgICAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIHZhciBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIHN0YXJ0SW5kZXggPSByYW5nZS5zdGFydEluZGV4LCBlbmRJbmRleCA9IHJhbmdlLmVuZEluZGV4O1xuICAgIHZhciBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICB2YXIgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgdmFyIGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICAgICAgICB2YXIgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlubmVyTWF0Y2ggJiYgaW5uZXJNYXRjaC52YWxpZEVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGVycyhyYW5nZSwgaW5uZXJSYW5nZSwgbm9kZVR5cGUsIGF0dHJzKSB7XG4gICAgdmFyIGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICB2YXIgaW5uZXIgPSBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICAgIGlmIChhcm91bmQgJiYgaW5uZXIpIHtcbiAgICAgICAgdmFyIGFyb3VuZE5vZGVzID0gYXJvdW5kLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlubmVyTm9kZXMgPSBpbm5lci5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGF0dHJzOiBhdHRycyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFyb3VuZE5vZGVzLmNvbmNhdCh7IHR5cGU6IG5vZGVUeXBlIH0pLmNvbmNhdChpbm5lck5vZGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB3cmFwSW5MaXN0KHRyLCBfYSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3QpIHtcbiAgICB2YXIgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kLCBzdGFydEluZGV4ID0gX2Euc3RhcnRJbmRleCwgZW5kSW5kZXggPSBfYS5lbmRJbmRleCwgcGFyZW50ID0gX2EucGFyZW50O1xuICAgIHZhciBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yICh2YXIgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIGVuZCwgc3RhcnQsIGVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbiAgICB2YXIgZm91bmRMaXN0SW5kZXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3JhcHBlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT09IGxpc3QpIHtcbiAgICAgICAgICAgIGZvdW5kTGlzdEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kTGlzdEluZGV4O1xuICAgIHZhciBzcGxpdFBvcyA9IHN0YXJ0ICsgd3JhcHBlcnMubGVuZ3RoIC0gKGpvaW5CZWZvcmUgPyAyIDogMCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXgsIGxlbiA9IGVuZEluZGV4OyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gaSA9PT0gc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKCFmaXJzdCAmJiBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgICAgICAgc3BsaXRQb3MgKz0gc3BsaXREZXB0aCAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgc3BsaXRQb3MgKz0gcGFyZW50LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBjaGFuZ2VUb0xpc3QodHIsIHJhbmdlLCBsaXN0LCBhdHRycykge1xuICAgIHZhciAkZnJvbSA9IHJhbmdlLiRmcm9tLCAkdG8gPSByYW5nZS4kdG8sIGRlcHRoID0gcmFuZ2UuZGVwdGg7XG4gICAgdmFyIG91dGVyUmFuZ2UgPSByYW5nZTtcbiAgICB2YXIgam9pbkJlZm9yZSA9IGZhbHNlO1xuICAgIGlmIChkZXB0aCA+PSAyICYmXG4gICAgICAgICRmcm9tLm5vZGUoZGVwdGggLSAxKS50eXBlLmNvbXBhdGlibGVDb250ZW50KGxpc3QpICYmXG4gICAgICAgIHJhbmdlLnN0YXJ0SW5kZXggPT09IDAgJiZcbiAgICAgICAgJGZyb20uaW5kZXgoZGVwdGggLSAxKSkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgICAgICBvdXRlclJhbmdlID0gbmV3IE5vZGVSYW5nZShzdGFydCwgc3RhcnQsIGRlcHRoKTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSgkZnJvbSwgdHIuZG9jLnJlc29sdmUoJHRvLmVuZChkZXB0aCkpLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgam9pbkJlZm9yZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciB3cmFwcGVycyA9IGZpbmRXcmFwcGVycyhvdXRlclJhbmdlLCByYW5nZSwgbGlzdCwgYXR0cnMpO1xuICAgIGlmICh3cmFwcGVycykge1xuICAgICAgICByZXR1cm4gd3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXBwZXJzLCBqb2luQmVmb3JlLCBsaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlTGluZUxpc3RJdGVtKGRvYywgb2Zmc2V0KSB7XG4gICAgdmFyIGVuZExpc3RJdGVtUG9zID0gZG9jLnJlc29sdmUob2Zmc2V0KTtcbiAgICB3aGlsZSAoZW5kTGlzdEl0ZW1Qb3Mubm9kZSgpLnR5cGUubmFtZSAhPT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgb2Zmc2V0IC09IDI7IC8vIFRoZSBwb3NpdGlvbiB2YWx1ZSBvZiA8L2xpPjwvdWw+XG4gICAgICAgIGVuZExpc3RJdGVtUG9zID0gZG9jLnJlc29sdmUob2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRMaXN0SXRlbShlbmRMaXN0SXRlbVBvcyk7XG59XG5mdW5jdGlvbiB0b2dnbGVUYXNrTGlzdEl0ZW1zKHRyLCBfYSkge1xuICAgIHZhciAkZnJvbSA9IF9hLiRmcm9tLCAkdG8gPSBfYS4kdG87XG4gICAgdmFyIHN0YXJ0TGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oJGZyb20pO1xuICAgIHZhciBlbmRMaXN0SXRlbSA9IGZpbmRMaXN0SXRlbSgkdG8pO1xuICAgIGlmIChzdGFydExpc3RJdGVtICYmIGVuZExpc3RJdGVtKSB7XG4gICAgICAgIHdoaWxlIChlbmRMaXN0SXRlbSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGVuZExpc3RJdGVtLm9mZnNldCwgbm9kZSA9IGVuZExpc3RJdGVtLm5vZGU7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7IHRhc2s6ICFub2RlLmF0dHJzLnRhc2ssIGNoZWNrZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKG9mZnNldCwgbnVsbCwgYXR0cnMpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gc3RhcnRMaXN0SXRlbS5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZExpc3RJdGVtID0gZ2V0QmVmb3JlTGluZUxpc3RJdGVtKHRyLmRvYywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBjaGFuZ2VMaXN0VHlwZSh0ciwgX2EsIGxpc3QpIHtcbiAgICB2YXIgJGZyb20gPSBfYS4kZnJvbSwgJHRvID0gX2EuJHRvO1xuICAgIHZhciBzdGFydExpc3RJdGVtID0gZmluZExpc3RJdGVtKCRmcm9tKTtcbiAgICB2YXIgZW5kTGlzdEl0ZW0gPSBmaW5kTGlzdEl0ZW0oJHRvKTtcbiAgICBpZiAoc3RhcnRMaXN0SXRlbSAmJiBlbmRMaXN0SXRlbSkge1xuICAgICAgICB3aGlsZSAoZW5kTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBlbmRMaXN0SXRlbS5vZmZzZXQsIG5vZGUgPSBlbmRMaXN0SXRlbS5ub2RlLCBkZXB0aCA9IGVuZExpc3RJdGVtLmRlcHRoO1xuICAgICAgICAgICAgaWYgKG5vZGUuYXR0cnMudGFzaykge1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAob2Zmc2V0LCBudWxsLCB7IHRhc2s6IGZhbHNlLCBjaGVja2VkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXNvbHZlZFBvcyA9IHRyLmRvYy5yZXNvbHZlKG9mZnNldCk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRQb3MucGFyZW50LnR5cGUgIT09IGxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50T2Zmc2V0ID0gcmVzb2x2ZWRQb3MuYmVmb3JlKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRPZmZzZXQsIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gc3RhcnRMaXN0SXRlbS5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZExpc3RJdGVtID0gZ2V0QmVmb3JlTGluZUxpc3RJdGVtKHRyLmRvYywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBjaGFuZ2VMaXN0KGxpc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSBpc0luTGlzdE5vZGUoJGZyb20pXG4gICAgICAgICAgICAgICAgPyBjaGFuZ2VMaXN0VHlwZSh0ciwgcmFuZ2UsIGxpc3QpXG4gICAgICAgICAgICAgICAgOiBjaGFuZ2VUb0xpc3QodHIsIHJhbmdlLCBsaXN0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9nZ2xlVGFzaygpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBuZXdUciA9IGlzSW5MaXN0Tm9kZSgkZnJvbSlcbiAgICAgICAgICAgICAgICA/IHRvZ2dsZVRhc2tMaXN0SXRlbXModHIsIHJhbmdlKVxuICAgICAgICAgICAgICAgIDogY2hhbmdlVG9MaXN0KHRyLCByYW5nZSwgc2NoZW1hLm5vZGVzLmJ1bGxldExpc3QsIHsgdGFzazogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2lua0xpc3RJdGVtKGxpc3RJdGVtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gX2EudHIsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IF9hLmNoaWxkQ291bnQsIGZpcnN0Q2hpbGQgPSBfYS5maXJzdENoaWxkO1xuICAgICAgICAgICAgcmV0dXJuICEhY2hpbGRDb3VudCAmJiBmaXJzdENoaWxkLnR5cGUgPT09IGxpc3RJdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLnN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSByYW5nZS5wYXJlbnQ7XG4gICAgICAgICAgICB2YXIgbm9kZUJlZm9yZSA9IHBhcmVudF8xLmNoaWxkKHJhbmdlLnN0YXJ0SW5kZXggLSAxKTtcbiAgICAgICAgICAgIGlmIChub2RlQmVmb3JlLnR5cGUgIT09IGxpc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5lc3RlZEJlZm9yZSA9IG5vZGVCZWZvcmUubGFzdENoaWxkICYmIG5vZGVCZWZvcmUubGFzdENoaWxkLnR5cGUgPT09IHBhcmVudF8xLnR5cGU7XG4gICAgICAgICAgICB2YXIgaW5uZXIgPSBuZXN0ZWRCZWZvcmUgPyBGcmFnbWVudC5mcm9tKGxpc3RJdGVtLmNyZWF0ZSgpKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShsaXN0SXRlbS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbShwYXJlbnRfMS50eXBlLmNyZWF0ZShudWxsLCBpbm5lcikpKSksIG5lc3RlZEJlZm9yZSA/IDMgOiAxLCAwKTtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgIHZhciBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5mdW5jdGlvbiBsaWZ0VG9PdXRlckxpc3QodHIsIHJhbmdlLCBsaXN0SXRlbSkge1xuICAgIHZhciAkZnJvbSA9IHJhbmdlLiRmcm9tLCAkdG8gPSByYW5nZS4kdG8sIGVuZCA9IHJhbmdlLmVuZCwgZGVwdGggPSByYW5nZS5kZXB0aCwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIHZhciBlbmRPZkxpc3QgPSAkdG8uZW5kKGRlcHRoKTtcbiAgICBpZiAoZW5kIDwgZW5kT2ZMaXN0KSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzaWJsaW5ncyBhZnRlciB0aGUgbGlmdGVkIGl0ZW1zLCB3aGljaCBtdXN0IGJlY29tZVxuICAgICAgICAvLyBjaGlsZHJlbiBvZiB0aGUgbGFzdCBpdGVtXG4gICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGVuZCAtIDEsIGVuZE9mTGlzdCwgZW5kLCBlbmRPZkxpc3QsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGxpc3RJdGVtLmNyZWF0ZShudWxsLCBwYXJlbnQuY29weSgpKSksIDEsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgIHJhbmdlID0gbmV3IE5vZGVSYW5nZSh0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MpLCB0ci5kb2MucmVzb2x2ZShlbmRPZkxpc3QpLCBkZXB0aCk7XG4gICAgfVxuICAgIHRyLmxpZnQocmFuZ2UsIGxpZnRUYXJnZXQocmFuZ2UpKTtcbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHRyLCByYW5nZSkge1xuICAgIHZhciBsaXN0ID0gcmFuZ2UucGFyZW50O1xuICAgIHZhciBwb3MgPSByYW5nZS5lbmQ7XG4gICAgLy8gTWVyZ2UgdGhlIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBiaWcgaXRlbVxuICAgIGZvciAodmFyIGkgPSByYW5nZS5lbmRJbmRleCAtIDEsIGxlbiA9IHJhbmdlLnN0YXJ0SW5kZXg7IGkgPiBsZW47IGkgLT0gMSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRQb3MgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCk7XG4gICAgdmFyIGxpc3RJdGVtID0gc3RhcnRQb3Mubm9kZUFmdGVyO1xuICAgIHZhciBhdFN0YXJ0ID0gcmFuZ2Uuc3RhcnRJbmRleCA9PT0gMDtcbiAgICB2YXIgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PT0gbGlzdC5jaGlsZENvdW50O1xuICAgIHZhciBwYXJlbnQgPSBzdGFydFBvcy5ub2RlKC0xKTtcbiAgICB2YXIgaW5kZXhCZWZvcmUgPSBzdGFydFBvcy5pbmRleCgtMSk7XG4gICAgdmFyIGNhblJlcGxhY2VQYXJlbnQgPSBwYXJlbnQuY2FuUmVwbGFjZShpbmRleEJlZm9yZSArIChhdFN0YXJ0ID8gMCA6IDEpLCBpbmRleEJlZm9yZSArIDEsIGxpc3RJdGVtID09PSBudWxsIHx8IGxpc3RJdGVtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0SXRlbS5jb250ZW50LmFwcGVuZChhdEVuZCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0KSkpO1xuICAgIGlmIChsaXN0SXRlbSAmJiBjYW5SZXBsYWNlUGFyZW50KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHN0YXJ0UG9zLnBvcztcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgbGlzdEl0ZW0ubm9kZVNpemU7XG4gICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgc3Vycm91bmRpbmcgbGlzdC4gQXQgdGhlIHNpZGVzIHdoZXJlIHdlJ3JlIG5vdCBhdFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBsaXN0LCB0aGUgZXhpc3RpbmcgbGlzdCBpcyBjbG9zZWQuIEF0IHNpZGVzIHdoZXJlXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQgLSAoYXRTdGFydCA/IDEgOiAwKSwgZW5kICsgKGF0RW5kID8gMSA6IDApLCBzdGFydCArIDEsIGVuZCAtIDEsIG5ldyBTbGljZSgoYXRTdGFydCA/IEZyYWdtZW50LmVtcHR5IDogRnJhZ21lbnQuZnJvbShsaXN0LmNvcHkoRnJhZ21lbnQuZW1wdHkpKSkuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShsaXN0SXRlbSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciB0ciA9IF9hLnRyLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb247XG4gICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSBfYS5jaGlsZENvdW50LCBmaXJzdENoaWxkID0gX2EuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHJldHVybiAhIWNoaWxkQ291bnQgJiYgZmlyc3RDaGlsZC50eXBlID09PSBsaXN0SXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHRvcExpc3RJdGVtID0gJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUgPT09IGxpc3RJdGVtO1xuICAgICAgICAgICAgdmFyIG5ld1RyID0gdG9wTGlzdEl0ZW0gPyBsaWZ0VG9PdXRlckxpc3QodHIsIHJhbmdlLCBsaXN0SXRlbSkgOiBsaWZ0T3V0T2ZMaXN0KHRyLCByYW5nZSk7XG4gICAgICAgICAgICBkaXNwYXRjaChuZXdUcik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0obGlzdEl0ZW0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICB2YXIgdHIgPSBfYS50ciwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIGlmICgkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncmFuZFBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gbGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PT0gMiB8fFxuICAgICAgICAgICAgICAgICRmcm9tLm5vZGUoLTMpLnR5cGUgIT09IGxpc3RJdGVtIHx8XG4gICAgICAgICAgICAgICAgJGZyb20uaW5kZXgoLTIpICE9PSAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50IC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrZWVwSXRlbSA9ICRmcm9tLmluZGV4KC0xKSA+IDA7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgZm9yICh2YXIgZGVwdGggPSAkZnJvbS5kZXB0aCAtIChrZWVwSXRlbSA/IDEgOiAyKTsgZGVwdGggPj0gJGZyb20uZGVwdGggLSAzOyBkZXB0aCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkZXB0aCkuY29weSh3cmFwcGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlci5hcHBlbmQoRnJhZ21lbnQuZnJvbShsaXN0SXRlbS5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2Uoa2VlcEl0ZW0gPyAkZnJvbS5iZWZvcmUoKSA6ICRmcm9tLmJlZm9yZSgtMSksICRmcm9tLmFmdGVyKC0zKSwgbmV3IFNsaWNlKHdyYXBwZXIsIGtlZXBJdGVtID8gMyA6IDIsIDIpKTtcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAoa2VlcEl0ZW0gPyAzIDogMikpKSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dFR5cGUgPSAkdG8ucG9zID09PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgdmFyIHR5cGVzID0gbmV4dFR5cGUgJiYgW251bGwsIHsgdHlwZTogbmV4dFR5cGUgfV07XG4gICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpO1xuICAgICAgICBpZiAoY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSkge1xuICAgICAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcyk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZW50KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvO1xuICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmIChyYW5nZSAmJiBpc0luTGlzdE5vZGUoJGZyb20pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lua0xpc3RJdGVtKHNjaGVtYS5ub2Rlcy5saXN0SXRlbSkoc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTsgfTtcbn1cbmZ1bmN0aW9uIG91dGRlbnQoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG87XG4gICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIGlzSW5MaXN0Tm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsaWZ0TGlzdEl0ZW0oc2NoZW1hLm5vZGVzLmxpc3RJdGVtKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9OyB9O1xufVxuZnVuY3Rpb24gZ2V0V3dDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRlbnQ6IGluZGVudCgpLFxuICAgICAgICBvdXRkZW50OiBvdXRkZW50KCksXG4gICAgfTtcbn1cblxudmFyIGNhY2hlID0gbmV3IE1hcCgpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG52YXIgVGFibGVPZmZzZXRNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFibGVPZmZzZXRNYXAodGFibGUsIHRhYmxlUm93cywgdGFibGVTdGFydFBvcywgcm93SW5mbykge1xuICAgICAgICB0aGlzLnRhYmxlID0gdGFibGU7XG4gICAgICAgIHRoaXMudGFibGVSb3dzID0gdGFibGVSb3dzO1xuICAgICAgICB0aGlzLnRhYmxlU3RhcnRQb3MgPSB0YWJsZVN0YXJ0UG9zO1xuICAgICAgICB0aGlzLnJvd0luZm8gPSByb3dJbmZvO1xuICAgIH1cbiAgICBUYWJsZU9mZnNldE1hcC5jcmVhdGUgPSBmdW5jdGlvbiAoY2VsbFBvcykge1xuICAgICAgICB2YXIgdGFibGUgPSBmaW5kTm9kZUJ5KGNlbGxQb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gJ3RhYmxlJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0YWJsZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0YWJsZS5ub2RlLCBkZXB0aCA9IHRhYmxlLmRlcHRoLCBvZmZzZXQgPSB0YWJsZS5vZmZzZXQ7XG4gICAgICAgICAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKChjYWNoZWQgPT09IG51bGwgfHwgY2FjaGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWNoZWQudGFibGVTdGFydFBvcykgPT09IG9mZnNldCArIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd3NfMSA9IFtdO1xuICAgICAgICAgICAgdmFyIHRhYmxlUG9zID0gY2VsbFBvcy5zdGFydChkZXB0aCk7XG4gICAgICAgICAgICB2YXIgdGhlYWQgPSBub2RlLmNoaWxkKDApO1xuICAgICAgICAgICAgdmFyIHRib2R5ID0gbm9kZS5jaGlsZCgxKTtcbiAgICAgICAgICAgIHZhciB0aGVhZENlbGxJbmZvID0gY3JlYXRlT2Zmc2V0TWFwKHRoZWFkLCB0YWJsZVBvcyk7XG4gICAgICAgICAgICB2YXIgdGJvZHlDZWxsSW5mbyA9IGNyZWF0ZU9mZnNldE1hcCh0Ym9keSwgdGFibGVQb3MgKyB0aGVhZC5ub2RlU2l6ZSk7XG4gICAgICAgICAgICB0aGVhZC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd3NfMS5wdXNoKHJvdyk7IH0pO1xuICAgICAgICAgICAgdGJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dzXzEucHVzaChyb3cpOyB9KTtcbiAgICAgICAgICAgIHZhciBtYXAgPSBuZXcgVGFibGVPZmZzZXRNYXAobm9kZSwgcm93c18xLCB0YWJsZVBvcywgdGhlYWRDZWxsSW5mby5jb25jYXQodGJvZHlDZWxsSW5mbykpO1xuICAgICAgICAgICAgY2FjaGUuc2V0KG5vZGUsIG1hcCk7XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0b3RhbFJvd0NvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidG90YWxDb2x1bW5Db3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SW5mb1swXS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRhYmxlU3RhcnRPZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlU3RhcnRQb3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRhYmxlRW5kT2Zmc2V0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJsZVN0YXJ0UG9zICsgdGhpcy50YWJsZS5ub2RlU2l6ZSAtIDE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbEluZm8gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF07XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUucG9zQXQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHJvd1N0YXJ0ID0gdGhpcy50YWJsZVN0YXJ0UG9zOzsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcm93RW5kID0gcm93U3RhcnQgKyB0aGlzLnRhYmxlUm93c1tpXS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpID09PSByb3dJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBjb2xJZHg7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgY2VsbHMgZnJvbSBwcmV2aW91cyByb3codmlhIHJvd3NwYW4pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgdGhpcy50b3RhbENvbHVtbkNvdW50ICYmIHRoaXMucm93SW5mb1tpXVtpbmRleF0ub2Zmc2V0IDwgcm93U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID09PSB0aGlzLnRvdGFsQ29sdW1uQ291bnQgPyByb3dFbmQgOiB0aGlzLnJvd0luZm9baV1baW5kZXhdLm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd1N0YXJ0ID0gcm93RW5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Tm9kZUFuZFBvcyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICB2YXIgY2VsbEluZm8gPSB0aGlzLnJvd0luZm9bcm93SWR4XVtjb2xJZHhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZTogdGhpcy50YWJsZS5ub2RlQXQoY2VsbEluZm8ub2Zmc2V0IC0gdGhpcy50YWJsZVN0YXJ0T2Zmc2V0KSxcbiAgICAgICAgICAgIHBvczogY2VsbEluZm8ub2Zmc2V0LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmV4dGVuZGVkUm93c3BhbiA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZXh0ZW5kZWRDb2xzcGFuID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSb3dzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q29sc3BhbkNvdW50ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmRlY3JlYXNlQ29sc3BhbkNvdW50ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmRlY3JlYXNlUm93c3BhbkNvdW50ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENvbHNwYW5TdGFydEluZm8gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Um93c3BhblN0YXJ0SW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsU3RhcnRPZmZzZXQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF0ub2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbmRlZFJvd3NwYW4ocm93SWR4LCBjb2xJZHgpID8gdGhpcy5wb3NBdChyb3dJZHgsIGNvbElkeCkgOiBvZmZzZXQ7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbEVuZE9mZnNldCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnJvd0luZm9bcm93SWR4XVtjb2xJZHhdLCBvZmZzZXQgPSBfYS5vZmZzZXQsIG5vZGVTaXplID0gX2Eubm9kZVNpemU7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgPyB0aGlzLnBvc0F0KHJvd0lkeCwgY29sSWR4KSA6IG9mZnNldCArIG5vZGVTaXplO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxJbmRleCA9IGZ1bmN0aW9uIChjZWxsUG9zKSB7XG4gICAgICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRoaXMudG90YWxSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciByb3dJbmZvID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF07XG4gICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSAwOyBjb2xJZHggPCB0aGlzLnRvdGFsQ29sdW1uQ291bnQ7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0luZm9bY29sSWR4XS5vZmZzZXQgKyAxID4gY2VsbFBvcy5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyb3dJZHgsIGNvbElkeF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0UmVjdE9mZnNldHMgPSBmdW5jdGlvbiAoc3RhcnRDZWxsUG9zLCBlbmRDZWxsUG9zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoZW5kQ2VsbFBvcyA9PT0gdm9pZCAwKSB7IGVuZENlbGxQb3MgPSBzdGFydENlbGxQb3M7IH1cbiAgICAgICAgaWYgKHN0YXJ0Q2VsbFBvcy5wb3MgPiBlbmRDZWxsUG9zLnBvcykge1xuICAgICAgICAgICAgX2EgPSBbZW5kQ2VsbFBvcywgc3RhcnRDZWxsUG9zXSwgc3RhcnRDZWxsUG9zID0gX2FbMF0sIGVuZENlbGxQb3MgPSBfYVsxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2QgPSB0aGlzLmdldENlbGxJbmRleChzdGFydENlbGxQb3MpLCBzdGFydFJvd0lkeCA9IF9kWzBdLCBzdGFydENvbElkeCA9IF9kWzFdO1xuICAgICAgICB2YXIgX2UgPSB0aGlzLmdldENlbGxJbmRleChlbmRDZWxsUG9zKSwgZW5kUm93SWR4ID0gX2VbMF0sIGVuZENvbElkeCA9IF9lWzFdO1xuICAgICAgICBfYiA9IGdldFNvcnRlZE51bVBhaXIoc3RhcnRSb3dJZHgsIGVuZFJvd0lkeCksIHN0YXJ0Um93SWR4ID0gX2JbMF0sIGVuZFJvd0lkeCA9IF9iWzFdO1xuICAgICAgICBfYyA9IGdldFNvcnRlZE51bVBhaXIoc3RhcnRDb2xJZHgsIGVuZENvbElkeCksIHN0YXJ0Q29sSWR4ID0gX2NbMF0sIGVuZENvbElkeCA9IF9jWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTcGFubmVkT2Zmc2V0cyh7IHN0YXJ0Um93SWR4OiBzdGFydFJvd0lkeCwgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LCBlbmRSb3dJZHg6IGVuZFJvd0lkeCwgZW5kQ29sSWR4OiBlbmRDb2xJZHggfSk7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0U3Bhbm5lZE9mZnNldHMgPSBmdW5jdGlvbiAoc2VsZWN0aW9uSW5mbykge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uSW5mbztcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZU9mZnNldE1hcDtcbn0oKSk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xudmFyIGNyZWF0ZU9mZnNldE1hcCA9IGZ1bmN0aW9uIChoZWFkT3JCb2R5LCBzdGFydE9mZnNldCkge1xuICAgIHZhciBjZWxsSW5mb01hdHJpeCA9IFtdO1xuICAgIGhlYWRPckJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93LCByb3dPZmZzZXQpIHtcbiAgICAgICAgLy8gZ2V0IHJvdyBpbmRleCBiYXNlZCBvbiB0YWJsZShub3QgdGFibGUgaGVhZCBvciB0YWJsZSBib2R5KVxuICAgICAgICB2YXIgcm93SW5mbyA9IHsgcm93c3Bhbk1hcDoge30sIGNvbHNwYW5NYXA6IHt9LCBsZW5ndGg6IDAgfTtcbiAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24gKF9hLCBjZWxsT2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIHZhciBjb2xJZHggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJvd0luZm9bY29sSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbElkeCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93SW5mb1tjb2xJZHhdID0ge1xuICAgICAgICAgICAgICAgIC8vIDIgaXMgdGhlIHN1bSBvZiB0aGUgZnJvbnQgYW5kIGJhY2sgcG9zaXRpb25zIG9mIHRoZSB0YWdcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0ICsgcm93T2Zmc2V0ICsgY2VsbE9mZnNldCArIDIsXG4gICAgICAgICAgICAgICAgbm9kZVNpemU6IG5vZGVTaXplLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJvd0luZm8ubGVuZ3RoICs9IDE7XG4gICAgICAgIH0pO1xuICAgICAgICBjZWxsSW5mb01hdHJpeC5wdXNoKHJvd0luZm8pO1xuICAgIH0pO1xuICAgIHJldHVybiBjZWxsSW5mb01hdHJpeDtcbn07XG5mdW5jdGlvbiBtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlKG9mZnNldE1hcE1peGluLCBjcmVhdGVPZmZzZXRNYXBNaXhpbikge1xuICAgIGFzc2lnbihUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIG9mZnNldE1hcE1peGluKTtcbiAgICBjcmVhdGVPZmZzZXRNYXAgPSBjcmVhdGVPZmZzZXRNYXBNaXhpbjtcbiAgICByZXR1cm4gVGFibGVPZmZzZXRNYXA7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlcyhkb2MsIG1hcCwgX2EpIHtcbiAgICB2YXIgc3RhcnRSb3dJZHggPSBfYS5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gX2EuZW5kUm93SWR4LCBlbmRDb2xJZHggPSBfYS5lbmRDb2xJZHg7XG4gICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgIGZvciAodmFyIHJvd0lkeCA9IHN0YXJ0Um93SWR4OyByb3dJZHggPD0gZW5kUm93SWR4OyByb3dJZHggKz0gMSkge1xuICAgICAgICBmb3IgKHZhciBjb2xJZHggPSBzdGFydENvbElkeDsgY29sSWR4IDw9IGVuZENvbElkeDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGNvbElkeCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBTZWxlY3Rpb25SYW5nZShkb2MucmVzb2x2ZShvZmZzZXQgKyAxKSwgZG9jLnJlc29sdmUob2Zmc2V0ICsgbm9kZVNpemUgLSAxKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUZyYWdtZW50KHRhYmxlSGVhZCwgdGFibGVCb2R5KSB7XG4gICAgdmFyIGZyYWdtZW50ID0gW107XG4gICAgaWYgKHRhYmxlSGVhZC5jaGlsZENvdW50KSB7XG4gICAgICAgIGZyYWdtZW50LnB1c2godGFibGVIZWFkKTtcbiAgICB9XG4gICAgaWYgKHRhYmxlQm9keS5jaGlsZENvdW50KSB7XG4gICAgICAgIGZyYWdtZW50LnB1c2godGFibGVCb2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50LmZyb20oZnJhZ21lbnQpO1xufVxudmFyIENlbGxTZWxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ2VsbFNlbGVjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDZWxsU2VsZWN0aW9uKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcykge1xuICAgICAgICBpZiAoZW5kQ2VsbFBvcyA9PT0gdm9pZCAwKSB7IGVuZENlbGxQb3MgPSBzdGFydENlbGxQb3M7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRvYyA9IHN0YXJ0Q2VsbFBvcy5ub2RlKDApO1xuICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKHN0YXJ0Q2VsbFBvcyk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcyk7XG4gICAgICAgIHZhciByYW5nZXMgPSBnZXRTZWxlY3Rpb25SYW5nZXMoZG9jLCBtYXAsIHNlbGVjdGlvbkluZm8pO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJhbmdlc1swXS4kZnJvbSwgcmFuZ2VzWzBdLiR0bywgcmFuZ2VzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGFydENlbGwgPSBzdGFydENlbGxQb3M7XG4gICAgICAgIF90aGlzLmVuZENlbGwgPSBlbmRDZWxsUG9zO1xuICAgICAgICBfdGhpcy5vZmZzZXRNYXAgPSBtYXA7XG4gICAgICAgIF90aGlzLmlzQ2VsbFNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgdGhlIGFwaSBvZiB0aGUgJ1NlbGVjdGlvbicgaW4gcHJvc2VtaXJyb3IsXG4gICAgICAgIC8vIGFuZCBpcyB1c2VkIHRvIGRpc2FibGUgdGhlIHRleHQgc2VsZWN0aW9uLlxuICAgICAgICBfdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGRvYywgbWFwcGluZykge1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0Q2VsbC5wb3M7XG4gICAgICAgIHZhciBlbmRQb3MgPSB0aGlzLmVuZENlbGwucG9zO1xuICAgICAgICB2YXIgc3RhcnRDZWxsID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAoc3RhcnRQb3MpKTtcbiAgICAgICAgdmFyIGVuZENlbGwgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChlbmRQb3MpKTtcbiAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShzdGFydENlbGwpO1xuICAgICAgICAvLyB0ZXh0IHNlbGVjdGlvbiB3aGVuIHJvd3Mgb3IgY29sdW1ucyBhcmUgZGVsZXRlZFxuICAgICAgICBpZiAodGhpcy5vZmZzZXRNYXAudG90YWxDb2x1bW5Db3VudCA+IG1hcC50b3RhbENvbHVtbkNvdW50IHx8XG4gICAgICAgICAgICB0aGlzLm9mZnNldE1hcC50b3RhbFJvd0NvdW50ID4gbWFwLnRvdGFsUm93Q291bnQpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aE1hcCA9IHsgdGFibGVCb2R5OiAxLCB0YWJsZVJvdzogMiwgdGFibGVDZWxsOiAzLCBwYXJhZ3JhcGg6IDQgfTtcbiAgICAgICAgICAgIHZhciBkZXB0aEZyb21UYWJsZSA9IGRlcHRoTWFwW2VuZENlbGwucGFyZW50LnR5cGUubmFtZV07XG4gICAgICAgICAgICB2YXIgdGFibGVFbmRQb3MgPSBlbmRDZWxsLmVuZChlbmRDZWxsLmRlcHRoIC0gZGVwdGhGcm9tVGFibGUpO1xuICAgICAgICAgICAgLy8gc3VidHJhY3QgNCg8L3RkPjwvdHI+PC90Ym9keT48L3RhYmxlPiB0YWcgbGVuZ3RoKVxuICAgICAgICAgICAgdmFyIGZyb20gPSBNYXRoLm1pbih0YWJsZUVuZFBvcyAtIDQsIGVuZENlbGwucG9zKTtcbiAgICAgICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2VsbFNlbGVjdGlvbihzdGFydENlbGwsIGVuZENlbGwpO1xuICAgIH07XG4gICAgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICByZXR1cm4gKGNlbGwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uICYmXG4gICAgICAgICAgICBjZWxsLnN0YXJ0Q2VsbC5wb3MgPT09IHRoaXMuc3RhcnRDZWxsLnBvcyAmJlxuICAgICAgICAgICAgY2VsbC5lbmRDZWxsLnBvcyA9PT0gdGhpcy5lbmRDZWxsLnBvcyk7XG4gICAgfTtcbiAgICBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLnN0YXJ0Q2VsbC5ub2RlKC0yKTtcbiAgICAgICAgdmFyIHRhYmxlT2Zmc2V0ID0gdGhpcy5zdGFydENlbGwuc3RhcnQoLTIpO1xuICAgICAgICB2YXIgcm93ID0gdGFibGUuY2hpbGQoMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIHRhYmxlSGVhZCA9IHRhYmxlLmNoaWxkKDApLnR5cGUuY3JlYXRlKCk7XG4gICAgICAgIHZhciB0YWJsZUJvZHkgPSB0YWJsZS5jaGlsZCgxKS50eXBlLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKHRoaXMuc3RhcnRDZWxsKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHModGhpcy5zdGFydENlbGwsIHRoaXMuZW5kQ2VsbCk7XG4gICAgICAgIHZhciBzdGFydFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gc2VsZWN0aW9uSW5mby5lbmRSb3dJZHgsIGVuZENvbElkeCA9IHNlbGVjdGlvbkluZm8uZW5kQ29sSWR4O1xuICAgICAgICB2YXIgaXNUYWJsZUhlYWRDZWxsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIHJvd0lkeCA9IHN0YXJ0Um93SWR4OyByb3dJZHggPD0gZW5kUm93SWR4OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSBzdGFydENvbElkeDsgY29sSWR4IDw9IGVuZENvbElkeDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgY29sSWR4KS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0YWJsZS5ub2RlQXQob2Zmc2V0IC0gdGFibGVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVGFibGVIZWFkQ2VsbCA9IGNlbGwudHlwZS5uYW1lID09PSAndGFibGVIZWFkQ2VsbCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcmsgdGhlIGV4dGVuZGVkIGNlbGwgZm9yIHBhc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5leHRlbmRlZFJvd3NwYW4ocm93SWR4LCBjb2xJZHgpIHx8IG1hcC5leHRlbmRlZENvbHNwYW4ocm93SWR4LCBjb2xJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwudHlwZS5jcmVhdGUoeyBleHRlbmRlZDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwuY29weShjZWxsLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb3BpZWRSb3cgPSByb3cuY29weShGcmFnbWVudC5mcm9tKGNlbGxzKSk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGlzVGFibGVIZWFkQ2VsbCA/IHRhYmxlSGVhZCA6IHRhYmxlQm9keTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldE5vZGUuY29udGVudCA9IHRhcmdldE5vZGUuY29udGVudC5hcHBlbmQoRnJhZ21lbnQuZnJvbShjb3BpZWRSb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGNyZWF0ZVRhYmxlRnJhZ21lbnQodGFibGVIZWFkLCB0YWJsZUJvZHkpLCAxLCAxKTtcbiAgICB9O1xuICAgIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIENlbGxTZWxlY3Rpb247XG59KFNlbGVjdGlvbikpO1xuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZUhlYWRSb3coY29sdW1uQ291bnQsIHNjaGVtYSwgZGF0YSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVIZWFkQ2VsbCA9IF9hLnRhYmxlSGVhZENlbGwsIHBhcmFncmFwaCA9IF9hLnBhcmFncmFwaDtcbiAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29sdW1uQ291bnQ7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkYXRhICYmIGRhdGFbaW5kZXhdO1xuICAgICAgICB2YXIgcGFyYSA9IHBhcmFncmFwaC5jcmVhdGUobnVsbCwgdGV4dCA/IHNjaGVtYS50ZXh0KHRleHQpIDogW10pO1xuICAgICAgICBjZWxscy5wdXNoKHRhYmxlSGVhZENlbGwuY3JlYXRlKG51bGwsIHBhcmEpKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0YWJsZVJvdy5jcmVhdGUobnVsbCwgY2VsbHMpXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlQm9keVJvd3Mocm93Q291bnQsIGNvbHVtbkNvdW50LCBzY2hlbWEsIGRhdGEpIHtcbiAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlUm93ID0gX2EudGFibGVSb3csIHRhYmxlQm9keUNlbGwgPSBfYS50YWJsZUJvZHlDZWxsLCBwYXJhZ3JhcGggPSBfYS5wYXJhZ3JhcGg7XG4gICAgdmFyIHRhYmxlUm93cyA9IFtdO1xuICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICB2YXIgY2VsbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gMDsgY29sSWR4IDwgY29sdW1uQ291bnQ7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IGRhdGEgJiYgZGF0YVtyb3dJZHggKiBjb2x1bW5Db3VudCArIGNvbElkeF07XG4gICAgICAgICAgICB2YXIgcGFyYSA9IHBhcmFncmFwaC5jcmVhdGUobnVsbCwgdGV4dCA/IHNjaGVtYS50ZXh0KHRleHQpIDogW10pO1xuICAgICAgICAgICAgY2VsbHMucHVzaCh0YWJsZUJvZHlDZWxsLmNyZWF0ZShudWxsLCBwYXJhKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVSb3dzLnB1c2godGFibGVSb3cuY3JlYXRlKG51bGwsIGNlbGxzKSk7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZVJvd3M7XG59XG5mdW5jdGlvbiBjcmVhdGVEdW1teUNlbGxzKGNvbHVtbkNvdW50LCByb3dJZHgsIHNjaGVtYSwgYXR0cnMpIHtcbiAgICBpZiAoYXR0cnMgPT09IHZvaWQgMCkgeyBhdHRycyA9IG51bGw7IH1cbiAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlSGVhZENlbGwgPSBfYS50YWJsZUhlYWRDZWxsLCB0YWJsZUJvZHlDZWxsID0gX2EudGFibGVCb2R5Q2VsbCwgcGFyYWdyYXBoID0gX2EucGFyYWdyYXBoO1xuICAgIHZhciBjZWxsID0gcm93SWR4ID09PSAwID8gdGFibGVIZWFkQ2VsbCA6IHRhYmxlQm9keUNlbGw7XG4gICAgdmFyIGNlbGxzID0gW107XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGNvbHVtbkNvdW50OyBpbmRleCArPSAxKSB7XG4gICAgICAgIGNlbGxzLnB1c2goY2VsbC5jcmVhdGUoYXR0cnMsIHBhcmFncmFwaC5jcmVhdGUoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG5mdW5jdGlvbiBmaW5kQ2VsbEVsZW1lbnQobm9kZSwgcm9vdCkge1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3QpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdURCcgfHwgbm9kZS5ub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ2VsbChwb3MpIHtcbiAgICByZXR1cm4gZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciAkYW5jaG9yID0gc2VsZWN0aW9uLiRhbmNob3I7XG4gICAgICAgIHZhciBmb3VuZENlbGwgPSBmaW5kQ2VsbCgkYW5jaG9yKTtcbiAgICAgICAgaWYgKGZvdW5kQ2VsbCkge1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9ICRhbmNob3Iubm9kZSgwKS5yZXNvbHZlKCRhbmNob3IuYmVmb3JlKGZvdW5kQ2VsbC5kZXB0aCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgYW5jaG9yOiBhbmNob3IsIGhlYWQ6IGFuY2hvciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBfYSA9IHNlbGVjdGlvbiwgc3RhcnRDZWxsID0gX2Euc3RhcnRDZWxsLCBlbmRDZWxsID0gX2EuZW5kQ2VsbDtcbiAgICByZXR1cm4geyBhbmNob3I6IHN0YXJ0Q2VsbCwgaGVhZDogZW5kQ2VsbCB9O1xufVxuZnVuY3Rpb24gZ2V0VGFibGVDb250ZW50RnJvbVNsaWNlKHNsaWNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzbGljZS5zaXplKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gc2xpY2UuY29udGVudCwgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0LCBvcGVuRW5kID0gc2xpY2Uub3BlbkVuZDtcbiAgICAgICAgaWYgKGNvbnRlbnQuY2hpbGRDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbnRlbnQuY2hpbGRDb3VudCA9PT0gMSAmJlxuICAgICAgICAgICAgKChvcGVuU3RhcnQgPiAwICYmIG9wZW5FbmQgPiAwKSB8fCAoKF9hID0gY29udGVudC5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSA9PT0gJ3RhYmxlJykpIHtcbiAgICAgICAgICAgIG9wZW5TdGFydCAtPSAxO1xuICAgICAgICAgICAgb3BlbkVuZCAtPSAxO1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50LmZpcnN0Q2hpbGQudHlwZS5uYW1lID09PSAndGFibGVIZWFkJyB8fFxuICAgICAgICAgICAgY29udGVudC5maXJzdENoaWxkLnR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keScpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Um93QW5kQ29sdW1uQ291bnQoX2EpIHtcbiAgICB2YXIgc3RhcnRSb3dJZHggPSBfYS5zdGFydFJvd0lkeCwgc3RhcnRDb2xJZHggPSBfYS5zdGFydENvbElkeCwgZW5kUm93SWR4ID0gX2EuZW5kUm93SWR4LCBlbmRDb2xJZHggPSBfYS5lbmRDb2xJZHg7XG4gICAgdmFyIHJvd0NvdW50ID0gZW5kUm93SWR4IC0gc3RhcnRSb3dJZHggKyAxO1xuICAgIHZhciBjb2x1bW5Db3VudCA9IGVuZENvbElkeCAtIHN0YXJ0Q29sSWR4ICsgMTtcbiAgICByZXR1cm4geyByb3dDb3VudDogcm93Q291bnQsIGNvbHVtbkNvdW50OiBjb2x1bW5Db3VudCB9O1xufVxuZnVuY3Rpb24gc2V0QXR0cnMoY2VsbCwgYXR0cnMpIHtcbiAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBjZWxsLmF0dHJzKSwgYXR0cnMpO1xufVxuXG52YXIgcGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgnY2VsbFNlbGVjdGlvbicpO1xudmFyIE1PVVNFX1JJR0hUX0JVVFRPTiA9IDI7XG52YXIgVGFibGVTZWxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFibGVTZWxlY3Rpb24odmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge1xuICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLmhhbmRsZU1vdXNlZG93bi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbW91c2Vtb3ZlOiB0aGlzLmhhbmRsZU1vdXNlbW92ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbW91c2V1cDogdGhpcy5oYW5kbGVNb3VzZXVwLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRDZWxsUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlcnMubW91c2Vkb3duKTtcbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIGZvdW5kQ2VsbCA9IGZpbmRDZWxsRWxlbWVudChldi50YXJnZXQsIHRoaXMudmlldy5kb20pO1xuICAgICAgICBpZiAoZXYuYnV0dG9uID09PSBNT1VTRV9SSUdIVF9CVVRUT04pIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ2VsbCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q2VsbFBvcyA9IHRoaXMuZ2V0Q2VsbFBvcyhldik7XG4gICAgICAgICAgICBpZiAoc3RhcnRDZWxsUG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydENlbGxQb3MgPSBzdGFydENlbGxQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJpbmRFdmVudCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTW91c2Vtb3ZlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBwcmV2RW5kQ2VsbE9mZnNldCA9IHBsdWdpbktleS5nZXRTdGF0ZSh0aGlzLnZpZXcuc3RhdGUpO1xuICAgICAgICB2YXIgZW5kQ2VsbFBvcyA9IHRoaXMuZ2V0Q2VsbFBvcyhldik7XG4gICAgICAgIHZhciBzdGFydENlbGxQb3MgPSB0aGlzLnN0YXJ0Q2VsbFBvcztcbiAgICAgICAgdmFyIHByZXZFbmRDZWxsUG9zO1xuICAgICAgICBpZiAocHJldkVuZENlbGxPZmZzZXQpIHtcbiAgICAgICAgICAgIHByZXZFbmRDZWxsUG9zID0gdGhpcy52aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHByZXZFbmRDZWxsT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydENlbGxQb3MgIT09IGVuZENlbGxQb3MpIHtcbiAgICAgICAgICAgIHByZXZFbmRDZWxsUG9zID0gc3RhcnRDZWxsUG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2RW5kQ2VsbFBvcyAmJiBzdGFydENlbGxQb3MgJiYgZW5kQ2VsbFBvcykge1xuICAgICAgICAgICAgdGhpcy5zZXRDZWxsU2VsZWN0aW9uKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlU2VsZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXJ0Q2VsbFBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5iaW5kRXZlbnQoKTtcbiAgICAgICAgaWYgKHBsdWdpbktleS5nZXRTdGF0ZSh0aGlzLnZpZXcuc3RhdGUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godGhpcy52aWV3LnN0YXRlLnRyLnNldE1ldGEocGx1Z2luS2V5LCAtMSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuYmluZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlcnMubW91c2Vtb3ZlKTtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZXJzLm1vdXNldXApO1xuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLnVuYmluZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlcnMubW91c2Vtb3ZlKTtcbiAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZXJzLm1vdXNldXApO1xuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmdldENlbGxQb3MgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNsaWVudFggPSBfYS5jbGllbnRYLCBjbGllbnRZID0gX2EuY2xpZW50WTtcbiAgICAgICAgdmFyIG1vdXNlUG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogY2xpZW50WCwgdG9wOiBjbGllbnRZIH0pO1xuICAgICAgICBpZiAobW91c2VQb3MpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLnZpZXcuc3RhdGUuZG9jO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3MgPSBkb2MucmVzb2x2ZShtb3VzZVBvcy5wb3MpO1xuICAgICAgICAgICAgdmFyIGZvdW5kQ2VsbCA9IGZpbmRDZWxsKGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgaWYgKGZvdW5kQ2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsT2Zmc2V0ID0gY3VycmVudFBvcy5iZWZvcmUoZm91bmRDZWxsLmRlcHRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jLnJlc29sdmUoY2VsbE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBUYWJsZVNlbGVjdGlvbi5wcm90b3R5cGUuc2V0Q2VsbFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHRyID0gX2EudHI7XG4gICAgICAgIHZhciBzdGFydGluZyA9IHBsdWdpbktleS5nZXRTdGF0ZSh0aGlzLnZpZXcuc3RhdGUpID09PSBudWxsO1xuICAgICAgICB2YXIgY2VsbFNlbGVjdGlvbiA9IG5ldyBDZWxsU2VsZWN0aW9uKHN0YXJ0Q2VsbFBvcywgZW5kQ2VsbFBvcyk7XG4gICAgICAgIGlmIChzdGFydGluZyB8fCAhc2VsZWN0aW9uLmVxKGNlbGxTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgbmV3VHIgPSB0ci5zZXRTZWxlY3Rpb24oY2VsbFNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICBuZXdUci5zZXRNZXRhKHBsdWdpbktleSwgZW5kQ2VsbFBvcy5wb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVTZWxlY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVycy5tb3VzZWRvd24pO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlU2VsZWN0aW9uO1xufSgpKTtcblxudmFyIFNFTEVDVEVEX0NFTExfQ0xBU1NfTkFNRSA9IGNscygnY2VsbC1zZWxlY3RlZCcpO1xuZnVuY3Rpb24gZHJhd0NlbGxTZWxlY3Rpb24oX2EpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBkb2MgPSBfYS5kb2M7XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNlbGxzXzEgPSBbXTtcbiAgICAgICAgdmFyIHJhbmdlcyA9IHNlbGVjdGlvbi5yYW5nZXM7XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyICRmcm9tID0gX2EuJGZyb20sICR0byA9IF9hLiR0bztcbiAgICAgICAgICAgIGNlbGxzXzEucHVzaChEZWNvcmF0aW9uLm5vZGUoJGZyb20ucG9zIC0gMSwgJHRvLnBvcyArIDEsIHsgY2xhc3M6IFNFTEVDVEVEX0NFTExfQ0xBU1NfTkFNRSB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBjZWxsc18xKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0YWJsZVNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogcGx1Z2luS2V5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5OiBmdW5jdGlvbiAodHIsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxPZmZzZXQgPSB0ci5nZXRNZXRhKHBsdWdpbktleSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxPZmZzZXQgPT09IC0xID8gbnVsbCA6IGNlbGxPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc051bGxfMSh2YWx1ZSkgfHwgIXRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0ci5tYXBwaW5nLm1hcFJlc3VsdCh2YWx1ZSksIGRlbGV0ZWQgPSBfYS5kZWxldGVkLCBwb3MgPSBfYS5wb3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBudWxsIDogcG9zO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBkcmF3Q2VsbFNlbGVjdGlvbixcbiAgICAgICAgICAgIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW46IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IF9hLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsXzEocGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB2aWV3OiBmdW5jdGlvbiAoZWRpdG9yVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbihlZGl0b3JWaWV3KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBpZ25vcmVcbiAqIEBjbGFzc2Rlc2MgRVM2IE1hcFxuICovXG52YXIgTWFwJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwKCkge1xuICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgTWFwLnByb3RvdHlwZS5nZXRLZXlJbmRleCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGluQXJyYXlfMShrZXksIHRoaXMua2V5cyk7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMuZ2V0S2V5SW5kZXgoa2V5KV07XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBrZXlJbmRleCA9IHRoaXMuZ2V0S2V5SW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKGtleUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzW2tleUluZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEtleUluZGV4KGtleSkgPiAtMTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIga2V5SW5kZXggPSB0aGlzLmdldEtleUluZGV4KGtleSk7XG4gICAgICAgIGlmIChrZXlJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMuc3BsaWNlKGtleUluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShrZXlJbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXNBcmcgPT09IHZvaWQgMCkgeyB0aGlzQXJnID0gdGhpczsgfVxuICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBfdGhpcy5rZXlzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIF90aGlzLmtleXNbaW5kZXhdLCBfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gTWFwO1xufSgpKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEltcGxlbWVudHMgaTE4blxuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cbnZhciBERUZBVUxUX0NPREUgPSAnZW4tVVMnO1xuLyoqXG4gKiBDbGFzcyBJMThuXG4gKiBAaWdub3JlXG4gKi9cbnZhciBJMThuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEkxOG4oKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IERFRkFVTFRfQ09ERTtcbiAgICAgICAgdGhpcy5sYW5ncyA9IG5ldyBNYXAkMSgpO1xuICAgIH1cbiAgICBJMThuLnByb3RvdHlwZS5zZXRDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZSB8fCBERUZBVUxUX0NPREU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbGFuZ3VhZ2Ugc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNvZGVzIGxvY2FsZSBjb2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgbGFuZ3VhZ2Ugc2V0XG4gICAgICovXG4gICAgSTE4bi5wcm90b3R5cGUuc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZXMsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29kZXMgPSBbXS5jb25jYXQoY29kZXMpO1xuICAgICAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmxhbmdzLmhhcyhjb2RlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxhbmdzLnNldChjb2RlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nRGF0YSA9IF90aGlzLmxhbmdzLmdldChjb2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYW5ncy5zZXQoY29kZSwgZXh0ZW5kXzEobGFuZ0RhdGEsIGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJMThuLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBjb2RlKSB7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuY29kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFuZ1NldCA9IHRoaXMubGFuZ3MuZ2V0KGNvZGUpO1xuICAgICAgICBpZiAoIWxhbmdTZXQpIHtcbiAgICAgICAgICAgIGxhbmdTZXQgPSB0aGlzLmxhbmdzLmdldChERUZBVUxUX0NPREUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0ID0gbGFuZ1NldFtrZXldO1xuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIHRleHQga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpbiBcIiArIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIEkxOG47XG59KCkpO1xudmFyIGkxOG4gPSBuZXcgSTE4bigpO1xuXG52YXIgY29udGV4dE1lbnVHcm91cHMgPSBbXG4gICAgW1xuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246ICdBZGQgcm93IHRvIHVwJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhZGRSb3dUb1VwJyxcbiAgICAgICAgICAgIGRpc2FibGVJblRoZWFkOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWRkLXJvdy11cCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FkZCByb3cgdG8gZG93bicsXG4gICAgICAgICAgICBjb21tYW5kOiAnYWRkUm93VG9Eb3duJyxcbiAgICAgICAgICAgIGRpc2FibGVJblRoZWFkOiB0cnVlLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWRkLXJvdy1kb3duJyxcbiAgICAgICAgfSxcbiAgICAgICAgeyBhY3Rpb246ICdSZW1vdmUgcm93JywgY29tbWFuZDogJ3JlbW92ZVJvdycsIGRpc2FibGVJblRoZWFkOiB0cnVlLCBjbGFzc05hbWU6ICdyZW1vdmUtcm93JyB9LFxuICAgIF0sXG4gICAgW1xuICAgICAgICB7IGFjdGlvbjogJ0FkZCBjb2x1bW4gdG8gbGVmdCcsIGNvbW1hbmQ6ICdhZGRDb2x1bW5Ub0xlZnQnLCBjbGFzc05hbWU6ICdhZGQtY29sdW1uLWxlZnQnIH0sXG4gICAgICAgIHsgYWN0aW9uOiAnQWRkIGNvbHVtbiB0byByaWdodCcsIGNvbW1hbmQ6ICdhZGRDb2x1bW5Ub1JpZ2h0JywgY2xhc3NOYW1lOiAnYWRkLWNvbHVtbi1yaWdodCcgfSxcbiAgICAgICAgeyBhY3Rpb246ICdSZW1vdmUgY29sdW1uJywgY29tbWFuZDogJ3JlbW92ZUNvbHVtbicsIGNsYXNzTmFtZTogJ3JlbW92ZS1jb2x1bW4nIH0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ0FsaWduIGNvbHVtbiB0byBsZWZ0JyxcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdhbGlnbkNvbHVtbicsXG4gICAgICAgICAgICBwYXlsb2FkOiB7IGFsaWduOiAnbGVmdCcgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2FsaWduLWNvbHVtbi1sZWZ0JyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgYWN0aW9uOiAnQWxpZ24gY29sdW1uIHRvIGNlbnRlcicsXG4gICAgICAgICAgICBjb21tYW5kOiAnYWxpZ25Db2x1bW4nLFxuICAgICAgICAgICAgcGF5bG9hZDogeyBhbGlnbjogJ2NlbnRlcicgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2FsaWduLWNvbHVtbi1jZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBhY3Rpb246ICdBbGlnbiBjb2x1bW4gdG8gcmlnaHQnLFxuICAgICAgICAgICAgY29tbWFuZDogJ2FsaWduQ29sdW1uJyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHsgYWxpZ246ICdyaWdodCcgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2FsaWduLWNvbHVtbi1yaWdodCcsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBbeyBhY3Rpb246ICdSZW1vdmUgdGFibGUnLCBjb21tYW5kOiAncmVtb3ZlVGFibGUnLCBjbGFzc05hbWU6ICdyZW1vdmUtdGFibGUnIH1dLFxuXTtcbmZ1bmN0aW9uIGdldENvbnRleHRNZW51R3JvdXBzKGV2ZW50RW1pdHRlciwgaW5UYWJsZUhlYWQpIHtcbiAgICByZXR1cm4gY29udGV4dE1lbnVHcm91cHNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udGV4dE1lbnVHcm91cCkge1xuICAgICAgICByZXR1cm4gY29udGV4dE1lbnVHcm91cC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gX2EuYWN0aW9uLCBjb21tYW5kID0gX2EuY29tbWFuZCwgcGF5bG9hZCA9IF9hLnBheWxvYWQsIGRpc2FibGVJblRoZWFkID0gX2EuZGlzYWJsZUluVGhlYWQsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGkxOG4uZ2V0KGFjdGlvbiksXG4gICAgICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY29tbWFuZCcsIGNvbW1hbmQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGluVGFibGVIZWFkICYmICEhZGlzYWJsZUluVGhlYWQsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAuY29uY2F0KCk7XG59XG5mdW5jdGlvbiB0YWJsZUNvbnRleHRNZW51KGV2ZW50RW1pdHRlcikge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbiAodmlldywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlQ2VsbCA9IGZpbmRDZWxsRWxlbWVudChldi50YXJnZXQsIHZpZXcuZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGV2LCBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2IubGVmdCwgdG9wXzEgPSBfYi50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5UYWJsZUhlYWQgPSB0YWJsZUNlbGwubm9kZU5hbWUgPT09ICdUSCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY29udGV4dG1lbnUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiB7IGxlZnQ6IGNsaWVudFggLSBsZWZ0ICsgMTAgKyBcInB4XCIsIHRvcDogY2xpZW50WSAtIHRvcF8xICsgMzAgKyBcInB4XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW51R3JvdXBzOiBnZXRDb250ZXh0TWVudUdyb3VwcyhldmVudEVtaXR0ZXIsIGluVGFibGVIZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNlbGw6IHRhYmxlQ2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0YXNrKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKHZpZXcsIGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGV2LCBjbGllbnRYID0gX2EuY2xpZW50WCwgY2xpZW50WSA9IF9hLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZVBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBjbGllbnRYLCB0b3A6IGNsaWVudFkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3VzZVBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gdmlldy5zdGF0ZSwgZG9jID0gX2IuZG9jLCB0ciA9IF9iLnRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3MgPSBkb2MucmVzb2x2ZShtb3VzZVBvcy5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RJdGVtID0gZmluZExpc3RJdGVtKGN1cnJlbnRQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0LCAnOmJlZm9yZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gZXYsIG9mZnNldFggPSBfYy5vZmZzZXRYLCBvZmZzZXRZID0gX2Mub2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbGlzdEl0ZW0gfHwgIWlzUG9zaXRpb25JbkJveChzdHlsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGN1cnJlbnRQb3MuYmVmb3JlKGxpc3RJdGVtLmRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IGxpc3RJdGVtLm5vZGUuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKG9mZnNldCwgbnVsbCwgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhdHRycyksIHsgY2hlY2tlZDogIWF0dHJzLmNoZWNrZWQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbnZhciBFWENFUFRfVFlQRVMgPSBbJ2ltYWdlJywgJ2xpbmsnLCAnY3VzdG9tQmxvY2snLCAnZnJvbnRNYXR0ZXInXTtcbnZhciBNQVJLX1RZUEVTID0gWydzdHJvbmcnLCAnc3RyaWtlJywgJ2VtcGgnLCAnY29kZSddO1xudmFyIExJU1RfVFlQRVMgPSBbJ2J1bGxldExpc3QnLCAnb3JkZXJlZExpc3QnLCAndGFza0xpc3QnXTtcbmZ1bmN0aW9uIGdldFRvb2xiYXJTdGF0ZVR5cGUobm9kZSwgcGFyZW50Tm9kZSkge1xuICAgIHZhciB0eXBlID0gbm9kZS50eXBlLm5hbWU7XG4gICAgaWYgKHR5cGUgPT09ICdsaXN0SXRlbScpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuYXR0cnMudGFzayA/ICd0YXNrTGlzdCcgOiBwYXJlbnROb2RlLnR5cGUubmFtZTtcbiAgICB9XG4gICAgaWYgKHR5cGUuaW5kZXhPZigndGFibGUnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICd0YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xufVxuZnVuY3Rpb24gc2V0TGlzdE5vZGVUb29sYmFyU3RhdGUodHlwZSwgbm9kZVR5cGVTdGF0ZSkge1xuICAgIG5vZGVUeXBlU3RhdGVbdHlwZV0gPSB7IGFjdGl2ZTogdHJ1ZSB9O1xuICAgIExJU1RfVFlQRVMuZmlsdGVyKGZ1bmN0aW9uIChsaXN0TmFtZSkgeyByZXR1cm4gbGlzdE5hbWUgIT09IHR5cGU7IH0pLmZvckVhY2goZnVuY3Rpb24gKGxpc3RUeXBlKSB7XG4gICAgICAgIGlmIChub2RlVHlwZVN0YXRlW2xpc3RUeXBlXSkge1xuICAgICAgICAgICAgZGVsZXRlIG5vZGVUeXBlU3RhdGVbbGlzdFR5cGVdO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRNYXJrVHlwZVN0YXRlcyhmcm9tLCB0bywgc2NoZW1hLCB0b29sYmFyU3RhdGUpIHtcbiAgICBNQVJLX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIG1hcmsgPSBzY2hlbWEubWFya3NbdHlwZV07XG4gICAgICAgIHZhciBtYXJrc0F0UG9zID0gZnJvbS5tYXJrc0Fjcm9zcyh0bykgfHwgW107XG4gICAgICAgIHZhciBmb3VuZE1hcmsgPSAhIW1hcmsuaXNJblNldChtYXJrc0F0UG9zKTtcbiAgICAgICAgaWYgKGZvdW5kTWFyaykge1xuICAgICAgICAgICAgdG9vbGJhclN0YXRlW3R5cGVdID0geyBhY3RpdmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0VG9vbGJhclN0YXRlKHNlbGVjdGlvbiwgZG9jLCBzY2hlbWEpIHtcbiAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sICR0byA9IHNlbGVjdGlvbi4kdG8sIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgdmFyIHRvb2xiYXJTdGF0ZSA9IHtcbiAgICAgICAgaW5kZW50OiB7IGFjdGl2ZTogZmFsc2UsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgICAgIG91dGRlbnQ6IHsgYWN0aXZlOiBmYWxzZSwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICB9O1xuICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGZ1bmN0aW9uIChub2RlLCBfLCBwYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0VG9vbGJhclN0YXRlVHlwZShub2RlLCBwYXJlbnROb2RlKTtcbiAgICAgICAgaWYgKGluY2x1ZGVzKEVYQ0VQVF9UWVBFUywgdHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZXMoTElTVF9UWVBFUywgdHlwZSkpIHtcbiAgICAgICAgICAgIHNldExpc3ROb2RlVG9vbGJhclN0YXRlKHR5cGUsIHRvb2xiYXJTdGF0ZSk7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGUuaW5kZW50LmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0b29sYmFyU3RhdGUub3V0ZGVudC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgc2V0TWFya1R5cGVTdGF0ZXMoJGZyb20sICR0bywgc2NoZW1hLCB0b29sYmFyU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9vbGJhclN0YXRlW3R5cGVdID0geyBhY3RpdmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0b29sYmFyU3RhdGU7XG59XG5mdW5jdGlvbiB0b29sYmFyU3RhdGVIaWdobGlnaHQoZXZlbnRFbWl0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICB2aWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gdmlldy5zdGF0ZSwgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCBkb2MgPSBfYS5kb2MsIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVRvb2xiYXJTdGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xiYXJTdGF0ZTogZ2V0VG9vbGJhclN0YXRlKHNlbGVjdGlvbiwgZG9jLCBzY2hlbWEpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxudmFyIEN1c3RvbUJsb2NrVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9ja1ZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCB0b0RPTUFkYXB0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vcGVuRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlubmVyRWRpdG9yVmlldykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGVkaXRvciBpcyBhbHJlYWR5IG9wZW5lZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmRvbS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLndyYXBwZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIF90aGlzLmlubmVyVmlld0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIF90aGlzLmlubmVyRWRpdG9yVmlldyA9IG5ldyBFZGl0b3JWaWV3KF90aGlzLmlubmVyVmlld0NvbnRhaW5lciwge1xuICAgICAgICAgICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBkb2M6IF90aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleW1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ01vZC16JzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kbyhfdGhpcy5pbm5lckVkaXRvclZpZXcuc3RhdGUsIF90aGlzLmlubmVyRWRpdG9yVmlldy5kaXNwYXRjaCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NoaWZ0LU1vZC16JzogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVkbyhfdGhpcy5pbm5lckVkaXRvclZpZXcuc3RhdGUsIF90aGlzLmlubmVyRWRpdG9yVmlldy5kaXNwYXRjaCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVGFiOiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoJ1xcdCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbnRlcjogbmV3bGluZUluQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFc2NhcGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDdHJsLUVudGVyJzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zYXZlQW5kRmluaXNoRWRpdGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5KCksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogZnVuY3Rpb24gKHRyKSB7IHJldHVybiBfdGhpcy5kaXNwYXRjaElubmVyKHRyKTsgfSxcbiAgICAgICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZWRpdG9yVmlldy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5uZXJFZGl0b3JWaWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYmx1cjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2F2ZUFuZEZpbmlzaEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmlubmVyRWRpdG9yVmlldy5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmdldFBvcyA9IGdldFBvcztcbiAgICAgICAgdGhpcy50b0RPTUFkYXB0b3IgPSB0b0RPTUFkYXB0b3I7XG4gICAgICAgIHRoaXMuaW5uZXJFZGl0b3JWaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHMoJ2N1c3RvbS1ibG9jaycpO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmNsYXNzTmFtZSA9IGNscygnY3VzdG9tLWJsb2NrLXZpZXcnKTtcbiAgICAgICAgdGhpcy5jcmVhdGVJbm5lclZpZXdDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXN0b21CbG9jaygpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmlubmVyVmlld0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlcik7XG4gICAgfVxuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUucmVuZGVyVG9vbEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHRvb2wuY2xhc3NOYW1lID0gJ3Rvb2wnO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5ub2RlLmF0dHJzLmluZm87XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gJ2luZm8nO1xuICAgICAgICBidXR0b24udHlwZSA9ICdidXR0b24nO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vcGVuRWRpdG9yKCk7IH0pO1xuICAgICAgICB0b29sLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICB0b29sLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0b29sKTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUucmVuZGVyQ3VzdG9tQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b0RPTU5vZGUgPSB0aGlzLnRvRE9NQWRhcHRvci5nZXRUb0RPTU5vZGUodGhpcy5ub2RlLmF0dHJzLmluZm8pO1xuICAgICAgICBpZiAodG9ET01Ob2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRvRE9NTm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMud3JhcHBlci5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyVG9vbEFyZWEoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5jcmVhdGVJbm5lclZpZXdDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW5uZXJWaWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9IGNscygnY3VzdG9tLWJsb2NrLWVkaXRvcicpO1xuICAgICAgICB0aGlzLmlubmVyVmlld0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5jbG9zZUVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5uZXJFZGl0b3JWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRWRpdG9yVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmlubmVyRWRpdG9yVmlldyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlubmVyVmlld0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuc2F2ZUFuZEZpbmlzaEVkaXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0byA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHZhciBvdXRlclN0YXRlID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcuZGlzcGF0Y2gob3V0ZXJTdGF0ZS50ci5zZXRTZWxlY3Rpb24oY3JlYXRlVGV4dFNlbGVjdGlvbihvdXRlclN0YXRlLnRyLCB0bykpKTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3LmZvY3VzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3VzdG9tQmxvY2soKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvcigpO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5jYW5jZWxFZGl0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdW5kb2FibGVDb3VudCA9IHVuZG9EZXB0aCh0aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAvLyBzaG91bGQgdW5kbyBlZGl0aW5nIHJlc3VsdFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgICAgd2hpbGUgKHVuZG9hYmxlQ291bnQtLSkge1xuICAgICAgICAgICAgdW5kbyh0aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZSwgdGhpcy5pbm5lckVkaXRvclZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgdW5kbyh0aGlzLmVkaXRvclZpZXcuc3RhdGUsIHRoaXMuZWRpdG9yVmlldy5kaXNwYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdG8gPSB0aGlzLmVkaXRvclZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICB2YXIgb3V0ZXJTdGF0ZSA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3LmRpc3BhdGNoKG91dGVyU3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKG91dGVyU3RhdGUuZG9jLCB0bykpKTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuY2xvc2VFZGl0b3IoKTtcbiAgICB9O1xuICAgIEN1c3RvbUJsb2NrVmlldy5wcm90b3R5cGUuZGlzcGF0Y2hJbm5lciA9IGZ1bmN0aW9uICh0cikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmlubmVyRWRpdG9yVmlldy5zdGF0ZS5hcHBseVRyYW5zYWN0aW9uKHRyKSwgc3RhdGUgPSBfYS5zdGF0ZSwgdHJhbnNhY3Rpb25zID0gX2EudHJhbnNhY3Rpb25zO1xuICAgICAgICB0aGlzLmlubmVyRWRpdG9yVmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIGlmICghdGhpcy5jYW5jZWxlZCAmJiBpc0Z1bmN0aW9uXzEodGhpcy5nZXRQb3MpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJUciA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBvZmZzZXRNYXAgPSBTdGVwTWFwLm9mZnNldCh0aGlzLmdldFBvcygpICsgMSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zYWN0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGVwcyA9IHRyYW5zYWN0aW9uc1tpXS5zdGVwcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXBzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyVHIuc3RlcChzdGVwc1tqXS5tYXAob2Zmc2V0TWFwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dGVyVHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yVmlldy5kaXNwYXRjaChvdXRlclRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgaWYgKCF0aGlzLmlubmVyRWRpdG9yVmlldykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDdXN0b21CbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5zdG9wRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICghIXRoaXMuaW5uZXJFZGl0b3JWaWV3ICYmXG4gICAgICAgICAgICAhIWV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgdGhpcy5pbm5lckVkaXRvclZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpO1xuICAgIH07XG4gICAgQ3VzdG9tQmxvY2tWaWV3LnByb3RvdHlwZS5pZ25vcmVNdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBDdXN0b21CbG9ja1ZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgdGhpcy5vcGVuRWRpdG9yKTtcbiAgICAgICAgdGhpcy5jbG9zZUVkaXRvcigpO1xuICAgIH07XG4gICAgcmV0dXJuIEN1c3RvbUJsb2NrVmlldztcbn0oKSk7XG5cbnZhciBJTUFHRV9MSU5LX0NMQVNTX05BTUUgPSAnaW1hZ2UtbGluayc7XG52YXIgSW1hZ2VWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltYWdlVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIGV2ZW50RW1pdHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldCwgb2Zmc2V0WCA9IGV2Lm9mZnNldFgsIG9mZnNldFkgPSBldi5vZmZzZXRZO1xuICAgICAgICAgICAgaWYgKF90aGlzLmltYWdlTGluayAmJlxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb25fMShfdGhpcy5nZXRQb3MpICYmXG4gICAgICAgICAgICAgICAgaGFzQ2xhc3NfMSh0YXJnZXQsIElNQUdFX0xJTktfQ0xBU1NfTkFNRSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgJzpiZWZvcmUnKTtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQb3NpdGlvbkluQm94KHN0eWxlLCBvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSBfdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gX3RoaXMuZ2V0UG9zKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihjcmVhdGVUZXh0U2VsZWN0aW9uKHRyLCBwb3MsIHBvcyArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdvcGVuUG9wdXAnLCAnbGluaycsIF90aGlzLmltYWdlTGluay5hdHRycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmdldFBvcyA9IGdldFBvcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaW1hZ2VMaW5rID0gKF9hID0gbm9kZS5tYXJrcy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnbGluayc7XG4gICAgICAgIH0pWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmJpbmRFdmVudCgpO1xuICAgIH1cbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuY3JlYXRlSW1hZ2VFbGVtZW50KHRoaXMubm9kZSk7XG4gICAgICAgIGlmICh0aGlzLmltYWdlTGluaykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IElNQUdFX0xJTktfQ0xBU1NfTkFNRTtcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW1hZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH07XG4gICAgSW1hZ2VWaWV3LnByb3RvdHlwZS5jcmVhdGVJbWFnZUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgdmFyIF9hID0gbm9kZS5hdHRycywgaW1hZ2VVcmwgPSBfYS5pbWFnZVVybCwgYWx0VGV4dCA9IF9hLmFsdFRleHQ7XG4gICAgICAgIHZhciBhdHRycyA9IGdldEN1c3RvbUF0dHJzKG5vZGUuYXR0cnMpO1xuICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVybDtcbiAgICAgICAgaWYgKGFsdFRleHQpIHtcbiAgICAgICAgICAgIGltYWdlLmFsdCA9IGFsdFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0QXR0cmlidXRlcyhhdHRycywgaW1hZ2UpO1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfTtcbiAgICBJbWFnZVZpZXcucHJvdG90eXBlLmJpbmRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VMaW5rKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlZG93bik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuc3RvcEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEltYWdlVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VMaW5rKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlZG93bik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVZpZXc7XG59KCkpO1xuXG52YXIgV1JBUFBFUl9DTEFTU19OQU1FID0gJ3RvYXN0dWktZWRpdG9yLXd3LWNvZGUtYmxvY2snO1xudmFyIENPREVfQkxPQ0tfTEFOR19DTEFTU19OQU1FID0gJ3RvYXN0dWktZWRpdG9yLXd3LWNvZGUtYmxvY2stbGFuZ3VhZ2UnO1xudmFyIENvZGVCbG9ja1ZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29kZUJsb2NrVmlldyhub2RlLCB2aWV3LCBnZXRQb3MsIGV2ZW50RW1pdHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBudWxsO1xuICAgICAgICB0aGlzLmlucHV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2Vkb3duID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQsICc6YWZ0ZXInKTtcbiAgICAgICAgICAgIC8vIGp1ZGdlIHRvIGNsaWNrIHBzZXVkbyBlbGVtZW50IHdpdGggYmFja2dyb3VuZCBpbWFnZSBmb3IgSUUxMVxuICAgICAgICAgICAgaWYgKHN0eWxlLmJhY2tncm91bmRJbWFnZSAhPT0gJ25vbmUnICYmIGlzRnVuY3Rpb25fMShfdGhpcy5nZXRQb3MpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMudmlldy5jb29yZHNBdFBvcyhfdGhpcy5nZXRQb3MoKSksIHRvcF8xID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0O1xuICAgICAgICAgICAgICAgIF90aGlzLmNyZWF0ZUxhbmd1YWdlRWRpdG9yKHsgdG9wOiB0b3BfMSwgcmlnaHQ6IHJpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFbnRlcicgJiYgX3RoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZUxhbmd1YWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gZ2V0UG9zO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuYmluZERPTUV2ZW50KCk7XG4gICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XG4gICAgfVxuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IHRoaXMubm9kZS5hdHRycy5sYW5ndWFnZTtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZ3VhZ2UnLCBsYW5ndWFnZSB8fCAndGV4dCcpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IFdSQVBQRVJfQ0xBU1NfTkFNRTtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMuY3JlYXRlQ29kZUJsb2NrRWxlbWVudCgpO1xuICAgICAgICB2YXIgY29kZSA9IHByZS5maXJzdENoaWxkO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHByZSk7XG4gICAgICAgIHRoaXMuZG9tID0gd3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NID0gY29kZTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmNyZWF0ZUNvZGVCbG9ja0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcbiAgICAgICAgdmFyIGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG4gICAgICAgIHZhciBsYW5ndWFnZSA9IHRoaXMubm9kZS5hdHRycy5sYW5ndWFnZTtcbiAgICAgICAgdmFyIGF0dHJzID0gZ2V0Q3VzdG9tQXR0cnModGhpcy5ub2RlLmF0dHJzKTtcbiAgICAgICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICAgICAgICBjb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5ndWFnZScsIGxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJzLCBwcmUpO1xuICAgICAgICBwcmUuYXBwZW5kQ2hpbGQoY29kZSk7XG4gICAgICAgIHJldHVybiBwcmU7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5jcmVhdGVMYW5ndWFnZUVkaXRvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9wID0gX2EudG9wLCByaWdodCA9IF9hLnJpZ2h0O1xuICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSBDT0RFX0JMT0NLX0xBTkdfQ0xBU1NfTkFNRTtcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLm5vZGUuYXR0cnMubGFuZ3VhZ2U7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIHZhciB3cnBwZXJXaWR0aCA9IHdyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgICAgIGNzc18xKHdyYXBwZXIsIHtcbiAgICAgICAgICAgIHRvcDogdG9wICsgMTAgKyBcInB4XCIsXG4gICAgICAgICAgICBsZWZ0OiByaWdodCAtIHdycHBlcldpZHRoIC0gMTAgKyBcInB4XCIsXG4gICAgICAgICAgICB3aWR0aDogd3JwcGVyV2lkdGggKyBcInB4XCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNoYW5nZUxhbmd1YWdlKCk7IH0pO1xuICAgICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24pO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5iaW5kRE9NRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZU1vdXNlZG93bik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmJpbmRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvZGVCbG9ja1ZpZXcucHJvdG90eXBlLmNoYW5nZUxhbmd1YWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dCAmJiBpc0Z1bmN0aW9uXzEodGhpcy5nZXRQb3MpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgICAgICB2YXIgdHIgPSB0aGlzLnZpZXcuc3RhdGUudHI7XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgbnVsbCwgeyBsYW5ndWFnZTogdmFsdWUgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5pbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuaW5wdXQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZSQxKHBhcmVudF8xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb2RlQmxvY2tWaWV3LnByb3RvdHlwZS5zdG9wRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlLnNhbWVNYXJrdXAodGhpcy5ub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ29kZUJsb2NrVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvZGVCbG9ja1ZpZXc7XG59KCkpO1xuXG52YXIgcmVNU09MaXN0Q2xhc3NOYW1lID0gL01zb0xpc3RQYXJhZ3JhcGgvO1xudmFyIHJlTVNPU3R5bGVQcmVmaXggPSAvc3R5bGU9KC58XFxuKSptc28tLztcbnZhciByZU1TT0xpc3RTdHlsZSA9IC9tc28tbGlzdDooLiopLztcbnZhciByZU1TT1RhZ05hbWUgPSAvTzpQLztcbnZhciByZU1TT0xpc3RCdWxsZXQgPSAvXihufHV8bCkvO1xudmFyIE1TT19DTEFTU19OQU1FX0xJU1RfUEFSQSA9ICdwLk1zb0xpc3RQYXJhZ3JhcGgnO1xuZnVuY3Rpb24gaXNGcm9tTXNvKGh0bWwpIHtcbiAgICByZXR1cm4gcmVNU09TdHlsZVByZWZpeC50ZXN0KGh0bWwpO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1Db250ZW50cyhwYXJhKSB7XG4gICAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHZhciB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHBhcmEsIDEsIG51bGwsIGZhbHNlKTtcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBub2RlLCBvdXRlckhUTUwgPSBfYS5vdXRlckhUTUwsIHRleHRDb250ZW50ID0gX2EudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbXNvU3BhbiA9IHJlTVNPU3R5bGVQcmVmaXgudGVzdChvdXRlckhUTUwpO1xuICAgICAgICAgICAgdmFyIGJ1bGxldFNwYW4gPSByZU1TT0xpc3RTdHlsZS50ZXN0KG91dGVySFRNTCk7XG4gICAgICAgICAgICBpZiAobXNvU3BhbiAmJiAhYnVsbGV0U3BhbiAmJiB0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKFtub2RlLCB0cnVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZU1TT1RhZ05hbWUudGVzdChub2RlLm5vZGVOYW1lKSB8fCAobXNvU3BhbiAmJiAhdGV4dENvbnRlbnQpIHx8IGJ1bGxldFNwYW4pIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkTm9kZXMucHVzaChbbm9kZSwgZmFsc2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYVswXSwgaXNVbndyYXAgPSBfYVsxXTtcbiAgICAgICAgaWYgKGlzVW53cmFwKSB7XG4gICAgICAgICAgICB1bndyYXBOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZSQxKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmEuaW5uZXJIVE1MLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RJdGVtRGF0YUZyb21QYXJhZ3JhcGgocGFyYSwgaW5kZXgpIHtcbiAgICB2YXIgc3R5bGVBdHRyID0gcGFyYS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgaWYgKHN0eWxlQXR0cikge1xuICAgICAgICB2YXIgX2EgPSBzdHlsZUF0dHIubWF0Y2gocmVNU09MaXN0U3R5bGUpLCBsaXN0SXRlbUluZm8gPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gbGlzdEl0ZW1JbmZvLnRyaW0oKS5zcGxpdCgnICcpLCBsZXZlbFN0ciA9IF9iWzFdO1xuICAgICAgICB2YXIgbGV2ZWwgPSBwYXJzZUludChsZXZlbFN0ci5yZXBsYWNlKCdsZXZlbCcsICcnKSwgMTApO1xuICAgICAgICB2YXIgdW5vcmRlcmVkID0gcmVNU09MaXN0QnVsbGV0LnRlc3QocGFyYS50ZXh0Q29udGVudCB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaW5kZXgsXG4gICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgdW5vcmRlcmVkOiB1bm9yZGVyZWQsXG4gICAgICAgICAgICBjb250ZW50czogZ2V0TGlzdEl0ZW1Db250ZW50cyhwYXJhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhZGRMaXN0SXRlbURldGFpbERhdGEoZGF0YSwgcHJldkRhdGEpIHtcbiAgICBpZiAocHJldkRhdGEubGV2ZWwgPCBkYXRhLmxldmVsKSB7XG4gICAgICAgIHByZXZEYXRhLmNoaWxkcmVuLnB1c2goZGF0YSk7XG4gICAgICAgIGRhdGEucGFyZW50ID0gcHJldkRhdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAocHJldkRhdGEpIHtcbiAgICAgICAgICAgIGlmIChwcmV2RGF0YS5sZXZlbCA9PT0gZGF0YS5sZXZlbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkRhdGEgPSBwcmV2RGF0YS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZEYXRhKSB7XG4gICAgICAgICAgICBkYXRhLnByZXYgPSBwcmV2RGF0YTtcbiAgICAgICAgICAgIGRhdGEucGFyZW50ID0gcHJldkRhdGEucGFyZW50O1xuICAgICAgICAgICAgaWYgKGRhdGEucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wYXJlbnQuY2hpbGRyZW4ucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpc3REYXRhKHBhcmFzKSB7XG4gICAgdmFyIGxpc3REYXRhID0gW107XG4gICAgcGFyYXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByZXZMaXN0SXRlbURhdGEgPSBsaXN0RGF0YVtpbmRleCAtIDFdO1xuICAgICAgICB2YXIgbGlzdEl0ZW1EYXRhID0gY3JlYXRlTGlzdEl0ZW1EYXRhRnJvbVBhcmFncmFwaChwYXJhLCBpbmRleCk7XG4gICAgICAgIGlmIChsaXN0SXRlbURhdGEpIHtcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdEl0ZW1EYXRhKSB7XG4gICAgICAgICAgICAgICAgYWRkTGlzdEl0ZW1EZXRhaWxEYXRhKGxpc3RJdGVtRGF0YSwgcHJldkxpc3RJdGVtRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0RGF0YS5wdXNoKGxpc3RJdGVtRGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGlzdERhdGE7XG59XG5mdW5jdGlvbiBtYWtlTGlzdChsaXN0RGF0YSkge1xuICAgIHZhciBsaXN0VGFnTmFtZSA9IGxpc3REYXRhWzBdLnVub3JkZXJlZCA/ICd1bCcgOiAnb2wnO1xuICAgIHZhciBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChsaXN0VGFnTmFtZSk7XG4gICAgbGlzdERhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuLCBjb250ZW50cyA9IGRhdGEuY29udGVudHM7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgIGxpc3RJdGVtLmlubmVySFRNTCA9IGNvbnRlbnRzO1xuICAgICAgICBsaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGlzdC5hcHBlbmRDaGlsZChtYWtlTGlzdChjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBtYWtlTGlzdEZyb21QYXJhZ3JhcGhzKHBhcmFzKSB7XG4gICAgdmFyIGxpc3REYXRhID0gY3JlYXRlTGlzdERhdGEocGFyYXMpO1xuICAgIHZhciByb290Q2hpbGRyZW4gPSBsaXN0RGF0YS5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBfYS5wYXJlbnQ7XG4gICAgICAgIHJldHVybiAhcGFyZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBtYWtlTGlzdChyb290Q2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gaXNNc29MaXN0UGFyYWdyYXBoRW5kKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoaXNFbGVtTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBub2RlID8gIXJlTVNPTGlzdENsYXNzTmFtZS50ZXN0KG5vZGUuY2xhc3NOYW1lKSA6IHRydWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0TXNvUGFyYWdyYXBoc1RvTGlzdChodG1sKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHZhciBwYXJhcyA9IFtdO1xuICAgIHZhciBmb3VuZFBhcmFzID0gZmluZE5vZGVzKGNvbnRhaW5lciwgTVNPX0NMQVNTX05BTUVfTElTVF9QQVJBKTtcbiAgICBmb3VuZFBhcmFzLmZvckVhY2goZnVuY3Rpb24gKHBhcmEpIHtcbiAgICAgICAgdmFyIG1zb0xpc3RQYXJhRW5kID0gaXNNc29MaXN0UGFyYWdyYXBoRW5kKHBhcmEubmV4dFNpYmxpbmcpO1xuICAgICAgICBwYXJhcy5wdXNoKHBhcmEpO1xuICAgICAgICBpZiAobXNvTGlzdFBhcmFFbmQpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3RGcm9tUGFyYWdyYXBocyhwYXJhcyk7XG4gICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBwYXJhLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlTm9kZShsaXN0LCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBlbmROb2Rlcyhjb250YWluZXIsIGxpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVOb2RlJDEocGFyYSk7XG4gICAgfSk7XG4gICAgLy8gd2l0aG91dCBgPHA+PC9wPmAsIHRoZSBsaXN0IHN0cmluZyB3YXMgcGFyc2VkIGFzIGEgcGFyYWdyYXBoIG5vZGUgYW5kIGFkZGVkXG4gICAgdmFyIGV4dHJhSFRNTCA9IGZvdW5kUGFyYXMubGVuZ3RoID8gJzxwPjwvcD4nIDogJyc7XG4gICAgcmV0dXJuIFwiXCIgKyBleHRyYUhUTUwgKyBjb250YWluZXIuaW5uZXJIVE1MO1xufVxuXG52YXIgU1RBUlRfRlJBR01FTlRfQ09NTUVOVCA9ICc8IS0tU3RhcnRGcmFnbWVudC0tPic7XG52YXIgRU5EX0ZSQUdNRU5UX0NPTU1FTlQgPSAnPCEtLUVuZEZyYWdtZW50LS0+JztcbmZ1bmN0aW9uIGdldENvbnRlbnRCZXR3ZWVuRnJhZ21lbnRDb21tZW50cyhodG1sKSB7XG4gICAgdmFyIHN0YXJ0RnJhZ21lbnRJbmRleCA9IGh0bWwuaW5kZXhPZihTVEFSVF9GUkFHTUVOVF9DT01NRU5UKTtcbiAgICB2YXIgZW5kRnJhZ21lbnRJbmRleCA9IGh0bWwubGFzdEluZGV4T2YoRU5EX0ZSQUdNRU5UX0NPTU1FTlQpO1xuICAgIGlmIChzdGFydEZyYWdtZW50SW5kZXggPiAtMSAmJiBlbmRGcmFnbWVudEluZGV4ID4gLTEpIHtcbiAgICAgICAgaHRtbCA9IGh0bWwuc2xpY2Uoc3RhcnRGcmFnbWVudEluZGV4ICsgU1RBUlRfRlJBR01FTlRfQ09NTUVOVC5sZW5ndGgsIGVuZEZyYWdtZW50SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88YnJbXj5dKj4vZywgQUxURVJOQVRJVkVfVEFHX0ZPUl9CUik7XG59XG5mdW5jdGlvbiBjb252ZXJ0TXNvVGFibGVUb0NvbXBsZXRlZFRhYmxlKGh0bWwpIHtcbiAgICAvLyB3cmFwIHdpdGggPHRyPiBpZiBodG1sIGNvbnRhaW5zIGRhbmdsaW5nIDx0ZD4gdGFnc1xuICAgIC8vIGRhbmdsaW5nIDx0ZD4gdGFnIGlzIHRoYXQgdGFnIGRvZXMgbm90IGhhdmUgPHRyPiBhcyBwYXJlbnQgbm9kZVxuICAgIGlmICgvPFxcL3RkPigoPyE8XFwvdHI+KVtcXHNcXFNdKSokL2kudGVzdChodG1sKSkge1xuICAgICAgICBodG1sID0gXCI8dHI+XCIgKyBodG1sICsgXCI8L3RyPlwiO1xuICAgIH1cbiAgICAvLyB3cmFwIHdpdGggPHRhYmxlPiBpZiBodG1sIGNvbnRhaW5zIGRhbmdsaW5nIDx0cj4gdGFnc1xuICAgIC8vIGRhbmdsaW5nIDx0cj4gdGFnIGlzIHRoYXQgdGFnIGRvZXMgbm90IGhhdmUgPHRhYmxlPiBhcyBwYXJlbnQgbm9kZVxuICAgIGlmICgvPFxcL3RyPigoPyE8XFwvdGFibGU+KVtcXHNcXFNdKSokL2kudGVzdChodG1sKSkge1xuICAgICAgICBodG1sID0gXCI8dGFibGU+XCIgKyBodG1sICsgXCI8L3RhYmxlPlwiO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbn1cbmZ1bmN0aW9uIGNoYW5nZVBhc3RlZEhUTUwoaHRtbCkge1xuICAgIGh0bWwgPSBnZXRDb250ZW50QmV0d2VlbkZyYWdtZW50Q29tbWVudHMoaHRtbCk7XG4gICAgaHRtbCA9IGNvbnZlcnRNc29UYWJsZVRvQ29tcGxldGVkVGFibGUoaHRtbCk7XG4gICAgaWYgKGlzRnJvbU1zbyhodG1sKSkge1xuICAgICAgICBodG1sID0gY29udmVydE1zb1BhcmFncmFwaHNUb0xpc3QoaHRtbCk7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuZnVuY3Rpb24gZ2V0TWF4Q29sdW1uQ291bnQocm93cykge1xuICAgIHZhciByb3cgPSByb3dzLnJlZHVjZShmdW5jdGlvbiAocHJldlJvdywgY3VycmVudFJvdykge1xuICAgICAgICByZXR1cm4gcHJldlJvdy5jaGlsZENvdW50ID4gY3VycmVudFJvdy5jaGlsZENvdW50ID8gcHJldlJvdyA6IGN1cnJlbnRSb3c7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvdy5jaGlsZENvdW50O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2VsbHMob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgY2VsbCkge1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIHZhciBjZWxsQ291bnQgPSBvcmdSb3cuY2hpbGRDb3VudDtcbiAgICBmb3IgKHZhciBjb2xJZHggPSAwOyBjb2xJZHggPCBjZWxsQ291bnQ7IGNvbElkeCArPSAxKSB7XG4gICAgICAgIGlmICghb3JnUm93LmNoaWxkKGNvbElkeCkuYXR0cnMuZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIHZhciBjb3BpZWRDZWxsID0gY29sSWR4IDwgY2VsbENvdW50XG4gICAgICAgICAgICAgICAgPyBjZWxsLmNyZWF0ZShvcmdSb3cuY2hpbGQoY29sSWR4KS5hdHRycywgb3JnUm93LmNoaWxkKGNvbElkeCkuY29udGVudClcbiAgICAgICAgICAgICAgICA6IGNlbGwuY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgICAgICAgY2VsbHMucHVzaChjb3BpZWRDZWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG5mdW5jdGlvbiBjb3B5VGFibGVIZWFkUm93KG9yZ1JvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVIZWFkQ2VsbCA9IF9hLnRhYmxlSGVhZENlbGw7XG4gICAgdmFyIGNlbGxzID0gY3JlYXRlQ2VsbHMob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgdGFibGVIZWFkQ2VsbCk7XG4gICAgcmV0dXJuIHRhYmxlUm93LmNyZWF0ZShudWxsLCBjZWxscyk7XG59XG5mdW5jdGlvbiBjb3B5VGFibGVCb2R5Um93KG9yZ1JvdywgbWF4Q29sdW1uQ291bnQsIHNjaGVtYSkge1xuICAgIHZhciBfYSA9IHNjaGVtYS5ub2RlcywgdGFibGVSb3cgPSBfYS50YWJsZVJvdywgdGFibGVCb2R5Q2VsbCA9IF9hLnRhYmxlQm9keUNlbGw7XG4gICAgdmFyIGNlbGxzID0gY3JlYXRlQ2VsbHMob3JnUm93LCBtYXhDb2x1bW5Db3VudCwgdGFibGVCb2R5Q2VsbCk7XG4gICAgcmV0dXJuIHRhYmxlUm93LmNyZWF0ZShudWxsLCBjZWxscyk7XG59XG5mdW5jdGlvbiBjcmVhdFRhYmxlQm9keUR1bW15Um93KGNvbHVtbkNvdW50LCBzY2hlbWEpIHtcbiAgICB2YXIgX2EgPSBzY2hlbWEubm9kZXMsIHRhYmxlUm93ID0gX2EudGFibGVSb3csIHRhYmxlQm9keUNlbGwgPSBfYS50YWJsZUJvZHlDZWxsO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjb2x1bW5Db3VudDsgY29sdW1uSW5kZXggKz0gMSkge1xuICAgICAgICB2YXIgZHVtbXlDZWxsID0gdGFibGVCb2R5Q2VsbC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgIGNlbGxzLnB1c2goZHVtbXlDZWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlUm93LmNyZWF0ZSh7IGR1bW15Um93Rm9yUGFzdGluZzogdHJ1ZSB9LCBjZWxscyk7XG59XG5mdW5jdGlvbiBjcmVhdGVSb3dzRnJvbVBhc3RpbmdUYWJsZSh0YWJsZUNvbnRlbnQpIHtcbiAgICB2YXIgdGFibGVIZWFkUm93cyA9IFtdO1xuICAgIHZhciB0YWJsZUJvZHlSb3dzID0gW107XG4gICAgaWYgKHRhYmxlQ29udGVudC5maXJzdENoaWxkLnR5cGUubmFtZSA9PT0gJ3RhYmxlSGVhZCcpIHtcbiAgICAgICAgdmFyIHRhYmxlSGVhZCA9IHRhYmxlQ29udGVudC5maXJzdENoaWxkO1xuICAgICAgICB0YWJsZUhlYWQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiB0YWJsZUhlYWRSb3dzLnB1c2gocm93KTsgfSk7XG4gICAgfVxuICAgIGlmICh0YWJsZUNvbnRlbnQubGFzdENoaWxkLnR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keScpIHtcbiAgICAgICAgdmFyIHRhYmxlQm9keSA9IHRhYmxlQ29udGVudC5sYXN0Q2hpbGQ7XG4gICAgICAgIHRhYmxlQm9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHRhYmxlQm9keVJvd3MucHVzaChyb3cpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShfX3NwcmVhZEFycmF5JDEoW10sIHRhYmxlSGVhZFJvd3MpLCB0YWJsZUJvZHlSb3dzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlSGVhZCh0YWJsZUhlYWRSb3csIG1heENvbHVtbkNvdW50LCBzY2hlbWEpIHtcbiAgICB2YXIgY29waWVkUm93ID0gY29weVRhYmxlSGVhZFJvdyh0YWJsZUhlYWRSb3csIG1heENvbHVtbkNvdW50LCBzY2hlbWEpO1xuICAgIHJldHVybiBzY2hlbWEubm9kZXMudGFibGVIZWFkLmNyZWF0ZShudWxsLCBjb3BpZWRSb3cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGVCb2R5KHRhYmxlQm9keVJvd3MsIG1heENvbHVtbkNvdW50LCBzY2hlbWEpIHtcbiAgICB2YXIgY29waWVkUm93cyA9IHRhYmxlQm9keVJvd3MubWFwKGZ1bmN0aW9uICh0YWJsZUJvZHlSb3cpIHtcbiAgICAgICAgcmV0dXJuIGNvcHlUYWJsZUJvZHlSb3codGFibGVCb2R5Um93LCBtYXhDb2x1bW5Db3VudCwgc2NoZW1hKTtcbiAgICB9KTtcbiAgICBpZiAoIXRhYmxlQm9keVJvd3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBkdW1teVRhYmxlUm93ID0gY3JlYXRUYWJsZUJvZHlEdW1teVJvdyhtYXhDb2x1bW5Db3VudCwgc2NoZW1hKTtcbiAgICAgICAgY29waWVkUm93cy5wdXNoKGR1bW15VGFibGVSb3cpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzLnRhYmxlQm9keS5jcmVhdGUobnVsbCwgY29waWVkUm93cyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUZyb21QYXN0aW5nVGFibGUocm93cywgc2NoZW1hLCBzdGFydEZyb21Cb2R5LCBpc0luVGFibGUpIHtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBnZXRNYXhDb2x1bW5Db3VudChyb3dzKTtcbiAgICBpZiAoc3RhcnRGcm9tQm9keSAmJiBpc0luVGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5ub2Rlcy50YWJsZS5jcmVhdGUobnVsbCwgW2NyZWF0ZVRhYmxlQm9keShyb3dzLCBjb2x1bW5Db3VudCwgc2NoZW1hKV0pO1xuICAgIH1cbiAgICB2YXIgdGFibGVIZWFkUm93ID0gcm93c1swXTtcbiAgICB2YXIgdGFibGVCb2R5Um93cyA9IHJvd3Muc2xpY2UoMSk7XG4gICAgdmFyIG5vZGVzID0gW2NyZWF0ZVRhYmxlSGVhZCh0YWJsZUhlYWRSb3csIGNvbHVtbkNvdW50LCBzY2hlbWEpXTtcbiAgICBpZiAodGFibGVCb2R5Um93cy5sZW5ndGgpIHtcbiAgICAgICAgbm9kZXMucHVzaChjcmVhdGVUYWJsZUJvZHkodGFibGVCb2R5Um93cywgY29sdW1uQ291bnQsIHNjaGVtYSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzLnRhYmxlLmNyZWF0ZShudWxsLCBub2Rlcyk7XG59XG5mdW5jdGlvbiBjaGFuZ2VQYXN0ZWRTbGljZShzbGljZSwgc2NoZW1hLCBpc0luVGFibGUpIHtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCA9IHNsaWNlLm9wZW5FbmQ7XG4gICAgY29udGVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gJ3RhYmxlJykge1xuICAgICAgICAgICAgdmFyIHRhYmxlQ29udGVudCA9IGdldFRhYmxlQ29udGVudEZyb21TbGljZShuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xuICAgICAgICAgICAgaWYgKHRhYmxlQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gY3JlYXRlUm93c0Zyb21QYXN0aW5nVGFibGUodGFibGVDb250ZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRGcm9tQm9keSA9IHRhYmxlQ29udGVudC5maXJzdENoaWxkLnR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keSc7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gY3JlYXRlVGFibGVGcm9tUGFzdGluZ1RhYmxlKHJvd3MsIHNjaGVtYSwgc3RhcnRGcm9tQm9keSwgaXNJblRhYmxlKTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKHRhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZXMpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG52YXIgRFVNTVlfQ0VMTF9TSVpFID0gNDtcbnZhciBUUl9OT0RFU19TSVpFID0gMjtcbmZ1bmN0aW9uIGdldER1bW15Q2VsbFNpemUoZHVtbXlDZWxsQ291bnQpIHtcbiAgICByZXR1cm4gZHVtbXlDZWxsQ291bnQgKiBEVU1NWV9DRUxMX1NJWkU7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXN0aW5nQ2VsbHModGFibGVDb250ZW50LCBjdXJTZWxlY3Rpb25JbmZvLCBzY2hlbWEpIHtcbiAgICB2YXIgcGFzdGluZ1Jvd3MgPSBbXTtcbiAgICB2YXIgcGFzdGluZ1RhYmxlUm93cyA9IGNyZWF0ZVJvd3NGcm9tUGFzdGluZ1RhYmxlKHRhYmxlQ29udGVudCk7XG4gICAgdmFyIGNvbHVtbkNvdW50ID0gcGFzdGluZ1RhYmxlUm93c1swXS5jaGlsZENvdW50O1xuICAgIHZhciByb3dDb3VudCA9IHBhc3RpbmdUYWJsZVJvd3MubGVuZ3RoO1xuICAgIHZhciBzdGFydFRvVGFibGVIZWFkID0gY3VyU2VsZWN0aW9uSW5mby5zdGFydFJvd0lkeCA9PT0gMDtcbiAgICB2YXIgc2xpY2VkUm93cyA9IHBhc3RpbmdUYWJsZVJvd3Muc2xpY2UoMCwgcm93Q291bnQpO1xuICAgIGlmIChzdGFydFRvVGFibGVIZWFkKSB7XG4gICAgICAgIHZhciB0YWJsZUhlYWRSb3cgPSBzbGljZWRSb3dzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0YWJsZUhlYWRSb3cpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gY29weVRhYmxlSGVhZFJvdyh0YWJsZUhlYWRSb3csIGNvbHVtbkNvdW50LCBzY2hlbWEpLmNvbnRlbnQ7XG4gICAgICAgICAgICBwYXN0aW5nUm93cy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlZFJvd3MuZm9yRWFjaChmdW5jdGlvbiAodGFibGVCb2R5Um93KSB7XG4gICAgICAgIGlmICghdGFibGVCb2R5Um93LmF0dHJzLmR1bW15Um93Rm9yUGFzdGluZykge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb3B5VGFibGVCb2R5Um93KHRhYmxlQm9keVJvdywgY29sdW1uQ291bnQsIHNjaGVtYSkuY29udGVudDtcbiAgICAgICAgICAgIHBhc3RpbmdSb3dzLnB1c2goY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFzdGluZ1Jvd3M7XG59XG5mdW5jdGlvbiBnZXRQYXN0aW5nUmFuZ2VJbmZvKG1hcCwgX2EsIHBhc3RpbmdDZWxscykge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4O1xuICAgIHZhciBwYXN0aW5nUm93Q291bnQgPSBwYXN0aW5nQ2VsbHMubGVuZ3RoO1xuICAgIHZhciBwYXN0aW5nQ29sdW1uQ291bnQgPSAwO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gcGFzdGluZ0NlbGxzW2ldLmNoaWxkQ291bnQ7XG4gICAgICAgIHBhc3RpbmdDZWxsc1tpXS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICB2YXIgY29sc3BhbiA9IGF0dHJzLmNvbHNwYW47XG4gICAgICAgICAgICBpZiAoY29sc3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCArPSBjb2xzcGFuIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhc3RpbmdDb2x1bW5Db3VudCA9IE1hdGgubWF4KHBhc3RpbmdDb2x1bW5Db3VudCwgY29sdW1uQ291bnQpO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXN0aW5nUm93Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICB2YXIgZW5kUm93SWR4ID0gc3RhcnRSb3dJZHggKyBwYXN0aW5nUm93Q291bnQgLSAxO1xuICAgIHZhciBlbmRDb2xJZHggPSBzdGFydENvbElkeCArIHBhc3RpbmdDb2x1bW5Db3VudCAtIDE7XG4gICAgdmFyIGFkZGVkUm93Q291bnQgPSBNYXRoLm1heChlbmRSb3dJZHggKyAxIC0gbWFwLnRvdGFsUm93Q291bnQsIDApO1xuICAgIHZhciBhZGRlZENvbHVtbkNvdW50ID0gTWF0aC5tYXgoZW5kQ29sSWR4ICsgMSAtIG1hcC50b3RhbENvbHVtbkNvdW50LCAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFJvd0lkeDogc3RhcnRSb3dJZHgsXG4gICAgICAgIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCxcbiAgICAgICAgZW5kUm93SWR4OiBlbmRSb3dJZHgsXG4gICAgICAgIGVuZENvbElkeDogZW5kQ29sSWR4LFxuICAgICAgICBhZGRlZFJvd0NvdW50OiBhZGRlZFJvd0NvdW50LFxuICAgICAgICBhZGRlZENvbHVtbkNvdW50OiBhZGRlZENvbHVtbkNvdW50LFxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRSZXBsYWNlZE9mZnNldHMoX2EsIGNlbGxzT2Zmc2V0cykge1xuICAgIHZhciBzdGFydFJvd0lkeCA9IF9hLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9hLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYS5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeCwgYWRkZWRSb3dDb3VudCA9IF9hLmFkZGVkUm93Q291bnQsIGFkZGVkQ29sdW1uQ291bnQgPSBfYS5hZGRlZENvbHVtbkNvdW50O1xuICAgIGZvciAodmFyIHJvd0lkeCA9IHN0YXJ0Um93SWR4OyByb3dJZHggPD0gZW5kUm93SWR4IC0gYWRkZWRSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgY2VsbHNPZmZzZXRzLnB1c2goe1xuICAgICAgICAgICAgcm93SWR4OiByb3dJZHgsXG4gICAgICAgICAgICBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsXG4gICAgICAgICAgICBlbmRDb2xJZHg6IGVuZENvbElkeCAtIGFkZGVkQ29sdW1uQ291bnQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4cGFuZENvbHVtbnModHIsIHNjaGVtYSwgbWFwLCBfYSwgY2VsbHNPZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0Um93SWR4ID0gX2Euc3RhcnRSb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHgsIGVuZFJvd0lkeCA9IF9hLmVuZFJvd0lkeCwgZW5kQ29sSWR4ID0gX2EuZW5kQ29sSWR4LCBhZGRlZFJvd0NvdW50ID0gX2EuYWRkZWRSb3dDb3VudCwgYWRkZWRDb2x1bW5Db3VudCA9IF9hLmFkZGVkQ29sdW1uQ291bnQ7XG4gICAgdmFyIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZvciAodmFyIHJvd0lkeCA9IDA7IHJvd0lkeCA8IHRvdGFsUm93Q291bnQ7IHJvd0lkeCArPSAxKSB7XG4gICAgICAgIHZhciBfYiA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGVuZENvbElkeCAtIGFkZGVkQ29sdW1uQ291bnQpLCBvZmZzZXQgPSBfYi5vZmZzZXQsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgICAgIHZhciBpbnNlcnRPZmZzZXQgPSB0ci5tYXBwaW5nLm1hcChvZmZzZXQgKyBub2RlU2l6ZSk7XG4gICAgICAgIHZhciBjZWxscyA9IGNyZWF0ZUR1bW15Q2VsbHMoYWRkZWRDb2x1bW5Db3VudCwgcm93SWR4LCBzY2hlbWEpO1xuICAgICAgICB0ci5pbnNlcnQoaW5zZXJ0T2Zmc2V0LCBjZWxscyk7XG4gICAgICAgIGlmIChyb3dJZHggPj0gc3RhcnRSb3dJZHggJiYgcm93SWR4IDw9IGVuZFJvd0lkeCAtIGFkZGVkUm93Q291bnQpIHtcbiAgICAgICAgICAgIHZhciBjZWxsSW5mbyA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGVuZENvbElkeCAtIGFkZGVkQ29sdW1uQ291bnQpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q2VsbE9mZnNldCA9IHRyLm1hcHBpbmcubWFwKGNlbGxJbmZvLm9mZnNldCk7XG4gICAgICAgICAgICB2YXIgZW5kQ2VsbE9mZnNldCA9IGluc2VydE9mZnNldCArIGdldER1bW15Q2VsbFNpemUoYWRkZWRDb2x1bW5Db3VudCk7XG4gICAgICAgICAgICBjZWxsc09mZnNldHNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgIHJvd0lkeDogcm93SWR4LFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sSWR4OiBzdGFydENvbElkeCxcbiAgICAgICAgICAgICAgICBlbmRDb2xJZHg6IGVuZENvbElkeCxcbiAgICAgICAgICAgICAgICBkdW1teU9mZnNldHM6IFtzdGFydENlbGxPZmZzZXQsIGVuZENlbGxPZmZzZXRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBleHBhbmRSb3dzKHRyLCBzY2hlbWEsIG1hcCwgX2EsIGNlbGxzT2Zmc2V0cykge1xuICAgIHZhciBhZGRlZFJvd0NvdW50ID0gX2EuYWRkZWRSb3dDb3VudCwgYWRkZWRDb2x1bW5Db3VudCA9IF9hLmFkZGVkQ29sdW1uQ291bnQsIHN0YXJ0Q29sSWR4ID0gX2Euc3RhcnRDb2xJZHgsIGVuZENvbElkeCA9IF9hLmVuZENvbElkeDtcbiAgICB2YXIgbWFwU3RhcnQgPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICAgIHZhciB0YWJsZUVuZFBvcyA9IG1hcC50YWJsZUVuZE9mZnNldCAtIDI7XG4gICAgdmFyIHJvd3MgPSBjcmVhdGVUYWJsZUJvZHlSb3dzKGFkZGVkUm93Q291bnQsIG1hcC50b3RhbENvbHVtbkNvdW50ICsgYWRkZWRDb2x1bW5Db3VudCwgc2NoZW1hKTtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0YWJsZUVuZFBvcztcbiAgICB0ci5pbnNlcnQodHIubWFwcGluZy5zbGljZShtYXBTdGFydCkubWFwKHN0YXJ0T2Zmc2V0KSwgcm93cyk7XG4gICAgZm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGFkZGVkUm93Q291bnQ7IHJvd0luZGV4ICs9IDEpIHtcbiAgICAgICAgdmFyIHN0YXJ0Q2VsbE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgZ2V0RHVtbXlDZWxsU2l6ZShzdGFydENvbElkeCkgKyAxO1xuICAgICAgICB2YXIgZW5kQ2VsbE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgZ2V0RHVtbXlDZWxsU2l6ZShlbmRDb2xJZHggKyAxKSArIDE7XG4gICAgICAgIHZhciBuZXh0Q2VsbE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgZ2V0RHVtbXlDZWxsU2l6ZShtYXAudG90YWxDb2x1bW5Db3VudCArIGFkZGVkQ29sdW1uQ291bnQpICsgVFJfTk9ERVNfU0laRTtcbiAgICAgICAgY2VsbHNPZmZzZXRzLnB1c2goe1xuICAgICAgICAgICAgcm93SWR4OiByb3dJbmRleCArIG1hcC50b3RhbFJvd0NvdW50LFxuICAgICAgICAgICAgc3RhcnRDb2xJZHg6IHN0YXJ0Q29sSWR4LFxuICAgICAgICAgICAgZW5kQ29sSWR4OiBlbmRDb2xJZHgsXG4gICAgICAgICAgICBkdW1teU9mZnNldHM6IFtzdGFydENlbGxPZmZzZXQsIGVuZENlbGxPZmZzZXRdLFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBuZXh0Q2VsbE9mZnNldDtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQ2VsbHModHIsIHBhc3RpbmdSb3dzLCBjZWxsc09mZnNldHMsIG1hcCkge1xuICAgIHZhciBtYXBTdGFydCA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gICAgY2VsbHNPZmZzZXRzLmZvckVhY2goZnVuY3Rpb24gKG9mZnNldHMsIGluZGV4KSB7XG4gICAgICAgIHZhciByb3dJZHggPSBvZmZzZXRzLnJvd0lkeCwgc3RhcnRDb2xJZHggPSBvZmZzZXRzLnN0YXJ0Q29sSWR4LCBlbmRDb2xJZHggPSBvZmZzZXRzLmVuZENvbElkeCwgZHVtbXlPZmZzZXRzID0gb2Zmc2V0cy5kdW1teU9mZnNldHM7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBTdGFydCk7XG4gICAgICAgIHZhciBjZWxscyA9IG5ldyBTbGljZShwYXN0aW5nUm93c1tpbmRleF0sIDAsIDApO1xuICAgICAgICB2YXIgZnJvbSA9IGR1bW15T2Zmc2V0cyA/IGR1bW15T2Zmc2V0c1swXSA6IG1hcC5nZXRDZWxsU3RhcnRPZmZzZXQocm93SWR4LCBzdGFydENvbElkeCk7XG4gICAgICAgIHZhciB0byA9IGR1bW15T2Zmc2V0cyA/IGR1bW15T2Zmc2V0c1sxXSA6IG1hcC5nZXRDZWxsRW5kT2Zmc2V0KHJvd0lkeCwgZW5kQ29sSWR4KTtcbiAgICAgICAgdHIucmVwbGFjZShtYXBwaW5nLm1hcChmcm9tKSwgbWFwcGluZy5tYXAodG8pLCBjZWxscyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXN0ZVRvVGFibGUodmlldywgc2xpY2UpIHtcbiAgICB2YXIgX2EgPSB2aWV3LnN0YXRlLCBzZWxlY3Rpb24gPSBfYS5zZWxlY3Rpb24sIHNjaGVtYSA9IF9hLnNjaGVtYSwgdHIgPSBfYS50cjtcbiAgICB2YXIgX2IgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYi5hbmNob3IsIGhlYWQgPSBfYi5oZWFkO1xuICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICB2YXIgdGFibGVDb250ZW50ID0gZ2V0VGFibGVDb250ZW50RnJvbVNsaWNlKHNsaWNlKTtcbiAgICAgICAgaWYgKCF0YWJsZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgIHZhciBjdXJTZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIHZhciBwYXN0aW5nQ2VsbHMgPSBjcmVhdGVQYXN0aW5nQ2VsbHModGFibGVDb250ZW50LCBjdXJTZWxlY3Rpb25JbmZvLCBzY2hlbWEpO1xuICAgICAgICB2YXIgcGFzdGluZ0luZm8gPSBnZXRQYXN0aW5nUmFuZ2VJbmZvKG1hcCwgY3VyU2VsZWN0aW9uSW5mbywgcGFzdGluZ0NlbGxzKTtcbiAgICAgICAgdmFyIGNlbGxzT2Zmc2V0cyA9IFtdO1xuICAgICAgICAvLyBAVE9ETzogdW5tZXJnZSB0aGUgc3BhbiBhbmQgcGFzdGUgdGhlIGNlbGxcbiAgICAgICAgaWYgKGNhbk1lcmdlKG1hcCwgcGFzdGluZ0luZm8pKSB7XG4gICAgICAgICAgICBhZGRSZXBsYWNlZE9mZnNldHMocGFzdGluZ0luZm8sIGNlbGxzT2Zmc2V0cyk7XG4gICAgICAgICAgICBpZiAocGFzdGluZ0luZm8uYWRkZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZENvbHVtbnModHIsIHNjaGVtYSwgbWFwLCBwYXN0aW5nSW5mbywgY2VsbHNPZmZzZXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXN0aW5nSW5mby5hZGRlZFJvd0NvdW50KSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kUm93cyh0ciwgc2NoZW1hLCBtYXAsIHBhc3RpbmdJbmZvLCBjZWxsc09mZnNldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZUNlbGxzKHRyLCBwYXN0aW5nQ2VsbHMsIGNlbGxzT2Zmc2V0cywgbWFwKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uKHZpZXcsIGNlbGxzT2Zmc2V0cywgbWFwLmdldENlbGxJbmZvKDAsIDApLm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbih2aWV3LCBjZWxsc09mZnNldHMsIHBvcykge1xuICAgIHZhciBfYSA9IHZpZXcuc3RhdGUsIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYztcbiAgICAvLyBnZXQgY2hhbmdlZCBjZWxsIG9mZnNldHNcbiAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGRvYy5yZXNvbHZlKHBvcykpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIHZhciBfYiA9IGNlbGxzT2Zmc2V0c1swXSwgc3RhcnRSb3dJZHggPSBfYi5yb3dJZHgsIHN0YXJ0Q29sSWR4ID0gX2Iuc3RhcnRDb2xJZHg7XG4gICAgdmFyIF9jID0gbGFzdCQxKGNlbGxzT2Zmc2V0cyksIGVuZFJvd0lkeCA9IF9jLnJvd0lkeCwgZW5kQ29sSWR4ID0gX2MuZW5kQ29sSWR4O1xuICAgIHZhciBzdGFydE9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhzdGFydFJvd0lkeCwgc3RhcnRDb2xJZHgpLm9mZnNldDtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKGVuZFJvd0lkeCwgZW5kQ29sSWR4KS5vZmZzZXQ7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24obmV3IENlbGxTZWxlY3Rpb24oZG9jLnJlc29sdmUoc3RhcnRPZmZzZXQpLCBkb2MucmVzb2x2ZShlbmRPZmZzZXQpKSkpO1xufVxuZnVuY3Rpb24gY2FuTWVyZ2UobWFwLCBwYXN0aW5nSW5mbykge1xuICAgIHZhciByYW5nZXMgPSBtYXAuZ2V0U3Bhbm5lZE9mZnNldHMocGFzdGluZ0luZm8pO1xuICAgIHZhciBfYSA9IGdldFJvd0FuZENvbHVtbkNvdW50KHJhbmdlcyksIHJvd0NvdW50ID0gX2Eucm93Q291bnQsIGNvbHVtbkNvdW50ID0gX2EuY29sdW1uQ291bnQ7XG4gICAgdmFyIF9iID0gZ2V0Um93QW5kQ29sdW1uQ291bnQocGFzdGluZ0luZm8pLCBwYXN0aW5nUm93Q291bnQgPSBfYi5yb3dDb3VudCwgcGFzdGluZ0NvbHVtbkNvdW50ID0gX2IuY29sdW1uQ291bnQ7XG4gICAgcmV0dXJuIHJvd0NvdW50ID09PSBwYXN0aW5nUm93Q291bnQgJiYgY29sdW1uQ291bnQgPT09IHBhc3RpbmdDb2x1bW5Db3VudDtcbn1cblxudmFyIERvYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShEb2MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9jKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2MucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2MucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnYmxvY2srJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRG9jO1xufShOb2RlJDIpKTtcblxudmFyIFBhcmFncmFwaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShQYXJhZ3JhcGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFyYWdyYXBoKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhZ3JhcGgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAncGFyYWdyYXBoJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhZ3JhcGgucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoe30sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW3sgdGFnOiAncCcgfV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsncCcsIGdldEN1c3RvbUF0dHJzKGF0dHJzKSwgMF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUGFyYWdyYXBoO1xufShOb2RlJDIpKTtcblxudmFyIHJlU29mdFRhYkxlbiA9IC9cXHN7MSw0fSQvO1xudmFyIFRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RleHQnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleHQucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBncm91cDogJ2lubGluZScsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGV4dC5wcm90b3R5cGUuYWRkU3BhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbiwgdHIgPSBfYS50cjtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbSwgJHRvID0gc2VsZWN0aW9uLiR0bztcbiAgICAgICAgICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAhaXNJbkxpc3ROb2RlKCRmcm9tKSAmJiAhaXNJblRhYmxlTm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5pbnNlcnRUZXh0KCcgICAgJywgJGZyb20ucG9zLCAkdG8ucG9zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5yZW1vdmVTcGFjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX2EsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2Euc2VsZWN0aW9uLCB0ciA9IF9hLnRyO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tLCAkdG8gPSBzZWxlY3Rpb24uJHRvLCBmcm9tID0gc2VsZWN0aW9uLmZyb207XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgIWlzSW5MaXN0Tm9kZSgkZnJvbSkgJiYgIWlzSW5UYWJsZU5vZGUoJGZyb20pKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSAkZnJvbS5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlQmVmb3JlICYmIG5vZGVCZWZvcmUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZUJlZm9yZS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZFNwYWNlVGV4dCA9IHRleHQucmVwbGFjZShyZVNvZnRUYWJMZW4sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYWNlcyA9IHRleHQubGVuZ3RoIC0gcmVtb3ZlZFNwYWNlVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLmRlbGV0ZShmcm9tIC0gc3BhY2VzLCBmcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRleHQucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUYWI6IHRoaXMuYWRkU3BhY2VzKCksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogdGhpcy5yZW1vdmVTcGFjZXMoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0O1xufShOb2RlJDIpKTtcblxudmFyIEhlYWRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSGVhZGluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkaW5nLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2hlYWRpbmcnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhlYWRpbmcucHJvdG90eXBlLCBcImxldmVsc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsxLCAyLCAzLCA0LCA1LCA2XTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkaW5nLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZURPTSA9IHRoaXMubGV2ZWxzLm1hcChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IFwiaFwiICsgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgbGV2ZWw6IGxldmVsIH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGxldmVsOiB7IGRlZmF1bHQ6IDEgfSwgaGVhZGluZ1R5cGU6IHsgZGVmYXVsdDogJ2F0eCcgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbmxpbmUqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogcGFyc2VET00sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImhcIiArIGF0dHJzLmxldmVsLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSGVhZGluZy5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gc3RhdGUuc2NoZW1hLm5vZGVzW3BheWxvYWQubGV2ZWwgPyAnaGVhZGluZycgOiAncGFyYWdyYXBoJ107XG4gICAgICAgICAgICByZXR1cm4gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBwYXlsb2FkKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgcmV0dXJuIEhlYWRpbmc7XG59KE5vZGUkMikpO1xuXG52YXIgQ29kZUJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKENvZGVCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGVCbG9jay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb2RlQmxvY2snO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGVCbG9jay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyBsYW5ndWFnZTogeyBkZWZhdWx0OiBudWxsIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBjb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1hcmtzOiAnJyxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdwcmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGRvbS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IGxhbmd1YWdlOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmdldEF0dHJpYnV0ZSgnZGF0YS1sYW5ndWFnZScpKSB8fCBudWxsIH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ3ByZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ2NvZGUnLCBfX2Fzc2lnbiQxKHsgJ2RhdGEtbGFuZ3VhZ2UnOiBhdHRycy5sYW5ndWFnZSB9LCBnZXRDdXN0b21BdHRycyhhdHRycykpLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiBzZXRCbG9ja1R5cGUoc3RhdGUuc2NoZW1hLm5vZGVzLmNvZGVCbG9jaykoc3RhdGUsIGRpc3BhdGNoKTsgfTsgfTtcbiAgICB9O1xuICAgIENvZGVCbG9jay5wcm90b3R5cGUubW92ZUN1cnNvciA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IHN0YXRlLnRyLCBkb2MgPSBzdGF0ZS5kb2MsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gX3RoaXMuY29udGV4dC52aWV3O1xuICAgICAgICAgICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyZWN0aW9uKSAmJiAkZnJvbS5ub2RlKCkudHlwZS5uYW1lID09PSAnY29kZUJsb2NrJykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/ICRmcm9tLnN0YXJ0KCkgOiAkZnJvbS5lbmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBkaXJlY3Rpb24gPT09ICd1cCdcbiAgICAgICAgICAgICAgICAgICAgPyBbb2Zmc2V0LCBsaW5lc1swXS5sZW5ndGggKyBvZmZzZXRdXG4gICAgICAgICAgICAgICAgICAgIDogW29mZnNldCAtIGxhc3QkMShsaW5lcykubGVuZ3RoLCBvZmZzZXRdO1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBkb2MucmVzb2x2ZShkaXJlY3Rpb24gPT09ICd1cCcgPyAkZnJvbS5iZWZvcmUoKSA6ICRmcm9tLmFmdGVyKCkpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZGlyZWN0aW9uID09PSAndXAnID8gcG9zLm5vZGVCZWZvcmUgOiBwb3Mubm9kZUFmdGVyO1xuICAgICAgICAgICAgICAgIGlmIChiZXR3ZWVuJDEoJGZyb20ucG9zLCByYW5nZVswXSwgcmFuZ2VbMV0pICYmICFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdUciA9IGFkZFBhcmFncmFwaCh0ciwgcG9zLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5ld1RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29kZUJsb2NrLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtcCc6IGNvZGVDb21tYW5kLFxuICAgICAgICAgICAgJ1NoaWZ0LU1vZC1QJzogY29kZUNvbW1hbmQsXG4gICAgICAgICAgICBBcnJvd1VwOiB0aGlzLm1vdmVDdXJzb3IoJ3VwJyksXG4gICAgICAgICAgICBBcnJvd0Rvd246IHRoaXMubW92ZUN1cnNvcignZG93bicpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVCbG9jaztcbn0oTm9kZSQyKSk7XG5cbnZhciBCdWxsZXRMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEJ1bGxldExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnVsbGV0TGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVsbGV0TGlzdC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdidWxsZXRMaXN0JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWxsZXRMaXN0LnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ2xpc3RJdGVtKycsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCgndWwnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndWwnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQnVsbGV0TGlzdC5wcm90b3R5cGUuY2hhbmdlTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIGNoYW5nZUxpc3Qoc3RhdGUuc2NoZW1hLm5vZGVzLmJ1bGxldExpc3QpKHN0YXRlLCBkaXNwYXRjaCk7IH07XG4gICAgfTtcbiAgICBCdWxsZXRMaXN0LnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJ1bGxldExpc3Q6IHRoaXMuY2hhbmdlTGlzdCxcbiAgICAgICAgICAgIHRhc2tMaXN0OiB0b2dnbGVUYXNrLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQnVsbGV0TGlzdC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1bGxldExpc3RDb21tYW5kID0gdGhpcy5jaGFuZ2VMaXN0KCk7XG4gICAgICAgIHZhciBfYSA9IGdldFd3Q29tbWFuZHMoKSwgaW5kZW50ID0gX2EuaW5kZW50LCBvdXRkZW50ID0gX2Eub3V0ZGVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtdSc6IGJ1bGxldExpc3RDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1VJzogYnVsbGV0TGlzdENvbW1hbmQsXG4gICAgICAgICAgICBUYWI6IGluZGVudCgpLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IG91dGRlbnQoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBCdWxsZXRMaXN0O1xufShOb2RlJDIpKTtcblxudmFyIE9yZGVyZWRMaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKE9yZGVyZWRMaXN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9yZGVyZWRMaXN0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcmRlcmVkTGlzdC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdvcmRlcmVkTGlzdCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3JkZXJlZExpc3QucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnbGlzdEl0ZW0rJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IG9yZGVyOiB7IGRlZmF1bHQ6IDEgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ29sJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gZG9tLmdldEF0dHJpYnV0ZSgnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IG9yZGVyOiBkb20uaGFzQXR0cmlidXRlKCdzdGFydCcpID8gTnVtYmVyKHN0YXJ0KSA6IDEgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMucmF3SFRNTCB8fCAnb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24kMSh7IHN0YXJ0OiBhdHRycy5vcmRlciA9PT0gMSA/IG51bGwgOiBhdHRycy5vcmRlciB9LCBnZXRDdXN0b21BdHRycyhhdHRycykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9yZGVyZWRMaXN0LnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIGNoYW5nZUxpc3Qoc3RhdGUuc2NoZW1hLm5vZGVzLm9yZGVyZWRMaXN0KShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgT3JkZXJlZExpc3QucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcmRlcmVkTGlzdENvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0V3dDb21tYW5kcygpLCBpbmRlbnQgPSBfYS5pbmRlbnQsIG91dGRlbnQgPSBfYS5vdXRkZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1vJzogb3JkZXJlZExpc3RDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1PJzogb3JkZXJlZExpc3RDb21tYW5kLFxuICAgICAgICAgICAgVGFiOiBpbmRlbnQoKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiBvdXRkZW50KCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gT3JkZXJlZExpc3Q7XG59KE5vZGUkMikpO1xuXG52YXIgTGlzdEl0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGlzdEl0ZW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGlzdEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpc3RJdGVtLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpc3RJdGVtJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXN0SXRlbS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICB0YXNrOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdsaScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgdGFzazogZG9tLmhhc0F0dHJpYnV0ZSgnZGF0YS10YXNrJyksIGNoZWNrZWQ6IGRvbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdGFzay1jaGVja2VkJykgfSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IGF0dHJzLnRhc2ssIGNoZWNrZWQgPSBhdHRycy5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0cnMucmF3SFRNTCB8fCAnbGknLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFsndGFzay1saXN0LWl0ZW0nXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5yYXdIVE1MIHx8ICdsaScsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2Fzc2lnbiQxKHsgY2xhc3M6IGNsYXNzTmFtZXMuam9pbignICcpLCAnZGF0YS10YXNrJzogdGFzayB9LCAoY2hlY2tlZCAmJiB7ICdkYXRhLXRhc2stY2hlY2tlZCc6IGNoZWNrZWQgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExpc3RJdGVtLnByb3RvdHlwZS5saWZ0VG9QcmV2TGlzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb20sIGVtcHR5ID0gc2VsZWN0aW9uLmVtcHR5O1xuICAgICAgICAgICAgdmFyIGxpc3RJdGVtID0gc2NoZW1hLm5vZGVzLmxpc3RJdGVtO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9ICRmcm9tLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBsaXN0SXRlbVBhcmVudCA9ICRmcm9tLm5vZGUoLTEpO1xuICAgICAgICAgICAgaWYgKGVtcHR5ICYmICFwYXJlbnQuY2hpbGRDb3VudCAmJiBsaXN0SXRlbVBhcmVudC50eXBlID09PSBsaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgdG8gcHJldmlvdXMgc2libGluZyBsaXN0IGl0ZW0gd2hlbiB0aGUgY3VycmVudCBsaXN0IGl0ZW0gaXMgbm90IHRvcCBsaXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoJGZyb20uaW5kZXgoLTIpID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHN1YnRyYWN0ICcxJyBmb3IgY29uc2lkZXJpbmcgdGFnIGxlbmd0aCg8bGk+KVxuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoJGZyb20uc3RhcnQoLTEpIC0gMSwgJGZyb20uZW5kKC0xKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBncmFuZFBhcmVudExpc3RJdGVtID0gJGZyb20ubm9kZSgtMyk7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0byBwYXJlbnQgbGlzdCBpdGVtIHdoZW4gdGhlIGN1cnJlbnQgbGlzdCBpdGVtIGlzIHRvcCBsaXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnRMaXN0SXRlbS50eXBlID09PSBsaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgc3VidHJhY3QgJzEnIGZvciBjb25zaWRlcmluZyB0YWcgbGVuZ3RoKDx1bD4pXG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSgkZnJvbS5zdGFydCgtMikgLSAxLCAkZnJvbS5lbmQoLTEpKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBMaXN0SXRlbS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0TGlzdEl0ZW0oc3RhdGUuc2NoZW1hLm5vZGVzLmxpc3RJdGVtKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQmFja3NwYWNlOiB0aGlzLmxpZnRUb1ByZXZMaXN0SXRlbSgpLFxuICAgICAgICAgICAgRW50ZXI6IHNwbGl0LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpc3RJdGVtO1xufShOb2RlJDIpKTtcblxudmFyIEJsb2NrUXVvdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQmxvY2tRdW90ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja1F1b3RlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCbG9ja1F1b3RlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Jsb2NrUXVvdGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2NrUXVvdGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnYmxvY2srJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW2NyZWF0ZURPTUluZm9QYXJzZWRSYXdIVE1MKCdibG9ja3F1b3RlJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2Jsb2NrcXVvdGUnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQmxvY2tRdW90ZS5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7IHJldHVybiB3cmFwSW4oc3RhdGUuc2NoZW1hLm5vZGVzLmJsb2NrUXVvdGUpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBCbG9ja1F1b3RlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmxvY2tRdXRvZUNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdBbHQtcSc6IGJsb2NrUXV0b2VDb21tYW5kLFxuICAgICAgICAgICAgJ0FsdC1RJzogYmxvY2tRdXRvZUNvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tRdW90ZTtcbn0oTm9kZSQyKSk7XG5cbnZhciBjZWxsT2Zmc2V0Rm5NYXAgPSB7XG4gICAgbGVmdDogZ2V0TGVmdENlbGxPZmZzZXQsXG4gICAgcmlnaHQ6IGdldFJpZ2h0Q2VsbE9mZnNldCxcbiAgICB1cDogZ2V0VXBDZWxsT2Zmc2V0LFxuICAgIGRvd246IGdldERvd25DZWxsT2Zmc2V0LFxufTtcbmZ1bmN0aW9uIGlzSW5GaXJzdExpc3RJdGVtKHBvcywgZG9jLCBfYSkge1xuICAgIHZhciBwYXJhRGVwdGggPSBfYVswXSwgbGlzdERlcHRoID0gX2FbMV07XG4gICAgdmFyIGxpc3RJdGVtTm9kZSA9IGRvYy5yZXNvbHZlKHBvcy5iZWZvcmUocGFyYURlcHRoIC0gMSkpO1xuICAgIHJldHVybiBsaXN0RGVwdGggPT09IHBhcmFEZXB0aCAmJiAhbGlzdEl0ZW1Ob2RlLm5vZGVCZWZvcmU7XG59XG5mdW5jdGlvbiBpc0luTGFzdExpc3RJdGVtKHBvcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZGVwdGggPSBwb3MuZGVwdGg7XG4gICAgdmFyIHBhcmVudE5vZGU7XG4gICAgd2hpbGUgKGRlcHRoKSB7XG4gICAgICAgIHBhcmVudE5vZGUgPSBwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChwYXJlbnROb2RlLnR5cGUubmFtZSA9PT0gJ3RhYmxlQm9keUNlbGwnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Tm9kZS50eXBlLm5hbWUgPT09ICdsaXN0SXRlbScpIHtcbiAgICAgICAgICAgIHZhciBncmFuZFBhcmVudCA9IHBvcy5ub2RlKGRlcHRoIC0gMSk7XG4gICAgICAgICAgICB2YXIgbGFzdExpc3RJdGVtID0gZ3JhbmRQYXJlbnQubGFzdENoaWxkID09PSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgdmFyIGhhc0NoaWxkcmVuID0gKChfYSA9IHBhcmVudE5vZGUubGFzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZS5uYW1lKSAhPT0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICBpZiAoIWxhc3RMaXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaGFzQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FuTW92ZVRvQmVmb3JlQ2VsbChkaXJlY3Rpb24sIF9hLCBmcm9tLCBkb2MsIGluTGlzdCkge1xuICAgIHZhciBwYXJhRGVwdGggPSBfYVswXSwgbGlzdERlcHRoID0gX2FbMV0sIGN1ckRlcHRoID0gX2FbMl07XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgLyogTEVGVCAqLyB8fCBkaXJlY3Rpb24gPT09IFwidXBcIiAvKiBVUCAqLykge1xuICAgICAgICBpZiAoaW5MaXN0ICYmICFpc0luRmlyc3RMaXN0SXRlbShmcm9tLCBkb2MsIFtwYXJhRGVwdGgsIGxpc3REZXB0aF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGZyb20uYmVmb3JlKGN1ckRlcHRoKTtcbiAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSBkb2MucmVzb2x2ZShlbmRPZmZzZXQpLm5vZGVCZWZvcmU7XG4gICAgICAgIGlmIChub2RlQmVmb3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5Nb3ZlVG9BZnRlckNlbGwoZGlyZWN0aW9uLCBjdXJEZXB0aCwgZnJvbSwgZG9jLCBpbkxpc3QpIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInJpZ2h0XCIgLyogUklHSFQgKi8gfHwgZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovKSB7XG4gICAgICAgIGlmIChpbkxpc3QgJiYgIWlzSW5MYXN0TGlzdEl0ZW0oZnJvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZnJvbS5hZnRlcihjdXJEZXB0aCk7XG4gICAgICAgIHZhciBub2RlQWZ0ZXIgPSBkb2MucmVzb2x2ZShlbmRPZmZzZXQpLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGVBZnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY2FuTW92ZUJldHdlZW5DZWxscyhkaXJlY3Rpb24sIF9hLCBmcm9tLCBkb2MpIHtcbiAgICB2YXIgY2VsbERlcHRoID0gX2FbMF0sIHBhcmFEZXB0aCA9IF9hWzFdO1xuICAgIHZhciBsaXN0RGVwdGggPSBjZWxsRGVwdGggKyAzOyAvLyAzIGlzIHBvc2l0aW9uIG9mIDx1bD48bGk+PHA+XG4gICAgdmFyIGluTGlzdCA9IHBhcmFEZXB0aCA+PSBsaXN0RGVwdGg7XG4gICAgdmFyIGN1ckRlcHRoID0gaW5MaXN0ID8gY2VsbERlcHRoICsgMSA6IHBhcmFEZXB0aDtcbiAgICB2YXIgbW92ZUJlZm9yZUNlbGwgPSBjYW5Nb3ZlVG9CZWZvcmVDZWxsKGRpcmVjdGlvbiwgW3BhcmFEZXB0aCwgbGlzdERlcHRoLCBjdXJEZXB0aF0sIGZyb20sIGRvYywgaW5MaXN0KTtcbiAgICB2YXIgbW92ZUFmdGVyQ2VsbCA9IGNhbk1vdmVUb0FmdGVyQ2VsbChkaXJlY3Rpb24sIGN1ckRlcHRoLCBmcm9tLCBkb2MsIGluTGlzdCk7XG4gICAgcmV0dXJuIG1vdmVCZWZvcmVDZWxsICYmIG1vdmVBZnRlckNlbGw7XG59XG5mdW5jdGlvbiBjYW5CZU91dE9mVGFibGUoZGlyZWN0aW9uLCBtYXAsIF9hKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICB2YXIgcm93c3BhbkluZm8gPSBtYXAuZ2V0Um93c3BhblN0YXJ0SW5mbyhyb3dJZHgsIGNvbElkeCk7XG4gICAgdmFyIGluRmlyc3RSb3cgPSBkaXJlY3Rpb24gPT09IFwidXBcIiAvKiBVUCAqLyAmJiByb3dJZHggPT09IDA7XG4gICAgdmFyIGluTGFzdFJvdyA9IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgLyogRE9XTiAqLyAmJlxuICAgICAgICAoKHJvd3NwYW5JbmZvID09PSBudWxsIHx8IHJvd3NwYW5JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb3dzcGFuSW5mby5jb3VudCkgPiAxID8gcm93SWR4ICsgcm93c3BhbkluZm8uY291bnQgLSAxIDogcm93SWR4KSA9PT0gbWFwLnRvdGFsUm93Q291bnQgLSAxO1xuICAgIHJldHVybiBpbkZpcnN0Um93IHx8IGluTGFzdFJvdztcbn1cbmZ1bmN0aW9uIGFkZFBhcmFncmFwaEJlZm9yZVRhYmxlKHRyLCBtYXAsIHNjaGVtYSkge1xuICAgIHZhciB0YWJsZVN0YXJ0UG9zID0gdHIuZG9jLnJlc29sdmUobWFwLnRhYmxlU3RhcnRPZmZzZXQgLSAxKTtcbiAgICBpZiAoIXRhYmxlU3RhcnRQb3Mubm9kZUJlZm9yZSkge1xuICAgICAgICByZXR1cm4gYWRkUGFyYWdyYXBoKHRyLCB0YWJsZVN0YXJ0UG9zLCBzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRhYmxlU3RhcnRQb3MsIC0xKSk7XG59XG5mdW5jdGlvbiBhZGRQYXJhZ3JhcGhBZnRlclRhYmxlKHRyLCBtYXAsIHNjaGVtYSwgZm9yY2VkQWRkdGlvbikge1xuICAgIGlmIChmb3JjZWRBZGR0aW9uID09PSB2b2lkIDApIHsgZm9yY2VkQWRkdGlvbiA9IGZhbHNlOyB9XG4gICAgdmFyIHRhYmxlRW5kUG9zID0gdHIuZG9jLnJlc29sdmUobWFwLnRhYmxlRW5kT2Zmc2V0KTtcbiAgICBpZiAoZm9yY2VkQWRkdGlvbiB8fCAhdGFibGVFbmRQb3Mubm9kZUFmdGVyKSB7XG4gICAgICAgIHJldHVybiBhZGRQYXJhZ3JhcGgodHIsIHRhYmxlRW5kUG9zLCBzY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRhYmxlRW5kUG9zLCAxKSk7XG59XG5mdW5jdGlvbiBnZXRSaWdodENlbGxPZmZzZXQoX2EsIG1hcCkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgdmFyIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudCwgdG90YWxDb2x1bW5Db3VudCA9IG1hcC50b3RhbENvbHVtbkNvdW50O1xuICAgIHZhciBsYXN0Q2VsbEluUm93ID0gY29sSWR4ID09PSB0b3RhbENvbHVtbkNvdW50IC0gMTtcbiAgICB2YXIgbGFzdENlbGxJblRhYmxlID0gcm93SWR4ID09PSB0b3RhbFJvd0NvdW50IC0gMSAmJiBsYXN0Q2VsbEluUm93O1xuICAgIGlmICghbGFzdENlbGxJblRhYmxlKSB7XG4gICAgICAgIHZhciBuZXh0Q29sSWR4ID0gY29sSWR4ICsgMTtcbiAgICAgICAgdmFyIGNvbHNwYW5JbmZvID0gbWFwLmdldENvbHNwYW5TdGFydEluZm8ocm93SWR4LCBjb2xJZHgpO1xuICAgICAgICBpZiAoKGNvbHNwYW5JbmZvID09PSBudWxsIHx8IGNvbHNwYW5JbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xzcGFuSW5mby5jb3VudCkgPiAxKSB7XG4gICAgICAgICAgICBuZXh0Q29sSWR4ICs9IGNvbHNwYW5JbmZvLmNvdW50IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdENlbGxJblJvdyB8fCBuZXh0Q29sSWR4ID09PSB0b3RhbENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICByb3dJZHggKz0gMTtcbiAgICAgICAgICAgIG5leHRDb2xJZHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSBtYXAuZ2V0Q2VsbEluZm8ocm93SWR4LCBuZXh0Q29sSWR4KS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExlZnRDZWxsT2Zmc2V0KF9hLCBtYXApIHtcbiAgICB2YXIgcm93SWR4ID0gX2FbMF0sIGNvbElkeCA9IF9hWzFdO1xuICAgIHZhciB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQ7XG4gICAgdmFyIGZpcnN0Q2VsbEluUm93ID0gY29sSWR4ID09PSAwO1xuICAgIHZhciBmaXJzdENlbGxJblRhYmxlID0gcm93SWR4ID09PSAwICYmIGZpcnN0Q2VsbEluUm93O1xuICAgIGlmICghZmlyc3RDZWxsSW5UYWJsZSkge1xuICAgICAgICBjb2xJZHggLT0gMTtcbiAgICAgICAgaWYgKGZpcnN0Q2VsbEluUm93KSB7XG4gICAgICAgICAgICByb3dJZHggLT0gMTtcbiAgICAgICAgICAgIGNvbElkeCA9IHRvdGFsQ29sdW1uQ291bnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYiA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGNvbElkeCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIG5vZGVTaXplIC0gMjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRVcENlbGxPZmZzZXQoX2EsIG1hcCkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgaWYgKHJvd0lkeCA+IDApIHtcbiAgICAgICAgdmFyIF9iID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCAtIDEsIGNvbElkeCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIG5vZGVTaXplIC0gMjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXREb3duQ2VsbE9mZnNldChfYSwgbWFwKSB7XG4gICAgdmFyIHJvd0lkeCA9IF9hWzBdLCBjb2xJZHggPSBfYVsxXTtcbiAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgIGlmIChyb3dJZHggPCB0b3RhbFJvd0NvdW50IC0gMSkge1xuICAgICAgICB2YXIgbmV4dFJvd0lkeCA9IHJvd0lkeCArIDE7XG4gICAgICAgIHZhciByb3dzcGFuSW5mbyA9IG1hcC5nZXRSb3dzcGFuU3RhcnRJbmZvKHJvd0lkeCwgY29sSWR4KTtcbiAgICAgICAgaWYgKChyb3dzcGFuSW5mbyA9PT0gbnVsbCB8fCByb3dzcGFuSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm93c3BhbkluZm8uY291bnQpID4gMSkge1xuICAgICAgICAgICAgbmV4dFJvd0lkeCArPSByb3dzcGFuSW5mby5jb3VudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IG1hcC5nZXRDZWxsSW5mbyhuZXh0Um93SWR4LCBjb2xJZHgpLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIDI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbW92ZVRvQ2VsbChkaXJlY3Rpb24sIHRyLCBjZWxsSW5kZXgsIG1hcCkge1xuICAgIHZhciBjZWxsT2Zmc2V0Rm4gPSBjZWxsT2Zmc2V0Rm5NYXBbZGlyZWN0aW9uXTtcbiAgICB2YXIgb2Zmc2V0ID0gY2VsbE9mZnNldEZuKGNlbGxJbmRleCwgbWFwKTtcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBkaXIgPSBkaXJlY3Rpb24gPT09IFwicmlnaHRcIiAvKiBSSUdIVCAqLyB8fCBkaXJlY3Rpb24gPT09IFwiZG93blwiIC8qIERPV04gKi8gPyAxIDogLTE7XG4gICAgICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUob2Zmc2V0KSwgZGlyKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2FuU2VsZWN0VGFibGVOb2RlKGRpcmVjdGlvbiwgbWFwLCBfYSkge1xuICAgIHZhciByb3dJZHggPSBfYVswXSwgY29sSWR4ID0gX2FbMV07XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovIHx8IGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgLyogRE9XTiAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB0YWJsZVN0YXJ0T2Zmc2V0ID0gbWFwLnRhYmxlU3RhcnRPZmZzZXQsIHRhYmxlRW5kT2Zmc2V0ID0gbWFwLnRhYmxlRW5kT2Zmc2V0O1xuICAgIHZhciBfYiA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGNvbElkeCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICB2YXIgcG9zID0gZGlyZWN0aW9uID09PSBcImxlZnRcIiAvKiBMRUZUICovID8gdGFibGVTdGFydE9mZnNldCA6IHRhYmxlRW5kT2Zmc2V0O1xuICAgIHZhciBjdXJQb3MgPSBkaXJlY3Rpb24gPT09IFwibGVmdFwiIC8qIExFRlQgKi8gPyBvZmZzZXQgLSAyIDogb2Zmc2V0ICsgbm9kZVNpemUgKyAzO1xuICAgIHJldHVybiBwb3MgPT09IGN1clBvcztcbn1cbmZ1bmN0aW9uIHNlbGVjdE5vZGUodHIsIHBvcywgZGVwdGgpIHtcbiAgICB2YXIgdGFibGVQb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MuYmVmb3JlKGRlcHRoIC0gMykpO1xuICAgIHJldHVybiB0ci5zZXRTZWxlY3Rpb24obmV3IE5vZGVTZWxlY3Rpb24odGFibGVQb3MpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0Um93SW5mbyhkaXJlY3Rpb24sIG1hcCwgc2VsZWN0aW9uSW5mbykge1xuICAgIHZhciB0YXJnZXRSb3dJZHg7XG4gICAgdmFyIGluc2VydENvbElkeDtcbiAgICB2YXIgbm9kZVNpemU7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovKSB7XG4gICAgICAgIHRhcmdldFJvd0lkeCA9IHNlbGVjdGlvbkluZm8uc3RhcnRSb3dJZHg7XG4gICAgICAgIGluc2VydENvbElkeCA9IDA7XG4gICAgICAgIG5vZGVTaXplID0gLTE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLmVuZFJvd0lkeDtcbiAgICAgICAgaW5zZXJ0Q29sSWR4ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQgLSAxO1xuICAgICAgICBub2RlU2l6ZSA9IG1hcC5nZXRDZWxsSW5mbyh0YXJnZXRSb3dJZHgsIGluc2VydENvbElkeCkubm9kZVNpemUgKyAxO1xuICAgIH1cbiAgICByZXR1cm4geyB0YXJnZXRSb3dJZHg6IHRhcmdldFJvd0lkeCwgaW5zZXJ0Q29sSWR4OiBpbnNlcnRDb2xJZHgsIG5vZGVTaXplOiBub2RlU2l6ZSB9O1xufVxuZnVuY3Rpb24gZ2V0Um93UmFuZ2VzKG1hcCwgcm93SWR4LCB0b3RhbENvbHVtbkNvdW50KSB7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0ID0gbWFwLmdldENlbGxJbmZvKHJvd0lkeCwgMCkub2Zmc2V0O1xuICAgIHZhciBfYSA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIHRvdGFsQ29sdW1uQ291bnQgLSAxKSwgb2Zmc2V0ID0gX2Eub2Zmc2V0LCBub2RlU2l6ZSA9IF9hLm5vZGVTaXplO1xuICAgIHJldHVybiB7IGZyb206IHN0YXJ0T2Zmc2V0LCB0bzogb2Zmc2V0ICsgbm9kZVNpemUgfTtcbn1cbnZhciBUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RhYmxlSGVhZHsxfSB0YWJsZUJvZHl7MX0nLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwoJ3RhYmxlJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3RhYmxlJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZCA9PT0gdm9pZCAwKSB7IHBheWxvYWQgPSB7IHJvd0NvdW50OiAyLCBjb2x1bW5Db3VudDogMSwgZGF0YTogW10gfTsgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93Q291bnQgPSBwYXlsb2FkLnJvd0NvdW50LCBjb2x1bW5Db3VudCA9IHBheWxvYWQuY29sdW1uQ291bnQsIGRhdGEgPSBwYXlsb2FkLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYSwgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gc2VsZWN0aW9uLmZyb20sIHRvID0gc2VsZWN0aW9uLnRvLCAkZnJvbSA9IHNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgICAgICB2YXIgY29sbGFwc2VkID0gZnJvbSA9PT0gdG87XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxhcHNlZCAmJiAhaXNJblRhYmxlTm9kZSgkZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gc2NoZW1hLm5vZGVzLCB0YWJsZUhlYWQgPSBfYS50YWJsZUhlYWQsIHRhYmxlQm9keSA9IF9hLnRhYmxlQm9keTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZWFkRGF0YSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5zbGljZSgwLCBjb2x1bW5Db3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0Ym9keURhdGEgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuc2xpY2UoY29sdW1uQ291bnQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlSGVhZFJvdyA9IGNyZWF0ZVRhYmxlSGVhZFJvdyhjb2x1bW5Db3VudCwgc2NoZW1hLCB0aGVhZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVCb2R5Um93cyA9IGNyZWF0ZVRhYmxlQm9keVJvd3Mocm93Q291bnQgLSAxLCBjb2x1bW5Db3VudCwgc2NoZW1hLCB0Ym9keURhdGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBzY2hlbWEubm9kZXMudGFibGUuY3JlYXRlKG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlSGVhZC5jcmVhdGUobnVsbCwgdGFibGVIZWFkUm93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQm9keS5jcmVhdGUobnVsbCwgdGFibGVCb2R5Um93cyksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aCh0YWJsZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5yZW1vdmVUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKHNlbGVjdGlvbi4kYW5jaG9yKTtcbiAgICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVTdGFydE9mZnNldCA9IG1hcC50YWJsZVN0YXJ0T2Zmc2V0LCB0YWJsZUVuZE9mZnNldCA9IG1hcC50YWJsZUVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSB0YWJsZVN0YXJ0T2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUG9zID0gY3JlYXRlVGV4dFNlbGVjdGlvbih0ci5kZWxldGUoc3RhcnRPZmZzZXQsIHRhYmxlRW5kT2Zmc2V0KSwgc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNldFNlbGVjdGlvbihjdXJzb3JQb3MpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRDb2x1bW4gPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb25JbmZvID0gbWFwLmdldFJlY3RPZmZzZXRzKGFuY2hvciwgaGVhZCk7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldENvbElkeCA9IGRpcmVjdGlvbiA9PT0gXCJsZWZ0XCIgLyogTEVGVCAqLyA/IHNlbGVjdGlvbkluZm8uc3RhcnRDb2xJZHggOiBzZWxlY3Rpb25JbmZvLmVuZENvbElkeCArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gZ2V0Um93QW5kQ29sdW1uQ291bnQoc2VsZWN0aW9uSW5mbykuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsUm93Q291bnQgPSBtYXAudG90YWxSb3dDb3VudDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBjcmVhdGVEdW1teUNlbGxzKGNvbHVtbkNvdW50LCByb3dJZHgsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLm1hcChtYXAucG9zQXQocm93SWR4LCB0YXJnZXRDb2xJZHgpKSwgY2VsbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUucmVtb3ZlQ29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbiwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxDb2x1bW5Db3VudCA9IG1hcC50b3RhbENvbHVtbkNvdW50LCB0b3RhbFJvd0NvdW50ID0gbWFwLnRvdGFsUm93Q291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gZ2V0Um93QW5kQ29sdW1uQ291bnQoc2VsZWN0aW9uSW5mbykuY29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkQWxsQ29sdW1uID0gY29sdW1uQ291bnQgPT09IHRvdGFsQ29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkQWxsQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q29sSWR4ID0gc2VsZWN0aW9uSW5mby5zdGFydENvbElkeCwgZW5kQ29sSWR4ID0gc2VsZWN0aW9uSW5mby5lbmRDb2xJZHg7XG4gICAgICAgICAgICAgICAgdmFyIG1hcFN0YXJ0ID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJZHggPSAwOyByb3dJZHggPCB0b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2xJZHggPSBlbmRDb2xJZHg7IGNvbElkeCA+PSBzdGFydENvbElkeDsgY29sSWR4IC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IG1hcC5nZXRDZWxsSW5mbyhyb3dJZHgsIGNvbElkeCksIG9mZnNldCA9IF9iLm9mZnNldCwgbm9kZVNpemUgPSBfYi5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdHIubWFwcGluZy5zbGljZShtYXBTdGFydCkubWFwKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG8gPSBmcm9tICsgbm9kZVNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hZGRSb3cgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93Q291bnQgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChzZWxlY3Rpb25JbmZvKS5yb3dDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRUYXJnZXRSb3dJbmZvKGRpcmVjdGlvbiwgbWFwLCBzZWxlY3Rpb25JbmZvKSwgdGFyZ2V0Um93SWR4ID0gX2IudGFyZ2V0Um93SWR4LCBpbnNlcnRDb2xJZHggPSBfYi5pbnNlcnRDb2xJZHgsIG5vZGVTaXplID0gX2Iubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkVGhlYWQgPSB0YXJnZXRSb3dJZHggPT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZFRoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdHIubWFwcGluZy5tYXAobWFwLnBvc0F0KHRhcmdldFJvd0lkeCwgaW5zZXJ0Q29sSWR4KSkgKyBub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IHRvdGFsQ29sdW1uQ291bnQ7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGNlbGxzLmNvbmNhdChjcmVhdGVEdW1teUNlbGxzKDEsIHRhcmdldFJvd0lkeCwgc2NoZW1hKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goc2NoZW1hLm5vZGVzLnRhYmxlUm93LmNyZWF0ZShudWxsLCBjZWxscykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLmluc2VydChmcm9tLCByb3dzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5yZW1vdmVSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgIGlmIChhbmNob3IgJiYgaGVhZCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50LCB0b3RhbENvbHVtbkNvdW50ID0gbWFwLnRvdGFsQ29sdW1uQ291bnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbkluZm8gPSBtYXAuZ2V0UmVjdE9mZnNldHMoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93Q291bnQgPSBnZXRSb3dBbmRDb2x1bW5Db3VudChzZWxlY3Rpb25JbmZvKS5yb3dDb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Um93SWR4LCBlbmRSb3dJZHggPSBzZWxlY3Rpb25JbmZvLmVuZFJvd0lkeDtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRUaGVhZCA9IHN0YXJ0Um93SWR4ID09PSAwO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEFsbFRib2R5Um93ID0gcm93Q291bnQgPT09IHRvdGFsUm93Q291bnQgLSAxO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEFsbFRib2R5Um93IHx8IHNlbGVjdGVkVGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJZHggPSBlbmRSb3dJZHg7IHJvd0lkeCA+PSBzdGFydFJvd0lkeDsgcm93SWR4IC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gZ2V0Um93UmFuZ2VzKG1hcCwgcm93SWR4LCB0b3RhbENvbHVtbkNvdW50KSwgZnJvbSA9IF9iLmZyb20sIHRvID0gX2IudG87XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0YWJsZSByb3dcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKGZyb20gLSAxLCB0byArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuYWxpZ25Db2x1bW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQgPT09IHZvaWQgMCkgeyBwYXlsb2FkID0geyBhbGlnbjogJ2NlbnRlcicgfTsgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxpZ24gPSBwYXlsb2FkLmFsaWduO1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKSwgYW5jaG9yID0gX2EuYW5jaG9yLCBoZWFkID0gX2EuaGVhZDtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxSb3dDb3VudCA9IG1hcC50b3RhbFJvd0NvdW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0aW9uSW5mbyA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLnN0YXJ0Q29sSWR4LCBlbmRDb2xJZHggPSBzZWxlY3Rpb25JbmZvLmVuZENvbElkeDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdG90YWxSb3dDb3VudDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IHN0YXJ0Q29sSWR4OyBjb2xJZHggPD0gZW5kQ29sSWR4OyBjb2xJZHggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWFwLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgJiYgIW1hcC5leHRlbmRlZENvbHNwYW4ocm93SWR4LCBjb2xJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IG1hcC5nZXROb2RlQW5kUG9zKHJvd0lkeCwgY29sSWR4KSwgbm9kZSA9IF9iLm5vZGUsIHBvcyA9IF9iLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gc2V0QXR0cnMobm9kZSwgeyBhbGlnbjogYWxpZ24gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCBudWxsLCBhdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUubW92ZVRvQ2VsbCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbiksIGFuY2hvciA9IF9hLmFuY2hvciwgaGVhZCA9IF9hLmhlYWQ7XG4gICAgICAgICAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxJbmRleCA9IG1hcC5nZXRDZWxsSW5kZXgoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VHIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGNhbkJlT3V0T2ZUYWJsZShkaXJlY3Rpb24sIG1hcCwgY2VsbEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIHRoZSB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZW1wdHkgbGluZSgncGFyYWdyYXBoJykgaXMgY3JlYXRlZCBieSBwcmVzc2luZyB0aGUgYXJyb3cga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSBhZGRQYXJhZ3JhcGhBZnRlclRhYmxlKHRyLCBtYXAsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdUciA9IG1vdmVUb0NlbGwoZGlyZWN0aW9uLCB0ciwgY2VsbEluZGV4LCBtYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3VHIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUubW92ZUluQ2VsbCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHIsIGRvYyA9IHN0YXRlLmRvYywgc2NoZW1hID0gc3RhdGUuc2NoZW1hO1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5jb250ZXh0LnZpZXc7XG4gICAgICAgICAgICBpZiAoIXZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjZWxsID0gZmluZE5vZGVCeSgkZnJvbSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYSA9IGZpbmROb2RlQnkoJGZyb20sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjZWxsRGVwdGggPSBjZWxsLmRlcHRoO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhICYmIGNhbk1vdmVCZXR3ZWVuQ2VsbHMoZGlyZWN0aW9uLCBbY2VsbERlcHRoLCBwYXJhLmRlcHRoXSwgJGZyb20sIGRvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IGdldFJlc29sdmVkU2VsZWN0aW9uKHNlbGVjdGlvbikuYW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gVGFibGVPZmZzZXRNYXAuY3JlYXRlKGFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZWxsSW5kZXggPSBtYXAuZ2V0Q2VsbEluZGV4KGFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdUciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhblNlbGVjdFRhYmxlTm9kZShkaXJlY3Rpb24sIG1hcCwgY2VsbEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgY3Vyc29yIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGNlbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGFibGUgaXMgc2VsZWN0ZWQgd2hlbiB0aGUgbGVmdCAvIHJpZ2h0IGFycm93IGtleXMgYXJlIHByZXNzZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUciA9IHNlbGVjdE5vZGUodHIsICRmcm9tLCBjZWxsRGVwdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhbkJlT3V0T2ZUYWJsZShkaXJlY3Rpb24sIG1hcCwgY2VsbEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBjb250ZW50IGJlZm9yZSBvciBhZnRlciB0aGUgdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBlbXB0eSBsaW5lKCdwYXJhZ3JhcGgnKSBpcyBjcmVhdGVkIGJ5IHByZXNzaW5nIHRoZSBhcnJvdyBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiIC8qIFVQICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSBhZGRQYXJhZ3JhcGhCZWZvcmVUYWJsZSh0ciwgbWFwLCBzY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIiAvKiBET1dOICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VHIgPSBhZGRQYXJhZ3JhcGhBZnRlclRhYmxlKHRyLCBtYXAsIHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdUciA9IG1vdmVUb0NlbGwoZGlyZWN0aW9uLCB0ciwgY2VsbEluZGV4LCBtYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobmV3VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuZGVsZXRlQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUuc2NoZW1hLCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICB2YXIgX2EgPSBnZXRSZXNvbHZlZFNlbGVjdGlvbihzZWxlY3Rpb24pLCBhbmNob3IgPSBfYS5hbmNob3IsIGhlYWQgPSBfYS5oZWFkO1xuICAgICAgICAgICAgdmFyIHRleHRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkICYmICF0ZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZShhbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IG1hcC5nZXRSZWN0T2Zmc2V0cyhhbmNob3IsIGhlYWQpLCBzdGFydFJvd0lkeCA9IF9iLnN0YXJ0Um93SWR4LCBzdGFydENvbElkeCA9IF9iLnN0YXJ0Q29sSWR4LCBlbmRSb3dJZHggPSBfYi5lbmRSb3dJZHgsIGVuZENvbElkeCA9IF9iLmVuZENvbElkeDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByb3dJZHggPSBzdGFydFJvd0lkeDsgcm93SWR4IDw9IGVuZFJvd0lkeDsgcm93SWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29sSWR4ID0gc3RhcnRDb2xJZHg7IGNvbElkeCA8PSBlbmRDb2xJZHg7IGNvbElkeCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcC5leHRlbmRlZFJvd3NwYW4ocm93SWR4LCBjb2xJZHgpICYmICFtYXAuZXh0ZW5kZWRDb2xzcGFuKHJvd0lkeCwgY29sSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IG1hcC5nZXROb2RlQW5kUG9zKHJvd0lkeCwgY29sSWR4KSwgbm9kZSA9IF9jLm5vZGUsIHBvcyA9IF9jLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBjcmVhdGVEdW1teUNlbGxzKDEsIHJvd0lkeCwgc2NoZW1hLCBub2RlLmF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh0ci5tYXBwaW5nLm1hcChwb3MpLCB0ci5tYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSwgY2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5leGl0VGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLCB0ciA9IHN0YXRlLnRyLCBzY2hlbWEgPSBzdGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICB2YXIgJGZyb20gPSBzZWxlY3Rpb24uJGZyb207XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGZpbmROb2RlQnkoJGZyb20sIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGVIZWFkQ2VsbCcgfHwgdHlwZS5uYW1lID09PSAndGFibGVCb2R5Q2VsbCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmEgPSBmaW5kTm9kZUJ5KCRmcm9tLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gZ2V0UmVzb2x2ZWRTZWxlY3Rpb24oc2VsZWN0aW9uKS5hbmNob3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBUYWJsZU9mZnNldE1hcC5jcmVhdGUoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goYWRkUGFyYWdyYXBoQWZ0ZXJUYWJsZSh0ciwgbWFwLCBzY2hlbWEsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkVGFibGU6IHRoaXMuYWRkVGFibGUoKSxcbiAgICAgICAgICAgIHJlbW92ZVRhYmxlOiB0aGlzLnJlbW92ZVRhYmxlKCksXG4gICAgICAgICAgICBhZGRDb2x1bW5Ub0xlZnQ6IHRoaXMuYWRkQ29sdW1uKFwibGVmdFwiIC8qIExFRlQgKi8pLFxuICAgICAgICAgICAgYWRkQ29sdW1uVG9SaWdodDogdGhpcy5hZGRDb2x1bW4oXCJyaWdodFwiIC8qIFJJR0hUICovKSxcbiAgICAgICAgICAgIHJlbW92ZUNvbHVtbjogdGhpcy5yZW1vdmVDb2x1bW4oKSxcbiAgICAgICAgICAgIGFkZFJvd1RvVXA6IHRoaXMuYWRkUm93KFwidXBcIiAvKiBVUCAqLyksXG4gICAgICAgICAgICBhZGRSb3dUb0Rvd246IHRoaXMuYWRkUm93KFwiZG93blwiIC8qIERPV04gKi8pLFxuICAgICAgICAgICAgcmVtb3ZlUm93OiB0aGlzLnJlbW92ZVJvdygpLFxuICAgICAgICAgICAgYWxpZ25Db2x1bW46IHRoaXMuYWxpZ25Db2x1bW4oKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5rZXltYXBzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVsZXRlQ2VsbENvbnRlbnQgPSB0aGlzLmRlbGV0ZUNlbGxzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUYWI6IHRoaXMubW92ZVRvQ2VsbChcInJpZ2h0XCIgLyogUklHSFQgKi8pLFxuICAgICAgICAgICAgJ1NoaWZ0LVRhYic6IHRoaXMubW92ZVRvQ2VsbChcImxlZnRcIiAvKiBMRUZUICovKSxcbiAgICAgICAgICAgIEFycm93VXA6IHRoaXMubW92ZUluQ2VsbChcInVwXCIgLyogVVAgKi8pLFxuICAgICAgICAgICAgQXJyb3dEb3duOiB0aGlzLm1vdmVJbkNlbGwoXCJkb3duXCIgLyogRE9XTiAqLyksXG4gICAgICAgICAgICBBcnJvd0xlZnQ6IHRoaXMubW92ZUluQ2VsbChcImxlZnRcIiAvKiBMRUZUICovKSxcbiAgICAgICAgICAgIEFycm93UmlnaHQ6IHRoaXMubW92ZUluQ2VsbChcInJpZ2h0XCIgLyogUklHSFQgKi8pLFxuICAgICAgICAgICAgQmFja3NwYWNlOiBkZWxldGVDZWxsQ29udGVudCxcbiAgICAgICAgICAgICdNb2QtQmFja3NwYWNlJzogZGVsZXRlQ2VsbENvbnRlbnQsXG4gICAgICAgICAgICBEZWxldGU6IGRlbGV0ZUNlbGxDb250ZW50LFxuICAgICAgICAgICAgJ01vZC1EZWxldGUnOiBkZWxldGVDZWxsQ29udGVudCxcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiB0aGlzLmV4aXRUYWJsZSgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufShOb2RlJDIpKTtcblxudmFyIFRhYmxlSGVhZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZUhlYWQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVIZWFkKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUhlYWQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVIZWFkJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUhlYWQucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGFibGVSb3d7MX0nLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlRE9NSW5mb1BhcnNlZFJhd0hUTUwoJ3RoZWFkJyldLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3RoZWFkJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZUhlYWQ7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVCb2R5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRhYmxlQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUJvZHkoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQm9keS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0YWJsZUJvZHknO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQm9keS5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0YWJsZVJvdysnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ3Rib2R5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBkb20ucXVlcnlTZWxlY3RvckFsbCgndHInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHJvd3NbMF0uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3Rib2R5JywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZUJvZHk7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVSb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVSb3coKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlUm93LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlUm93JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZVJvdy5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcodGFibGVIZWFkQ2VsbCB8IHRhYmxlQm9keUNlbGwpKicsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAndHInLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IGRvbS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndHInLCBnZXRDdXN0b21BdHRycyhhdHRycyksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlUm93O1xufShOb2RlJDIpKTtcblxudmFyIFRhYmxlSGVhZENlbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVIZWFkQ2VsbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUhlYWRDZWxsKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZUhlYWRDZWxsLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RhYmxlSGVhZENlbGwnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlSGVhZENlbGwucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAncGFyYWdyYXBoKycsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyBhbGlnbjogeyBkZWZhdWx0OiBudWxsIH0sIGNsYXNzTmFtZTogeyBkZWZhdWx0OiBudWxsIH0sIHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9LCBjb2xzcGFuOiB7IGRlZmF1bHQ6IG51bGwgfSwgZXh0ZW5kZWQ6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFtjcmVhdGVQYXJzZWRDZWxsRE9NKCd0aCcpXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbEF0dHJzID0gY3JlYXRlQ2VsbEF0dHJzKGF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsndGgnLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGNlbGxBdHRycyksIGdldEN1c3RvbUF0dHJzKGF0dHJzKSksIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFRhYmxlSGVhZENlbGw7XG59KE5vZGUkMikpO1xuXG52YXIgVGFibGVCb2R5Q2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJsZUJvZHlDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQm9keUNlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlQm9keUNlbGwucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFibGVCb2R5Q2VsbCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVCb2R5Q2VsbC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcocGFyYWdyYXBoIHwgYnVsbGV0TGlzdCB8IG9yZGVyZWRMaXN0KSsnLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFsaWduOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbHNwYW46IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICByb3dzcGFuOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWQ6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNvbGF0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbY3JlYXRlUGFyc2VkQ2VsbERPTSgndGQnKV0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxBdHRycyA9IGNyZWF0ZUNlbGxBdHRycyhhdHRycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3RkJywgY2VsbEF0dHJzLCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBUYWJsZUJvZHlDZWxsO1xufShOb2RlJDIpKTtcblxudmFyIEltYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEltYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEltYWdlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbWFnZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1hZ2UucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyBpbWFnZVVybDogeyBkZWZhdWx0OiAnJyB9LCBhbHRUZXh0OiB7IGRlZmF1bHQ6IG51bGwgfSwgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdpbWdbc3JjXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRET00gPSBzYW5pdGl6ZUhUTUwoZG9tLCB7IFJFVFVSTl9ET01fRlJBR01FTlQ6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltYWdlVXJsID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsdFRleHQgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IGltYWdlVXJsOiBpbWFnZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0VGV4dDogYWx0VGV4dCB9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRycy5yYXdIVE1MIHx8ICdpbWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHsgc3JjOiBlc2NhcGVYbWwkMShhdHRycy5pbWFnZVVybCkgfSwgKGF0dHJzLmFsdFRleHQgJiYgeyBhbHQ6IGF0dHJzLmFsdFRleHQgfSkpLCBnZXRDdXN0b21BdHRycyhhdHRycykpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSW1hZ2UucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChfYSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBfYS5zY2hlbWEsIHRyID0gX2EudHI7XG4gICAgICAgICAgICB2YXIgX2IgPSBwYXlsb2FkLCBpbWFnZVVybCA9IF9iLmltYWdlVXJsLCBhbHRUZXh0ID0gX2IuYWx0VGV4dDtcbiAgICAgICAgICAgIGlmICghaW1hZ2VVcmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHNjaGVtYS5ub2Rlcy5pbWFnZS5jcmVhdGVBbmRGaWxsKF9fYXNzaWduJDEoeyBpbWFnZVVybDogaW1hZ2VVcmwgfSwgKGFsdFRleHQgJiYgeyBhbHRUZXh0OiBhbHRUZXh0IH0pKSk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgSW1hZ2UucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkSW1hZ2U6IHRoaXMuYWRkSW1hZ2UoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZTtcbn0oTm9kZSQyKSk7XG5cbnZhciBST09UX0JMT0NLX0RFUFRIID0gMTtcbnZhciBUaGVtYXRpY0JyZWFrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRoZW1hdGljQnJlYWssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGhlbWF0aWNCcmVhaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGhlbWF0aWNCcmVhay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd0aGVtYXRpY0JyZWFrJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaGVtYXRpY0JyZWFrLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgcGFyc2VET006IFt7IHRhZzogJ2hyJyB9XSxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCBnZXRDdXN0b21BdHRycyhhdHRycyksIFthdHRycy5yYXdIVE1MIHx8ICdociddXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmhyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gc3RhdGUuc2VsZWN0aW9uLCAkZnJvbSA9IF9iLiRmcm9tLCAkdG8gPSBfYi4kdG87XG4gICAgICAgICAgICBpZiAoJGZyb20gPT09ICR0bykge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBzdGF0ZS5kb2M7XG4gICAgICAgICAgICAgICAgdmFyIF9jID0gc3RhdGUuc2NoZW1hLm5vZGVzLCB0aGVtYXRpY0JyZWFrID0gX2MudGhlbWF0aWNCcmVhaywgcGFyYWdyYXBoID0gX2MucGFyYWdyYXBoO1xuICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IFt0aGVtYXRpY0JyZWFrLmNyZWF0ZSgpXTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdEJsb2NrID0gJGZyb20ubm9kZShST09UX0JMT0NLX0RFUFRIKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdEJsb2NrID0gZG9jLmNoaWxkKGRvYy5jaGlsZENvdW50IC0gMSkgPT09IHJvb3RCbG9jaztcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tFbmQgPSBkb2MucmVzb2x2ZSgkZnJvbS5hZnRlcihST09UX0JMT0NLX0RFUFRIKSk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRIciA9ICgoX2EgPSAkZnJvbS5ub2RlQWZ0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlLm5hbWUpID09PSBfdGhpcy5uYW1lO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QmxvY2sgfHwgbmV4dEhyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gocGFyYWdyYXBoLmNyZWF0ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0KGJsb2NrRW5kLnBvcywgbm9kZXMpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgVGhlbWF0aWNCcmVhay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGhyOiB0aGlzLmhyKCkgfTtcbiAgICB9O1xuICAgIFRoZW1hdGljQnJlYWsucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBockNvbW1hbmQgPSB0aGlzLmhyKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtbCc6IGhyQ29tbWFuZCxcbiAgICAgICAgICAgICdNb2QtTCc6IGhyQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUaGVtYXRpY0JyZWFrO1xufShOb2RlJDIpKTtcblxudmFyIFN0cm9uZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShTdHJvbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Ryb25nKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJvbmcucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3Ryb25nJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJvbmcucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlRE9NID0gWydiJywgJ3N0cm9uZyddLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IHBhcnNlRE9NLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0cnMucmF3SFRNTCB8fCAnc3Ryb25nJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0cm9uZy5wcm90b3R5cGUuYm9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHsgcmV0dXJuIHRvZ2dsZU1hcmskMShzdGF0ZS5zY2hlbWEubWFya3Muc3Ryb25nKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgU3Ryb25nLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgYm9sZDogdGhpcy5ib2xkKCkgfTtcbiAgICB9O1xuICAgIFN0cm9uZy5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvbGRDb21tYW5kID0gdGhpcy5ib2xkKCkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtYic6IGJvbGRDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1CJzogYm9sZENvbW1hbmQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3Ryb25nO1xufShNYXJrKSk7XG5cbnZhciBFbXBoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEVtcGgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1waCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1waC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdlbXBoJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbXBoLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZURPTSA9IFsnaScsICdlbSddLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3SFRNTCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IF9fYXNzaWduJDEoeyByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgcGFyc2VET006IHBhcnNlRE9NLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX2EuYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYXR0cnMucmF3SFRNTCB8fCAnZW0nLCBnZXRDdXN0b21BdHRycyhhdHRycyldO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRW1waC5wcm90b3R5cGUuaXRhbGljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gdG9nZ2xlTWFyayQxKHN0YXRlLnNjaGVtYS5tYXJrcy5lbXBoKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgRW1waC5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IGl0YWxpYzogdGhpcy5pdGFsaWMoKSB9O1xuICAgIH07XG4gICAgRW1waC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0YWxpY0NvbW1hbmQgPSB0aGlzLml0YWxpYygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWknOiBpdGFsaWNDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1JJzogaXRhbGljQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBFbXBoO1xufShNYXJrKSk7XG5cbnZhciBTdHJpa2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoU3RyaWtlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0cmlrZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWtlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3N0cmlrZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWtlLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZURPTSA9IFsncycsICdkZWwnXS5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7fSwgKHJhd0hUTUwgJiYgeyByYXdIVE1MOiByYXdIVE1MIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGF0dHJzOiBfX2Fzc2lnbiQxKHsgcmF3SFRNTDogeyBkZWZhdWx0OiBudWxsIH0gfSwgZ2V0RGVmYXVsdEN1c3RvbUF0dHJzKCkpLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBwYXJzZURPTSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2F0dHJzLnJhd0hUTUwgfHwgJ2RlbCcsIGdldEN1c3RvbUF0dHJzKGF0dHJzKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHJpa2UucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gdG9nZ2xlTWFyayQxKHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJpa2UpKHN0YXRlLCBkaXNwYXRjaCk7IH07IH07XG4gICAgfTtcbiAgICBTdHJpa2UucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJpa2VDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLXMnOiBzdHJpa2VDb21tYW5kLFxuICAgICAgICAgICAgJ01vZC1TJzogc3RyaWtlQ29tbWFuZCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpa2U7XG59KE1hcmspKTtcblxudmFyIExpbmsgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rKGxpbmtBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxpbmtBdHRyaWJ1dGVzID0gbGlua0F0dHJpYnV0ZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmsucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGluayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluay5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IGxpbmtVcmw6IHsgZGVmYXVsdDogJycgfSwgdGl0bGU6IHsgZGVmYXVsdDogbnVsbCB9LCByYXdIVE1MOiB7IGRlZmF1bHQ6IG51bGwgfSB9LCBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSksXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdhW2hyZWZdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhbml0aXplZERPTSA9IHNhbml0aXplSFRNTChkb20sIHsgUkVUVVJOX0RPTV9GUkFHTUVOVDogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IHNhbml0aXplZERPTS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGUgPSBzYW5pdGl6ZWRET00uZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXdIVE1MID0gc2FuaXRpemVkRE9NLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKHsgbGlua1VybDogaHJlZiwgdGl0bGU6IHRpdGxlIH0sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLnJhd0hUTUwgfHwgJ2EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19hc3NpZ24kMShfX2Fzc2lnbiQxKHsgaHJlZjogZXNjYXBlWG1sJDEoYXR0cnMubGlua1VybCkgfSwgX3RoaXMubGlua0F0dHJpYnV0ZXMpLCBnZXRDdXN0b21BdHRycyhhdHRycykpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTGluay5wcm90b3R5cGUuYWRkTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXlsb2FkLCBsaW5rVXJsID0gX2EubGlua1VybCwgX2IgPSBfYS5saW5rVGV4dCwgbGlua1RleHQgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcbiAgICAgICAgICAgIHZhciBzY2hlbWEgPSBzdGF0ZS5zY2hlbWEsIHRyID0gc3RhdGUudHIsIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBlbXB0eSA9IHNlbGVjdGlvbi5lbXB0eSwgZnJvbSA9IHNlbGVjdGlvbi5mcm9tLCB0byA9IHNlbGVjdGlvbi50bztcbiAgICAgICAgICAgIGlmIChmcm9tICYmIHRvICYmIGxpbmtVcmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB7IGxpbmtVcmw6IGxpbmtVcmwgfTtcbiAgICAgICAgICAgICAgICB2YXIgbWFyayA9IHNjaGVtYS5tYXJrKCdsaW5rJywgYXR0cnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSAmJiBsaW5rVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRleHROb2RlJDEoc2NoZW1hLCBsaW5rVGV4dCwgbWFyayk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhmcm9tLCB0bywgbWFyayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUudG9nZ2xlTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwYXlsb2FkKSB7IHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9nZ2xlTWFyayQxKHN0YXRlLnNjaGVtYS5tYXJrcy5saW5rLCBwYXlsb2FkKShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuY29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRMaW5rOiB0aGlzLmFkZExpbmsoKSxcbiAgICAgICAgICAgIHRvZ2dsZUxpbms6IHRoaXMudG9nZ2xlTGluaygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpbms7XG59KE1hcmspKTtcblxudmFyIENvZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb2RlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2RlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvZGUnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGUucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdHRyczogX19hc3NpZ24kMSh7IHJhd0hUTUw6IHsgZGVmYXVsdDogbnVsbCB9IH0sIGdldERlZmF1bHRDdXN0b21BdHRycygpKSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0hUTUwgPSBkb20uZ2V0QXR0cmlidXRlKCdkYXRhLXJhdy1odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoe30sIChyYXdIVE1MICYmIHsgcmF3SFRNTDogcmF3SFRNTCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthdHRycy5yYXdIVE1MIHx8ICdjb2RlJywgZ2V0Q3VzdG9tQXR0cnMoYXR0cnMpXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvZGUucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkgeyByZXR1cm4gdG9nZ2xlTWFyayQxKHN0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKShzdGF0ZSwgZGlzcGF0Y2gpOyB9OyB9O1xuICAgIH07XG4gICAgQ29kZS5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvZGVDb21tYW5kID0gdGhpcy5jb21tYW5kcygpKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnU2hpZnQtTW9kLWMnOiBjb2RlQ29tbWFuZCxcbiAgICAgICAgICAgICdTaGlmdC1Nb2QtQyc6IGNvZGVDb21tYW5kLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvZGU7XG59KE1hcmspKTtcblxudmFyIEN1c3RvbUJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKEN1c3RvbUJsb2NrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21CbG9jay5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdjdXN0b21CbG9jayc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tQmxvY2sucHJvdG90eXBlLCBcInNjaGVtYVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiAndGV4dConLFxuICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZm86IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXRvbTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJ2RpdltkYXRhLWN1c3RvbS1pbmZvXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZnVuY3Rpb24gKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1jdXN0b20taW5mbycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluZm86IGluZm8gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB7ICdkYXRhLWN1c3RvbS1pbmZvJzogYXR0cnMuaW5mbyB8fCBudWxsIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ3VzdG9tQmxvY2sucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAocGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLmluZm8pXG4gICAgICAgICAgICAgICAgPyBzZXRCbG9ja1R5cGUoc3RhdGUuc2NoZW1hLm5vZGVzLmN1c3RvbUJsb2NrLCBwYXlsb2FkKShzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfTsgfTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21CbG9jaztcbn0oTm9kZSQyKSk7XG5cbnZhciBGcm9udE1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShGcm9udE1hdHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm9udE1hdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJvbnRNYXR0ZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnZnJvbnRNYXR0ZXInO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb250TWF0dGVyLnByb3RvdHlwZSwgXCJzY2hlbWFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogJ3RleHQqJyxcbiAgICAgICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICBjb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlZmluaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnZGl2W2RhdGEtZnJvbnQtbWF0dGVyXScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB0b0RPTTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydkaXYnLCB7ICdkYXRhLWZyb250LW1hdHRlcic6ICd0cnVlJyB9LCAwXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZyb250TWF0dGVyLnByb3RvdHlwZS5jb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICAgICAgICAgIHZhciAkZnJvbSA9IHN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgICAgIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKCdkb3duJykgJiYgJGZyb20ubm9kZSgpLnR5cGUubmFtZSA9PT0gJ2Zyb250TWF0dGVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9OyB9O1xuICAgIH07XG4gICAgRnJvbnRNYXR0ZXIucHJvdG90eXBlLmtleW1hcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFbnRlcjogdGhpcy5jb21tYW5kcygpKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbnRNYXR0ZXI7XG59KE5vZGUkMikpO1xuXG52YXIgSFRNTENvbW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSFRNTENvbW1lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSFRNTENvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxDb21tZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2h0bWxDb21tZW50JztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MQ29tbWVudC5wcm90b3R5cGUsIFwic2NoZW1hXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICd0ZXh0KicsXG4gICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgY29kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYXJzZURPTTogW3sgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsIHRhZzogJ2RpdltkYXRhLWh0bWwtY29tbWVudF0nIH1dLFxuICAgICAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpdicsIHsgJ2RhdGEtaHRtbC1jb21tZW50JzogJ3RydWUnIH0sIDBdO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgSFRNTENvbW1lbnQucHJvdG90eXBlLmNvbW1hbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICAgICAgdmFyICRmcm9tID0gc3RhdGUuc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICAgICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soJ2Rvd24nKSAmJiAkZnJvbS5ub2RlKCkudHlwZS5uYW1lID09PSAnaHRtbENvbW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXRDb2RlKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07IH07XG4gICAgfTtcbiAgICBIVE1MQ29tbWVudC5wcm90b3R5cGUua2V5bWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEVudGVyOiB0aGlzLmNvbW1hbmRzKCkoKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBIVE1MQ29tbWVudDtcbn0oTm9kZSQyKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNwZWNzKGxpbmtBdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBTcGVjTWFuYWdlcihbXG4gICAgICAgIG5ldyBEb2MoKSxcbiAgICAgICAgbmV3IFBhcmFncmFwaCgpLFxuICAgICAgICBuZXcgVGV4dCgpLFxuICAgICAgICBuZXcgSGVhZGluZygpLFxuICAgICAgICBuZXcgQ29kZUJsb2NrKCksXG4gICAgICAgIG5ldyBCdWxsZXRMaXN0KCksXG4gICAgICAgIG5ldyBPcmRlcmVkTGlzdCgpLFxuICAgICAgICBuZXcgTGlzdEl0ZW0oKSxcbiAgICAgICAgbmV3IEJsb2NrUXVvdGUoKSxcbiAgICAgICAgbmV3IFRhYmxlKCksXG4gICAgICAgIG5ldyBUYWJsZUhlYWQoKSxcbiAgICAgICAgbmV3IFRhYmxlQm9keSgpLFxuICAgICAgICBuZXcgVGFibGVSb3coKSxcbiAgICAgICAgbmV3IFRhYmxlSGVhZENlbGwoKSxcbiAgICAgICAgbmV3IFRhYmxlQm9keUNlbGwoKSxcbiAgICAgICAgbmV3IEltYWdlKCksXG4gICAgICAgIG5ldyBUaGVtYXRpY0JyZWFrKCksXG4gICAgICAgIG5ldyBTdHJvbmcoKSxcbiAgICAgICAgbmV3IEVtcGgoKSxcbiAgICAgICAgbmV3IFN0cmlrZSgpLFxuICAgICAgICBuZXcgTGluayhsaW5rQXR0cmlidXRlcyksXG4gICAgICAgIG5ldyBDb2RlKCksXG4gICAgICAgIG5ldyBDdXN0b21CbG9jaygpLFxuICAgICAgICBuZXcgRnJvbnRNYXR0ZXIoKSxcbiAgICAgICAgbmV3IFdpZGdldCgpLFxuICAgICAgICBuZXcgSFRNTENvbW1lbnQoKSxcbiAgICBdKTtcbn1cblxudmFyIENPTlRFTlRTX0NMQVNTX05BTUUgPSBjbHMoJ2NvbnRlbnRzJyk7XG52YXIgV3lzaXd5Z0VkaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShXeXNpd3lnRWRpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFd5c2l3eWdFZGl0b3IoZXZlbnRFbWl0dGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGV2ZW50RW1pdHRlcikgfHwgdGhpcztcbiAgICAgICAgdmFyIHRvRE9NQWRhcHRvciA9IG9wdGlvbnMudG9ET01BZGFwdG9yLCBfYSA9IG9wdGlvbnMuaHRtbFNjaGVtYU1hcCwgaHRtbFNjaGVtYU1hcCA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYiA9IG9wdGlvbnMubGlua0F0dHJpYnV0ZXMsIGxpbmtBdHRyaWJ1dGVzID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIF9jID0gb3B0aW9ucy51c2VDb21tYW5kU2hvcnRjdXQsIHVzZUNvbW1hbmRTaG9ydGN1dCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy53d1BsdWdpbnMsIHd3UGx1Z2lucyA9IF9kID09PSB2b2lkIDAgPyBbXSA6IF9kLCBfZSA9IG9wdGlvbnMud3dOb2RlVmlld3MsIHd3Tm9kZVZpZXdzID0gX2UgPT09IHZvaWQgMCA/IHt9IDogX2U7XG4gICAgICAgIF90aGlzLmVkaXRvclR5cGUgPSAnd3lzaXd5Zyc7XG4gICAgICAgIF90aGlzLmVsLmNsYXNzTGlzdC5hZGQoJ3d3LW1vZGUnKTtcbiAgICAgICAgX3RoaXMudG9ET01BZGFwdG9yID0gdG9ET01BZGFwdG9yO1xuICAgICAgICBfdGhpcy5saW5rQXR0cmlidXRlcyA9IGxpbmtBdHRyaWJ1dGVzO1xuICAgICAgICBfdGhpcy5leHRyYVBsdWdpbnMgPSB3d1BsdWdpbnM7XG4gICAgICAgIF90aGlzLnBsdWdpbk5vZGVWaWV3cyA9IHd3Tm9kZVZpZXdzO1xuICAgICAgICBfdGhpcy5zcGVjcyA9IF90aGlzLmNyZWF0ZVNwZWNzKCk7XG4gICAgICAgIF90aGlzLnNjaGVtYSA9IF90aGlzLmNyZWF0ZVNjaGVtYShodG1sU2NoZW1hTWFwKTtcbiAgICAgICAgX3RoaXMuY29udGV4dCA9IF90aGlzLmNyZWF0ZUNvbnRleHQoKTtcbiAgICAgICAgX3RoaXMua2V5bWFwcyA9IF90aGlzLmNyZWF0ZUtleW1hcHModXNlQ29tbWFuZFNob3J0Y3V0KTtcbiAgICAgICAgX3RoaXMudmlldyA9IF90aGlzLmNyZWF0ZVZpZXcoKTtcbiAgICAgICAgX3RoaXMuY29tbWFuZHMgPSBfdGhpcy5jcmVhdGVDb21tYW5kcygpO1xuICAgICAgICBfdGhpcy5zcGVjcy5zZXRDb250ZXh0KF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgX3RoaXMuY29udGV4dCksIHsgdmlldzogX3RoaXMudmlldyB9KSk7XG4gICAgICAgIF90aGlzLmluaXRFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmNyZWF0ZVNwZWNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3BlY3ModGhpcy5saW5rQXR0cmlidXRlcyk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVTY2hlbWEgPSBmdW5jdGlvbiAoaHRtbFNjaGVtYU1hcCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjaGVtYSh7XG4gICAgICAgICAgICBub2RlczogX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0aGlzLnNwZWNzLm5vZGVzKSwgaHRtbFNjaGVtYU1hcC5ub2RlcyksXG4gICAgICAgICAgICBtYXJrczogX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0aGlzLnNwZWNzLm1hcmtzKSwgaHRtbFNjaGVtYU1hcC5tYXJrcyksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlUGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkkMShbXG4gICAgICAgICAgICB0YWJsZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgdGFibGVDb250ZXh0TWVudSh0aGlzLmV2ZW50RW1pdHRlciksXG4gICAgICAgICAgICB0YXNrKCksXG4gICAgICAgICAgICB0b29sYmFyU3RhdGVIaWdobGlnaHQodGhpcy5ldmVudEVtaXR0ZXIpXG4gICAgICAgIF0sIHRoaXMuY3JlYXRlUGx1Z2luUHJvcHMoKSkuY29uY2F0KHRoaXMuZGVmYXVsdFBsdWdpbnMpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlUGx1Z2luTm9kZVZpZXdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXIsIHBsdWdpbk5vZGVWaWV3cyA9IF9hLnBsdWdpbk5vZGVWaWV3cztcbiAgICAgICAgdmFyIHBsdWdpbk5vZGVWaWV3TWFwID0ge307XG4gICAgICAgIGlmIChwbHVnaW5Ob2RlVmlld3MpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBsdWdpbk5vZGVWaWV3cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luTm9kZVZpZXdNYXBba2V5XSA9IGZ1bmN0aW9uIChub2RlLCB2aWV3LCBnZXRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbk5vZGVWaWV3c1trZXldKG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpbk5vZGVWaWV3TWFwO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgdG9ET01BZGFwdG9yID0gX2EudG9ET01BZGFwdG9yLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yVmlldyh0aGlzLmVsLCB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jcmVhdGVTdGF0ZSgpLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBDT05URU5UU19DTEFTU19OQU1FLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vZGVWaWV3czogX19hc3NpZ24kMSh7IGN1c3RvbUJsb2NrOiBmdW5jdGlvbiAobm9kZSwgdmlldywgZ2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tQmxvY2tWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgdG9ET01BZGFwdG9yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGltYWdlOiBmdW5jdGlvbiAobm9kZSwgdmlldywgZ2V0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2VWaWV3KG5vZGUsIHZpZXcsIGdldFBvcywgZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUsIHZpZXcsIGdldFBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvZGVCbG9ja1ZpZXcobm9kZSwgdmlldywgZ2V0UG9zLCBldmVudEVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIH0sIHdpZGdldDogd2lkZ2V0Tm9kZVZpZXcgfSwgdGhpcy5jcmVhdGVQbHVnaW5Ob2RlVmlld3MoKSksXG4gICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiBmdW5jdGlvbiAodHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBfdGhpcy52aWV3LnN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odHIpLnN0YXRlO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXRDaGFuZ2VFdmVudCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnc2V0Rm9jdXNlZE5vZGUnLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubm9kZSgxKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtUGFzdGVkSFRNTDogY2hhbmdlUGFzdGVkSFRNTCxcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhc3RlZDogZnVuY3Rpb24gKHNsaWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZVBhc3RlZFNsaWNlKHNsaWNlLCBfdGhpcy5zY2hlbWEsIGlzSW5UYWJsZU5vZGUoX3RoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVQYXN0ZTogZnVuY3Rpb24gKHZpZXcsIF8sIHNsaWNlKSB7IHJldHVybiBwYXN0ZVRvVGFibGUodmlldywgc2xpY2UpOyB9LFxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24gKF8sIGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2tleWRvd24nLCBfdGhpcy5lZGl0b3JUeXBlLCBldik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIHBhc3RlOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaXBib2FyZERhdGEgPSBldi5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBjbGlwYm9hcmREYXRhID09PSBudWxsIHx8IGNsaXBib2FyZERhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaXBib2FyZERhdGEuaXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5SdGZJdGVtID0gdG9BcnJheV8xKGl0ZW1zKS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmtpbmQgPT09ICdzdHJpbmcnICYmIGl0ZW0udHlwZSA9PT0gJ3RleHQvcnRmJzsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBjb250YWlucyBydGYsIGl0J3MgbW9zdCBsaWtlbHkgY29weSBwYXN0ZSBmcm9tIG9mZmljZSAtPiBubyBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluUnRmSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZUJsb2IgPSBwYXN0ZUltYWdlT25seShpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlQmxvYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0SW1hZ2VCbG9iSG9vayhfdGhpcy5ldmVudEVtaXR0ZXIsIGltYWdlQmxvYiwgZXYudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGtleXVwOiBmdW5jdGlvbiAoXywgZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2tleXVwJywgX3RoaXMuZWRpdG9yVHlwZSwgZXYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JvbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbCcsICdlZGl0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuY3JlYXRlQ29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWNzLmNvbW1hbmRzKHRoaXMudmlldywgZ2V0V3dDb21tYW5kcygpKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldEhUTUwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVQcm9zZU1pcnJvckhhY2tOb2Rlcyh0aGlzLnZpZXcuZG9tLmlubmVySFRNTCk7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2M7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24sIGZyb20gPSBfYS5mcm9tLCB0byA9IF9hLnRvO1xuICAgICAgICByZXR1cm4gW2Zyb20sIHRvXTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldFNjaGVtYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5zY2hlbWE7XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5yZXBsYWNlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBzY2hlbWEgPSBfYS5zY2hlbWEsIHRyID0gX2EudHI7XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgdmFyIHBhcmFzID0gbGluZVRleHRzLm1hcChmdW5jdGlvbiAobGluZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGgoc2NoZW1hLCBjcmVhdGVOb2Rlc1dpdGhXaWRnZXQobGluZVRleHQsIHNjaGVtYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyYXMpLCAxLCAxKTtcbiAgICAgICAgdmFyIG5ld1RyID0gaXNOdW1iZXJfMShzdGFydCkgJiYgaXNOdW1iZXJfMShlbmQpXG4gICAgICAgICAgICA/IHRyLnJlcGxhY2VSYW5nZShzdGFydCwgZW5kLCBzbGljZSlcbiAgICAgICAgICAgIDogdHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaChuZXdUcik7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciB0ciA9IHRoaXMudmlldy5zdGF0ZS50cjtcbiAgICAgICAgdmFyIG5ld1RyID0gaXNOdW1iZXJfMShzdGFydCkgJiYgaXNOdW1iZXJfMShlbmQpID8gdHIuZGVsZXRlUmFuZ2Uoc3RhcnQsIGVuZCkgOiB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKG5ld1RyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH07XG4gICAgV3lzaXd5Z0VkaXRvci5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRUZXh0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyIGZyb20gPSBzZWxlY3Rpb24uZnJvbSwgdG8gPSBzZWxlY3Rpb24udG87XG4gICAgICAgIGlmIChpc051bWJlcl8xKHN0YXJ0KSAmJiBpc051bWJlcl8xKGVuZCkpIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGFydDtcbiAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2MudGV4dEJldHdlZW4oZnJvbSwgdG8sICdcXG4nKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLnNldE1vZGVsID0gZnVuY3Rpb24gKG5ld0RvYywgY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgaWYgKGN1cnNvclRvRW5kID09PSB2b2lkIDApIHsgY3Vyc29yVG9FbmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLnZpZXcuc3RhdGUsIHRyID0gX2EudHIsIGRvYyA9IF9hLmRvYztcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHRyLnJlcGxhY2VXaXRoKDAsIGRvYy5jb250ZW50LnNpemUsIG5ld0RvYykpO1xuICAgICAgICBpZiAoY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvclRvRW5kKHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXeXNpd3lnRWRpdG9yLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gc3RhcnQ7IH1cbiAgICAgICAgdmFyIHRyID0gdGhpcy52aWV3LnN0YXRlLnRyO1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gY3JlYXRlVGV4dFNlbGVjdGlvbih0ciwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uIChub2RlLCBzdHlsZSwgcG9zKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMudmlldywgZGlzcGF0Y2ggPSBfYS5kaXNwYXRjaCwgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0TWV0YSgnd2lkZ2V0JywgeyBwb3M6IHBvcyAhPT0gbnVsbCAmJiBwb3MgIT09IHZvaWQgMCA/IHBvcyA6IHN0YXRlLnNlbGVjdGlvbi50bywgbm9kZTogbm9kZSwgc3R5bGU6IHN0eWxlIH0pKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLnJlcGxhY2VXaXRoV2lkZ2V0ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRleHQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCB0ciA9IF9hLnRyLCBzY2hlbWEgPSBfYS5zY2hlbWE7XG4gICAgICAgIHZhciBub2RlcyA9IGNyZWF0ZU5vZGVzV2l0aFdpZGdldCh0ZXh0LCBzY2hlbWEpO1xuICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2godHIucmVwbGFjZVdpdGgoc3RhcnQsIGVuZCwgbm9kZXMpKTtcbiAgICB9O1xuICAgIFd5c2l3eWdFZGl0b3IucHJvdG90eXBlLmdldFJhbmdlSW5mb09mTm9kZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy52aWV3LnN0YXRlLCBkb2MgPSBfYS5kb2MsIHNlbGVjdGlvbiA9IF9hLnNlbGVjdGlvbjtcbiAgICAgICAgdmFyICRwb3MgPSBwb3MgPyBkb2MucmVzb2x2ZShwb3MpIDogc2VsZWN0aW9uLiRmcm9tO1xuICAgICAgICB2YXIgbWFya3MgPSAkcG9zLm1hcmtzKCk7XG4gICAgICAgIHZhciBub2RlID0gJHBvcy5ub2RlKCk7XG4gICAgICAgIHZhciBzdGFydCA9ICRwb3Muc3RhcnQoKTtcbiAgICAgICAgdmFyIGVuZCA9ICRwb3MuZW5kKCk7XG4gICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlLm5hbWU7XG4gICAgICAgIGlmIChtYXJrcy5sZW5ndGggfHwgdHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIHZhciBtYXJrXzEgPSBtYXJrc1ttYXJrcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBtYXliZUhhc01hcmtfMSA9IGZ1bmN0aW9uIChub2RlTWFya3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU1hcmtzLmxlbmd0aCA/IGluY2x1ZGVzKG5vZGVNYXJrcywgbWFya18xKSA6IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHlwZSA9IG1hcmtfMSA/IG1hcmtfMS50eXBlLm5hbWUgOiAndGV4dCc7XG4gICAgICAgICAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUZXh0ID0gY2hpbGQuaXNUZXh0LCBub2RlU2l6ZSA9IGNoaWxkLm5vZGVTaXplLCBub2RlTWFya3MgPSBjaGlsZC5tYXJrcztcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSAkcG9zLnBvcyAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChpc1RleHQgJiZcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IDw9IHN0YXJ0T2Zmc2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArIG5vZGVTaXplID49IHN0YXJ0T2Zmc2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIG1heWJlSGFzTWFya18xKG5vZGVNYXJrcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogW3N0YXJ0LCBlbmRdLCB0eXBlOiB0eXBlIH07XG4gICAgfTtcbiAgICByZXR1cm4gV3lzaXd5Z0VkaXRvcjtcbn0oRWRpdG9yQmFzZSkpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZXhpc3Rpbmcgb3Igbm90LlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxudmFyIGlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWRfMTtcbnZhciBpc051bGwgPSBpc051bGxfMTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBleGlzdGluZyBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbm90IG51bGwgYW5kIG5vdCB1bmRlZmluZWQsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gcGFyYW0gLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZXhpc3R5P1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgaXNFeGlzdHkgZnJvbSAndHVpLWNvZGUtc25pcHBldC90eXBlL2lzRXhpc3R5Jyk7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBpc0V4aXN0eSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0V4aXN0eScpO1xuICpcbiAqIGlzRXhpc3R5KCcnKTsgLy90cnVlXG4gKiBpc0V4aXN0eSgwKTsgLy90cnVlXG4gKiBpc0V4aXN0eShbXSk7IC8vdHJ1ZVxuICogaXNFeGlzdHkoe30pOyAvL3RydWVcbiAqIGlzRXhpc3R5KG51bGwpOyAvL2ZhbHNlXG4gKiBpc0V4aXN0eSh1bmRlZmluZWQpOyAvL2ZhbHNlXG4qL1xuZnVuY3Rpb24gaXNFeGlzdHkkMShwYXJhbSkge1xuICByZXR1cm4gIWlzVW5kZWZpbmVkKHBhcmFtKSAmJiAhaXNOdWxsKHBhcmFtKTtcbn1cblxudmFyIGlzRXhpc3R5XzEgPSBpc0V4aXN0eSQxO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdHJ1dGh5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc0V4aXN0eSA9IGlzRXhpc3R5XzE7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdHJ1dGh5IG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgbnVsbCBvciBub3QgdW5kZWZpbmVkIG9yIG5vdCBmYWxzZSwgcmV0dXJucyB0cnVlLlxuICogKEl0IHJlZ2FyZHMgMCBhcyB0cnVlKVxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgdHJ1dGh5P1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzVHJ1dGh5JDEob2JqKSB7XG4gIHJldHVybiBpc0V4aXN0eShvYmopICYmIG9iaiAhPT0gZmFsc2U7XG59XG5cbnZhciBpc1RydXRoeV8xID0gaXNUcnV0aHkkMTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGZhbHN5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbnZhciBpc1RydXRoeSA9IGlzVHJ1dGh5XzE7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZmFsc3kgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBmYWxzeT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0ZhbHN5KG9iaikge1xuICByZXR1cm4gIWlzVHJ1dGh5KG9iaik7XG59XG5cbnZhciBpc0ZhbHN5XzEgPSBpc0ZhbHN5O1xuXG52YXIgZXZlbnRUeXBlTGlzdCA9IFtcbiAgICAnYWZ0ZXJQcmV2aWV3UmVuZGVyJyxcbiAgICAndXBkYXRlUHJldmlldycsXG4gICAgJ2NoYW5nZU1vZGUnLFxuICAgICduZWVkQ2hhbmdlTW9kZScsXG4gICAgJ2NvbW1hbmQnLFxuICAgICdjaGFuZ2VQcmV2aWV3U3R5bGUnLFxuICAgICdjaGFuZ2VQcmV2aWV3VGFiUHJldmlldycsXG4gICAgJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnc2hvdycsXG4gICAgJ2hpZGUnLFxuICAgICdjaGFuZ2VMYW5ndWFnZScsXG4gICAgJ2NoYW5nZVRvb2xiYXJTdGF0ZScsXG4gICAgJ3RvZ2dsZVNjcm9sbFN5bmMnLFxuICAgICdtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlJyxcbiAgICAnc2V0Rm9jdXNlZE5vZGUnLFxuICAgICdyZW1vdmVQb3B1cFdpZGdldCcsXG4gICAgJ3F1ZXJ5JyxcbiAgICAvLyBwcm92aWRlIGV2ZW50IGZvciB1c2VyXG4gICAgJ29wZW5Qb3B1cCcsXG4gICAgJ2Nsb3NlUG9wdXAnLFxuICAgICdhZGRJbWFnZUJsb2JIb29rJyxcbiAgICAnYmVmb3JlUHJldmlld1JlbmRlcicsXG4gICAgJ2JlZm9yZUNvbnZlcnRXeXNpd3lnVG9NYXJrZG93bicsXG4gICAgJ2xvYWQnLFxuICAgICdsb2FkVUknLFxuICAgICdjaGFuZ2UnLFxuICAgICdjYXJldENoYW5nZScsXG4gICAgJ2Rlc3Ryb3knLFxuICAgICdmb2N1cycsXG4gICAgJ2JsdXInLFxuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnLFxuXTtcbi8qKlxuICogQ2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAaWdub3JlXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBNYXAkMSgpO1xuICAgICAgICB0aGlzLmV2ZW50VHlwZXMgPSBldmVudFR5cGVMaXN0LnJlZHVjZShmdW5jdGlvbiAodHlwZXMsIHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHR5cGVzKSwgeyB0eXBlOiB0eXBlIH0pO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHRoaXMuaG9sZCA9IGZhbHNlO1xuICAgICAgICBldmVudFR5cGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuYWRkRXZlbnRUeXBlKGV2ZW50VHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZXZlbnQgYW5kIGJpbmQgZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgc3RyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgdHlwZUluZm8gPSB0aGlzLmdldFR5cGVJbmZvKHR5cGUpO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlSW5mby50eXBlKSB8fCBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0V2ZW50VHlwZSh0eXBlSW5mby50eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gZXZlbnQgdHlwZSBcIiArIHR5cGVJbmZvLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlSW5mby5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIGhhbmRsZXIubmFtZXNwYWNlID0gdHlwZUluZm8ubmFtZXNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50SGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldmVudHMuc2V0KHR5cGVJbmZvLnR5cGUsIGV2ZW50SGFuZGxlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBlbWl0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlSW5mbyA9IHRoaXMuZ2V0VHlwZUluZm8odHlwZSk7XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGVJbmZvLnR5cGUpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMuaG9sZCAmJiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWRfMShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBnaXZlbiBldmVudCBhbmQgcmV0dXJuIHJlc3VsdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBlbWl0XG4gICAgICogQHBhcmFtIHthbnl9IHNvdXJjZSBTb3VyY2UgdG8gY2hhbmdlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRSZWR1Y2UgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXRoaXMuaG9sZCAmJiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlci5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkkMShbc291cmNlXSwgYXJncykpO1xuICAgICAgICAgICAgICAgIGlmICghaXNGYWxzeV8xKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgdHlwZSBhbmQgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHJldHVybnMge3t0eXBlOiBzdHJpbmcsIG5hbWVzcGFjZTogc3RyaW5nfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0VHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc3BsaXRlZCA9IHR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHNwbGl0ZWRbMF0sXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHNwbGl0ZWRbMV0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGV2ZW50IHR5cGUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXNFdmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkXzEodGhpcy5ldmVudFR5cGVzW3RoaXMuZ2V0VHlwZUluZm8odHlwZSkudHlwZV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGV2ZW50IHR5cGUgd2hlbiBnaXZlbiBldmVudCBub3QgZXhpc3RzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNFdmVudFR5cGUodHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIGFscmVhZHkgaGF2ZSBldmVudCB0eXBlIFwiICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFR5cGVzW3R5cGVdID0gdHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIGZyb20gZ2l2ZW4gZXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIC0gcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0VHlwZUluZm8oZXZlbnRUeXBlKSwgdHlwZSA9IF9hLnR5cGUsIG5hbWVzcGFjZSA9IF9hLm5hbWVzcGFjZTtcbiAgICAgICAgaWYgKHR5cGUgJiYgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEhhbmRsZXJXaXRoSGFuZGxlcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlICYmICFuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdHlwZSAmJiBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKF8sIGV2dFR5cGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8oZXZ0VHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgJiYgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyh0eXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciB3aXRoIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBldmVudCBoYW5kbGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhIYW5kbGVyID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZSk7XG4gICAgICAgIGlmIChldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlckluZGV4ID0gZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVycy5zcGxpY2UoaGFuZGxlckluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgd2l0aCBldmVudCB0eXBlIGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSBFdmVudCBuYW1lc3BhY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvID0gZnVuY3Rpb24gKHR5cGUsIG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgaGFuZGxlcnNUb1N1cnZpdmUgPSBbXTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZSk7XG4gICAgICAgIGlmICghZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50SGFuZGxlcnMubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlci5uYW1lc3BhY2UgIT09IG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzVG9TdXJ2aXZlLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnNldCh0eXBlLCBoYW5kbGVyc1RvU3Vydml2ZSk7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ob2xkRXZlbnRJbnZva2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5ob2xkID0gdHJ1ZTtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGhpcy5ob2xkID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpKTtcblxudmFyIENvbW1hbmRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbW1hbmRNYW5hZ2VyKGV2ZW50RW1pdHRlciwgbWRDb21tYW5kcywgd3dDb21tYW5kcywgZ2V0RWRpdG9yVHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5tZENvbW1hbmRzID0gbWRDb21tYW5kcztcbiAgICAgICAgdGhpcy53d0NvbW1hbmRzID0gd3dDb21tYW5kcztcbiAgICAgICAgdGhpcy5nZXRFZGl0b3JUeXBlID0gZ2V0RWRpdG9yVHlwZTtcbiAgICAgICAgdGhpcy5pbml0RXZlbnQoKTtcbiAgICB9XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjb21tYW5kJywgZnVuY3Rpb24gKGNvbW1hbmQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIF90aGlzLmV4ZWMoY29tbWFuZCwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlLmFkZENvbW1hbmQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgY29tbWFuZCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21hcmtkb3duJykge1xuICAgICAgICAgICAgdGhpcy5tZENvbW1hbmRzW25hbWVdID0gY29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud3dDb21tYW5kc1tuYW1lXSA9IGNvbW1hbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbW1hbmRNYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVDb21tYW5kID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtYXJrZG93bicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1kQ29tbWFuZHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy53d0NvbW1hbmRzW25hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21tYW5kTWFuYWdlci5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChuYW1lLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5nZXRFZGl0b3JUeXBlKCk7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWFya2Rvd24nKSB7XG4gICAgICAgICAgICB0aGlzLm1kQ29tbWFuZHNbbmFtZV0ocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnd3Q29tbWFuZHNbbmFtZV0ocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21tYW5kTWFuYWdlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dFt0ZXh0Lmxlbmd0aCAtIDFdID09PSAnXFxuJyA/IHRleHQuc2xpY2UoMCwgdGV4dC5sZW5ndGggLSAxKSA6IHRleHQ7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUhUTUxJbmxpbmVOb2RlKF9hLCBub2RlKSB7XG4gICAgdmFyIHNjaGVtYSA9IF9hLnNjaGVtYTtcbiAgICB2YXIgaHRtbCA9IG5vZGUubGl0ZXJhbDtcbiAgICB2YXIgbWF0Y2hlZCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICB2YXIgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSAob3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaHRtbElubGluZScgJiYgISEoc2NoZW1hLm1hcmtzW3R5cGVOYW1lXSB8fCBzY2hlbWEubm9kZXNbdHlwZU5hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVOb2RlKF9hKSB7XG4gICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgIHJldHVybiBpbmNsdWRlcyhbJ3RleHQnLCAnc3Ryb25nJywgJ2VtcGgnLCAnc3RyaWtlJywgJ2ltYWdlJywgJ2xpbmsnLCAnY29kZSddLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzU29mdGJyZWFrKG1kTm9kZSkge1xuICAgIHJldHVybiAobWROb2RlID09PSBudWxsIHx8IG1kTm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWROb2RlLnR5cGUpID09PSAnc29mdGJyZWFrJztcbn1cbmZ1bmN0aW9uIGlzTGlzdE5vZGUoX2EpIHtcbiAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIGxpdGVyYWwgPSBfYS5saXRlcmFsO1xuICAgIHZhciBtYXRjaGVkID0gdHlwZSA9PT0gJ2h0bWxJbmxpbmUnICYmIGxpdGVyYWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICB2YXIgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZTtcbiAgICAgICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlcyhbJ3VsJywgJ29sJywgJ2xpJ10sIHRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1BdHRycyhfYSkge1xuICAgIHZhciBsaXRlcmFsID0gX2EubGl0ZXJhbDtcbiAgICB2YXIgdGFzayA9IC9kYXRhLXRhc2svLnRlc3QobGl0ZXJhbCk7XG4gICAgdmFyIGNoZWNrZWQgPSAvZGF0YS10YXNrLWNoZWNrZWQvLnRlc3QobGl0ZXJhbCk7XG4gICAgcmV0dXJuIHsgdGFzazogdGFzaywgY2hlY2tlZDogY2hlY2tlZCB9O1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hlZEF0dHJpYnV0ZVZhbHVlKHJhd0hUTUwpIHtcbiAgICB2YXIgYXR0ck5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXR0ck5hbWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gc2FuaXRpemVIVE1MKHJhd0hUTUwpO1xuICAgIHZhciBlbCA9IHdyYXBwZXIuZmlyc3RDaGlsZDtcbiAgICByZXR1cm4gYXR0ck5hbWVzLm1hcChmdW5jdGlvbiAoYXR0ck5hbWUpIHsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgfHwgJyc7IH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udmVydG9ycyhjb252ZXJ0b3JzKSB7XG4gICAgdmFyIGNvbnZlcnRvck1hcCA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGNvbnZlcnRvcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGFnTmFtZXMgPSBrZXkuc3BsaXQoJywgJyk7XG4gICAgICAgIHRhZ05hbWVzLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29udmVydG9yTWFwW25hbWVdID0gY29udmVydG9yc1trZXldO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29udmVydG9yTWFwO1xufVxudmFyIGNvbnZlcnRvcnMgPSB7XG4gICAgJ2IsIHN0cm9uZyc6IGZ1bmN0aW9uIChzdGF0ZSwgXywgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgdmFyIHN0cm9uZyA9IHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJvbmc7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoc3Ryb25nLmNyZWF0ZSh7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhzdHJvbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAnaSwgZW0nOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBlbXBoID0gc3RhdGUuc2NoZW1hLm1hcmtzLmVtcGg7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoZW1waC5jcmVhdGUoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoZW1waCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgICdzLCBkZWwnOiBmdW5jdGlvbiAoc3RhdGUsIF8sIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBzdHJpa2UgPSBzdGF0ZS5zY2hlbWEubWFya3Muc3RyaWtlO1xuICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKHN0cmlrZS5jcmVhdGUoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoc3RyaWtlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY29kZTogZnVuY3Rpb24gKHN0YXRlLCBfLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgY29kZSA9IHN0YXRlLnNjaGVtYS5tYXJrcy5jb2RlO1xuICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKGNvZGUuY3JlYXRlKHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGNvZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciB0YWcgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgIHZhciBsaW5rID0gc3RhdGUuc2NoZW1hLm1hcmtzLmxpbms7XG4gICAgICAgIGlmIChvcGVuVGFnTmFtZSkge1xuICAgICAgICAgICAgdmFyIGxpbmtVcmwgPSBnZXRNYXRjaGVkQXR0cmlidXRlVmFsdWUodGFnLCAnaHJlZicpWzBdO1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsobGluay5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGxpbmtVcmw6IGxpbmtVcmwsXG4gICAgICAgICAgICAgICAgcmF3SFRNTDogb3BlblRhZ05hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsobGluayk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGltZzogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS5saXRlcmFsO1xuICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldE1hdGNoZWRBdHRyaWJ1dGVWYWx1ZSh0YWcsICdzcmMnLCAnYWx0JyksIGltYWdlVXJsID0gX2FbMF0sIGFsdFRleHQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IHN0YXRlLnNjaGVtYS5ub2Rlcy5pbWFnZTtcbiAgICAgICAgICAgIHN0YXRlLmFkZE5vZGUoaW1hZ2UsIF9fYXNzaWduJDEoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSwgaW1hZ2VVcmw6IGltYWdlVXJsIH0sIChhbHRUZXh0ICYmIHsgYWx0VGV4dDogYWx0VGV4dCB9KSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBocjogZnVuY3Rpb24gKHN0YXRlLCBfLCBvcGVuVGFnTmFtZSkge1xuICAgICAgICBzdGF0ZS5hZGROb2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50aGVtYXRpY0JyZWFrLCB7IHJhd0hUTUw6IG9wZW5UYWdOYW1lIH0pO1xuICAgIH0sXG4gICAgYnI6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICB2YXIgcGFyYWdyYXBoID0gc3RhdGUuc2NoZW1hLm5vZGVzLnBhcmFncmFwaDtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50LCBwcmV2ID0gbm9kZS5wcmV2LCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlKSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBvcGVuIGEgcGFyYWdyYXBoIG5vZGUgd2hlbiBsaW5lIHRleHQgaGFzIG9ubHkgPGJyPiB0YWdcbiAgICAgICAgICAgIC8vIGV4KSBmaXJzdCBsaW5lXFxuXFxuPGJyPlxcbmZvdXJ0aCBsaW5lXG4gICAgICAgICAgICBpZiAoaXNTb2Z0YnJlYWsocHJldikpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2hvdWxkIGNsb3NlIGEgcGFyYWdyYXBoIG5vZGUgd2hlbiBsaW5lIHRleHQgaGFzIG9ubHkgPGJyPiB0YWdcbiAgICAgICAgICAgIC8vIGV4KSBmaXJzdCBsaW5lXFxuXFxuPGJyPlxcbmZvdXJ0aCBsaW5lXG4gICAgICAgICAgICBpZiAoaXNTb2Z0YnJlYWsobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgY2xvc2UgYSBwYXJhZ3JhcGggbm9kZSBhbmQgb3BlbiBhIHBhcmFncmFwaCBub2RlIHRvIHNlcGFyYXRlIGJldHdlZW4gYmxvY2tzXG4gICAgICAgICAgICAgICAgLy8gd2hlbiA8YnI+IHRhZyBpcyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgICAvLyBleCkgZmlyc3QgPGJyPmxpbmVcXG50aGlyZCBsaW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LnR5cGUpID09PSAndGFibGVDZWxsJykge1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgKGlzSW5saW5lTm9kZShwcmV2KSB8fCBpc0N1c3RvbUhUTUxJbmxpbmVOb2RlKHN0YXRlLCBwcmV2KSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIChpc0lubGluZU5vZGUobmV4dCkgfHwgaXNDdXN0b21IVE1MSW5saW5lTm9kZShzdGF0ZSwgbmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgdmFyIGxpdGVyYWwgPSAoX2IgPSAoX2EgPSBjb250YWluZXIuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpcnN0Q2hpbGQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLmNvZGVCbG9jaywgeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9KTtcbiAgICAgICAgc3RhdGUuYWRkVGV4dChnZXRUZXh0V2l0aG91dFRyYWlsaW5nTmV3bGluZShsaXRlcmFsKSk7XG4gICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgIH0sXG4gICAgJ3VsLCBvbCc6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgb3BlblRhZ05hbWUpIHtcbiAgICAgICAgLy8gaW4gdGhlIHRhYmxlIGNlbGwsICc8dWw+JywgJzxvbD4nIGlzIHBhcnNlZCBhcyAnaHRtbElubGluZScgbm9kZVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ3RhYmxlQ2VsbCcpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHN0YXRlLnNjaGVtYS5ub2RlcywgYnVsbGV0TGlzdCA9IF9hLmJ1bGxldExpc3QsIG9yZGVyZWRMaXN0ID0gX2Eub3JkZXJlZExpc3QsIHBhcmFncmFwaCA9IF9hLnBhcmFncmFwaDtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gb3BlblRhZ05hbWUgPT09ICd1bCcgPyBidWxsZXRMaXN0IDogb3JkZXJlZExpc3Q7XG4gICAgICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2ICYmICFpc0xpc3ROb2RlKG5vZGUucHJldikpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKGxpc3QsIHsgcmF3SFRNTDogb3BlblRhZ05hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uZXh0ICYmICFpc0xpc3ROb2RlKG5vZGUubmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxpOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gaW4gdGhlIHRhYmxlIGNlbGwsICc8bGk+JyBpcyBwYXJzZWQgYXMgJ2h0bWxJbmxpbmUnIG5vZGVcbiAgICAgICAgaWYgKCgoX2EgPSBub2RlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAndGFibGVDZWxsJykge1xuICAgICAgICAgICAgdmFyIF9iID0gc3RhdGUuc2NoZW1hLm5vZGVzLCBsaXN0SXRlbSA9IF9iLmxpc3RJdGVtLCBwYXJhZ3JhcGggPSBfYi5wYXJhZ3JhcGg7XG4gICAgICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSBnZXRMaXN0SXRlbUF0dHJzKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXYgJiYgIWlzTGlzdE5vZGUobm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUobGlzdEl0ZW0sIF9fYXNzaWduJDEoeyByYXdIVE1MOiBvcGVuVGFnTmFtZSB9LCBhdHRycykpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHQgJiYgIWlzTGlzdE5vZGUobm9kZS5uZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXYgJiYgIWlzTGlzdE5vZGUobm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbnZhciBodG1sVG9Xd0NvbnZlcnRvcnMgPSBjcmVhdGVDb252ZXJ0b3JzKGNvbnZlcnRvcnMpO1xuXG5mdW5jdGlvbiBpc0JSVGFnKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaHRtbElubGluZScgJiYgcmVCUi50ZXN0KG5vZGUubGl0ZXJhbCk7XG59XG5mdW5jdGlvbiBhZGRSYXdIVE1MQXR0cmlidXRlVG9ET00ocGFyZW50KSB7XG4gICAgdG9BcnJheV8xKHBhcmVudC5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoaXNFbGVtTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmF3LWh0bWwnLCBvcGVuVGFnTmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hpbGQuY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgICAgIGFkZFJhd0hUTUxBdHRyaWJ1dGVUb0RPTShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnZhciB0b1d3Q29udmVydG9ycyA9IHtcbiAgICB0ZXh0OiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgc3RhdGUuYWRkVGV4dChub2RlLmxpdGVyYWwgfHwgJycpO1xuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBwYXJhZ3JhcGggPSBzdGF0ZS5zY2hlbWEubm9kZXMucGFyYWdyYXBoO1xuICAgICAgICAgICAgLy8gVGhlIGBcXG5cXG5gIGVudGVyZWQgaW4gbWFya2Rvd24gc2VwYXJhdGVzIHRoZSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBXaGVuIGNoYW5naW5nIHRvIHd5c2l3eWcsIGEgbmV3bGluZSBpcyBhZGRlZCBiZXR3ZWVuIHRoZSB0d28gcGFyYWdyYXBocy5cbiAgICAgICAgICAgIGlmICgoKF9iID0gbm9kZS5wcmV2KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZSkgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoLCBjdXN0b21BdHRycyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoZWFkaW5nOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBub2RlLCBsZXZlbCA9IF9iLmxldmVsLCBoZWFkaW5nVHlwZSA9IF9iLmhlYWRpbmdUeXBlO1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLmhlYWRpbmcsIF9fYXNzaWduJDEoeyBsZXZlbDogbGV2ZWwsIGhlYWRpbmdUeXBlOiBoZWFkaW5nVHlwZSB9LCBjdXN0b21BdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgY29kZUJsb2NrID0gc3RhdGUuc2NoZW1hLm5vZGVzLmNvZGVCbG9jaztcbiAgICAgICAgdmFyIF9hID0gbm9kZSwgaW5mbyA9IF9hLmluZm8sIGxpdGVyYWwgPSBfYS5saXRlcmFsO1xuICAgICAgICBzdGF0ZS5vcGVuTm9kZShjb2RlQmxvY2ssIF9fYXNzaWduJDEoeyBsYW5ndWFnZTogaW5mbyB9LCBjdXN0b21BdHRycykpO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKGxpdGVyYWwgfHwgJycpKTtcbiAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgfSxcbiAgICBsaXN0OiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIGJ1bGxldExpc3QgPSBfYi5idWxsZXRMaXN0LCBvcmRlcmVkTGlzdCA9IF9iLm9yZGVyZWRMaXN0O1xuICAgICAgICAgICAgdmFyIF9jID0gbm9kZS5saXN0RGF0YSwgdHlwZSA9IF9jLnR5cGUsIHN0YXJ0ID0gX2Muc3RhcnQ7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2J1bGxldCcpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShidWxsZXRMaXN0LCBjdXN0b21BdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShvcmRlcmVkTGlzdCwgX19hc3NpZ24kMSh7IG9yZGVyOiBzdGFydCB9LCBjdXN0b21BdHRycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSBzdGF0ZS5zY2hlbWEubm9kZXMubGlzdEl0ZW07XG4gICAgICAgIHZhciBfYiA9IG5vZGUubGlzdERhdGEsIHRhc2sgPSBfYi50YXNrLCBjaGVja2VkID0gX2IuY2hlY2tlZDtcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgKHRhc2sgJiYgeyB0YXNrOiB0YXNrIH0pKSwgKGNoZWNrZWQgJiYgeyBjaGVja2VkOiBjaGVja2VkIH0pKSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUobGlzdEl0ZW0sIGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBibG9ja1F1b3RlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuYmxvY2tRdW90ZSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGltYWdlOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZywgc2tpcENoaWxkcmVuID0gX2Euc2tpcENoaWxkcmVuO1xuICAgICAgICB2YXIgaW1hZ2UgPSBzdGF0ZS5zY2hlbWEubm9kZXMuaW1hZ2U7XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIGRlc3RpbmF0aW9uID0gX2IuZGVzdGluYXRpb24sIGZpcnN0Q2hpbGQgPSBfYi5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgc2tpcENoaWxkcmVuKSB7XG4gICAgICAgICAgICBza2lwQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5hZGROb2RlKGltYWdlLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoeyBpbWFnZVVybDogZGVzdGluYXRpb24gfSwgKGZpcnN0Q2hpbGQgJiYgeyBhbHRUZXh0OiBmaXJzdENoaWxkLmxpdGVyYWwgfSkpLCBjdXN0b21BdHRycykpO1xuICAgIH0sXG4gICAgdGhlbWF0aWNCcmVhazogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfLCBjdXN0b21BdHRycykge1xuICAgICAgICBzdGF0ZS5hZGROb2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50aGVtYXRpY0JyZWFrLCBjdXN0b21BdHRycyk7XG4gICAgfSxcbiAgICBzdHJvbmc6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgc3Ryb25nID0gc3RhdGUuc2NoZW1hLm1hcmtzLnN0cm9uZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTWFyayhzdHJvbmcuY3JlYXRlKGN1c3RvbUF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU1hcmsoc3Ryb25nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW1waDogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBlbXBoID0gc3RhdGUuc2NoZW1hLm1hcmtzLmVtcGg7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoZW1waC5jcmVhdGUoY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhlbXBoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHZhciBsaW5rID0gc3RhdGUuc2NoZW1hLm1hcmtzLmxpbms7XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIGRlc3RpbmF0aW9uID0gX2IuZGVzdGluYXRpb24sIHRpdGxlID0gX2IudGl0bGU7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gX19hc3NpZ24kMSh7IGxpbmtVcmw6IGRlc3RpbmF0aW9uLCB0aXRsZTogdGl0bGUgfSwgY3VzdG9tQXR0cnMpO1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsobGluay5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhsaW5rKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc29mdGJyZWFrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IG5vZGUucHJldiwgbmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmICFpc0JSVGFnKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAhaXNCUlRhZyhuZXh0KSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy5wYXJhZ3JhcGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBHRk0gc3BlY2lmaWNhdGlvbnMgbm9kZVxuICAgIHRhYmxlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMudGFibGUsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUhlYWQ6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50YWJsZUhlYWQsIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0YWJsZUJvZHk6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EsIGN1c3RvbUF0dHJzKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHN0YXRlLm9wZW5Ob2RlKHN0YXRlLnNjaGVtYS5ub2Rlcy50YWJsZUJvZHksIGN1c3RvbUF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0YWJsZVJvdzogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSwgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLnRhYmxlUm93LCBjdXN0b21BdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGFibGVDZWxsOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICBpZiAoIW5vZGUuaWdub3JlZCkge1xuICAgICAgICAgICAgdmFyIGhhc1BhcmFOb2RlID0gZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGUgJiYgKGlzSW5saW5lTm9kZShjaGlsZE5vZGUpIHx8IGlzQ3VzdG9tSFRNTElubGluZU5vZGUoc3RhdGUsIGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IHN0YXRlLnNjaGVtYS5ub2RlcywgdGFibGVIZWFkQ2VsbCA9IF9iLnRhYmxlSGVhZENlbGwsIHRhYmxlQm9keUNlbGwgPSBfYi50YWJsZUJvZHlDZWxsLCBwYXJhZ3JhcGggPSBfYi5wYXJhZ3JhcGg7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlUGFydCA9IG5vZGUucGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRhYmxlUGFydC50eXBlID09PSAndGFibGVIZWFkJyA/IHRhYmxlSGVhZENlbGwgOiB0YWJsZUJvZHlDZWxsO1xuICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHRhYmxlUGFydC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGFsaWduID0gKHRhYmxlLmNvbHVtbnNbbm9kZS5zdGFydElkeF0gfHwge30pLmFsaWduO1xuICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IF9fYXNzaWduJDEoe30sIG5vZGUuYXR0cnMpO1xuICAgICAgICAgICAgICAgIGlmIChhbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5hbGlnbiA9IGFsaWduO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShjZWxsLCBhdHRycyk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc1BhcmFOb2RlKG5vZGUuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUub3Blbk5vZGUocGFyYWdyYXBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUGFyYU5vZGUobm9kZS5sYXN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RyaWtlOiBmdW5jdGlvbiAoc3RhdGUsIF8sIF9hLCBjdXN0b21BdHRycykge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIHN0cmlrZSA9IHN0YXRlLnNjaGVtYS5tYXJrcy5zdHJpa2U7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgc3RhdGUub3Blbk1hcmsoc3RyaWtlLmNyZWF0ZShjdXN0b21BdHRycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VNYXJrKHN0cmlrZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvZGU6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSwgXywgY3VzdG9tQXR0cnMpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdGF0ZS5zY2hlbWEubWFya3MuY29kZTtcbiAgICAgICAgc3RhdGUub3Blbk1hcmsoY29kZS5jcmVhdGUoY3VzdG9tQXR0cnMpKTtcbiAgICAgICAgc3RhdGUuYWRkVGV4dChnZXRUZXh0V2l0aG91dFRyYWlsaW5nTmV3bGluZShub2RlLmxpdGVyYWwgfHwgJycpKTtcbiAgICAgICAgc3RhdGUuY2xvc2VNYXJrKGNvZGUpO1xuICAgIH0sXG4gICAgY3VzdG9tQmxvY2s6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICB2YXIgX2EgPSBzdGF0ZS5zY2hlbWEubm9kZXMsIGN1c3RvbUJsb2NrID0gX2EuY3VzdG9tQmxvY2ssIHBhcmFncmFwaCA9IF9hLnBhcmFncmFwaDtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgaW5mbyA9IF9iLmluZm8sIGxpdGVyYWwgPSBfYi5saXRlcmFsO1xuICAgICAgICBzdGF0ZS5vcGVuTm9kZShjdXN0b21CbG9jaywgeyBpbmZvOiBpbmZvIH0pO1xuICAgICAgICBzdGF0ZS5hZGRUZXh0KGdldFRleHRXaXRob3V0VHJhaWxpbmdOZXdsaW5lKGxpdGVyYWwgfHwgJycpKTtcbiAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIC8vIGFkZCBlbXB0eSBsaW5lIHRvIGVkaXQgdGhlIGNvbnRlbnQgaW4gbmV4dCBsaW5lXG4gICAgICAgIGlmICghbm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShwYXJhZ3JhcGgpO1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGZyb250TWF0dGVyOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgc3RhdGUub3Blbk5vZGUoc3RhdGUuc2NoZW1hLm5vZGVzLmZyb250TWF0dGVyKTtcbiAgICAgICAgc3RhdGUuYWRkVGV4dChub2RlLmxpdGVyYWwpO1xuICAgICAgICBzdGF0ZS5jbG9zZU5vZGUoKTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uIChzdGF0ZSwgbm9kZSkge1xuICAgICAgICB2YXIgaHRtbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBodG1sLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgIHZhciB0eXBlTmFtZSA9IChvcGVuVGFnTmFtZSB8fCBjbG9zZVRhZ05hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBtYXJrVHlwZSA9IHN0YXRlLnNjaGVtYS5tYXJrc1t0eXBlTmFtZV07XG4gICAgICAgIHZhciBzYW5pdGl6ZWRIVE1MID0gc2FuaXRpemVIVE1MKGh0bWwpO1xuICAgICAgICAvLyBmb3IgdXNlciBkZWZpbmVkIGh0bWwgc2NoZW1hXG4gICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbnVsbCB8fCBtYXJrVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFya1R5cGUuc3BlYy5hdHRycy5odG1sSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAob3BlblRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbEF0dHJzID0gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKHNhbml0aXplZEhUTUwpO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5NYXJrKG1hcmtUeXBlLmNyZWF0ZSh7IGh0bWxBdHRyczogaHRtbEF0dHJzIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNsb3NlTWFyayhtYXJrVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaHRtbFRvV3dDb252ZXJ0b3IgPSBodG1sVG9Xd0NvbnZlcnRvcnNbdHlwZU5hbWVdO1xuICAgICAgICAgICAgaWYgKGh0bWxUb1d3Q29udmVydG9yKSB7XG4gICAgICAgICAgICAgICAgaHRtbFRvV3dDb252ZXJ0b3Ioc3RhdGUsIG5vZGUsIG9wZW5UYWdOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaHRtbEJsb2NrOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBub2RlLmxpdGVyYWw7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIGlzSFRNTENvbW1lbnQgPSByZUhUTUxDb21tZW50LnRlc3QoaHRtbCk7XG4gICAgICAgIGlmIChpc0hUTUxDb21tZW50KSB7XG4gICAgICAgICAgICBzdGF0ZS5vcGVuTm9kZShzdGF0ZS5zY2hlbWEubm9kZXMuaHRtbENvbW1lbnQpO1xuICAgICAgICAgICAgc3RhdGUuYWRkVGV4dChub2RlLmxpdGVyYWwpO1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKTtcbiAgICAgICAgICAgIHZhciBvcGVuVGFnTmFtZSA9IG1hdGNoZWRbMV0sIGNsb3NlVGFnTmFtZSA9IG1hdGNoZWRbM107XG4gICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSAob3BlblRhZ05hbWUgfHwgY2xvc2VUYWdOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gc3RhdGUuc2NoZW1hLm5vZGVzW3R5cGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRIVE1MID0gc2FuaXRpemVIVE1MKGh0bWwpO1xuICAgICAgICAgICAgLy8gZm9yIHVzZXIgZGVmaW5lZCBodG1sIHNjaGVtYVxuICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSBudWxsIHx8IG5vZGVUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlVHlwZS5zcGVjLmF0dHJzLmh0bWxCbG9jaykge1xuICAgICAgICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBnZXRIVE1MQXR0cnNCeUhUTUxTdHJpbmcoc2FuaXRpemVkSFRNTCk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuSFRNTCA9IGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuYWRkTm9kZShub2RlVHlwZSwgeyBodG1sQXR0cnM6IGh0bWxBdHRycywgY2hpbGRyZW5IVE1MOiBjaGlsZHJlbkhUTUwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gc2FuaXRpemVkSFRNTDtcbiAgICAgICAgICAgICAgICBhZGRSYXdIVE1MQXR0cmlidXRlVG9ET00oY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb252ZXJ0QnlET01QYXJzZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3VzdG9tSW5saW5lOiBmdW5jdGlvbiAoc3RhdGUsIG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIGluZm8gPSBfYi5pbmZvLCBmaXJzdENoaWxkID0gX2IuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIHNjaGVtYSA9IHN0YXRlLnNjaGVtYTtcbiAgICAgICAgaWYgKGluZm8uaW5kZXhPZignd2lkZ2V0JykgIT09IC0xICYmIGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGdldFdpZGdldENvbnRlbnQobm9kZSk7XG4gICAgICAgICAgICBza2lwQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHN0YXRlLmFkZE5vZGUoc2NoZW1hLm5vZGVzLndpZGdldCwgeyBpbmZvOiBpbmZvIH0sIFtcbiAgICAgICAgICAgICAgICBzY2hlbWEudGV4dChjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIGNvbnRlbnQpKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAnJCQnO1xuICAgICAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBmaXJzdENoaWxkID8gaW5mbyArIFwiIFwiIDogaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLmFkZFRleHQodGV4dCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVd3Q29udmVydG9ycyhjdXN0b21Db252ZXJ0b3JzKSB7XG4gICAgdmFyIGN1c3RvbUNvbnZlcnRvclR5cGVzID0gT2JqZWN0LmtleXMoY3VzdG9tQ29udmVydG9ycyk7XG4gICAgdmFyIGNvbnZlcnRvcnMgPSBfX2Fzc2lnbiQxKHt9LCB0b1d3Q29udmVydG9ycyk7XG4gICAgdmFyIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHtcbiAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICBub2RlSWQ6IHRydWUsXG4gICAgICAgIGNvbnZlcnRvcnM6IGN1c3RvbUNvbnZlcnRvcnMsXG4gICAgfSk7XG4gICAgdmFyIG9yZ0NvbnZlcnRvcnMgPSByZW5kZXJlci5nZXRDb252ZXJ0b3JzKCk7XG4gICAgY3VzdG9tQ29udmVydG9yVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgd3dDb252ZXJ0b3IgPSB0b1d3Q29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgaWYgKHd3Q29udmVydG9yICYmICFpbmNsdWRlcyhbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10sIHR5cGUpKSB7XG4gICAgICAgICAgICBjb252ZXJ0b3JzW3R5cGVdID0gZnVuY3Rpb24gKHN0YXRlLCBub2RlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5vcmlnaW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmdDb252ZXJ0b3JzW3R5cGVdKG5vZGUsIGNvbnRleHQsIG9yZ0NvbnZlcnRvcnMpOyB9O1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBjdXN0b21Db252ZXJ0b3JzW3R5cGVdKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciBhdHRycztcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IEFycmF5LmlzQXJyYXkodG9rZW5zKSA/IHRva2Vuc1swXSA6IHRva2VucywgaHRtbEF0dHJzID0gX2EuYXR0cmlidXRlcywgY2xhc3NOYW1lcyA9IF9hLmNsYXNzTmFtZXM7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzID0geyBodG1sQXR0cnM6IGh0bWxBdHRycywgY2xhc3NOYW1lczogY2xhc3NOYW1lcyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3d0NvbnZlcnRvcihzdGF0ZSwgbm9kZSwgY29udGV4dCwgYXR0cnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb252ZXJ0b3JzO1xufVxuXG5mdW5jdGlvbiBtZXJnZU1hcmtUZXh0KGEsIGIpIHtcbiAgICBpZiAoYS5pc1RleHQgJiYgYi5pc1RleHQgJiYgTWFyayQxLnNhbWVTZXQoYS5tYXJrcywgYi5tYXJrcykpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAvLyB0eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBcIndpdGhUZXh0XCIgaW4gcHJvc2VtaXJyb3ItbW9kZWxcbiAgICAgICAgcmV0dXJuIGEud2l0aFRleHQoYS50ZXh0ICsgYi50ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIFRvV3dDb252ZXJ0b3JTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb1d3Q29udmVydG9yU3RhdGUoc2NoZW1hLCBjb252ZXJ0b3JzKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmNvbnZlcnRvcnMgPSBjb252ZXJ0b3JzO1xuICAgICAgICB0aGlzLnN0YWNrID0gW3sgdHlwZTogdGhpcy5zY2hlbWEudG9wTm9kZVR5cGUsIGF0dHJzOiBudWxsLCBjb250ZW50OiBbXSB9XTtcbiAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmskMS5ub25lO1xuICAgIH1cbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3QkMSh0aGlzLnN0YWNrKTtcbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50b3AoKS5jb250ZW50LnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvV3dDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuYWRkVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLnRvcCgpLmNvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGUgPSBsYXN0JDEobm9kZXMpO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnNjaGVtYS50ZXh0KHRleHQsIHRoaXMubWFya3MpO1xuICAgICAgICAgICAgdmFyIG1lcmdlZCA9IGxhc3ROb2RlICYmIG1lcmdlTWFya1RleHQobGFzdE5vZGUsIG5vZGUpO1xuICAgICAgICAgICAgaWYgKG1lcmdlZCkge1xuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbWVyZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5vcGVuTWFyayA9IGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrLmFkZFRvU2V0KHRoaXMubWFya3MpO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jbG9zZU1hcmsgPSBmdW5jdGlvbiAobWFyaykge1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFyay5yZW1vdmVGcm9tU2V0KHRoaXMubWFya3MpO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24gKHR5cGUsIGF0dHJzLCBjb250ZW50KSB7XG4gICAgICAgIHZhciBub2RlID0gdHlwZS5jcmVhdGVBbmRGaWxsKGF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5vcGVuTm9kZSA9IGZ1bmN0aW9uICh0eXBlLCBhdHRycykge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2goeyB0eXBlOiB0eXBlLCBhdHRyczogYXR0cnMsIGNvbnRlbnQ6IFtdIH0pO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jbG9zZU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmskMS5ub25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhY2sucG9wKCksIHR5cGUgPSBfYS50eXBlLCBhdHRycyA9IF9hLmF0dHJzLCBjb250ZW50ID0gX2EuY29udGVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZSh0eXBlLCBhdHRycywgY29udGVudCk7XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRCeURPTVBhcnNlciA9IGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkb2MgPSBET01QYXJzZXIuZnJvbVNjaGVtYSh0aGlzLnNjaGVtYSkucGFyc2Uocm9vdCk7XG4gICAgICAgIGRvYy5jb250ZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnB1c2gobm9kZSk7IH0pO1xuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jbG9zZVVubWF0Y2hlZEhUTUxJbmxpbmUgPSBmdW5jdGlvbiAobm9kZSwgZW50ZXJpbmcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWVudGVyaW5nICYmIG5vZGUudHlwZSAhPT0gJ2h0bWxJbmxpbmUnKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoXzE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmZvID0gdGhpcy5zdGFja1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gbm9kZUluZm8uYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yYXdIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlSW5mby5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZU5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcG9wIHVzZWxlc3MgdW5tYXRjaGVkIGh0bWwgaW5saW5lIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9Xd0NvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG1kTm9kZSwgaW5mb0ZvclBvc1N5bmMpIHtcbiAgICAgICAgdmFyIHdhbGtlciA9IG1kTm9kZS53YWxrZXIoKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgICAgICB2YXIgY29udmVydG9yID0gdGhpc18xLmNvbnZlcnRvcnNbbm9kZS50eXBlXTtcbiAgICAgICAgICAgIHZhciBza2lwcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29udmVydG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyaW5nOiBlbnRlcmluZyxcbiAgICAgICAgICAgICAgICAgICAgbGVhZjogIWlzQ29udGFpbmVyJDIobm9kZSksXG4gICAgICAgICAgICAgICAgICAgIGdldENoaWxkcmVuVGV4dDogZ2V0Q2hpbGRyZW5UZXh0JDEsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHsgZ2ZtOiB0cnVlLCBub2RlSWQ6IGZhbHNlLCB0YWdGaWx0ZXI6IGZhbHNlLCBzb2Z0YnJlYWs6ICdcXG4nIH0sXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzXzEuY2xvc2VVbm1hdGNoZWRIVE1MSW5saW5lKG5vZGUsIGVudGVyaW5nKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3IodGhpc18xLCBub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoKGluZm9Gb3JQb3NTeW5jID09PSBudWxsIHx8IGluZm9Gb3JQb3NTeW5jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvRm9yUG9zU3luYy5ub2RlKSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpc18xLnN0YWNrLnJlZHVjZShmdW5jdGlvbiAobm9kZVNpemUsIHN0YWNrSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVTaXplICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0l0ZW0uY29udGVudC5yZWR1Y2UoZnVuY3Rpb24gKGNvbnRlbnRTaXplLCBwbU5vZGUpIHsgcmV0dXJuIGNvbnRlbnRTaXplICsgcG1Ob2RlLm5vZGVTaXplOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpbmZvRm9yUG9zU3luYy5zZXRNYXBwZWRQb3MocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgIHdhbGtlci5yZXN1bWVBdChub2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50ID0gd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChldmVudCkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb1d3Q29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnROb2RlID0gZnVuY3Rpb24gKG1kTm9kZSwgaW5mb0ZvclBvc1N5bmMpIHtcbiAgICAgICAgdGhpcy5jb252ZXJ0KG1kTm9kZSwgaW5mb0ZvclBvc1N5bmMpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFRvV3dDb252ZXJ0b3JTdGF0ZTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb1Jhd0hUTUxIYXZpbmdJbmxpbmVzKHN0YXRlLCBub2RlLCBfYSkge1xuICAgIHZhciBvcGVuVGFnID0gX2FbMF0sIGNsb3NlVGFnID0gX2FbMV07XG4gICAgc3RhdGUud3JpdGUob3BlblRhZyk7XG4gICAgc3RhdGUuY29udmVydElubGluZShub2RlKTtcbiAgICBzdGF0ZS53cml0ZShjbG9zZVRhZyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9SYXdIVE1MSGF2aW5nQmxvY2tzKHN0YXRlLCBfYSwgX2IpIHtcbiAgICB2YXIgbm9kZSA9IF9hLm5vZGUsIHBhcmVudCA9IF9hLnBhcmVudDtcbiAgICB2YXIgb3BlblRhZyA9IF9iWzBdLCBjbG9zZVRhZyA9IF9iWzFdO1xuICAgIHN0YXRlLnN0b3BOZXdsaW5lID0gdHJ1ZTtcbiAgICBzdGF0ZS53cml0ZShvcGVuVGFnKTtcbiAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICBzdGF0ZS53cml0ZShjbG9zZVRhZyk7XG4gICAgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQudHlwZS5uYW1lKSA9PT0gJ2RvYycpIHtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICAgICAgc3RhdGUuc3RvcE5ld2xpbmUgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZUhlYWREZWxpbSh0ZXh0Q29udGVudCwgY29sdW1uQWxpZ24pIHtcbiAgICB2YXIgdGV4dExlbiA9IHRleHRDb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgbGVmdERlbGltID0gJyc7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSAnJztcbiAgICBpZiAoY29sdW1uQWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICBsZWZ0RGVsaW0gPSAnOic7XG4gICAgICAgIHRleHRMZW4gLT0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sdW1uQWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9ICc6JztcbiAgICAgICAgdGV4dExlbiAtPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2x1bW5BbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbGVmdERlbGltID0gJzonO1xuICAgICAgICByaWdodERlbGltID0gJzonO1xuICAgICAgICB0ZXh0TGVuIC09IDI7XG4gICAgfVxuICAgIHJldHVybiBcIlwiICsgbGVmdERlbGltICsgcmVwZWF0JDEoJy0nLCBNYXRoLm1heCh0ZXh0TGVuLCAzKSkgKyByaWdodERlbGltO1xufVxudmFyIG5vZGVUeXBlV3JpdGVycyA9IHtcbiAgICB0ZXh0OiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgdGV4dCA9IChfYiA9IG5vZGUudGV4dCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIGlmICgobm9kZS5tYXJrcyB8fCBbXSkuc29tZShmdW5jdGlvbiAobWFyaykgeyByZXR1cm4gbWFyay50eXBlLm5hbWUgPT09ICdsaW5rJzsgfSkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRleHQoZXNjYXBlVGV4dEZvckxpbmsodGV4dCksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnRleHQodGV4dCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGUsIHBhcmVudCA9IF9hLnBhcmVudCwgX2IgPSBfYS5pbmRleCwgaW5kZXggPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xuICAgICAgICBpZiAoc3RhdGUuc3RvcE5ld2xpbmUpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRJbmxpbmUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RDaGlsZE5vZGUgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9ICFmaXJzdENoaWxkTm9kZSAmJiBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIHZhciBwcmV2RW1wdHlOb2RlID0gcHJldk5vZGUgJiYgcHJldk5vZGUuY2hpbGRDb3VudCA9PT0gMDtcbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IGluZGV4IDwgcGFyZW50LmNoaWxkQ291bnQgLSAxICYmIHBhcmVudC5jaGlsZChpbmRleCArIDEpO1xuICAgICAgICAgICAgdmFyIG5leHRQYXJhTm9kZSA9IG5leHROb2RlICYmIG5leHROb2RlLnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICB2YXIgZW1wdHlOb2RlID0gbm9kZS5jaGlsZENvdW50ID09PSAwO1xuICAgICAgICAgICAgaWYgKGVtcHR5Tm9kZSAmJiBwcmV2RW1wdHlOb2RlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUud3JpdGUoJzxicj5cXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5Tm9kZSAmJiAhcHJldkVtcHR5Tm9kZSAmJiAhZmlyc3RDaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC50eXBlLm5hbWUpID09PSAnbGlzdEl0ZW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2RGVsaW0gPSBzdGF0ZS5nZXREZWxpbSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXREZWxpbSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlKCc8YnI+Jyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNldERlbGltKHByZXZEZWxpbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLndyaXRlKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRJbmxpbmUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQYXJhTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS53cml0ZSgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGluZzogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbTtcbiAgICAgICAgdmFyIGhlYWRpbmdUeXBlID0gbm9kZS5hdHRycy5oZWFkaW5nVHlwZTtcbiAgICAgICAgaWYgKGhlYWRpbmdUeXBlID09PSAnYXR4Jykge1xuICAgICAgICAgICAgc3RhdGUud3JpdGUoZGVsaW0gKyBcIiBcIik7XG4gICAgICAgICAgICBzdGF0ZS5jb252ZXJ0SW5saW5lKG5vZGUpO1xuICAgICAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbnZlcnRJbmxpbmUobm9kZSk7XG4gICAgICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShkZWxpbSk7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjb2RlQmxvY2s6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW0sIHRleHQgPSBfYi50ZXh0O1xuICAgICAgICB2YXIgX2MgPSBkZWxpbSwgb3BlbkRlbGltID0gX2NbMF0sIGNsb3NlRGVsaW0gPSBfY1sxXTtcbiAgICAgICAgc3RhdGUud3JpdGUob3BlbkRlbGltKTtcbiAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgICAgICBzdGF0ZS50ZXh0KHRleHQsIGZhbHNlKTtcbiAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgICAgICBzdGF0ZS53cml0ZShjbG9zZURlbGltKTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxuICAgIGJsb2NrUXVvdGU6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgcGFyZW50ID0gX2EucGFyZW50O1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbTtcbiAgICAgICAgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQudHlwZS5uYW1lKSA9PT0gbm9kZS50eXBlLm5hbWUpIHtcbiAgICAgICAgICAgIHN0YXRlLmZsdXNoQ2xvc2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUud3JhcEJsb2NrKGRlbGltLCBudWxsLCBub2RlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTsgfSk7XG4gICAgfSxcbiAgICBidWxsZXRMaXN0OiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBkZWxpbSA9IF9iLmRlbGltO1xuICAgICAgICAvLyBzb2Z0LXRhYig0KVxuICAgICAgICBzdGF0ZS5jb252ZXJ0TGlzdChub2RlLCByZXBlYXQkMSgnICcsIDQpLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWxpbSArIFwiIFwiOyB9KTtcbiAgICB9LFxuICAgIG9yZGVyZWRMaXN0OiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbm9kZS5hdHRycy5vcmRlciB8fCAxO1xuICAgICAgICAvLyBzb2Z0LXRhYig0KVxuICAgICAgICBzdGF0ZS5jb252ZXJ0TGlzdChub2RlLCByZXBlYXQkMSgnICcsIDQpLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBvcmRlcmVkTnVtID0gU3RyaW5nKHN0YXJ0ICsgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIG9yZGVyZWROdW0gKyBcIi4gXCI7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgbGlzdEl0ZW06IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmF0dHJzLCB0YXNrID0gX2IudGFzaywgY2hlY2tlZCA9IF9iLmNoZWNrZWQ7XG4gICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICBzdGF0ZS53cml0ZShcIltcIiArIChjaGVja2VkID8gJ3gnIDogJyAnKSArIFwiXSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgfSxcbiAgICBpbWFnZTogZnVuY3Rpb24gKHN0YXRlLCBfLCBfYSkge1xuICAgICAgICB2YXIgYXR0cnMgPSBfYS5hdHRycztcbiAgICAgICAgc3RhdGUud3JpdGUoXCIhW1wiICsgKGF0dHJzID09PSBudWxsIHx8IGF0dHJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdHRycy5hbHRUZXh0KSArIFwiXShcIiArIChhdHRycyA9PT0gbnVsbCB8fCBhdHRycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXR0cnMuaW1hZ2VVcmwpICsgXCIpXCIpO1xuICAgIH0sXG4gICAgdGhlbWF0aWNCcmVhazogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbTtcbiAgICAgICAgc3RhdGUud3JpdGUoZGVsaW0pO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG4gICAgdGFibGU6IGZ1bmN0aW9uIChzdGF0ZSwgX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0Tm9kZShub2RlKTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZGVsaW0gPSBfYi5kZWxpbTtcbiAgICAgICAgdmFyIHJvdyA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBkZWxpbSAhPT0gbnVsbCAmJiBkZWxpbSAhPT0gdm9pZCAwID8gZGVsaW0gOiAnJztcbiAgICAgICAgaWYgKCFkZWxpbSAmJiByb3cpIHtcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9IF9hLnRleHRDb250ZW50LCBhdHRycyA9IF9hLmF0dHJzO1xuICAgICAgICAgICAgICAgIHZhciBoZWFkRGVsaW0gPSBjcmVhdGVUYWJsZUhlYWREZWxpbSh0ZXh0Q29udGVudCwgYXR0cnMuYWxpZ24pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInwgXCIgKyBoZWFkRGVsaW0gKyBcIiBcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLndyaXRlKHJlc3VsdCArIFwifFwiKTtcbiAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgIH0sXG4gICAgdGFibGVCb2R5OiBmdW5jdGlvbiAoc3RhdGUsIF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgc3RhdGUuY29udmVydE5vZGUobm9kZSk7XG4gICAgfSxcbiAgICB0YWJsZVJvdzogZnVuY3Rpb24gKHN0YXRlLCBfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHN0YXRlLmNvbnZlcnROb2RlKG5vZGUpO1xuICAgICAgICBzdGF0ZS53cml0ZSgnfCcpO1xuICAgICAgICBzdGF0ZS5lbnN1cmVOZXdMaW5lKCk7XG4gICAgfSxcbiAgICB0YWJsZUhlYWRDZWxsOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfYyA9IF9iLmRlbGltLCBkZWxpbSA9IF9jID09PSB2b2lkIDAgPyAnfCAnIDogX2M7XG4gICAgICAgIHN0YXRlLndyaXRlKGRlbGltKTtcbiAgICAgICAgc3RhdGUuY29udmVydFRhYmxlQ2VsbChub2RlKTtcbiAgICAgICAgc3RhdGUud3JpdGUoJyAnKTtcbiAgICB9LFxuICAgIHRhYmxlQm9keUNlbGw6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9jID0gX2IuZGVsaW0sIGRlbGltID0gX2MgPT09IHZvaWQgMCA/ICd8ICcgOiBfYztcbiAgICAgICAgc3RhdGUud3JpdGUoZGVsaW0pO1xuICAgICAgICBzdGF0ZS5jb252ZXJ0VGFibGVDZWxsKG5vZGUpO1xuICAgICAgICBzdGF0ZS53cml0ZSgnICcpO1xuICAgIH0sXG4gICAgY3VzdG9tQmxvY2s6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGRlbGltID0gX2IuZGVsaW0sIHRleHQgPSBfYi50ZXh0O1xuICAgICAgICB2YXIgX2MgPSBkZWxpbSwgb3BlbkRlbGltID0gX2NbMF0sIGNsb3NlRGVsaW0gPSBfY1sxXTtcbiAgICAgICAgc3RhdGUud3JpdGUob3BlbkRlbGltKTtcbiAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgICAgICBzdGF0ZS50ZXh0KHRleHQsIGZhbHNlKTtcbiAgICAgICAgc3RhdGUuZW5zdXJlTmV3TGluZSgpO1xuICAgICAgICBzdGF0ZS53cml0ZShjbG9zZURlbGltKTtcbiAgICAgICAgc3RhdGUuY2xvc2VCbG9jayhub2RlKTtcbiAgICB9LFxuICAgIGZyb250TWF0dGVyOiBmdW5jdGlvbiAoc3RhdGUsIF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciB0ZXh0ID0gX2IudGV4dDtcbiAgICAgICAgc3RhdGUudGV4dCh0ZXh0LCBmYWxzZSk7XG4gICAgICAgIHN0YXRlLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfSxcbiAgICB3aWRnZXQ6IGZ1bmN0aW9uIChzdGF0ZSwgXywgX2EpIHtcbiAgICAgICAgdmFyIHRleHQgPSBfYS50ZXh0O1xuICAgICAgICBzdGF0ZS53cml0ZSh0ZXh0KTtcbiAgICB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uIChzdGF0ZSwgX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIHRleHQgPSBfYi50ZXh0O1xuICAgICAgICBzdGF0ZS53cml0ZSh0ZXh0KTtcbiAgICAgICAgaWYgKG5vZGUuYXR0cnMuaHRtbEJsb2NrKSB7XG4gICAgICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBodG1sQ29tbWVudDogZnVuY3Rpb24gKHN0YXRlLCBfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgdGV4dCA9IF9iLnRleHQ7XG4gICAgICAgIHN0YXRlLndyaXRlKHRleHQpO1xuICAgICAgICBzdGF0ZS5jbG9zZUJsb2NrKG5vZGUpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gd3JpdGUodHlwZSwgX2EpIHtcbiAgICB2YXIgc3RhdGUgPSBfYS5zdGF0ZSwgbm9kZUluZm8gPSBfYS5ub2RlSW5mbywgcGFyYW1zID0gX2EucGFyYW1zO1xuICAgIHZhciByYXdIVE1MID0gcGFyYW1zLnJhd0hUTUw7XG4gICAgaWYgKHJhd0hUTUwpIHtcbiAgICAgICAgaWYgKGluQXJyYXlfMSh0eXBlLCBbJ2hlYWRpbmcnLCAnY29kZUJsb2NrJ10pID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnZlcnRUb1Jhd0hUTUxIYXZpbmdJbmxpbmVzKHN0YXRlLCBub2RlSW5mby5ub2RlLCByYXdIVE1MKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbkFycmF5XzEodHlwZSwgWydpbWFnZScsICd0aGVtYXRpY0JyZWFrJ10pID4gLTEpIHtcbiAgICAgICAgICAgIHN0YXRlLndyaXRlKHJhd0hUTUwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udmVydFRvUmF3SFRNTEhhdmluZ0Jsb2NrcyhzdGF0ZSwgbm9kZUluZm8sIHJhd0hUTUwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlVHlwZVdyaXRlcnNbdHlwZV0oc3RhdGUsIG5vZGVJbmZvLCBwYXJhbXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkQmFja3RpY2tzKG5vZGUsIHNpZGUpIHtcbiAgICB2YXIgdGV4dCA9IG5vZGUudGV4dDtcbiAgICB2YXIgdGlja3MgPSAvYCsvZztcbiAgICB2YXIgbGVuID0gMDtcbiAgICBpZiAobm9kZS5pc1RleHQgJiYgdGV4dCkge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IHRpY2tzLmV4ZWModGV4dCk7XG4gICAgICAgIHdoaWxlIChtYXRjaGVkKSB7XG4gICAgICAgICAgICBsZW4gPSBNYXRoLm1heChsZW4sIG1hdGNoZWRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hdGNoZWQgPSB0aWNrcy5leGVjKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBsZW4gPiAwICYmIHNpZGUgPiAwID8gJyBgJyA6ICdgJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlc3VsdCArPSAnYCc7XG4gICAgfVxuICAgIGlmIChsZW4gPiAwICYmIHNpZGUgPCAwKSB7XG4gICAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQYWlyUmF3SFRNTChyYXdIVE1MKSB7XG4gICAgcmV0dXJuIHJhd0hUTUwgPyBbXCI8XCIgKyByYXdIVE1MICsgXCI+XCIsIFwiPC9cIiArIHJhd0hUTUwgKyBcIj5cIl0gOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0T3BlblJhd0hUTUwocmF3SFRNTCkge1xuICAgIHJldHVybiByYXdIVE1MID8gXCI8XCIgKyByYXdIVE1MICsgXCI+XCIgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VSYXdIVE1MKHJhd0hUTUwpIHtcbiAgICByZXR1cm4gcmF3SFRNTCA/IFwiPC9cIiArIHJhd0hUTUwgKyBcIj5cIiA6IG51bGw7XG59XG52YXIgdG9NZENvbnZlcnRvcnMgPSB7XG4gICAgaGVhZGluZzogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycztcbiAgICAgICAgdmFyIGxldmVsID0gYXR0cnMubGV2ZWw7XG4gICAgICAgIHZhciBkZWxpbSA9IHJlcGVhdCQxKCcjJywgbGV2ZWwpO1xuICAgICAgICBpZiAoYXR0cnMuaGVhZGluZ1R5cGUgPT09ICdzZXRleHQnKSB7XG4gICAgICAgICAgICBkZWxpbSA9IGxldmVsID09PSAxID8gJz09PScgOiAnLS0tJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06IGRlbGltLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwoYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlQmxvY2s6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIGF0dHJzID0gX2IuYXR0cnMsIHRleHRDb250ZW50ID0gX2IudGV4dENvbnRlbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogW1wiYGBgXCIgKyAoYXR0cnMubGFuZ3VhZ2UgfHwgJycpLCAnYGBgJ10sXG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChhdHRycy5yYXdIVE1MKSxcbiAgICAgICAgICAgIHRleHQ6IHRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnPiAnLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGJ1bGxldExpc3Q6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgaW5UYWJsZSA9IF9iLmluVGFibGU7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICBpZiAoaW5UYWJsZSkge1xuICAgICAgICAgICAgcmF3SFRNTCA9IHJhd0hUTUwgfHwgJ3VsJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICcqJyxcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKHJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb3JkZXJlZExpc3Q6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgaW5UYWJsZSA9IF9iLmluVGFibGU7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICBpZiAoaW5UYWJsZSkge1xuICAgICAgICAgICAgcmF3SFRNTCA9IHJhd0hUTUwgfHwgJ29sJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBsaXN0SXRlbTogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBpblRhYmxlID0gX2IuaW5UYWJsZTtcbiAgICAgICAgdmFyIF9jID0gbm9kZS5hdHRycywgdGFzayA9IF9jLnRhc2ssIGNoZWNrZWQgPSBfYy5jaGVja2VkO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IG5vZGUuYXR0cnMucmF3SFRNTDtcbiAgICAgICAgaWYgKGluVGFibGUpIHtcbiAgICAgICAgICAgIHJhd0hUTUwgPSByYXdIVE1MIHx8ICdsaSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRhc2sgPyBcIiBjbGFzcz1cXFwidGFzay1saXN0LWl0ZW1cIiArIChjaGVja2VkID8gJyBjaGVja2VkJyA6ICcnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIHZhciBkYXRhc2V0ID0gdGFzayA/IFwiIGRhdGEtdGFza1wiICsgKGNoZWNrZWQgPyBcIiBkYXRhLXRhc2stY2hlY2tlZFwiIDogJycpIDogJyc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiByYXdIVE1MID8gW1wiPFwiICsgcmF3SFRNTCArIGNsYXNzTmFtZSArIGRhdGFzZXQgKyBcIj5cIiwgXCI8L1wiICsgcmF3SFRNTCArIFwiPlwiXSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZUhlYWQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVCb2R5OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3SFRNTDogZ2V0UGFpclJhd0hUTUwobm9kZS5hdHRycy5yYXdIVE1MKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZENlbGw6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXdIVE1MOiBnZXRQYWlyUmF3SFRNTChub2RlLmF0dHJzLnJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGFibGVCb2R5Q2VsbDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldFBhaXJSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpbWFnZTogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGF0dHJzID0gbm9kZS5hdHRycztcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBhdHRycy5yYXdIVE1MLCBhbHRUZXh0ID0gYXR0cnMuYWx0VGV4dDtcbiAgICAgICAgdmFyIGltYWdlVXJsID0gYXR0cnMuaW1hZ2VVcmwucmVwbGFjZSgvJmFtcDsvZywgJyYnKTtcbiAgICAgICAgdmFyIGFsdEF0dHIgPSBhbHRUZXh0ID8gXCIgYWx0PVxcXCJcIiArIGVzY2FwZVhtbCQxKGFsdFRleHQpICsgXCJcXFwiXCIgOiAnJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd0hUTUw6IHJhd0hUTUwgPyBcIjxcIiArIHJhd0hUTUwgKyBcIiBzcmM9XFxcIlwiICsgZXNjYXBlWG1sJDEoaW1hZ2VVcmwpICsgXCJcXFwiXCIgKyBhbHRBdHRyICsgXCI+XCIgOiBudWxsLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBhbHRUZXh0OiBlc2NhcGVUZXh0Rm9yTGluayhhbHRUZXh0IHx8ICcnKSxcbiAgICAgICAgICAgICAgICBpbWFnZVVybDogaW1hZ2VVcmwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGhlbWF0aWNCcmVhazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiAnKioqJyxcbiAgICAgICAgICAgIHJhd0hUTUw6IGdldE9wZW5SYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF9iID0gbm9kZSwgYXR0cnMgPSBfYi5hdHRycywgdGV4dENvbnRlbnQgPSBfYi50ZXh0Q29udGVudDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGltOiBbXCIkJFwiICsgYXR0cnMuaW5mbywgJyQkJ10sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0Q29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGZyb250TWF0dGVyOiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogbm9kZS50ZXh0Q29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHdpZGdldDogZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG5vZGUudGV4dENvbnRlbnQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHJvbmc6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJyoqJyxcbiAgICAgICAgICAgIHJhd0hUTUw6IGVudGVyaW5nID8gZ2V0T3BlblJhd0hUTUwocmF3SFRNTCkgOiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBlbXBoOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciByYXdIVE1MID0gbm9kZS5hdHRycy5yYXdIVE1MO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsaW06ICcqJyxcbiAgICAgICAgICAgIHJhd0hUTUw6IGVudGVyaW5nID8gZ2V0T3BlblJhd0hUTUwocmF3SFRNTCkgOiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHJpa2U6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfYS5ub2RlO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIHJhd0hUTUwgPSBub2RlLmF0dHJzLnJhd0hUTUw7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogJ35+JyxcbiAgICAgICAgICAgIHJhd0hUTUw6IGVudGVyaW5nID8gZ2V0T3BlblJhd0hUTUwocmF3SFRNTCkgOiBnZXRDbG9zZVJhd0hUTUwocmF3SFRNTCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2IuZW50ZXJpbmc7XG4gICAgICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cnM7XG4gICAgICAgIHZhciB0aXRsZSA9IGF0dHJzLnRpdGxlLCByYXdIVE1MID0gYXR0cnMucmF3SFRNTDtcbiAgICAgICAgdmFyIGxpbmtVcmwgPSBhdHRycy5saW5rVXJsLnJlcGxhY2UoLyZhbXA7L2csICcmJyk7XG4gICAgICAgIHZhciB0aXRsZUF0dHIgPSB0aXRsZSA/IFwiIHRpdGxlPVxcXCJcIiArIGVzY2FwZVhtbCQxKHRpdGxlKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZWxpbTogJ1snLFxuICAgICAgICAgICAgICAgIHJhd0hUTUw6IHJhd0hUTUwgPyBcIjxcIiArIHJhd0hUTUwgKyBcIiBocmVmPVxcXCJcIiArIGVzY2FwZVhtbCQxKGxpbmtVcmwpICsgXCJcXFwiXCIgKyB0aXRsZUF0dHIgKyBcIj5cIiA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogXCJdKFwiICsgbGlua1VybCArICh0aXRsZSA/IFwiIFwiICsgcXVvdGUoZXNjYXBlVGV4dEZvckxpbmsodGl0bGUpKSA6ICcnKSArIFwiKVwiLFxuICAgICAgICAgICAgcmF3SFRNTDogZ2V0Q2xvc2VSYXdIVE1MKHJhd0hUTUwpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29kZTogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGUsIHBhcmVudCA9IF9hLnBhcmVudCwgX2MgPSBfYS5pbmRleCwgaW5kZXggPSBfYyA9PT0gdm9pZCAwID8gMCA6IF9jO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYi5lbnRlcmluZztcbiAgICAgICAgdmFyIGRlbGltID0gZW50ZXJpbmdcbiAgICAgICAgICAgID8gYWRkQmFja3RpY2tzKHBhcmVudC5jaGlsZChpbmRleCksIC0xKVxuICAgICAgICAgICAgOiBhZGRCYWNrdGlja3MocGFyZW50LmNoaWxkKGluZGV4IC0gMSksIDEpO1xuICAgICAgICB2YXIgcmF3SFRNTCA9IGVudGVyaW5nXG4gICAgICAgICAgICA/IGdldE9wZW5SYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTClcbiAgICAgICAgICAgIDogZ2V0Q2xvc2VSYXdIVE1MKG5vZGUuYXR0cnMucmF3SFRNTCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxpbTogZGVsaW0sXG4gICAgICAgICAgICByYXdIVE1MOiByYXdIVE1MLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaHRtbENvbW1lbnQ6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBub2RlLnRleHRDb250ZW50LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgLy8gaHRtbCBpbmxpbmUgbm9kZSwgaHRtbCBibG9jayBub2RlXG4gICAgaHRtbDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9iLmVudGVyaW5nO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUudHlwZS5uYW1lO1xuICAgICAgICB2YXIgYXR0cnMgPSBub2RlLmF0dHJzLmh0bWxBdHRycztcbiAgICAgICAgdmFyIG9wZW5UYWcgPSBcIjxcIiArIHRhZ05hbWU7XG4gICAgICAgIHZhciBjbG9zZVRhZyA9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGJyb2tlbiBjb252ZXJ0aW5nIHdoZW4gYXR0cmlidXRlcyBoYXMgZG91YmxlIHF1b3RlIHN0cmluZ1xuICAgICAgICAgICAgb3BlblRhZyArPSBcIiBcIiArIGF0dHJOYW1lICsgXCI9XFxcIlwiICsgYXR0cnNbYXR0ck5hbWVdLnJlcGxhY2UoL1wiL2csIFwiJ1wiKSArIFwiXFxcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgb3BlblRhZyArPSAnPic7XG4gICAgICAgIGlmIChub2RlLmF0dHJzLmh0bWxJbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmF3SFRNTDogZW50ZXJpbmcgPyBvcGVuVGFnIDogY2xvc2VUYWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiICsgb3BlblRhZyArIG5vZGUuYXR0cnMuY2hpbGRyZW5IVE1MICsgY2xvc2VUYWcsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG52YXIgbWFya1R5cGVPcHRpb25zID0ge1xuICAgIHN0cm9uZzoge1xuICAgICAgICBtaXhhYmxlOiB0cnVlLFxuICAgICAgICByZW1vdmVkRW5jbG9zaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICB9LFxuICAgIGVtcGg6IHtcbiAgICAgICAgbWl4YWJsZTogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlZEVuY2xvc2luZ1doaXRlc3BhY2U6IHRydWUsXG4gICAgfSxcbiAgICBzdHJpa2U6IHtcbiAgICAgICAgbWl4YWJsZTogdHJ1ZSxcbiAgICAgICAgcmVtb3ZlZEVuY2xvc2luZ1doaXRlc3BhY2U6IHRydWUsXG4gICAgfSxcbiAgICBjb2RlOiB7XG4gICAgICAgIGVzY2FwZTogZmFsc2UsXG4gICAgfSxcbiAgICBsaW5rOiBudWxsLFxuICAgIGh0bWw6IG51bGwsXG59O1xuZnVuY3Rpb24gY3JlYXRlTm9kZVR5cGVDb252ZXJ0b3JzKGNvbnZlcnRvcnMpIHtcbiAgICB2YXIgbm9kZVR5cGVDb252ZXJ0b3JzID0ge307XG4gICAgdmFyIG5vZGVUeXBlcyA9IE9iamVjdC5rZXlzKG5vZGVUeXBlV3JpdGVycyk7XG4gICAgbm9kZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgbm9kZVR5cGVDb252ZXJ0b3JzW3R5cGVdID0gZnVuY3Rpb24gKHN0YXRlLCBub2RlSW5mbykge1xuICAgICAgICAgICAgdmFyIHdyaXRlciA9IG5vZGVUeXBlV3JpdGVyc1t0eXBlXTtcbiAgICAgICAgICAgIGlmICh3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydG9yID0gY29udmVydG9yc1t0eXBlXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gY29udmVydG9yXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydG9yKG5vZGVJbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblRhYmxlOiBzdGF0ZS5pblRhYmxlLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgICAgIHdyaXRlKHR5cGUsIHsgc3RhdGU6IHN0YXRlLCBub2RlSW5mbzogbm9kZUluZm8sIHBhcmFtczogcGFyYW1zIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlVHlwZUNvbnZlcnRvcnM7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXJrVHlwZUNvbnZlcnRvcnMoY29udmVydG9ycykge1xuICAgIHZhciBtYXJrVHlwZUNvbnZlcnRvcnMgPSB7fTtcbiAgICB2YXIgbWFya1R5cGVzID0gT2JqZWN0LmtleXMobWFya1R5cGVPcHRpb25zKTtcbiAgICBtYXJrVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBtYXJrVHlwZUNvbnZlcnRvcnNbdHlwZV0gPSBmdW5jdGlvbiAobm9kZUluZm8sIGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgbWFya09wdGlvbiA9IG1hcmtUeXBlT3B0aW9uc1t0eXBlXTtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSBjb252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGNhbGwgdGhlIG1hcmsgdHlwZSBjb252ZXJ0ZXJcbiAgICAgICAgICAgIC8vIGluIHRoZSBgdG9NZENvbnZlcnRvclN0YXRlYCBtb2R1bGUuXG4gICAgICAgICAgICAvLyBXaGVuIGNhbGxpbmcgdGhlIGNvbnZlcnRlciB3aXRob3V0IHVzaW5nIGBkZWxpbWAgYW5kIGByYXdIVE1MYCB2YWx1ZXMsXG4gICAgICAgICAgICAvLyB0aGUgY29udmVydGVyIGlzIGNhbGxlZCB3aXRob3V0IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICB2YXIgcnVuQ29udmVydG9yID0gY29udmVydG9yICYmIG5vZGVJbmZvICYmICFpc1VuZGVmaW5lZF8xKGVudGVyaW5nKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBydW5Db252ZXJ0b3IgPyBjb252ZXJ0b3Iobm9kZUluZm8sIHsgZW50ZXJpbmc6IGVudGVyaW5nIH0pIDoge307XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBwYXJhbXMpLCBtYXJrT3B0aW9uKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFya1R5cGVDb252ZXJ0b3JzO1xufVxuLy8gU3RlcCAxOiBDcmVhdGUgdGhlIGNvbnZlcnRlciBieSBvdmVycmlkaW5nIHRoZSBjdXN0b20gY29udmVydGVyXG4vLyAgICAgICAgIHRvIHRoZSBvcmlnaW5hbCBjb252ZXJ0ZXIgZGVmaW5lZCBpbiB0aGUgYHRvTWRDb252ZXJ0b3JzYCBtb2R1bGUuXG4vLyAgICAgICAgIElmIHRoZSBub2RlIHR5cGUgaXMgZGVmaW5lZCBpbiB0aGUgb3JpZ2luYWwgY29udmVydGVyLFxuLy8gICAgICAgICB0aGUgYG9yaWdpbigpYCBmdW5jdGlvbiBpcyBleHBvcnRlZCB0byB0aGUgcGFyYW10ZXIgb2YgdGhlIGNvbnZlcnRlci5cbi8vIFN0ZXAgMjogQ3JlYXRlIGEgY29udmVydGVyIGZvciB0aGUgbm9kZSB0eXBlIG9mIFByb3NlTWlycm9yIGJ5IGNvbWJpbmluZyB0aGUgY29udmVydGVyXG4vLyAgICAgICAgIGNyZWF0ZWQgaW4gU3RlcCAxIHdpdGggdGhlIHdyaXRlcnMgZGVmaW5lZCBpbiB0aGVgdG9NZE5vZGVUeXBlV3JpdGVyc2AgbW9kdWxlLlxuLy8gICAgICAgICBFYWNoIHdyaXRlciBjb252ZXJ0cyB0aGUgUHJvc2VNaXJyb3IncyBub2RlIHRvIGEgc3RyaW5nIHdpdGggdGhlIHZhbHVlIHJldHVybmVkXG4vLyAgICAgICAgIGJ5IHRoZSBjb252ZXJ0ZXIsIGFuZCB0aGVuIHN0b3JlcyB0aGUgc3RhdGUgaW4gdGhlYHRvTWRDb252ZXJ0ZXJTdGF0ZWAgY2xhc3MuXG4vLyBTdGVwIDM6IENyZWF0ZSBhIGNvbnZlcnRlciBmb3IgdGhlIG1hcmsgdHlwZSBvZiBQcm9zZU1pcnJvciBieSBjb21iaW5pbmcgdGhlIGNvbnZlcnRlclxuLy8gICAgICAgICBjcmVhdGVkIGluIFN0ZXAgMSB3aXRoIGBtYXJrVHlwZU9wdGlvbnNgLlxuLy8gU3RlcCA0OiBUaGUgY3JlYXRlZCBub2RlIHR5cGUgY29udmVydGVyIGFuZCBtYXJrIHR5cGUgY29udmVydGVyIGFyZSBpbmplY3RlZFxuLy8gICAgICAgICB3aGVuIGNyZWF0aW5nIGFuIGluc3RhbmNlIG9mIHRoZWB0b01kQ29udmVydGVyU3RhdGVgIGNsYXNzLlxuZnVuY3Rpb24gY3JlYXRlTWRDb252ZXJ0b3JzKGN1c3RvbUNvbnZlcnRvcnMpIHtcbiAgICB2YXIgY3VzdG9tQ29udmVydG9yVHlwZXMgPSBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKTtcbiAgICBjdXN0b21Db252ZXJ0b3JUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciBiYXNlQ29udmVydG9yID0gdG9NZENvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JzW3R5cGVdO1xuICAgICAgICBpZiAoYmFzZUNvbnZlcnRvcikge1xuICAgICAgICAgICAgdG9NZENvbnZlcnRvcnNbdHlwZV0gPSBmdW5jdGlvbiAobm9kZUluZm8sIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VDb252ZXJ0b3Iobm9kZUluZm8sIGNvbnRleHQpOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZUluZm8sIGNvbnRleHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvTWRDb252ZXJ0b3JzW3R5cGVdID0gY3VzdG9tQ29udmVydG9yO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjdXN0b21Db252ZXJ0b3JzW3R5cGVdO1xuICAgIH0pO1xuICAgIHZhciBub2RlVHlwZUNvbnZlcnRvcnMgPSBjcmVhdGVOb2RlVHlwZUNvbnZlcnRvcnModG9NZENvbnZlcnRvcnMpO1xuICAgIHZhciBtYXJrVHlwZUNvbnZlcnRvcnMgPSBjcmVhdGVNYXJrVHlwZUNvbnZlcnRvcnModG9NZENvbnZlcnRvcnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlQ29udmVydG9yczogbm9kZVR5cGVDb252ZXJ0b3JzLFxuICAgICAgICBtYXJrVHlwZUNvbnZlcnRvcnM6IG1hcmtUeXBlQ29udmVydG9ycyxcbiAgICB9O1xufVxuXG52YXIgVG9NZENvbnZlcnRvclN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvTWRDb252ZXJ0b3JTdGF0ZShfYSkge1xuICAgICAgICB2YXIgbm9kZVR5cGVDb252ZXJ0b3JzID0gX2Eubm9kZVR5cGVDb252ZXJ0b3JzLCBtYXJrVHlwZUNvbnZlcnRvcnMgPSBfYS5tYXJrVHlwZUNvbnZlcnRvcnM7XG4gICAgICAgIHRoaXMubm9kZVR5cGVDb252ZXJ0b3JzID0gbm9kZVR5cGVDb252ZXJ0b3JzO1xuICAgICAgICB0aGlzLm1hcmtUeXBlQ29udmVydG9ycyA9IG1hcmtUeXBlQ29udmVydG9ycztcbiAgICAgICAgdGhpcy5kZWxpbSA9ICcnO1xuICAgICAgICB0aGlzLnJlc3VsdCA9ICcnO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpZ2h0TGlzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0b3BOZXdsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5UYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmdldE1hcmtDb252ZXJ0b3IgPSBmdW5jdGlvbiAobWFyaykge1xuICAgICAgICB2YXIgdHlwZSA9IG1hcmsuYXR0cnMuaHRtbElubGluZSA/ICdodG1sJyA6IG1hcmsudHlwZS5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrVHlwZUNvbnZlcnRvcnNbdHlwZV07XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmlzSW5CbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC8oXnxcXG4pJC8udGVzdCh0aGlzLnJlc3VsdCk7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLm1hcmtUZXh0ID0gZnVuY3Rpb24gKG1hcmssIGVudGVyaW5nLCBwYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzLmdldE1hcmtDb252ZXJ0b3IobWFyayk7XG4gICAgICAgIGlmIChjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRvcih7IG5vZGU6IG1hcmssIHBhcmVudDogcGFyZW50LCBpbmRleDogaW5kZXggfSwgZW50ZXJpbmcpLCBkZWxpbSA9IF9hLmRlbGltLCByYXdIVE1MID0gX2EucmF3SFRNTDtcbiAgICAgICAgICAgIHJldHVybiByYXdIVE1MIHx8IGRlbGltO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuc2V0RGVsaW0gPSBmdW5jdGlvbiAoZGVsaW0pIHtcbiAgICAgICAgdGhpcy5kZWxpbSA9IGRlbGltO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5nZXREZWxpbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsaW07XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmZsdXNoQ2xvc2UgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc3RvcE5ld2xpbmUgJiYgdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0luQmxhbmsoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsaW1NaW4gPSB0aGlzLmRlbGltO1xuICAgICAgICAgICAgICAgIHZhciB0cmltID0gL1xccyskLy5leGVjKGRlbGltTWluKTtcbiAgICAgICAgICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxpbU1pbiA9IGRlbGltTWluLnNsaWNlKDAsIGRlbGltTWluLmxlbmd0aCAtIHRyaW1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gZGVsaW1NaW4gKyBcIlxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUud3JhcEJsb2NrID0gZnVuY3Rpb24gKGRlbGltLCBmaXJzdERlbGltLCBub2RlLCBmbikge1xuICAgICAgICB2YXIgb2xkID0gdGhpcy5nZXREZWxpbSgpO1xuICAgICAgICB0aGlzLndyaXRlKGZpcnN0RGVsaW0gfHwgZGVsaW0pO1xuICAgICAgICB0aGlzLnNldERlbGltKHRoaXMuZ2V0RGVsaW0oKSArIGRlbGltKTtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGhpcy5zZXREZWxpbShvbGQpO1xuICAgICAgICB0aGlzLmNsb3NlQmxvY2sobm9kZSk7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmVuc3VyZU5ld0xpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0luQmxhbmsoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdm9pZCAwKSB7IGNvbnRlbnQgPSAnJzsgfVxuICAgICAgICB0aGlzLmZsdXNoQ2xvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVsaW0gJiYgdGhpcy5pc0luQmxhbmsoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gdGhpcy5kZWxpbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gY29udGVudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jbG9zZUJsb2NrID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBub2RlO1xuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKHRleHQsIGVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGVzY2FwZWQgPT09IHZvaWQgMCkgeyBlc2NhcGVkID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gZXNjYXBlZCA/IGVzY2FwZSQxKGxpbmVzW2ldKSA6IGxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKGkgIT09IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0QmxvY2sgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZS5uYW1lO1xuICAgICAgICB2YXIgY29udmVydG9yID0gdGhpcy5ub2RlVHlwZUNvbnZlcnRvcnNbdHlwZV07XG4gICAgICAgIHZhciBub2RlSW5mbyA9IHsgbm9kZTogbm9kZSwgcGFyZW50OiBwYXJlbnQsIGluZGV4OiBpbmRleCB9O1xuICAgICAgICBpZiAobm9kZS5hdHRycy5odG1sQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGVDb252ZXJ0b3JzLmh0bWwodGhpcywgbm9kZUluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnZlcnRvcikge1xuICAgICAgICAgICAgY29udmVydG9yKHRoaXMsIG5vZGVJbmZvKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9NZENvbnZlcnRvclN0YXRlLnByb3RvdHlwZS5jb252ZXJ0SW5saW5lID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYWN0aXZlID0gW107XG4gICAgICAgIHZhciB0cmFpbGluZyA9ICcnO1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBmdW5jdGlvbiAobm9kZSwgXywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBtYXJrcyA9IG5vZGUgPyBub2RlLm1hcmtzIDogW107XG4gICAgICAgICAgICB2YXIgbGVhZGluZyA9IHRyYWlsaW5nO1xuICAgICAgICAgICAgdHJhaWxpbmcgPSAnJztcbiAgICAgICAgICAgIC8vIElmIHdoaXRlc3BhY2UgaGFzIHRvIGJlIGV4cGVsbGVkIGZyb20gdGhlIG5vZGUsIGFkanVzdFxuICAgICAgICAgICAgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZFdoaXRlc3BhY2UgPSBub2RlICYmXG4gICAgICAgICAgICAgICAgbm9kZS5pc1RleHQgJiZcbiAgICAgICAgICAgICAgICBtYXJrcy5zb21lKGZ1bmN0aW9uIChtYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXJrQ29udmVydG9yID0gX3RoaXMuZ2V0TWFya0NvbnZlcnRvcihtYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBtYXJrQ29udmVydG9yICYmIG1hcmtDb252ZXJ0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZm8gJiYgaW5mby5yZW1vdmVkRW5jbG9zaW5nV2hpdGVzcGFjZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkV2hpdGVzcGFjZSAmJiBub2RlICYmIG5vZGUudGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IC9eKFxccyopKC4qPykoXFxzKikkL20uZXhlYyhub2RlLnRleHQpLCBsZWFkID0gX2FbMV0sIG1hcmsgPSBfYVsyXSwgdHJhaWwgPSBfYVszXTtcbiAgICAgICAgICAgICAgICBsZWFkaW5nICs9IGxlYWQ7XG4gICAgICAgICAgICAgICAgdHJhaWxpbmcgPSB0cmFpbDtcbiAgICAgICAgICAgICAgICBpZiAobGVhZCB8fCB0cmFpbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGUgaXMgbm90IGRlZmluZWQgZm9yIFwid2l0aFRleHRcIiBpbiBwcm9zZW1pcnJvci1tb2RlbFxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbWFyayA/IG5vZGUud2l0aFRleHQobWFyaykgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gYWN0aXZlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxhc3RNYXJrID0gbWFya3MubGVuZ3RoICYmIGxhc3QkMShtYXJrcyk7XG4gICAgICAgICAgICB2YXIgbWFya0NvbnZlcnRvciA9IGxhc3RNYXJrICYmIF90aGlzLmdldE1hcmtDb252ZXJ0b3IobGFzdE1hcmspO1xuICAgICAgICAgICAgdmFyIG1hcmtUeXBlID0gbWFya0NvbnZlcnRvciAmJiBtYXJrQ29udmVydG9yKCk7XG4gICAgICAgICAgICB2YXIgbm9Fc2NhcGUgPSBtYXJrVHlwZSAmJiBtYXJrVHlwZS5lc2NhcGUgPT09IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG1hcmtzLmxlbmd0aCAtIChub0VzY2FwZSA/IDEgOiAwKTtcbiAgICAgICAgICAgIC8vIFRyeSB0byByZW9yZGVyICdtaXhhYmxlJyBtYXJrcywgc3VjaCBhcyBlbSBhbmQgc3Ryb25nLCB3aGljaFxuICAgICAgICAgICAgLy8gaW4gTWFya2Rvd24gbWF5IGJlIG9wZW5lZCBhbmQgY2xvc2VkIGluIGRpZmZlcmVudCBvcmRlciwgc29cbiAgICAgICAgICAgIC8vIHRoYXQgb3JkZXIgb2YgdGhlIG1hcmtzIGZvciB0aGUgdG9rZW4gbWF0Y2hlcyB0aGUgb3JkZXIgaW5cbiAgICAgICAgICAgIC8vIGFjdGl2ZS5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFyayA9IG1hcmtzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiAhbWFya1R5cGUubWl4YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhY3RpdmUubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVyID0gYWN0aXZlW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgIW1hcmtUeXBlLm1peGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrLmVxKG90aGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmtzLnNsaWNlKGosIGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KG1hcmtzLnNsaWNlKGkgKyAxLCBsZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrcy5zbGljZShpICsgMSwgaikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQobWFyaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChtYXJrcy5zbGljZShqLCBsZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCB0aGUgcHJlZml4IG9mIHRoZSBtYXJrIHNldCB0aGF0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgIHZhciBrZWVwID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgTWF0aC5taW4oYWN0aXZlLmxlbmd0aCwgbGVuKSAmJiBtYXJrc1trZWVwXS5lcShhY3RpdmVba2VlcF0pKSB7XG4gICAgICAgICAgICAgICAga2VlcCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xvc2UgdGhlIG1hcmtzIHRoYXQgbmVlZCB0byBiZSBjbG9zZWRcbiAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVkTWFyayA9IGFjdGl2ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlZE1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dChfdGhpcy5tYXJrVGV4dChhY3RpdmVkTWFyaywgZmFsc2UsIHBhcmVudCwgaW5kZXgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3V0cHV0IGFueSBwcmV2aW91c2x5IGV4cGVsbGVkIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3V0c2lkZSB0aGUgbWFya3NcbiAgICAgICAgICAgIGlmIChsZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGV4dChsZWFkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIG1hcmtzIHRoYXQgbmVlZCB0byBiZSBvcGVuZWRcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmsgPSBtYXJrc1thY3RpdmUubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobWFyayk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRleHQoX3RoaXMubWFya1RleHQobWFyaywgdHJ1ZSwgcGFyZW50LCBpbmRleCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBub2RlLiBTcGVjaWFsIGNhc2UgY29kZSBtYXJrcywgc2luY2UgdGhlaXIgY29udGVudFxuICAgICAgICAgICAgICAgIC8vIG1heSBub3QgYmUgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICBpZiAobm9Fc2NhcGUgJiYgbm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dChfdGhpcy5tYXJrVGV4dChsYXN0TWFyaywgdHJ1ZSwgcGFyZW50LCBpbmRleCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcmtUZXh0KGxhc3RNYXJrLCBmYWxzZSwgcGFyZW50LCBpbmRleCArIDEpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb252ZXJ0QmxvY2sobm9kZSwgcGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwYXJlbnQuZm9yRWFjaChwcm9ncmVzcyk7XG4gICAgICAgIHByb2dyZXNzKG51bGwsIG51bGwsIHBhcmVudC5jaGlsZENvdW50KTtcbiAgICB9O1xuICAgIC8vIFJlbmRlciBhIG5vZGUncyBjb250ZW50IGFzIGEgbGlzdC4gYGRlbGltYCBzaG91bGQgYmUgdGhlIGV4dHJhXG4gICAgLy8gaW5kZW50YXRpb24gYWRkZWQgdG8gYWxsIGxpbmVzIGV4Y2VwdCB0aGUgZmlyc3QgaW4gYW4gaXRlbSxcbiAgICAvLyBgZmlyc3REZWxpbUZuYCBpcyBhIGZ1bmN0aW9uIGdvaW5nIGZyb20gYW4gaXRlbSBpbmRleCB0byBhXG4gICAgLy8gZGVsaW1pdGVyIGZvciB0aGUgZmlyc3QgbGluZSBvZiB0aGUgaXRlbS5cbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnRMaXN0ID0gZnVuY3Rpb24gKG5vZGUsIGRlbGltLCBmaXJzdERlbGltRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQgJiYgdGhpcy5jbG9zZWQudHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ2xvc2UoMyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50aWdodExpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDbG9zZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGlnaHQgPSAoX2EgPSBub2RlLmF0dHJzLnRpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgICAgICB2YXIgcHJldlRpZ2h0ID0gdGhpcy50aWdodExpc3Q7XG4gICAgICAgIHRoaXMudGlnaHRMaXN0ID0gdGlnaHQ7XG4gICAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIF8sIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggJiYgdGlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mbHVzaENsb3NlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMud3JhcEJsb2NrKGRlbGltLCBmaXJzdERlbGltRm4oaW5kZXgpLCBub2RlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb252ZXJ0QmxvY2soY2hpbGQsIG5vZGUsIGluZGV4KTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpZ2h0TGlzdCA9IHByZXZUaWdodDtcbiAgICB9O1xuICAgIFRvTWRDb252ZXJ0b3JTdGF0ZS5wcm90b3R5cGUuY29udmVydFRhYmxlQ2VsbCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcE5ld2xpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmluVGFibGUgPSB0cnVlO1xuICAgICAgICBub2RlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBfLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKFsnYnVsbGV0TGlzdCcsICdvcmRlcmVkTGlzdCddLCBjaGlsZC50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udmVydEJsb2NrKGNoaWxkLCBub2RlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb252ZXJ0SW5saW5lKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBub2RlLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSBub2RlLmNoaWxkKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMud3JpdGUoJzxicj4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RvcE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pblRhYmxlID0gZmFsc2U7XG4gICAgfTtcbiAgICBUb01kQ29udmVydG9yU3RhdGUucHJvdG90eXBlLmNvbnZlcnROb2RlID0gZnVuY3Rpb24gKHBhcmVudCwgaW5mb0ZvclBvc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIF8sIGluZGV4KSB7XG4gICAgICAgICAgICBfdGhpcy5jb252ZXJ0QmxvY2sobm9kZSwgcGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoKGluZm9Gb3JQb3NTeW5jID09PSBudWxsIHx8IGluZm9Gb3JQb3NTeW5jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvRm9yUG9zU3luYy5ub2RlKSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lVGV4dHMgPSBfdGhpcy5yZXN1bHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgIGluZm9Gb3JQb3NTeW5jLnNldE1hcHBlZFBvcyhbbGluZVRleHRzLmxlbmd0aCwgbGFzdCQxKGxpbmVUZXh0cykubGVuZ3RoICsgMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFRvTWRDb252ZXJ0b3JTdGF0ZTtcbn0oKSk7XG5cbnZhciBDb252ZXJ0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udmVydG9yKHNjaGVtYSwgdG9NZENvbnZlcnRvcnMsIHRvSFRNTENvbnZlcnRvcnMsIGV2ZW50RW1pdHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldE1hcHBlZFBvcyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIF90aGlzLm1hcHBlZFBvc1doZW5Db252ZXJ0aW5nID0gcG9zO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuZm9jdXNlZE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm1hcHBlZFBvc1doZW5Db252ZXJ0aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy50b1d3Q29udmVydG9ycyA9IGNyZWF0ZVd3Q29udmVydG9ycyh0b0hUTUxDb252ZXJ0b3JzKTtcbiAgICAgICAgdGhpcy50b01kQ29udmVydG9ycyA9IGNyZWF0ZU1kQ29udmVydG9ycyh0b01kQ29udmVydG9ycyB8fCB7fSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbignc2V0Rm9jdXNlZE5vZGUnLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gKF90aGlzLmZvY3VzZWROb2RlID0gbm9kZSk7IH0pO1xuICAgIH1cbiAgICBDb252ZXJ0b3IucHJvdG90eXBlLmdldE1hcHBlZFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwcGVkUG9zV2hlbkNvbnZlcnRpbmc7XG4gICAgfTtcbiAgICBDb252ZXJ0b3IucHJvdG90eXBlLmdldEluZm9Gb3JQb3NTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmZvY3VzZWROb2RlLCBzZXRNYXBwZWRQb3M6IHRoaXMuc2V0TWFwcGVkUG9zIH07XG4gICAgfTtcbiAgICBDb252ZXJ0b3IucHJvdG90eXBlLnRvV3lzaXd5Z01vZGVsID0gZnVuY3Rpb24gKG1kTm9kZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgVG9Xd0NvbnZlcnRvclN0YXRlKHRoaXMuc2NoZW1hLCB0aGlzLnRvV3dDb252ZXJ0b3JzKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbnZlcnROb2RlKG1kTm9kZSwgdGhpcy5nZXRJbmZvRm9yUG9zU3luYygpKTtcbiAgICB9O1xuICAgIENvbnZlcnRvci5wcm90b3R5cGUudG9NYXJrZG93blRleHQgPSBmdW5jdGlvbiAod3dOb2RlKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBUb01kQ29udmVydG9yU3RhdGUodGhpcy50b01kQ29udmVydG9ycyk7XG4gICAgICAgIHZhciBtYXJrZG93blRleHQgPSBzdGF0ZS5jb252ZXJ0Tm9kZSh3d05vZGUsIHRoaXMuZ2V0SW5mb0ZvclBvc1N5bmMoKSk7XG4gICAgICAgIG1hcmtkb3duVGV4dCA9IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXRSZWR1Y2UoJ2JlZm9yZUNvbnZlcnRXeXNpd3lnVG9NYXJrZG93bicsIG1hcmtkb3duVGV4dCk7XG4gICAgICAgIHJldHVybiBtYXJrZG93blRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udmVydG9yO1xufSgpKTtcblxuZnVuY3Rpb24gZXhlY1BsdWdpbihwbHVnaW5JbmZvKSB7XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbkluZm8ucGx1Z2luLCBldmVudEVtaXR0ZXIgPSBwbHVnaW5JbmZvLmV2ZW50RW1pdHRlciwgdXNhZ2VTdGF0aXN0aWNzID0gcGx1Z2luSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luSW5mby5pbnN0YW5jZTtcbiAgICB2YXIgcG1TdGF0ZSA9IHsgUGx1Z2luOiBQbHVnaW4sIFBsdWdpbktleTogUGx1Z2luS2V5LCBTZWxlY3Rpb246IFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbjogVGV4dFNlbGVjdGlvbiB9O1xuICAgIHZhciBwbVZpZXcgPSB7IERlY29yYXRpb246IERlY29yYXRpb24sIERlY29yYXRpb25TZXQ6IERlY29yYXRpb25TZXQgfTtcbiAgICB2YXIgcG1Nb2RlbCA9IHsgRnJhZ21lbnQ6IEZyYWdtZW50IH07XG4gICAgdmFyIHBtUnVsZXMgPSB7IElucHV0UnVsZTogSW5wdXRSdWxlLCBpbnB1dFJ1bGVzOiBpbnB1dFJ1bGVzLCB1bmRvSW5wdXRSdWxlOiB1bmRvSW5wdXRSdWxlIH07XG4gICAgdmFyIHBtS2V5bWFwID0geyBrZXltYXA6IGtleW1hcCB9O1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlcixcbiAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB1c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgcG1TdGF0ZTogcG1TdGF0ZSxcbiAgICAgICAgcG1WaWV3OiBwbVZpZXcsXG4gICAgICAgIHBtTW9kZWw6IHBtTW9kZWwsXG4gICAgICAgIHBtUnVsZXM6IHBtUnVsZXMsXG4gICAgICAgIHBtS2V5bWFwOiBwbUtleW1hcCxcbiAgICAgICAgaTE4bjogaTE4bixcbiAgICB9O1xuICAgIGlmIChpc0FycmF5XzEocGx1Z2luKSkge1xuICAgICAgICB2YXIgcGx1Z2luRm4gPSBwbHVnaW5bMF0sIF9hID0gcGx1Z2luWzFdLCBvcHRpb25zID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2E7XG4gICAgICAgIHJldHVybiBwbHVnaW5Gbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbihjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldFBsdWdpbkluZm8ocGx1Z2luc0luZm8pIHtcbiAgICB2YXIgcGx1Z2lucyA9IHBsdWdpbnNJbmZvLnBsdWdpbnMsIGV2ZW50RW1pdHRlciA9IHBsdWdpbnNJbmZvLmV2ZW50RW1pdHRlciwgdXNhZ2VTdGF0aXN0aWNzID0gcGx1Z2luc0luZm8udXNhZ2VTdGF0aXN0aWNzLCBpbnN0YW5jZSA9IHBsdWdpbnNJbmZvLmluc3RhbmNlO1xuICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ21peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUnLCBtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlKTtcbiAgICByZXR1cm4gKHBsdWdpbnMgIT09IG51bGwgJiYgcGx1Z2lucyAhPT0gdm9pZCAwID8gcGx1Z2lucyA6IFtdKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGx1Z2luKSB7XG4gICAgICAgIHZhciBwbHVnaW5JbmZvUmVzdWx0ID0gZXhlY1BsdWdpbih7XG4gICAgICAgICAgICBwbHVnaW46IHBsdWdpbixcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB1c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBsdWdpbkluZm9SZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZXhlY3V0ZWQgcGx1Z2luIGlzIGVtcHR5LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZG93blBhcnNlcnMgPSBwbHVnaW5JbmZvUmVzdWx0Lm1hcmtkb3duUGFyc2VycywgdG9IVE1MUmVuZGVyZXJzID0gcGx1Z2luSW5mb1Jlc3VsdC50b0hUTUxSZW5kZXJlcnMsIHRvTWFya2Rvd25SZW5kZXJlcnMgPSBwbHVnaW5JbmZvUmVzdWx0LnRvTWFya2Rvd25SZW5kZXJlcnMsIG1hcmtkb3duUGx1Z2lucyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25QbHVnaW5zLCB3eXNpd3lnUGx1Z2lucyA9IHBsdWdpbkluZm9SZXN1bHQud3lzaXd5Z1BsdWdpbnMsIHd5c2l3eWdOb2RlVmlld3MgPSBwbHVnaW5JbmZvUmVzdWx0Lnd5c2l3eWdOb2RlVmlld3MsIG1hcmtkb3duQ29tbWFuZHMgPSBwbHVnaW5JbmZvUmVzdWx0Lm1hcmtkb3duQ29tbWFuZHMsIHd5c2l3eWdDb21tYW5kcyA9IHBsdWdpbkluZm9SZXN1bHQud3lzaXd5Z0NvbW1hbmRzLCB0b29sYmFySXRlbXMgPSBwbHVnaW5JbmZvUmVzdWx0LnRvb2xiYXJJdGVtcztcbiAgICAgICAgaWYgKHRvSFRNTFJlbmRlcmVycykge1xuICAgICAgICAgICAgYWNjLnRvSFRNTFJlbmRlcmVycyA9IGRlZXBNZXJnZWRDb3B5KGFjYy50b0hUTUxSZW5kZXJlcnMsIHRvSFRNTFJlbmRlcmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvTWFya2Rvd25SZW5kZXJlcnMpIHtcbiAgICAgICAgICAgIGFjYy50b01hcmtkb3duUmVuZGVyZXJzID0gZGVlcE1lcmdlZENvcHkoYWNjLnRvTWFya2Rvd25SZW5kZXJlcnMsIHRvTWFya2Rvd25SZW5kZXJlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93blBsdWdpbnMpIHtcbiAgICAgICAgICAgIGFjYy5tZFBsdWdpbnMgPSBhY2MubWRQbHVnaW5zLmNvbmNhdChtYXJrZG93blBsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnUGx1Z2lucykge1xuICAgICAgICAgICAgYWNjLnd3UGx1Z2lucyA9IGFjYy53d1BsdWdpbnMuY29uY2F0KHd5c2l3eWdQbHVnaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z05vZGVWaWV3cykge1xuICAgICAgICAgICAgYWNjLnd3Tm9kZVZpZXdzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhY2Mud3dOb2RlVmlld3MpLCB3eXNpd3lnTm9kZVZpZXdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2Rvd25Db21tYW5kcykge1xuICAgICAgICAgICAgYWNjLm1kQ29tbWFuZHMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFjYy5tZENvbW1hbmRzKSwgbWFya2Rvd25Db21tYW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdDb21tYW5kcykge1xuICAgICAgICAgICAgYWNjLnd3Q29tbWFuZHMgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGFjYy53d0NvbW1hbmRzKSwgd3lzaXd5Z0NvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9vbGJhckl0ZW1zKSB7XG4gICAgICAgICAgICBhY2MudG9vbGJhckl0ZW1zID0gYWNjLnRvb2xiYXJJdGVtcy5jb25jYXQodG9vbGJhckl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2Rvd25QYXJzZXJzKSB7XG4gICAgICAgICAgICBhY2MubWFya2Rvd25QYXJzZXJzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhY2MubWFya2Rvd25QYXJzZXJzKSwgbWFya2Rvd25QYXJzZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHtcbiAgICAgICAgdG9IVE1MUmVuZGVyZXJzOiB7fSxcbiAgICAgICAgdG9NYXJrZG93blJlbmRlcmVyczoge30sXG4gICAgICAgIG1kUGx1Z2luczogW10sXG4gICAgICAgIHd3UGx1Z2luczogW10sXG4gICAgICAgIHd3Tm9kZVZpZXdzOiB7fSxcbiAgICAgICAgbWRDb21tYW5kczoge30sXG4gICAgICAgIHd3Q29tbWFuZHM6IHt9LFxuICAgICAgICB0b29sYmFySXRlbXM6IFtdLFxuICAgICAgICBtYXJrZG93blBhcnNlcnM6IHt9LFxuICAgIH0pO1xufVxuXG52YXIgVEFTS19BVFRSX05BTUUgPSAnZGF0YS10YXNrJztcbnZhciBESVNBQkxFRF9UQVNLX0FUVFJfTkFNRSA9ICdkYXRhLXRhc2stZGlzYWJsZWQnO1xudmFyIFRBU0tfQ0hFQ0tFRF9DTEFTU19OQU1FID0gJ2NoZWNrZWQnO1xuZnVuY3Rpb24gcmVnaXN0ZXJIVE1MVGFnVG9XaGl0ZWxpc3QoY29udmVydG9yTWFwKSB7XG4gICAgWydodG1sQmxvY2snLCAnaHRtbElubGluZSddLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUeXBlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKSB7XG4gICAgICAgICAgICAvLyByZWdpc3RlciB0YWcgd2hpdGUgbGlzdCBmb3IgcHJldmVudGluZyB0byByZW1vdmUgdGhlIGh0bWwgaW4gc2FuaXRpemVyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb252ZXJ0b3JNYXBbaHRtbFR5cGVdKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiByZWdpc3RlclRhZ1doaXRlbGlzdElmUG9zc2libGUodHlwZSk7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIENsYXNzIFRvYXN0VUlFZGl0b3JWaWV3ZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbiBvYmplY3RcbiAqICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLmVsIC0gY29udGFpbmVyIGVsZW1lbnRcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5pdGlhbFZhbHVlXSBFZGl0b3IncyBpbml0aWFsIHZhbHVlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV2ZW50c10gLSBFdmVudHNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmxvYWRdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBmdWxseSBsb2FkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jaGFuZ2VdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGNvbnRlbnQgY2hhbmdlZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2FyZXRDaGFuZ2VdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGZvcm1hdCBjaGFuZ2UgYnkgY3Vyc29yIHBvc2l0aW9uXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5mb2N1c10gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGdldCBmb2N1c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmx1cl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGxvb3NlIGZvY3VzXG4gKiAgICAgQHBhcmFtIHtBcnJheS48ZnVuY3Rpb258QXJyYXk+fSBbb3B0aW9ucy5wbHVnaW5zXSAtIEFycmF5IG9mIHBsdWdpbnMuIEEgcGx1Z2luIGNhbiBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBhbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbZnVuY3Rpb24sIG9wdGlvbnNdLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbmRlZEF1dG9saW5rc10gLSBVc2luZyBleHRlbmRlZCBBdXRvbGlua3Mgc3BlY2lmaWVkIGluIEdGTSBzcGVjXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxpbmtBdHRyaWJ1dGVzXSAtIEF0dHJpYnV0ZXMgb2YgYW5jaG9yIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVsLCB0YXJnZXQsIGhyZWZsYW5nLCB0eXBlXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmN1c3RvbUhUTUxSZW5kZXJlcj1udWxsXSAtIE9iamVjdCBjb250YWluaW5nIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbnMgY29ycmVzcG9uZCB0byBjaGFuZ2UgbWFya2Rvd24gbm9kZSB0byBwcmV2aWV3IEhUTUwgb3Igd3lzaXd5ZyBub2RlXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBzcGVjaWZpY2F0aW9uIG9mIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25cbiAqICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5jdXN0b21IVE1MU2FuaXRpemVyPW51bGxdIC0gY3VzdG9tIEhUTUwgc2FuaXRpemVyXG4gKiAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mcm9udE1hdHRlcj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgZnJvbnQgbWF0dGVyXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRoZW1lXSAtIFRoZSB0aGVtZSB0byBzdHlsZSB0aGUgdmlld2VyIHdpdGguIFRoZSBkZWZhdWx0IGlzIGluY2x1ZGVkIGluIHRvYXN0dWktZWRpdG9yLmNzcy5cbiAqL1xudmFyIFRvYXN0VUlFZGl0b3JWaWV3ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9hc3RVSUVkaXRvclZpZXdlcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZF8xKHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MU2FuaXRpemVyOiBudWxsLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0cnVlLFxuICAgICAgICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gc2FuaXRpemVMaW5rQXR0cmlidXRlKHRoaXMub3B0aW9ucy5saW5rQXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBfYSA9IGdldFBsdWdpbkluZm8oe1xuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5vcHRpb25zLnBsdWdpbnMsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0aGlzLm9wdGlvbnMudXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgIH0pIHx8IHt9LCB0b0hUTUxSZW5kZXJlcnMgPSBfYS50b0hUTUxSZW5kZXJlcnMsIG1hcmtkb3duUGFyc2VycyA9IF9hLm1hcmtkb3duUGFyc2VycztcbiAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBfYi5jdXN0b21IVE1MUmVuZGVyZXIsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2IuZXh0ZW5kZWRBdXRvbGlua3MsIHJlZmVyZW5jZURlZmluaXRpb24gPSBfYi5yZWZlcmVuY2VEZWZpbml0aW9uLCBmcm9udE1hdHRlciA9IF9iLmZyb250TWF0dGVyLCBjdXN0b21IVE1MU2FuaXRpemVyID0gX2IuY3VzdG9tSFRNTFNhbml0aXplcjtcbiAgICAgICAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBsaW5rQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxSZW5kZXJlcjogX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCB0b0hUTUxSZW5kZXJlcnMpLCBjdXN0b21IVE1MUmVuZGVyZXIpLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIHNhbml0aXplcjogY3VzdG9tSFRNTFNhbml0aXplciB8fCBzYW5pdGl6ZUhUTUwsXG4gICAgICAgIH07XG4gICAgICAgIHJlZ2lzdGVySFRNTFRhZ1RvV2hpdGVsaXN0KHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgICAgZm9yRWFjaE93blByb3BlcnRpZXNfMSh0aGlzLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uKGtleSwgZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jID0gdGhpcy5vcHRpb25zLCBlbCA9IF9jLmVsLCBpbml0aWFsVmFsdWUgPSBfYy5pbml0aWFsVmFsdWUsIHRoZW1lID0gX2MudGhlbWU7XG4gICAgICAgIHZhciBleGlzdGluZ0hUTUwgPSBlbC5pbm5lckhUTUw7XG4gICAgICAgIGlmICh0aGVtZSAhPT0gJ2xpZ2h0Jykge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHModGhlbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy50b2FzdE1hcmsgPSBuZXcgVG9hc3RNYXJrKCcnLCB7XG4gICAgICAgICAgICBkaXNhbGxvd2VkSHRtbEJsb2NrVGFnczogWydicicsICdpbWcnXSxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBleHRlbmRlZEF1dG9saW5rcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IHJlZmVyZW5jZURlZmluaXRpb24sXG4gICAgICAgICAgICBkaXNhbGxvd0RlZXBIZWFkaW5nOiB0cnVlLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuICAgICAgICAgICAgY3VzdG9tUGFyc2VyOiBtYXJrZG93blBhcnNlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXZpZXcgPSBuZXcgTWFya2Rvd25QcmV2aWV3KHRoaXMuZXZlbnRFbWl0dGVyLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHJlbmRlcmVyT3B0aW9ucyksIHsgaXNWaWV3ZXI6IHRydWUgfSkpO1xuICAgICAgICBvbl8xKHRoaXMucHJldmlldy5wcmV2aWV3Q29udGVudCwgJ21vdXNlZG93bicsIHRoaXMudG9nZ2xlVGFzay5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZG93bihpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nSFRNTCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aWV3LnNldEhUTUwoZXhpc3RpbmdIVE1MKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXcucHJldmlld0NvbnRlbnQpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdsb2FkJywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0YXNrIGJ5IGRldGVjdGluZyBtb3VzZWRvd24gZXZlbnQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldiAtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS50b2dnbGVUYXNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZXYudGFyZ2V0O1xuICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICc6YmVmb3JlJyk7XG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoRElTQUJMRURfVEFTS19BVFRSX05BTUUpICYmXG4gICAgICAgICAgICBlbGVtZW50Lmhhc0F0dHJpYnV0ZShUQVNLX0FUVFJfTkFNRSkgJiZcbiAgICAgICAgICAgIGlzUG9zaXRpb25JbkJveChzdHlsZSwgZXYub2Zmc2V0WCwgZXYub2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIFRBU0tfQ0hFQ0tFRF9DTEFTU19OQU1FKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICd2aWV3ZXInLFxuICAgICAgICAgICAgICAgIGRhdGU6IGV2LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBjb250ZW50IGZvciBwcmV2aWV3XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmtkb3duIE1hcmtkb3duIHRleHRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5zZXRNYXJrZG93biA9IGZ1bmN0aW9uIChtYXJrZG93bikge1xuICAgICAgICB2YXIgbGluZVRleHRzID0gdGhpcy50b2FzdE1hcmsuZ2V0TGluZVRleHRzKCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaW5lVGV4dHMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdExpbmUgPSBsYXN0JDEobGluZVRleHRzKTtcbiAgICAgICAgdmFyIGVuZFNvdXJjZXBvcyA9IFtsZW5ndGgsIGxhc3RMaW5lLmxlbmd0aCArIDFdO1xuICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHRoaXMudG9hc3RNYXJrLmVkaXRNYXJrZG93bihbMSwgMV0sIGVuZFNvdXJjZXBvcywgbWFya2Rvd24gfHwgJycpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGVQcmV2aWV3JywgZWRpdFJlc3VsdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kIGV2ZW50SGFuZGxlciB0byBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5iaW5kIGV2ZW50SGFuZGxlciBmcm9tIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGhvb2sgdG8gVFVJRWRpdG9yIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmFkZEhvb2sgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBWaWV3ZXIgcHJldmlldyBmcm9tIGRvY3VtZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmXzEodGhpcy5wcmV2aWV3LmVsLCAnbW91c2Vkb3duJywgdGhpcy50b2dnbGVUYXNrLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnByZXZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdkZXN0cm95Jyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmlzVmlld2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmlzTWFya2Rvd25Nb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yVmlld2VyLnByb3RvdHlwZS5pc1d5c2l3eWdNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gVG9hc3RVSUVkaXRvclZpZXdlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlzUG1Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUkMztcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmVyKHR5cGUpIHtcbiAgICB2YXIgY29udGFpbmVyVHlwZXMgPSBbXG4gICAgICAgICdkb2N1bWVudCcsXG4gICAgICAgICdibG9ja1F1b3RlJyxcbiAgICAgICAgJ2J1bGxldExpc3QnLFxuICAgICAgICAnb3JkZXJlZExpc3QnLFxuICAgICAgICAnbGlzdEl0ZW0nLFxuICAgICAgICAncGFyYWdyYXBoJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnZW1waCcsXG4gICAgICAgICdzdHJvbmcnLFxuICAgICAgICAnc3RyaWtlJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAndGFibGUnLFxuICAgICAgICAndGFibGVIZWFkJyxcbiAgICAgICAgJ3RhYmxlQm9keScsXG4gICAgICAgICd0YWJsZVJvdycsXG4gICAgICAgICd0YWJsZUhlYWRDZWxsJyxcbiAgICAgICAgJ3RhYmxlQm9keUNlbGwnLFxuICAgIF07XG4gICAgcmV0dXJuIGluY2x1ZGVzKGNvbnRhaW5lclR5cGVzLCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1kTGlrZU5vZGUobm9kZSkge1xuICAgIHZhciBhdHRycyA9IG5vZGUuYXR0cnMsIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgdmFyIG5vZGVUeXBlID0gdHlwZS5uYW1lO1xuICAgIHZhciBtZExpa2VOb2RlID0ge1xuICAgICAgICB0eXBlOiBub2RlVHlwZSxcbiAgICAgICAgd3lzaXd5Z05vZGU6IHRydWUsXG4gICAgICAgIGxpdGVyYWw6ICFpc0NvbnRhaW5lcihub2RlVHlwZSkgJiYgaXNQbU5vZGUobm9kZSkgPyBub2RlLnRleHRDb250ZW50IDogbnVsbCxcbiAgICB9O1xuICAgIHZhciBub2RlVHlwZU1hcCA9IHtcbiAgICAgICAgaGVhZGluZzogeyBsZXZlbDogYXR0cnMubGV2ZWwgfSxcbiAgICAgICAgbGluazogeyBkZXN0aW5hdGlvbjogYXR0cnMubGlua1VybCwgdGl0bGU6IGF0dHJzLnRpdGxlIH0sXG4gICAgICAgIGltYWdlOiB7IGRlc3RpbmF0aW9uOiBhdHRycy5pbWFnZVVybCB9LFxuICAgICAgICBjb2RlQmxvY2s6IHsgaW5mbzogYXR0cnMubGFuZ3VhZ2UgfSxcbiAgICAgICAgYnVsbGV0TGlzdDogeyB0eXBlOiAnbGlzdCcsIGxpc3REYXRhOiB7IHR5cGU6ICdidWxsZXQnIH0gfSxcbiAgICAgICAgb3JkZXJlZExpc3Q6IHsgdHlwZTogJ2xpc3QnLCBsaXN0RGF0YTogeyB0eXBlOiAnb3JkZXJlZCcsIHN0YXJ0OiBhdHRycy5vcmRlciB9IH0sXG4gICAgICAgIGxpc3RJdGVtOiB7IHR5cGU6ICdpdGVtJywgbGlzdERhdGE6IHsgdGFzazogYXR0cnMudGFzaywgY2hlY2tlZDogYXR0cnMuY2hlY2tlZCB9IH0sXG4gICAgICAgIHRhYmxlSGVhZENlbGw6IHsgdHlwZTogJ3RhYmxlQ2VsbCcsIGNlbGxUeXBlOiAnaGVhZCcsIGFsaWduOiBhdHRycy5hbGlnbiB9LFxuICAgICAgICB0YWJsZUJvZHlDZWxsOiB7IHR5cGU6ICd0YWJsZUNlbGwnLCBjZWxsVHlwZTogJ2JvZHknLCBhbGlnbjogYXR0cnMuYWxpZ24gfSxcbiAgICAgICAgY3VzdG9tQmxvY2s6IHsgaW5mbzogYXR0cnMuaW5mbyB9LFxuICAgIH07XG4gICAgdmFyIG5vZGVJbmZvID0gbm9kZVR5cGVNYXBbbm9kZVR5cGVdO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBtZExpa2VOb2RlKSwgbm9kZUluZm8pO1xuICAgIC8vIGh0bWwgYmxvY2ssIGlubGluZSBub2RlXG4gICAgdmFyIF9hID0gbm9kZS5hdHRycywgaHRtbEF0dHJzID0gX2EuaHRtbEF0dHJzLCBjaGlsZHJlbkhUTUwgPSBfYS5jaGlsZHJlbkhUTUw7XG4gICAgaWYgKGh0bWxBdHRycykge1xuICAgICAgICByZXR1cm4gX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBhdHRyaWJ1dGVzKSwgeyBhdHRyczogaHRtbEF0dHJzLCBjaGlsZHJlbkhUTUw6IGNoaWxkcmVuSFRNTCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5cbnZhciB0b2tlblRvRE9NTm9kZSA9IHtcbiAgICBvcGVuVGFnOiBmdW5jdGlvbiAodG9rZW4sIHN0YWNrKSB7XG4gICAgICAgIHZhciBfYSA9IHRva2VuLCB0YWdOYW1lID0gX2EudGFnTmFtZSwgY2xhc3NOYW1lcyA9IF9hLmNsYXNzTmFtZXMsIGF0dHJpYnV0ZXMgPSBfYS5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBhdHRycyA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgYXR0cnMpLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBdHRyaWJ1dGVzKGF0dHJzLCBlbCk7XG4gICAgICAgIHN0YWNrLnB1c2goZWwpO1xuICAgIH0sXG4gICAgY2xvc2VUYWc6IGZ1bmN0aW9uIChfLCBzdGFjaykge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGVsID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBsYXN0JDEoc3RhY2spLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaHRtbDogZnVuY3Rpb24gKHRva2VuLCBzdGFjaykge1xuICAgICAgICBsYXN0JDEoc3RhY2spLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgdG9rZW4uY29udGVudCk7XG4gICAgfSxcbiAgICB0ZXh0OiBmdW5jdGlvbiAodG9rZW4sIHN0YWNrKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLmNvbnRlbnQpO1xuICAgICAgICBsYXN0JDEoc3RhY2spLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICB9LFxufTtcbnZhciBXd1RvRE9NQWRhcHRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXd1RvRE9NQWRhcHRvcihsaW5rQXR0cmlidXRlcywgY3VzdG9tUmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRvcnMgPSBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tUmVuZGVyZXIpO1xuICAgICAgICB2YXIgY3VzdG9tSFRNTENvbnZlcnRvciA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgY3VzdG9tUmVuZGVyZXIuaHRtbEJsb2NrKSwgY3VzdG9tUmVuZGVyZXIuaHRtbElubGluZSk7XG4gICAgICAgIC8vIGZsYXR0ZW4gdGhlIGh0bWwgYmxvY2ssIGlubGluZSBjb252ZXJ0b3IgdG8gb3RoZXIgY3VzdG9tIGNvbnZlcnRvcnNcbiAgICAgICAgdGhpcy5jdXN0b21Db252ZXJ0b3JLZXlzID0gT2JqZWN0LmtleXMoY3VzdG9tUmVuZGVyZXIpLmNvbmNhdChPYmplY3Qua2V5cyhjdXN0b21IVE1MQ29udmVydG9yKSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICAgICAgY29udmVydG9yczogX19hc3NpZ24kMShfX2Fzc2lnbiQxKHt9LCBjb252ZXJ0b3JzKSwgY3VzdG9tSFRNTENvbnZlcnRvciksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnZlcnRvcnMgPSB0aGlzLnJlbmRlcmVyLmdldENvbnZlcnRvcnMoKTtcbiAgICB9XG4gICAgV3dUb0RPTUFkYXB0b3IucHJvdG90eXBlLmdlbmVyYXRlVG9rZW5zID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG1kTGlrZU5vZGUgPSBjcmVhdGVNZExpa2VOb2RlKG5vZGUpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGVudGVyaW5nOiB0cnVlLFxuICAgICAgICAgICAgbGVhZjogaXNQbU5vZGUobm9kZSkgPyBub2RlLmlzTGVhZiA6IGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5yZW5kZXJlci5nZXRPcHRpb25zKCksXG4gICAgICAgICAgICBnZXRDaGlsZHJlblRleHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChpc1BtTm9kZShub2RlKSA/IG5vZGUudGV4dENvbnRlbnQgOiAnJyk7IH0sXG4gICAgICAgICAgICBza2lwQ2hpbGRyZW46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udmVydG9yID0gdGhpcy5jb252ZXJ0b3JzW25vZGUudHlwZS5uYW1lXTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGNvbnZlcnRvcihtZExpa2VOb2RlLCBjb250ZXh0LCB0aGlzLmNvbnZlcnRvcnMpO1xuICAgICAgICB2YXIgdG9rZW5zID0gaXNBcnJheV8xKGNvbnZlcnRlZCkgPyBjb252ZXJ0ZWQgOiBbY29udmVydGVkXTtcbiAgICAgICAgaWYgKGlzQ29udGFpbmVyKG5vZGUudHlwZS5uYW1lKSB8fCBub2RlLmF0dHJzLmh0bWxJbmxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZW50ZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBpc1BtTm9kZShub2RlKSA/IG5vZGUudGV4dENvbnRlbnQgOiAnJyB9KTtcbiAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQoY29udmVydG9yKG1kTGlrZU5vZGUsIGNvbnRleHQsIHRoaXMuY29udmVydG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcbiAgICBXd1RvRE9NQWRhcHRvci5wcm90b3R5cGUudG9ET01Ob2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IHRoaXMuZ2VuZXJhdGVUb2tlbnMobm9kZSk7XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIHRva2VuVG9ET01Ob2RlW3Rva2VuLnR5cGVdKHRva2VuLCBzdGFjayk7IH0pO1xuICAgICAgICByZXR1cm4gc3RhY2tbMF07XG4gICAgfTtcbiAgICBXd1RvRE9NQWRhcHRvci5wcm90b3R5cGUuZ2V0VG9ET01Ob2RlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuY3VzdG9tQ29udmVydG9yS2V5cywgbmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRE9NTm9kZS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFd3VG9ET01BZGFwdG9yO1xufSgpKTtcblxudmFyIEFOSU1BVElPTl9USU1FID0gMTAwO1xudmFyIFNDUk9MTF9CTE9DS0lOR19SRVNFVF9ERUxBWSA9IDE1O1xudmFyIGN1cnJlbnRUaW1lb3V0SWQgPSBudWxsO1xudmFyIHJlbGVhc2VUaW1lciA9IG51bGw7XG5mdW5jdGlvbiBydW4oZGVsdGFTY3JvbGxUb3AsIF9hKSB7XG4gICAgdmFyIHN5bmNTY3JvbGxUb3AgPSBfYS5zeW5jU2Nyb2xsVG9wLCByZWxlYXNlRXZlbnRCbG9jayA9IF9hLnJlbGVhc2VFdmVudEJsb2NrO1xuICAgIGlmIChyZWxlYXNlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlbGVhc2VUaW1lcik7XG4gICAgfVxuICAgIHN5bmNTY3JvbGxUb3AoZGVsdGFTY3JvbGxUb3ApO1xuICAgIHJlbGVhc2VUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZWxlYXNlRXZlbnRCbG9jaygpO1xuICAgIH0sIFNDUk9MTF9CTE9DS0lOR19SRVNFVF9ERUxBWSk7XG59XG5mdW5jdGlvbiBhbmltYXRlKGN1clNjcm9sbFRvcCwgdGFyZ2V0U2Nyb2xsVG9wLCBzeW5jQ2FsbGJhY2tzKSB7XG4gICAgdmFyIGRpZmYgPSB0YXJnZXRTY3JvbGxUb3AgLSBjdXJTY3JvbGxUb3A7XG4gICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IChzdGVwVGltZSAtIHN0YXJ0VGltZSkgLyBBTklNQVRJT05fVElNRTtcbiAgICAgICAgdmFyIGRlbHRhVmFsdWU7XG4gICAgICAgIGlmIChjdXJyZW50VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY3VycmVudFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyZXNzIDwgMSkge1xuICAgICAgICAgICAgZGVsdGFWYWx1ZSA9IGN1clNjcm9sbFRvcCArIGRpZmYgKiBNYXRoLmNvcygoKDEgLSBwcm9ncmVzcykgKiBNYXRoLlBJKSAvIDIpO1xuICAgICAgICAgICAgcnVuKE1hdGguY2VpbChkZWx0YVZhbHVlKSwgc3luY0NhbGxiYWNrcyk7XG4gICAgICAgICAgICBjdXJyZW50VGltZW91dElkID0gc2V0VGltZW91dChzdGVwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bih0YXJnZXRTY3JvbGxUb3AsIHN5bmNDYWxsYmFja3MpO1xuICAgICAgICAgICAgY3VycmVudFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0ZXAoKTtcbn1cblxudmFyIEVESVRPUl9CT1RUT01fUEFERElORyA9IDE4O1xudmFyIFNjcm9sbFN5bmMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nyb2xsU3luYyhtZEVkaXRvciwgcHJldmlldywgZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0RWRpdG9yU2Nyb2xsVG9wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RQcmV2aWV3U2Nyb2xsVG9wID0gbnVsbDtcbiAgICAgICAgdGhpcy5ibG9ja2VkU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZpZXdSb290ID0gcHJldmlldy5wcmV2aWV3Q29udGVudCwgcHJldmlld0VsID0gcHJldmlldy5lbDtcbiAgICAgICAgdGhpcy5wcmV2aWV3Um9vdCA9IHByZXZpZXdSb290O1xuICAgICAgICB0aGlzLnByZXZpZXdFbCA9IHByZXZpZXdFbDtcbiAgICAgICAgdGhpcy5tZEVkaXRvciA9IG1kRWRpdG9yO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcgPSBtZEVkaXRvci52aWV3O1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG1kRWRpdG9yLmdldFRvYXN0TWFyaygpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcbiAgICAgICAgdGhpcy5hZGRTY3JvbGxTeW5jRXZlbnQoKTtcbiAgICB9XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuYWRkU2Nyb2xsU3luY0V2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2FmdGVyUHJldmlld1JlbmRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIHRoZSAnYWZ0ZXJQcmV2aWV3UmVuZGVyJyBldmVudCBoYXMgb2NjdXJyZWQsXG4gICAgICAgICAgICAvLyBicm93c2VyIHJlbmRlcmluZyBpcyBub3QgeWV0IGNvbXBsZXRlLlxuICAgICAgICAgICAgLy8gU28gdGhlIHNpemUgb2YgZWxlbWVudHMgY2FuIG5vdCBiZSBhY2N1cmF0ZWx5IG1lYXN1cmVkLlxuICAgICAgICAgICAgX3RoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zeW5jUHJldmlld1Njcm9sbFRvcCh0cnVlKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3Njcm9sbCcsIGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdlZGl0b3InICYmIF90aGlzLmJsb2NrZWRTY3JvbGwgIT09ICdlZGl0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN5bmNQcmV2aWV3U2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdwcmV2aWV3JyAmJiBfdGhpcy5ibG9ja2VkU2Nyb2xsICE9PSAncHJldmlldycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3luY0VkaXRvclNjcm9sbFRvcChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ3RvZ2dsZVNjcm9sbFN5bmMnLCBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgICAgICAgICBfdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuZ2V0TWROb2RlQXRQb3MgPSBmdW5jdGlvbiAoZG9jLCBwb3NJbmZvKSB7XG4gICAgICAgIHZhciBpbmRleEluZm8gPSBkb2MuY29udGVudC5maW5kSW5kZXgocG9zSW5mby5wb3MpO1xuICAgICAgICB2YXIgbGluZSA9IGluZGV4SW5mby5pbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUobGluZSArIDEpO1xuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wQnlDYXJldFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMubWRFZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciBmaXJzdE1kTm9kZSA9IHRoaXMudG9hc3RNYXJrLmZpbmRGaXJzdE5vZGVBdExpbmUocG9zWzBdWzBdKTtcbiAgICAgICAgdmFyIHByZXZpZXdIZWlnaHQgPSB0aGlzLnByZXZpZXdFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBlbCA9IGdldFBhcmVudE5vZGVPYmoodGhpcy5wcmV2aWV3Um9vdCwgZmlyc3RNZE5vZGUpLmVsO1xuICAgICAgICB2YXIgdG90YWxPZmZzZXRUb3AgPSBnZXRUb3RhbE9mZnNldFRvcChlbCwgdGhpcy5wcmV2aWV3Um9vdCkgfHwgZWwub2Zmc2V0VG9wO1xuICAgICAgICB2YXIgbm9kZUhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgLy8gbXVsdGlwbHkgMC41IGZvciBjYWxjdWxhdGluZyB0aGUgcG9zaXRpb24gaW4gdGhlIG1pZGRsZSBvZiBwcmV2aWV3IGFyZWFcbiAgICAgICAgdmFyIHRhcmdldFNjcm9sbFRvcCA9IHRvdGFsT2Zmc2V0VG9wICsgbm9kZUhlaWdodCAtIHByZXZpZXdIZWlnaHQgKiAwLjU7XG4gICAgICAgIHRoaXMubGF0ZXN0RWRpdG9yU2Nyb2xsVG9wID0gbnVsbDtcbiAgICAgICAgdmFyIGRpZmYgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0aGlzLnByZXZpZXdFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIHJldHVybiBkaWZmIDwgcHJldmlld0hlaWdodCA/IG51bGwgOiB0YXJnZXRTY3JvbGxUb3A7XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5zeW5jUHJldmlld1Njcm9sbFRvcCA9IGZ1bmN0aW9uIChlZGl0aW5nKSB7XG4gICAgICAgIGlmIChlZGl0aW5nID09PSB2b2lkIDApIHsgZWRpdGluZyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGVkaXRvclZpZXcgPSBfYS5lZGl0b3JWaWV3LCBwcmV2aWV3RWwgPSBfYS5wcmV2aWV3RWwsIHByZXZpZXdSb290ID0gX2EucHJldmlld1Jvb3Q7XG4gICAgICAgIHZhciBfYiA9IGVkaXRvclZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2IubGVmdCwgdG9wID0gX2IudG9wO1xuICAgICAgICB2YXIgcG9zSW5mbyA9IGVkaXRvclZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9KTtcbiAgICAgICAgdmFyIGRvYyA9IGVkaXRvclZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB2YXIgZmlyc3RNZE5vZGUgPSB0aGlzLmdldE1kTm9kZUF0UG9zKGRvYywgcG9zSW5mbyk7XG4gICAgICAgIGlmICghZmlyc3RNZE5vZGUgfHwgaXNIVE1MTm9kZShmaXJzdE1kTm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VyU2Nyb2xsVG9wID0gcHJldmlld0VsLnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIF9jID0gZWRpdG9yVmlldy5kb20sIHNjcm9sbFRvcCA9IF9jLnNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0ID0gX2Muc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgPSBfYy5jbGllbnRIZWlnaHQsIGNoaWxkcmVuID0gX2MuY2hpbGRyZW47XG4gICAgICAgIHZhciBpc0JvdHRvbVBvcyA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCA8PSBjbGllbnRIZWlnaHQgKyBFRElUT1JfQk9UVE9NX1BBRERJTkc7XG4gICAgICAgIHZhciB0YXJnZXRTY3JvbGxUb3AgPSBpc0JvdHRvbVBvcyA/IHByZXZpZXdFbC5zY3JvbGxIZWlnaHQgOiAwO1xuICAgICAgICBpZiAoc2Nyb2xsVG9wICYmICFpc0JvdHRvbVBvcykge1xuICAgICAgICAgICAgaWYgKGVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wQnlFZGl0aW5nID0gdGhpcy5nZXRTY3JvbGxUb3BCeUNhcmV0UG9zKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxUb3BCeUVkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgPSBzY3JvbGxUb3BCeUVkaXRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2QgPSBnZXRQYXJlbnROb2RlT2JqKHRoaXMucHJldmlld1Jvb3QsIGZpcnN0TWROb2RlKSwgZWwgPSBfZC5lbCwgbWROb2RlID0gX2QubWROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBfZSA9IGdldEVkaXRvclJhbmdlSGVpZ2h0SW5mbyhkb2MsIG1kTm9kZSwgY2hpbGRyZW4pLCBoZWlnaHQgPSBfZS5oZWlnaHQsIHJlY3QgPSBfZS5yZWN0O1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbE9mZnNldFRvcCA9IGdldFRvdGFsT2Zmc2V0VG9wKGVsLCBwcmV2aWV3Um9vdCkgfHwgZWwub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciByYXRpbyA9IHRvcCA+IHJlY3QudG9wID8gTWF0aC5taW4oKHRvcCAtIHJlY3QudG9wKSAvIGhlaWdodCwgMSkgOiAwO1xuICAgICAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IHRvdGFsT2Zmc2V0VG9wICsgbm9kZUhlaWdodCAqIHJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0U2Nyb2xsVG9wID0gdGhpcy5nZXRSZXNvbHZlZFNjcm9sbFRvcCgnZWRpdG9yJywgc2Nyb2xsVG9wLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdEVkaXRvclNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0U2Nyb2xsVG9wICE9PSBjdXJTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMucnVuKCdlZGl0b3InLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLnN5bmNFZGl0b3JTY3JvbGxUb3AgPSBmdW5jdGlvbiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB0b2FzdE1hcmsgPSBfYS50b2FzdE1hcmssIGVkaXRvclZpZXcgPSBfYS5lZGl0b3JWaWV3LCBwcmV2aWV3Um9vdCA9IF9hLnByZXZpZXdSb290LCBwcmV2aWV3RWwgPSBfYS5wcmV2aWV3RWw7XG4gICAgICAgIHZhciBkb20gPSBlZGl0b3JWaWV3LmRvbSwgc3RhdGUgPSBlZGl0b3JWaWV3LnN0YXRlO1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gcHJldmlld0VsLnNjcm9sbFRvcCwgY2xpZW50SGVpZ2h0ID0gcHJldmlld0VsLmNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0ID0gcHJldmlld0VsLnNjcm9sbEhlaWdodDtcbiAgICAgICAgdmFyIGlzQm90dG9tUG9zID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIDw9IGNsaWVudEhlaWdodDtcbiAgICAgICAgdmFyIGN1clNjcm9sbFRvcCA9IGRvbS5zY3JvbGxUb3A7XG4gICAgICAgIHZhciB0YXJnZXRTY3JvbGxUb3AgPSBpc0JvdHRvbVBvcyA/IGRvbS5zY3JvbGxIZWlnaHQgOiAwO1xuICAgICAgICBpZiAoc2Nyb2xsVG9wICYmIHRhcmdldE5vZGUgJiYgIWlzQm90dG9tUG9zKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlID0gZmluZEFuY2VzdG9ySGF2aW5nSWQodGFyZ2V0Tm9kZSwgcHJldmlld1Jvb3QpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGRvbS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBtZE5vZGVJZCA9IE51bWJlcih0YXJnZXROb2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSk7XG4gICAgICAgICAgICB2YXIgX2IgPSBnZXRQYXJlbnROb2RlT2JqKHRoaXMucHJldmlld1Jvb3QsIHRvYXN0TWFyay5maW5kTm9kZUJ5SWQobWROb2RlSWQpKSwgbWROb2RlID0gX2IubWROb2RlLCBlbCA9IF9iLmVsO1xuICAgICAgICAgICAgdmFyIG1kTm9kZVN0YXJ0TGluZSA9IGdldE1kU3RhcnRMaW5lKG1kTm9kZSk7XG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgPSBjaGlsZHJlblttZE5vZGVTdGFydExpbmUgLSAxXS5vZmZzZXRUb3A7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZ2V0RWRpdG9yUmFuZ2VIZWlnaHRJbmZvKHN0YXRlLmRvYywgbWROb2RlLCBjaGlsZHJlbikuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIF9jID0gZ2V0QW5kU2F2ZU9mZnNldEluZm8oZWwsIHByZXZpZXdSb290LCBtZE5vZGVJZCksIG5vZGVIZWlnaHQgPSBfYy5ub2RlSGVpZ2h0LCBvZmZzZXRUb3AgPSBfYy5vZmZzZXRUb3A7XG4gICAgICAgICAgICB0YXJnZXRTY3JvbGxUb3AgKz0gZ2V0QWRkaXRpb25hbFBvcyhzY3JvbGxUb3AsIG9mZnNldFRvcCwgbm9kZUhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRhcmdldFNjcm9sbFRvcCA9IHRoaXMuZ2V0UmVzb2x2ZWRTY3JvbGxUb3AoJ3ByZXZpZXcnLCBzY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0UHJldmlld1Njcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0U2Nyb2xsVG9wICE9PSBjdXJTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMucnVuKCdwcmV2aWV3JywgdGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5nZXRSZXNvbHZlZFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChmcm9tLCBzY3JvbGxUb3AsIHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKSB7XG4gICAgICAgIHZhciBsYXRlc3RTY3JvbGxUb3AgPSBmcm9tID09PSAnZWRpdG9yJyA/IHRoaXMubGF0ZXN0RWRpdG9yU2Nyb2xsVG9wIDogdGhpcy5sYXRlc3RQcmV2aWV3U2Nyb2xsVG9wO1xuICAgICAgICBpZiAobGF0ZXN0U2Nyb2xsVG9wID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0U2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXRlc3RTY3JvbGxUb3AgPCBzY3JvbGxUb3BcbiAgICAgICAgICAgID8gTWF0aC5tYXgodGFyZ2V0U2Nyb2xsVG9wLCBjdXJTY3JvbGxUb3ApXG4gICAgICAgICAgICA6IE1hdGgubWluKHRhcmdldFNjcm9sbFRvcCwgY3VyU2Nyb2xsVG9wKTtcbiAgICB9O1xuICAgIFNjcm9sbFN5bmMucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmcm9tLCB0YXJnZXRTY3JvbGxUb3AsIGN1clNjcm9sbFRvcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoZnJvbSA9PT0gJ2VkaXRvcicpIHtcbiAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHRoaXMucHJldmlld0VsO1xuICAgICAgICAgICAgdGhpcy5ibG9ja2VkU2Nyb2xsID0gJ3ByZXZpZXcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gdGhpcy5lZGl0b3JWaWV3LmRvbTtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tlZFNjcm9sbCA9ICdlZGl0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeW5jQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgc3luY1Njcm9sbFRvcDogZnVuY3Rpb24gKHNjcm9sbFRvcCkgeyByZXR1cm4gKHNjcm9sbFRhcmdldC5zY3JvbGxUb3AgPSBzY3JvbGxUb3ApOyB9LFxuICAgICAgICAgICAgcmVsZWFzZUV2ZW50QmxvY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfdGhpcy5ibG9ja2VkU2Nyb2xsID0gbnVsbCk7IH0sXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGUoY3VyU2Nyb2xsVG9wLCB0YXJnZXRTY3JvbGxUb3AsIHN5bmNDYWxsYmFja3MpO1xuICAgIH07XG4gICAgU2Nyb2xsU3luYy5wcm90b3R5cGUuY2xlYXJUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxTeW5jLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKCdzY3JvbGwnKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKCdhZnRlclByZXZpZXdSZW5kZXInKTtcbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxTeW5jO1xufSgpKTtcblxudmFyIHF1ZXJ5TWFwID0ge1xuICAgIGdldFBvcHVwSW5pdGlhbFZhbHVlczogZnVuY3Rpb24gKGVkaXRvciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgcG9wdXBOYW1lID0gcGF5bG9hZC5wb3B1cE5hbWU7XG4gICAgICAgIHJldHVybiBwb3B1cE5hbWUgPT09ICdsaW5rJyA/IHsgbGlua1RleHQ6IGVkaXRvci5nZXRTZWxlY3RlZFRleHQoKSB9IDoge307XG4gICAgfSxcbn07XG5mdW5jdGlvbiBidWlsZFF1ZXJ5KGVkaXRvcikge1xuICAgIGVkaXRvci5ldmVudEVtaXR0ZXIubGlzdGVuKCdxdWVyeScsIGZ1bmN0aW9uIChxdWVyeSwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gcXVlcnlNYXBbcXVlcnldKGVkaXRvciwgcGF5bG9hZCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVG9hc3RVSUVkaXRvckNvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbiBvYmplY3RcbiAqICAgICBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLmVsIC0gY29udGFpbmVyIGVsZW1lbnRcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaGVpZ2h0PSczMDBweCddIC0gRWRpdG9yJ3MgaGVpZ2h0IHN0eWxlIHZhbHVlLiBIZWlnaHQgaXMgYXBwbGllZCBhcyBib3JkZXItYm94IGV4KSAnMzAwcHgnLCAnMTAwJScsICdhdXRvJ1xuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5taW5IZWlnaHQ9JzIwMHB4J10gLSBFZGl0b3IncyBtaW4taGVpZ2h0IHN0eWxlIHZhbHVlIGluIHBpeGVsIGV4KSAnMzAwcHgnXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluaXRpYWxWYWx1ZV0gLSBFZGl0b3IncyBpbml0aWFsIHZhbHVlXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByZXZpZXdTdHlsZV0gLSBNYXJrZG93biBlZGl0b3IncyBwcmV2aWV3IHN0eWxlICh0YWIsIHZlcnRpY2FsKVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJldmlld0hpZ2hsaWdodCA9IHRydWVdIC0gSGlnaGxpZ2h0IGEgcHJldmlldyBlbGVtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBjdXJzb3IgcG9zaXRpb24gaW4gdGhlIG1hcmtkb3duIGVkaXRvclxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5pbml0aWFsRWRpdFR5cGVdIC0gSW5pdGlhbCBlZGl0b3IgdHlwZSAobWFya2Rvd24sIHd5c2l3eWcpXG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV2ZW50c10gLSBFdmVudHNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmxvYWRdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBmdWxseSBsb2FkXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5jaGFuZ2VdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGNvbnRlbnQgY2hhbmdlZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2FyZXRDaGFuZ2VdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGZvcm1hdCBjaGFuZ2UgYnkgY3Vyc29yIHBvc2l0aW9uXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5mb2N1c10gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGdldCBmb2N1c1xuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuYmx1cl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gZWRpdG9yIGxvb3NlIGZvY3VzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5rZXlkb3duXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiB0aGUga2V5IGlzIHByZXNzZWQgaW4gZWRpdG9yXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5rZXl1cF0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIHdoZW4gdGhlIGtleSBpcyByZWxlYXNlZCBpbiBlZGl0b3JcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmJlZm9yZVByZXZpZXdSZW5kZXJdIC0gSXQgd291bGQgYmUgZW1pdHRlZCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBtYXJrZG93biBwcmV2aWV3IHdpdGggaHRtbCBzdHJpbmdcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmJlZm9yZUNvbnZlcnRXeXNpd3lnVG9NYXJrZG93bl0gLSBJdCB3b3VsZCBiZSBlbWl0dGVkIGJlZm9yZSBjb252ZXJ0aW5nIHd5c2l3eWcgdG8gbWFya2Rvd24gd2l0aCBtYXJrZG93biB0ZXh0XG4gKiAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmhvb2tzXSAtIEhvb2tzXG4gKiAgICAgICAgIEBwYXJhbSB7YWRkSW1hZ2VCbG9iSG9va30gW29wdGlvbnMuaG9va3MuYWRkSW1hZ2VCbG9iSG9va10gLSBob29rIGZvciBpbWFnZSB1cGxvYWRcbiAqICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9J2VuLVVTJ10gLSBsYW5ndWFnZVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNlQ29tbWFuZFNob3J0Y3V0PXRydWVdIC0gd2hldGhlciB1c2Uga2V5Ym9hcmQgc2hvcnRjdXRzIHRvIHBlcmZvcm0gY29tbWFuZHNcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVzYWdlU3RhdGlzdGljcz10cnVlXSAtIHNlbmQgaG9zdG5hbWUgdG8gZ29vZ2xlIGFuYWx5dGljc1xuICogICAgIEBwYXJhbSB7QXJyYXkuPHN0cmluZ3x0b29sYmFySXRlbXNWYWx1ZT59IFtvcHRpb25zLnRvb2xiYXJJdGVtc10gLSB0b29sYmFyIGl0ZW1zLlxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGlkZU1vZGVTd2l0Y2g9ZmFsc2VdIC0gaGlkZSBtb2RlIHN3aXRjaCB0YWIgYmFyXG4gKiAgICAgQHBhcmFtIHtBcnJheS48ZnVuY3Rpb258QXJyYXk+fSBbb3B0aW9ucy5wbHVnaW5zXSAtIEFycmF5IG9mIHBsdWdpbnMuIEEgcGx1Z2luIGNhbiBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciBhbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbZnVuY3Rpb24sIG9wdGlvbnNdLlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbmRlZEF1dG9saW5rc10gLSBVc2luZyBleHRlbmRlZCBBdXRvbGlua3Mgc3BlY2lmaWVkIGluIEdGTSBzcGVjXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBsYWNlaG9sZGVyXSAtIFRoZSBwbGFjZWhvbGRlciB0ZXh0IG9mIHRoZSBlZGl0YWJsZSBlbGVtZW50LlxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5saW5rQXR0cmlidXRlc10gLSBBdHRyaWJ1dGVzIG9mIGFuY2hvciBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbCwgdGFyZ2V0LCBocmVmbGFuZywgdHlwZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXI9bnVsbF0gLSBPYmplY3QgY29udGFpbmluZyBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb25zIGNvcnJlc3BvbmQgdG8gY2hhbmdlIG1hcmtkb3duIG5vZGUgdG8gcHJldmlldyBIVE1MIG9yIHd5c2l3eWcgbm9kZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jdXN0b21NYXJrZG93blJlbmRlcmVyPW51bGxdIC0gT2JqZWN0IGNvbnRhaW5pbmcgY3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9ucyBjb3JyZXNwb25kIHRvIGNoYW5nZSB3eXNpd3lnIG5vZGUgdG8gbWFya2Rvd24gdGV4dFxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgc3BlY2lmaWNhdGlvbiBvZiBsaW5rIHJlZmVyZW5jZSBkZWZpbml0aW9uXG4gKiAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY3VzdG9tSFRNTFNhbml0aXplcj1udWxsXSAtIGN1c3RvbSBIVE1MIHNhbml0aXplclxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucHJldmlld0hpZ2hsaWdodD1mYWxzZV0gLSB3aGV0aGVyIGhpZ2hsaWdodCBwcmV2aWV3IGFyZWFcbiAqICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZyb250TWF0dGVyPWZhbHNlXSAtIHdoZXRoZXIgdXNlIHRoZSBmcm9udCBtYXR0ZXJcbiAqICAgICBAcGFyYW0ge0FycmF5LjxvYmplY3Q+fSBbb3B0aW9ucy53aWRnZXRSdWxlcz1bXV0gLSBUaGUgcnVsZXMgZm9yIHJlcGxhY2luZyB0aGUgdGV4dCB3aXRoIHdpZGdldCBub2RlXG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRoZW1lXSAtIFRoZSB0aGVtZSB0byBzdHlsZSB0aGUgZWRpdG9yIHdpdGguIFRoZSBkZWZhdWx0IGlzIGluY2x1ZGVkIGluIHRvYXN0dWktZWRpdG9yLmNzcy5cbiAqICAgICBAcGFyYW0ge2F1dG9mb2N1c30gW29wdGlvbnMuYXV0b2ZvY3VzPXRydWVdIC0gYXV0b21hdGljYWxseSBmb2N1cyB0aGUgZWRpdG9yIG9uIGNyZWF0aW9uLlxuICovXG52YXIgVG9hc3RVSUVkaXRvckNvcmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9hc3RVSUVkaXRvckNvcmUob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXRpYWxIVE1MID0gb3B0aW9ucy5lbC5pbm5lckhUTUw7XG4gICAgICAgIG9wdGlvbnMuZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZF8xKHtcbiAgICAgICAgICAgIHByZXZpZXdTdHlsZTogJ3RhYicsXG4gICAgICAgICAgICBwcmV2aWV3SGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgaW5pdGlhbEVkaXRUeXBlOiAnbWFya2Rvd24nLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMzAwcHgnLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiAnMjAwcHgnLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6ICdlbi1VUycsXG4gICAgICAgICAgICB1c2VDb21tYW5kU2hvcnRjdXQ6IHRydWUsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRydWUsXG4gICAgICAgICAgICB0b29sYmFySXRlbXM6IFtcbiAgICAgICAgICAgICAgICBbJ2hlYWRpbmcnLCAnYm9sZCcsICdpdGFsaWMnLCAnc3RyaWtlJ10sXG4gICAgICAgICAgICAgICAgWydocicsICdxdW90ZSddLFxuICAgICAgICAgICAgICAgIFsndWwnLCAnb2wnLCAndGFzaycsICdpbmRlbnQnLCAnb3V0ZGVudCddLFxuICAgICAgICAgICAgICAgIFsndGFibGUnLCAnaW1hZ2UnLCAnbGluayddLFxuICAgICAgICAgICAgICAgIFsnY29kZScsICdjb2RlYmxvY2snXSxcbiAgICAgICAgICAgICAgICBbJ3Njcm9sbFN5bmMnXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBoaWRlTW9kZVN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlczogbnVsbCxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgICAgIGN1c3RvbU1hcmtkb3duUmVuZGVyZXI6IG51bGwsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxTYW5pdGl6ZXI6IG51bGwsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZmFsc2UsXG4gICAgICAgICAgICB3aWRnZXRSdWxlczogW10sXG4gICAgICAgICAgICB0aGVtZTogJ2xpZ2h0JyxcbiAgICAgICAgICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgY3VzdG9tSFRNTFJlbmRlcmVyID0gX2EuY3VzdG9tSFRNTFJlbmRlcmVyLCBleHRlbmRlZEF1dG9saW5rcyA9IF9hLmV4dGVuZGVkQXV0b2xpbmtzLCByZWZlcmVuY2VEZWZpbml0aW9uID0gX2EucmVmZXJlbmNlRGVmaW5pdGlvbiwgZnJvbnRNYXR0ZXIgPSBfYS5mcm9udE1hdHRlciwgY3VzdG9tTWFya2Rvd25SZW5kZXJlciA9IF9hLmN1c3RvbU1hcmtkb3duUmVuZGVyZXIsIHVzZUNvbW1hbmRTaG9ydGN1dCA9IF9hLnVzZUNvbW1hbmRTaG9ydGN1dCwgaW5pdGlhbEVkaXRUeXBlID0gX2EuaW5pdGlhbEVkaXRUeXBlLCB3aWRnZXRSdWxlcyA9IF9hLndpZGdldFJ1bGVzLCBjdXN0b21IVE1MU2FuaXRpemVyID0gX2EuY3VzdG9tSFRNTFNhbml0aXplcjtcbiAgICAgICAgdGhpcy5tb2RlID0gaW5pdGlhbEVkaXRUeXBlIHx8ICdtYXJrZG93bic7XG4gICAgICAgIHRoaXMubWRQcmV2aWV3U3R5bGUgPSB0aGlzLm9wdGlvbnMucHJldmlld1N0eWxlO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgICAgICB0aGlzLmkxOG4uc2V0Q29kZSh0aGlzLm9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgc2V0V2lkZ2V0UnVsZXMod2lkZ2V0UnVsZXMpO1xuICAgICAgICB2YXIgbGlua0F0dHJpYnV0ZXMgPSBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmxpbmtBdHRyaWJ1dGVzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5JbmZvID0gZ2V0UGx1Z2luSW5mbyh7XG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLm9wdGlvbnMucGx1Z2lucyxcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlcjogdGhpcy5ldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHRoaXMub3B0aW9ucy51c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucGx1Z2luSW5mbywgdG9IVE1MUmVuZGVyZXJzID0gX2IudG9IVE1MUmVuZGVyZXJzLCB0b01hcmtkb3duUmVuZGVyZXJzID0gX2IudG9NYXJrZG93blJlbmRlcmVycywgbWRQbHVnaW5zID0gX2IubWRQbHVnaW5zLCB3d1BsdWdpbnMgPSBfYi53d1BsdWdpbnMsIHd3Tm9kZVZpZXdzID0gX2Iud3dOb2RlVmlld3MsIG1kQ29tbWFuZHMgPSBfYi5tZENvbW1hbmRzLCB3d0NvbW1hbmRzID0gX2Iud3dDb21tYW5kcywgbWFya2Rvd25QYXJzZXJzID0gX2IubWFya2Rvd25QYXJzZXJzO1xuICAgICAgICB2YXIgcmVuZGVyZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgbGlua0F0dHJpYnV0ZXM6IGxpbmtBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBkZWVwTWVyZ2VkQ29weSh0b0hUTUxSZW5kZXJlcnMsIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgICAgICBleHRlbmRlZEF1dG9saW5rczogZXh0ZW5kZWRBdXRvbGlua3MsXG4gICAgICAgICAgICByZWZlcmVuY2VEZWZpbml0aW9uOiByZWZlcmVuY2VEZWZpbml0aW9uLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuICAgICAgICAgICAgc2FuaXRpemVyOiBjdXN0b21IVE1MU2FuaXRpemVyIHx8IHNhbml0aXplSFRNTCxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHd3VG9ET01BZGFwdG9yID0gbmV3IFd3VG9ET01BZGFwdG9yKGxpbmtBdHRyaWJ1dGVzLCByZW5kZXJlck9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyKTtcbiAgICAgICAgdmFyIGh0bWxTY2hlbWFNYXAgPSBjcmVhdGVIVE1MU2NoZW1hTWFwKHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIsIHJlbmRlcmVyT3B0aW9ucy5zYW5pdGl6ZXIsIHd3VG9ET01BZGFwdG9yKTtcbiAgICAgICAgdGhpcy50b2FzdE1hcmsgPSBuZXcgVG9hc3RNYXJrKCcnLCB7XG4gICAgICAgICAgICBkaXNhbGxvd2VkSHRtbEJsb2NrVGFnczogWydicicsICdpbWcnXSxcbiAgICAgICAgICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBleHRlbmRlZEF1dG9saW5rcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZURlZmluaXRpb246IHJlZmVyZW5jZURlZmluaXRpb24sXG4gICAgICAgICAgICBkaXNhbGxvd0RlZXBIZWFkaW5nOiB0cnVlLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyLFxuICAgICAgICAgICAgY3VzdG9tUGFyc2VyOiBtYXJrZG93blBhcnNlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1kRWRpdG9yID0gbmV3IE1kRWRpdG9yKHRoaXMuZXZlbnRFbWl0dGVyLCB7XG4gICAgICAgICAgICB0b2FzdE1hcms6IHRoaXMudG9hc3RNYXJrLFxuICAgICAgICAgICAgdXNlQ29tbWFuZFNob3J0Y3V0OiB1c2VDb21tYW5kU2hvcnRjdXQsXG4gICAgICAgICAgICBtZFBsdWdpbnM6IG1kUGx1Z2lucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldmlldyA9IG5ldyBNYXJrZG93blByZXZpZXcodGhpcy5ldmVudEVtaXR0ZXIsIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcmVuZGVyZXJPcHRpb25zKSwgeyBpc1ZpZXdlcjogZmFsc2UsIGhpZ2hsaWdodDogdGhpcy5vcHRpb25zLnByZXZpZXdIaWdobGlnaHQgfSkpO1xuICAgICAgICB0aGlzLnd3RWRpdG9yID0gbmV3IFd5c2l3eWdFZGl0b3IodGhpcy5ldmVudEVtaXR0ZXIsIHtcbiAgICAgICAgICAgIHRvRE9NQWRhcHRvcjogd3dUb0RPTUFkYXB0b3IsXG4gICAgICAgICAgICB1c2VDb21tYW5kU2hvcnRjdXQ6IHVzZUNvbW1hbmRTaG9ydGN1dCxcbiAgICAgICAgICAgIGh0bWxTY2hlbWFNYXA6IGh0bWxTY2hlbWFNYXAsXG4gICAgICAgICAgICBsaW5rQXR0cmlidXRlczogbGlua0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICB3d1BsdWdpbnM6IHd3UGx1Z2lucyxcbiAgICAgICAgICAgIHd3Tm9kZVZpZXdzOiB3d05vZGVWaWV3cyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29udmVydG9yID0gbmV3IENvbnZlcnRvcih0aGlzLnd3RWRpdG9yLmdldFNjaGVtYSgpLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIHRvTWFya2Rvd25SZW5kZXJlcnMpLCBjdXN0b21NYXJrZG93blJlbmRlcmVyKSwgZ2V0SFRNTFJlbmRlckNvbnZlcnRvcnMobGlua0F0dHJpYnV0ZXMsIHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIpLCB0aGlzLmV2ZW50RW1pdHRlcik7XG4gICAgICAgIHRoaXMuc2V0TWluSGVpZ2h0KHRoaXMub3B0aW9ucy5taW5IZWlnaHQpO1xuICAgICAgICB0aGlzLnNldEhlaWdodCh0aGlzLm9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5zZXRNYXJrZG93bih0aGlzLm9wdGlvbnMuaW5pdGlhbFZhbHVlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIodGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SFRNTCh0aGlzLmluaXRpYWxIVE1MLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcih0aGlzLmV2ZW50RW1pdHRlciwgdGhpcy5tZEVkaXRvci5jb21tYW5kcywgdGhpcy53d0VkaXRvci5jb21tYW5kcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubW9kZTsgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNhZ2VTdGF0aXN0aWNzKSB7XG4gICAgICAgICAgICBzZW5kSG9zdE5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbFN5bmMgPSBuZXcgU2Nyb2xsU3luYyh0aGlzLm1kRWRpdG9yLCB0aGlzLnByZXZpZXcsIHRoaXMuZXZlbnRFbWl0dGVyKTtcbiAgICAgICAgdGhpcy5hZGRJbml0RXZlbnQoKTtcbiAgICAgICAgdGhpcy5hZGRJbml0Q29tbWFuZChtZENvbW1hbmRzLCB3d0NvbW1hbmRzKTtcbiAgICAgICAgYnVpbGRRdWVyeSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob29rcykge1xuICAgICAgICAgICAgZm9yRWFjaE93blByb3BlcnRpZXNfMSh0aGlzLm9wdGlvbnMuaG9va3MsIGZ1bmN0aW9uIChmbiwga2V5KSB7IHJldHVybiBfdGhpcy5hZGRIb29rKGtleSwgZm4pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgICAgZm9yRWFjaE93blByb3BlcnRpZXNfMSh0aGlzLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbiAoZm4sIGtleSkgeyByZXR1cm4gX3RoaXMub24oa2V5LCBmbik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2xvYWQnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yVG9TdGFydCh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcbiAgICB9XG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmFkZEluaXRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5vbignbmVlZENoYW5nZU1vZGUnLCB0aGlzLmNoYW5nZU1vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMub24oJ2xvYWRVSScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5oZWlnaHQgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIC8vIDc1cHggZXF1YWxzIGRlZmF1bHQgZWRpdG9yIHVpIGhlaWdodCAtIHRoZSBlZGl0aW5nIGFyZWEgaGVpZ2h0XG4gICAgICAgICAgICAgICAgdmFyIG1pbkhlaWdodCA9IE1hdGgubWluKHBhcnNlSW50KF90aGlzLm1pbkhlaWdodCwgMTApLCBwYXJzZUludChfdGhpcy5oZWlnaHQsIDEwKSAtIDc1KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRNaW5IZWlnaHQobWluSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFkZERlZmF1bHRJbWFnZUJsb2JIb29rKHRoaXMuZXZlbnRFbWl0dGVyKTtcbiAgICB9O1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5hZGRJbml0Q29tbWFuZCA9IGZ1bmN0aW9uIChtZENvbW1hbmRzLCB3d0NvbW1hbmRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhZGRQbHVnaW5Db21tYW5kcyA9IGZ1bmN0aW9uICh0eXBlLCBjb21tYW5kTWFwKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb21tYW5kTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWRkQ29tbWFuZCh0eXBlLCBuYW1lLCBjb21tYW5kTWFwW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZENvbW1hbmQoJ21hcmtkb3duJywgJ3RvZ2dsZVNjcm9sbFN5bmMnLCBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3RvZ2dsZVNjcm9sbFN5bmMnLCBwYXlsb2FkLmFjdGl2ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFkZFBsdWdpbkNvbW1hbmRzKCdtYXJrZG93bicsIG1kQ29tbWFuZHMpO1xuICAgICAgICBhZGRQbHVnaW5Db21tYW5kcygnd3lzaXd5ZycsIHd3Q29tbWFuZHMpO1xuICAgIH07XG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldEN1cnJlbnRNb2RlRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNNYXJrZG93bk1vZGUoKSA/IHRoaXMubWRFZGl0b3IgOiB0aGlzLnd3RWRpdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIGZvciBFZGl0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb24gZm9yIGluaXRpYWxpemUgVFVJRWRpdG9yXG4gICAgICogQHJldHVybnMge29iamVjdH0gVG9hc3RVSUVkaXRvckNvcmUgb3IgVG9hc3RVSUVkaXRvclZpZXdlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLmZhY3RvcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy52aWV3ZXIgPyBuZXcgVG9hc3RVSUVkaXRvclZpZXdlcihvcHRpb25zKSA6IG5ldyBUb2FzdFVJRWRpdG9yQ29yZShvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBsYW5ndWFnZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjb2RlIC0gY29kZSBmb3IgSTE4TiBsYW5ndWFnZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gbGFuZ3VhZ2Ugc2V0XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUuc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICAgICAgICBpMThuLnNldExhbmd1YWdlKGNvZGUsIGRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY2hhbmdlIHByZXZpZXcgc3R5bGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3R5bGUgLSAndGFiJ3wndmVydGljYWwnXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmNoYW5nZVByZXZpZXdTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5tZFByZXZpZXdTdHlsZSAhPT0gc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMubWRQcmV2aWV3U3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2NoYW5nZVByZXZpZXdTdHlsZScsIHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogZXhlY3V0ZSBlZGl0b3IgY29tbWFuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gY29tbWFuZCBuYW1lXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXlsb2FkXSAtIHBheWxvYWQgZm9yIGNvbW1hbmRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uIChuYW1lLCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIuZXhlYyhuYW1lLCBwYXlsb2FkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZWRpdG9yIHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGNvbW1hbmQgbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbW1hbmQgLSBjb21tYW5kIGhhbmRsZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkQ29tbWFuZCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBjb21tYW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb21tYW5kSG9jID0gZnVuY3Rpb24gKHBheWxhb2QpIHtcbiAgICAgICAgICAgIGlmIChwYXlsYW9kID09PSB2b2lkIDApIHsgcGF5bGFvZCA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgdmlldyA9ICh0eXBlID09PSAnbWFya2Rvd24nID8gX3RoaXMubWRFZGl0b3IgOiBfdGhpcy53d0VkaXRvcikudmlldztcbiAgICAgICAgICAgIGNvbW1hbmQocGF5bGFvZCwgdmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIuYWRkQ29tbWFuZCh0eXBlLCBuYW1lLCBjb21tYW5kSG9jKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJpbmQgZXZlbnRIYW5kbGVyIHRvIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciBFdmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5iaW5kIGV2ZW50SGFuZGxlciBmcm9tIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBob29rIHRvIFRVSUVkaXRvciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuYWRkSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLnJlbW92ZUV2ZW50SGFuZGxlcih0eXBlKTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGhvb2sgZnJvbSBUVUlFZGl0b3IgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnJlbW92ZUhvb2sgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgZm9jdXMgdG8gY3VycmVudCBFZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGZvY3VzIG9mIGN1cnJlbnQgRWRpdG9yXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5ibHVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgY3Vyc29yIHBvc2l0aW9uIHRvIGVuZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvY3VzXSAtIGF1dG9tYXRpY2FsbHkgZm9jdXMgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9FbmQgPSBmdW5jdGlvbiAoZm9jdXMpIHtcbiAgICAgICAgaWYgKGZvY3VzID09PSB2b2lkIDApIHsgZm9jdXMgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5tb3ZlQ3Vyc29yVG9FbmQoZm9jdXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGN1cnNvciBwb3NpdGlvbiB0byBzdGFydFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvY3VzXSAtIGF1dG9tYXRpY2FsbHkgZm9jdXMgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5tb3ZlQ3Vyc29yVG9TdGFydCA9IGZ1bmN0aW9uIChmb2N1cykge1xuICAgICAgICBpZiAoZm9jdXMgPT09IHZvaWQgMCkgeyBmb2N1cyA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLm1vdmVDdXJzb3JUb1N0YXJ0KGZvY3VzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBtYXJrZG93biBzeW50YXggdGV4dC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya2Rvd24gLSBtYXJrZG93biBzeW50YXggdGV4dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjdXJzb3JUb0VuZD10cnVlXSAtIG1vdmUgY3Vyc29yIHRvIGNvbnRlbnRzIGVuZFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRNYXJrZG93biA9IGZ1bmN0aW9uIChtYXJrZG93biwgY3Vyc29yVG9FbmQpIHtcbiAgICAgICAgaWYgKG1hcmtkb3duID09PSB2b2lkIDApIHsgbWFya2Rvd24gPSAnJzsgfVxuICAgICAgICBpZiAoY3Vyc29yVG9FbmQgPT09IHZvaWQgMCkgeyBjdXJzb3JUb0VuZCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRNYXJrZG93bihtYXJrZG93biwgY3Vyc29yVG9FbmQpO1xuICAgICAgICBpZiAodGhpcy5pc1d5c2l3eWdNb2RlKCkpIHtcbiAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0aGlzLnRvYXN0TWFyay5nZXRSb290Tm9kZSgpO1xuICAgICAgICAgICAgdmFyIHd3Tm9kZSA9IHRoaXMuY29udmVydG9yLnRvV3lzaXd5Z01vZGVsKG1kTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnd3RWRpdG9yLnNldE1vZGVsKHd3Tm9kZSwgY3Vyc29yVG9FbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgaHRtbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCAtIGh0bWwgc3ludGF4IHRleHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjdXJzb3JUb0VuZD10cnVlXSAtIG1vdmUgY3Vyc29yIHRvIGNvbnRlbnRzIGVuZFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRIVE1MID0gZnVuY3Rpb24gKGh0bWwsIGN1cnNvclRvRW5kKSB7XG4gICAgICAgIGlmIChodG1sID09PSB2b2lkIDApIHsgaHRtbCA9ICcnOyB9XG4gICAgICAgIGlmIChjdXJzb3JUb0VuZCA9PT0gdm9pZCAwKSB7IGN1cnNvclRvRW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIHRoZSBgYnJgIHRhZyBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBlbXB0eSBibG9jayB0byBzZXBhcmF0ZSBiZXR3ZWVuIGJsb2Nrc1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gcmVwbGFjZUJSV2l0aEVtcHR5QmxvY2soaHRtbCk7XG4gICAgICAgIHZhciB3d05vZGUgPSBET01QYXJzZXIuZnJvbVNjaGVtYSh0aGlzLnd3RWRpdG9yLnNjaGVtYSkucGFyc2UoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXJrZG93bk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRNYXJrZG93bih0aGlzLmNvbnZlcnRvci50b01hcmtkb3duVGV4dCh3d05vZGUpLCBjdXJzb3JUb0VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnd3RWRpdG9yLnNldE1vZGVsKHd3Tm9kZSwgY3Vyc29yVG9FbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgY29udGVudCB0byBtYXJrZG93blxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IG1hcmtkb3duIHRleHRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0TWFya2Rvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTWFya2Rvd25Nb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1kRWRpdG9yLmdldE1hcmtkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydG9yLnRvTWFya2Rvd25UZXh0KHRoaXMud3dFZGl0b3IuZ2V0TW9kZWwoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgY29udGVudCB0byBodG1sXG4gICAgICogQHJldHVybnMge3N0cmluZ30gaHRtbCBzdHJpbmdcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuaG9sZEV2ZW50SW52b2tlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc01hcmtkb3duTW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IF90aGlzLnRvYXN0TWFyay5nZXRSb290Tm9kZSgpO1xuICAgICAgICAgICAgICAgIHZhciB3d05vZGUgPSBfdGhpcy5jb252ZXJ0b3IudG9XeXNpd3lnTW9kZWwobWROb2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy53d0VkaXRvci5zZXRNb2RlbCh3d05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGh0bWwgPSByZW1vdmVQcm9zZU1pcnJvckhhY2tOb2Rlcyh0aGlzLnd3RWRpdG9yLnZpZXcuZG9tLmlubmVySFRNTCk7XG4gICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgcmVQbGFjZWhvbGRlciA9IG5ldyBSZWdFeHAoXCI8c3BhbiBjbGFzcz1cXFwicGxhY2Vob2xkZXJbXj5dKz5cIiArIHRoaXMucGxhY2Vob2xkZXIgKyBcIjwvc3Bhbj5cIiwgJ2knKTtcbiAgICAgICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UocmVQbGFjZWhvbGRlciwgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IHRleHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgY29udGVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5pbnNlcnRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgc2VsZWN0aW9uIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IHN0YXJ0IC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gZW5kIC0gZW5kIHBvc2l0aW9uXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHNlbGVjdGlvbiByYW5nZSB3aXRoIGdpdmVuIHRleHQgY29udGVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGV4dCBjb250ZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtzdGFydF0gLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbZW5kXSAtIGVuZCBwb3NpdGlvblxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5yZXBsYWNlU2VsZWN0aW9uID0gZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLnJlcGxhY2VTZWxlY3Rpb24odGV4dCwgc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgb2Ygc2VsZWN0aW9uIHJhbmdlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IFtzdGFydF0gLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbZW5kXSAtIGVuZCBwb3NpdGlvblxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5kZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZGVsZXRlU2VsZWN0aW9uKHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHNlbGVjdGVkIHRleHQgY29udGVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbc3RhcnRdIC0gc3RhcnQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gW2VuZF0gLSBlbmQgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHNlbGVjdGVkIHRleHQgY29udGVudFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRTZWxlY3RlZFRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLmdldFNlbGVjdGVkVGV4dChzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCByYW5nZSBvZiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbcG9zXSAtIHBvc2l0aW9uXG4gICAgICogQHJldHVybnMge0FycmF5LjxudW1iZXJbXT58QXJyYXkuPG51bWJlcj59IC0gbm9kZSBbc3RhcnQsIGVuZF0gcmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1hcmtkb3duIG1vZGVcbiAgICAgKiBjb25zdCByYW5nZUluZm8gPSBlZGl0b3IuZ2V0UmFuZ2VJbmZvT2ZOb2RlKCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhyYW5nZUluZm8pOyAvLyB7IHJhbmdlOiBbW3N0YXJ0TGluZU9mZnNldCwgc3RhcnRDdXJvck9mZnNldF0sIFtlbmRMaW5lT2Zmc2V0LCBlbmRDdXJvck9mZnNldF1dLCB0eXBlOiAnZW1waCcgfVxuICAgICAqXG4gICAgICogLy8gV1lTSVdZRyBtb2RlXG4gICAgICogY29uc3QgcmFuZ2VJbmZvID0gZWRpdG9yLmdldFJhbmdlSW5mb09mTm9kZSgpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocmFuZ2VJbmZvKTsgLy8geyByYW5nZTogW3N0YXJ0Q3Vyc29yT2Zmc2V0LCBlbmRDdXJzb3JPZmZzZXRdLCB0eXBlOiAnZW1waCcgfVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRSYW5nZUluZm9PZk5vZGUgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZ2V0UmFuZ2VJbmZvT2ZOb2RlKHBvcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgd2lkZ2V0IHRvIHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIHdpZGdldCBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlIC0gQWRkaW5nIHN0eWxlIFwidG9wXCIgb3IgXCJib3R0b21cIlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBbcG9zXSAtIHBvc2l0aW9uXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmFkZFdpZGdldCA9IGZ1bmN0aW9uIChub2RlLCBzdHlsZSwgcG9zKSB7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE1vZGVFZGl0b3IoKS5hZGRXaWRnZXQobm9kZSwgc3R5bGUsIHBvcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIG5vZGUgd2l0aCB3aWRnZXQgdG8gcmFuZ2VcbiAgICAgKiBAcGFyYW0ge251bWJlcnxBcnJheS48bnVtYmVyPn0gc3RhcnQgLSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBlbmQgLSBlbmQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHdpZGdldCB0ZXh0IGNvbnRlbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUucmVwbGFjZVdpdGhXaWRnZXQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkucmVwbGFjZVdpdGhXaWRnZXQoc3RhcnQsIGVuZCwgdGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgZWRpdG9yIGhlaWdodFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgLSBlZGl0b3IgaGVpZ2h0IGluIHBpeGVsXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5vcHRpb25zLmVsO1xuICAgICAgICBpZiAoaXNTdHJpbmdfMShoZWlnaHQpKSB7XG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc18xKGVsLCAnYXV0by1oZWlnaHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEoZWwsICdhdXRvLWhlaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRNaW5IZWlnaHQodGhpcy5nZXRNaW5IZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3NzXzEoZWwsIHsgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IGVkaXRvciBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBlZGl0b3IgaGVpZ2h0IGluIHBpeGVsXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG1pbmltdW0gaGVpZ2h0IHRvIGVkaXRvciBjb250ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbkhlaWdodCAtIG1pbiBjb250ZW50IGhlaWdodCBpbiBwaXhlbFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRNaW5IZWlnaHQgPSBmdW5jdGlvbiAobWluSGVpZ2h0KSB7XG4gICAgICAgIGlmIChtaW5IZWlnaHQgIT09IHRoaXMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgdGhpcy5vcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgIT09ICdhdXRvJyAmJiB0aGlzLm9wdGlvbnMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIGNscygnbWFpbicpKSkge1xuICAgICAgICAgICAgICAgIC8vIDc1cHggZXF1YWxzIGRlZmF1bHQgZWRpdG9yIHVpIGhlaWdodCAtIHRoZSBlZGl0aW5nIGFyZWEgaGVpZ2h0XG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0ID0gTWF0aC5taW4ocGFyc2VJbnQobWluSGVpZ2h0LCAxMCksIHBhcnNlSW50KGhlaWdodCwgMTApIC0gNzUpICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbkhlaWdodE51bSA9IHBhcnNlSW50KG1pbkhlaWdodCwgMTApO1xuICAgICAgICAgICAgdGhpcy5taW5IZWlnaHQgPSBtaW5IZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnd3RWRpdG9yLnNldE1pbkhlaWdodChtaW5IZWlnaHROdW0pO1xuICAgICAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRNaW5IZWlnaHQobWluSGVpZ2h0TnVtKTtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zZXRNaW5IZWlnaHQobWluSGVpZ2h0TnVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IG1pbmltdW0gaGVpZ2h0IG9mIGVkaXRvciBjb250ZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ30gbWluIGhlaWdodCBpbiBwaXhlbFxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRNaW5IZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbkhlaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGN1cnJlbnQgZWRpdG9yIG1vZGUgaXMgTWFya2Rvd25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuaXNNYXJrZG93bk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgPT09ICdtYXJrZG93bic7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBjdXJyZW50IGVkaXRvciBtb2RlIGlzIFdZU0lXWUdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuaXNXeXNpd3lnTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gJ3d5c2l3eWcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmlzVmlld2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBNYXJrZG93biBlZGl0b3IncyBwcmV2aWV3IHN0eWxlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZ2V0Q3VycmVudFByZXZpZXdTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWRQcmV2aWV3U3R5bGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgZWRpdG9yJ3MgbW9kZSB0byBnaXZlbiBtb2RlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gRWRpdG9yIG1vZGUgbmFtZSBvZiB3YW50IHRvIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dpdGhvdXRGb2N1c10gLSBDaGFuZ2UgbW9kZSB3aXRob3V0IGZvY3VzXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmNoYW5nZU1vZGUgPSBmdW5jdGlvbiAobW9kZSwgd2l0aG91dEZvY3VzKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICBpZiAodGhpcy5pc1d5c2l3eWdNb2RlKCkpIHtcbiAgICAgICAgICAgIHZhciBtZE5vZGUgPSB0aGlzLnRvYXN0TWFyay5nZXRSb290Tm9kZSgpO1xuICAgICAgICAgICAgdmFyIHd3Tm9kZSA9IHRoaXMuY29udmVydG9yLnRvV3lzaXd5Z01vZGVsKG1kTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnd3RWRpdG9yLnNldE1vZGVsKHd3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgd3dOb2RlID0gdGhpcy53d0VkaXRvci5nZXRNb2RlbCgpO1xuICAgICAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRNYXJrZG93bih0aGlzLmNvbnZlcnRvci50b01hcmtkb3duVGV4dCh3d05vZGUpLCAhd2l0aG91dEZvY3VzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdyZW1vdmVQb3B1cFdpZGdldCcpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VNb2RlJywgbW9kZSk7XG4gICAgICAgIGlmICghd2l0aG91dEZvY3VzKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5jb252ZXJ0b3IuZ2V0TWFwcGVkUG9zKCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1d5c2l3eWdNb2RlKCkgJiYgaXNOdW1iZXJfMShwb3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53d0VkaXRvci5zZXRTZWxlY3Rpb24ocG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocG9zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWRFZGl0b3Iuc2V0U2VsZWN0aW9uKHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgVFVJRWRpdG9yIGZyb20gZG9jdW1lbnRcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy53d0VkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubWRFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnByZXZpZXcuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnNjcm9sbFN5bmMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmdldEV2ZW50cygpLmZvckVhY2goZnVuY3Rpb24gKF8sIHR5cGUpIHsgcmV0dXJuIF90aGlzLm9mZih0eXBlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIaWRlIFRVSUVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdoaWRlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaG93IFRVSUVkaXRvclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdzaG93Jyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNb3ZlIG9uIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBzY3JvbGxUb3AgdmFsdWUgb2YgZWRpdG9yIGNvbnRhaW5lclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TW9kZUVkaXRvcigpLnNldFNjcm9sbFRvcCh2YWx1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlIG9mIGVkaXRvciBjb250YWluZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBzY3JvbGxUb3AgdmFsdWUgb2YgZWRpdG9yIGNvbnRhaW5lclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCBUVUlFZGl0b3JcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yQ29yZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0TW9kZWwoW10pO1xuICAgICAgICB0aGlzLm1kRWRpdG9yLnNldE1hcmtkb3duKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IHNlbGVjdGlvbiByYW5nZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyW10+fEFycmF5LjxudW1iZXI+fSBSZXR1cm5zIHRoZSByYW5nZSBvZiB0aGUgc2VsZWN0aW9uIGRlcGVuZGluZyBvbiB0aGUgZWRpdG9yIG1vZGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIE1hcmtkb3duIG1vZGVcbiAgICAgKiBjb25zdCBtZFNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG1kU2VsZWN0aW9uKTsgLy8gW1tzdGFydExpbmVPZmZzZXQsIHN0YXJ0Q3Vyb3JPZmZzZXRdLCBbZW5kTGluZU9mZnNldCwgZW5kQ3Vyb3JPZmZzZXRdXVxuICAgICAqXG4gICAgICogLy8gV1lTSVdZRyBtb2RlXG4gICAgICogY29uc3Qgd3dTZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyh3d1NlbGVjdGlvbik7IC8vIFtzdGFydEN1cnNvck9mZnNldCwgZW5kQ3Vyc29yT2Zmc2V0XVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRNb2RlRWRpdG9yKCkuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBsYWNlaG9sZGVyIG9uIGFsbCBlZGl0b3JzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBsYWNlaG9sZGVyIC0gcGxhY2Vob2xkZXIgdG8gc2V0XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLnNldFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5tZEVkaXRvci5zZXRQbGFjZWhvbGRlcihwbGFjZWhvbGRlcik7XG4gICAgICAgIHRoaXMud3dFZGl0b3Iuc2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IG1hcmtkb3duIGVkaXRvciwgcHJldmlldywgd3lzaXd5ZyBlZGl0b3IgRE9NIGVsZW1lbnRzXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvckNvcmUucHJvdG90eXBlLmdldEVkaXRvckVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWRFZGl0b3I6IHRoaXMubWRFZGl0b3IuZ2V0RWxlbWVudCgpLFxuICAgICAgICAgICAgbWRQcmV2aWV3OiB0aGlzLnByZXZpZXcuZ2V0RWxlbWVudCgpLFxuICAgICAgICAgICAgd3dFZGl0b3I6IHRoaXMud3dFZGl0b3IuZ2V0RWxlbWVudCgpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBwb3NpdGlvbiB0byBtYXRjaCBlZGl0b3IgbW9kZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8QXJyYXkuPG51bWJlcj59IGVuZCAtIGVuZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gRWRpdG9yIG1vZGUgbmFtZSBvZiB3YW50IHRvIG1hdGNoIGNvbnZlcnRlZCBwb3NpdGlvbiB0b1xuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JDb3JlLnByb3RvdHlwZS5jb252ZXJ0UG9zVG9NYXRjaEVkaXRvck1vZGUgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbW9kZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gc3RhcnQ7IH1cbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gdGhpcy5tb2RlOyB9XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLm1kRWRpdG9yLnZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB2YXIgaXNGcm9tQXJyYXkgPSBBcnJheS5pc0FycmF5KHN0YXJ0KTtcbiAgICAgICAgdmFyIGlzVG9BcnJheSA9IEFycmF5LmlzQXJyYXkoZW5kKTtcbiAgICAgICAgdmFyIGNvbnZlcnRlZEZyb20gPSBzdGFydDtcbiAgICAgICAgdmFyIGNvbnZlcnRlZFRvID0gZW5kO1xuICAgICAgICBpZiAoaXNGcm9tQXJyYXkgIT09IGlzVG9BcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlcyBvZiBhcmd1bWVudHMgbXVzdCBiZSBzYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUgPT09ICdtYXJrZG93bicgJiYgIWlzRnJvbUFycmF5ICYmICFpc1RvQXJyYXkpIHtcbiAgICAgICAgICAgIF9hID0gZ2V0RWRpdG9yVG9NZFBvcyhkb2MsIHN0YXJ0LCBlbmQpLCBjb252ZXJ0ZWRGcm9tID0gX2FbMF0sIGNvbnZlcnRlZFRvID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ3d5c2l3eWcnICYmIGlzRnJvbUFycmF5ICYmIGlzVG9BcnJheSkge1xuICAgICAgICAgICAgX2IgPSBnZXRNZFRvRWRpdG9yUG9zKGRvYywgc3RhcnQsIGVuZCksIGNvbnZlcnRlZEZyb20gPSBfYlswXSwgY29udmVydGVkVG8gPSBfYlsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NvbnZlcnRlZEZyb20sIGNvbnZlcnRlZFRvXTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdFVJRWRpdG9yQ29yZTtcbn0oKSk7XG5cbi8vIEBUT0RPOiBjaGFuZ2Ugc3ludGF4IHdpdGggb3VyIGNvbnZlbnRpb25cbi8qIGVzbGludC1kaXNhYmxlICovXG5mdW5jdGlvbiBodG1sJDEgKG4pIHtcbiAgZm9yIChcbiAgICB2YXIgbCxcbiAgICAgIGUsXG4gICAgICBzID0gYXJndW1lbnRzLFxuICAgICAgdCA9IDEsXG4gICAgICByID0gJycsXG4gICAgICB1ID0gJycsXG4gICAgICBhID0gWzBdLFxuICAgICAgYyA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHQgPT09IDEgJiYgKG4gfHwgKHIgPSByLnJlcGxhY2UoL15cXHMqXFxuXFxzKnxcXHMqXFxuXFxzKiQvZywgJycpKSlcbiAgICAgICAgICA/IGEucHVzaChuID8gc1tuXSA6IHIpXG4gICAgICAgICAgOiB0ID09PSAzICYmIChuIHx8IHIpXG4gICAgICAgICAgPyAoKGFbMV0gPSBuID8gc1tuXSA6IHIpLCAodCA9IDIpKVxuICAgICAgICAgIDogdCA9PT0gMiAmJiByID09PSAnLi4uJyAmJiBuXG4gICAgICAgICAgPyAoYVsyXSA9IGFzc2lnbihhWzJdIHx8IHt9LCBzW25dKSlcbiAgICAgICAgICA6IHQgPT09IDIgJiYgciAmJiAhblxuICAgICAgICAgID8gKChhWzJdID0gYVsyXSB8fCB7fSlbcl0gPSAhMClcbiAgICAgICAgICA6IHQgPj0gNSAmJlxuICAgICAgICAgICAgKHQgPT09IDVcbiAgICAgICAgICAgICAgPyAoKChhWzJdID0gYVsyXSB8fCB7fSlbZV0gPSBuID8gKHIgPyByICsgc1tuXSA6IHNbbl0pIDogciksICh0ID0gNikpXG4gICAgICAgICAgICAgIDogKG4gfHwgcikgJiYgKGFbMl1bZV0gKz0gbiA/IHIgKyBzW25dIDogcikpLFxuICAgICAgICAgIChyID0gJycpO1xuICAgICAgfSxcbiAgICAgIGggPSAwO1xuICAgIGggPCBuLmxlbmd0aDtcbiAgICBoKytcbiAgKSB7XG4gICAgaCAmJiAodCA9PT0gMSAmJiBjKCksIGMoaCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbltoXS5sZW5ndGg7IGkrKylcbiAgICAgIChsID0gbltoXVtpXSksXG4gICAgICAgIHQgPT09IDFcbiAgICAgICAgICA/IGwgPT09ICc8J1xuICAgICAgICAgICAgPyAoYygpLCAoYSA9IFthLCAnJywgbnVsbF0pLCAodCA9IDMpKVxuICAgICAgICAgICAgOiAociArPSBsKVxuICAgICAgICAgIDogdCA9PT0gNFxuICAgICAgICAgID8gciA9PT0gJy0tJyAmJiBsID09PSAnPidcbiAgICAgICAgICAgID8gKCh0ID0gMSksIChyID0gJycpKVxuICAgICAgICAgICAgOiAociA9IGwgKyByWzBdKVxuICAgICAgICAgIDogdVxuICAgICAgICAgID8gbCA9PT0gdVxuICAgICAgICAgICAgPyAodSA9ICcnKVxuICAgICAgICAgICAgOiAociArPSBsKVxuICAgICAgICAgIDogbCA9PT0gJ1wiJyB8fCBsID09PSBcIidcIlxuICAgICAgICAgID8gKHUgPSBsKVxuICAgICAgICAgIDogbCA9PT0gJz4nXG4gICAgICAgICAgPyAoYygpLCAodCA9IDEpKVxuICAgICAgICAgIDogdCAmJlxuICAgICAgICAgICAgKGwgPT09ICc9J1xuICAgICAgICAgICAgICA/ICgodCA9IDUpLCAoZSA9IHIpLCAociA9ICcnKSlcbiAgICAgICAgICAgICAgOiBsID09PSAnLycgJiYgKHQgPCA1IHx8IG5baF1baSArIDFdID09PSAnPicpXG4gICAgICAgICAgICAgID8gKGMoKSxcbiAgICAgICAgICAgICAgICB0ID09PSAzICYmIChhID0gYVswXSksXG4gICAgICAgICAgICAgICAgKHQgPSBhKSxcbiAgICAgICAgICAgICAgICAoYSA9IGFbMF0pLnB1c2godGhpcy5hcHBseShudWxsLCB0LnNsaWNlKDEpKSksXG4gICAgICAgICAgICAgICAgKHQgPSAwKSlcbiAgICAgICAgICAgICAgOiBsID09PSAnICcgfHwgbCA9PT0gJ1xcdCcgfHwgbCA9PT0gJ1xcbicgfHwgbCA9PT0gJ1xccidcbiAgICAgICAgICAgICAgPyAoYygpLCAodCA9IDIpKVxuICAgICAgICAgICAgICA6IChyICs9IGwpKSxcbiAgICAgICAgdCA9PT0gMyAmJiByID09PSAnIS0tJyAmJiAoKHQgPSA0KSwgKGEgPSBhWzBdKSk7XG4gIH1cbiAgcmV0dXJuIGMoKSwgYS5sZW5ndGggPiAyID8gYS5zbGljZSgxKSA6IGFbMV07XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgYm9vbGVhbiBvciBub3QuXG4gKiAgSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgYm9vbGVhbiwgcmV0dXJuIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBib29sZWFuP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fCBvYmogaW5zdGFuY2VvZiBCb29sZWFuO1xufVxuXG52YXIgaXNCb29sZWFuXzEgPSBpc0Jvb2xlYW47XG5cbnZhciBWTm9kZVdhbGtlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWTm9kZVdhbGtlcihjdXJyZW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBWTm9kZVdhbGtlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZW50ZXJpbmcgPSBfYS5lbnRlcmluZywgY3VyID0gX2EuY3VycmVudDtcbiAgICAgICAgaWYgKCFjdXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgaWYgKGN1ci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5uZXh0O1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZub2RlOiBjdXIsIGVudGVyaW5nOiBlbnRlcmluZyB9O1xuICAgIH07XG4gICAgcmV0dXJuIFZOb2RlV2Fsa2VyO1xufSgpKTtcbnZhciBWTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9sZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2tpcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICBpZiAocHJvcHMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IHByb3BzLnJlZjtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wcy5yZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmtleSkge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBwcm9wcy5rZXk7XG4gICAgICAgICAgICBkZWxldGUgcHJvcHMua2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIFZOb2RlLnByb3RvdHlwZS53YWxrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVk5vZGVXYWxrZXIodGhpcyk7XG4gICAgfTtcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbXTtcbiAgICByZXR1cm4gVk5vZGU7XG59KCkpO1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSgnVEVYVF9OT0RFJywgeyBub2RlVmFsdWU6IHRleHQgfSwgW10pO1xufVxuZnVuY3Rpb24gZXhjbHVkZVVubmVjZXNzYXJ5Q2hpbGQoY2hpbGQsIGZsYXR0ZWQpIHtcbiAgICB2YXIgdm5vZGUgPSBjaGlsZDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICBpZiAoaXNCb29sZWFuXzEoY2hpbGQpIHx8IGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgdm5vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZ18xKGNoaWxkKSB8fCBpc051bWJlcl8xKGNoaWxkKSkge1xuICAgICAgICB2bm9kZSA9IGNyZWF0ZVRleHROb2RlKFN0cmluZyhjaGlsZCkpO1xuICAgIH1cbiAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgZmxhdHRlZC5wdXNoKHZub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBmbGF0dGVkID0gW107XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICBjaGlsZC5mb3JFYWNoKGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVVbm5lY2Vzc2FyeUNoaWxkKHZub2RlLCBmbGF0dGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhjbHVkZVVubmVjZXNzYXJ5Q2hpbGQoY2hpbGQsIGZsYXR0ZWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBWTm9kZSh0eXBlLCBwcm9wcyB8fCB7fSwgZmxhdHRlZCk7XG59XG4vLyBAdHMtaWdub3JlXG52YXIgaHRtbCA9IGh0bWwkMS5iaW5kKGgpO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gb2JqZWN0IG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBvYmplY3QsIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgb2JqZWN0P1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn1cblxudmFyIGlzT2JqZWN0XzEgPSBpc09iamVjdDtcblxuLy8gQFRPRE86IGNsZWFyZnkgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgQ1NTRGVjbGFyYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodm5vZGUpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAodm5vZGUudHlwZSA9PT0gJ1RFWFRfTk9ERScpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZub2RlLnByb3BzLm5vZGVWYWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2bm9kZS50eXBlKTtcbiAgICAgICAgc2V0UHJvcHMobm9kZSwge30sIHZub2RlLnByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZW1vdmVOb2RlKHZub2RlLCBwYXJlbnROb2RlKSB7XG4gICAgaWYgKHZub2RlLm5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2bm9kZS5ub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZU5vZGUodm5vZGUuZmlyc3RDaGlsZCwgcGFyZW50Tm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5uZXJEaWZmKG5vZGUsIHByZXZQcm9wcywgbmV4dFByb3BzKSB7XG4gICAgT2JqZWN0LmtleXMocHJldlByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICBpZiAoL15vbi8udGVzdChwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIGlmICghbmV4dFByb3BzW3Byb3BOYW1lXSB8fCBwcmV2UHJvcHNbcHJvcE5hbWVdICE9PSBuZXh0UHJvcHNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHByb3BOYW1lLnNsaWNlKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcHJldlByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcE5hbWUgIT09ICdjaGlsZHJlbicgJiYgIW5leHRQcm9wc1twcm9wTmFtZV0gJiYgIWlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNldFByb3BzKG5vZGUsIHByZXZQcm9wcywgbmV4dFByb3BzLCBmdW5jdGlvbiAocHJvcE5hbWUpIHsgcmV0dXJuICFzaGFsbG93RXF1YWwocHJldlByb3BzW3Byb3BOYW1lXSwgbmV4dFByb3BzW3Byb3BOYW1lXSk7IH0pO1xufVxudmFyIHJlTm9uRGltZW5zaW9uID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkL2k7XG5mdW5jdGlvbiBzZXRQcm9wcyhub2RlLCBwcmV2UHJvcHMsIHByb3BzLCBjb25kaXRpb24pIHtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24gfHwgY29uZGl0aW9uKHByb3BOYW1lKSkge1xuICAgICAgICAgICAgaWYgKC9eb24vLnRlc3QocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHByb3BOYW1lLnNsaWNlKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BOYW1lID09PSAnbm9kZVZhbHVlJykge1xuICAgICAgICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcE5hbWUgPT09ICdzdHlsZScgJiYgaXNPYmplY3RfMShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgc2V0U3R5bGVQcm9wcyhub2RlLCBwcmV2UHJvcHNbcHJvcE5hbWVdLCBwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcE5hbWUgIT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlUHJvcHMobm9kZSwgcHJldlN0eWxlUHJvcHMsIHN0eWxlUHJvcHMpIHtcbiAgICBpZiAocHJldlN0eWxlUHJvcHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJldlN0eWxlUHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlUHJvcCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbm9kZS5zdHlsZVtzdHlsZVByb3BdID0gJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzdHlsZVByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVByb3ApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wc1tzdHlsZVByb3BdO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVQcm9wXSA9XG4gICAgICAgICAgICBpc051bWJlcl8xKHZhbHVlKSAmJiAhcmVOb25EaW1lbnNpb24udGVzdChzdHlsZVByb3ApID8gdmFsdWUgKyBcInB4XCIgOiB2YWx1ZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0KHZub2RlKSB7XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJlbW92YWxOb2RlKSB7IHJldHVybiBkaWZmKHJlbW92YWxOb2RlKTsgfSk7XG4gICAgaWYgKHZub2RlKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICB2YXIgd2Fsa2VyID0gdm5vZGUud2Fsa2VyKCk7XG4gICAgICAgIHdoaWxlICgobmV4dCA9IHdhbGtlci53YWxrKCkpKSB7XG4gICAgICAgICAgICB2bm9kZSA9IG5leHQudm5vZGU7XG4gICAgICAgICAgICBpZiAobmV4dC5lbnRlcmluZykge1xuICAgICAgICAgICAgICAgIGRpZmYodm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbl8xKHZub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXAgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgLy8gbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgICAgICAgICAgIGlmICghdm5vZGUub2xkICYmIGNvbXAubW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wLm1vdW50ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLm9sZCAmJiBjb21wLnVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGNvbXAucHJldlByb3BzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb21wLnVwZGF0ZWQocHJldlByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKHZub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IHZub2RlLnBhcmVudDtcbiAgICB3aGlsZSAoIXBhcmVudC5ub2RlKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnQubm9kZTtcbn1cbmZ1bmN0aW9uIGRpZmYodm5vZGUpIHtcbiAgICBpZiAoIXZub2RlIHx8ICF2bm9kZS5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm5vZGUubm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUodm5vZGUpO1xuICAgICAgICBpZiAodm5vZGUuZWZmZWN0ID09PSAnQScpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodm5vZGUubm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUuZWZmZWN0ID09PSAnVScpIHtcbiAgICAgICAgICAgIGlubmVyRGlmZih2bm9kZS5ub2RlLCB2bm9kZS5vbGQucHJvcHMsIHZub2RlLnByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm5vZGUuZWZmZWN0ID09PSAnRCcpIHtcbiAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG4gICAgICAgIHZhciB3YWxrZXIgPSB2bm9kZS53YWxrZXIoKTtcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gd2Fsa2VyLndhbGsoKSkpIHtcbiAgICAgICAgICAgIHZub2RlID0gbmV4dC52bm9kZTtcbiAgICAgICAgICAgIGlmICghbmV4dC5lbnRlcmluZykge1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEodm5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXAgPSB2bm9kZS5jb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpZmVjeWNsZSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAuYmVmb3JlRGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcC5iZWZvcmVEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZSh2bm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUodm5vZGUsIHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhcHBseSByZWZcbiAgICBpZiAodm5vZGUucmVmKSB7XG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZub2RlLnJlZih2bm9kZS5jb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZub2RlLm5vZGUpIHtcbiAgICAgICAgICAgIHZub2RlLnJlZih2bm9kZS5ub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KENvbXAsIHZub2RlKSB7XG4gICAgdmFyIHByb3BzID0gdm5vZGUucHJvcHMsIGNvbXBvbmVudCA9IHZub2RlLmNvbXBvbmVudDtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5wcmV2UHJvcHMgPSBjb21wb25lbnQucHJvcHM7XG4gICAgICAgIGNvbXBvbmVudC5wcm9wcyA9IHZub2RlLnByb3BzO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbXAocHJvcHMpO1xufVxuZnVuY3Rpb24gYnVpbGRWTm9kZSh2bm9kZSkge1xuICAgIHZhciByb290ID0gdm5vZGU7XG4gICAgd2hpbGUgKHZub2RlICYmICF2bm9kZS5za2lwKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEodm5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudCh2bm9kZS50eXBlLCB2bm9kZSk7XG4gICAgICAgICAgICBpbnN0YW5jZS52bm9kZSA9IHZub2RlO1xuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB2bm9kZS5wcm9wcy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuID0gW2luc3RhbmNlLnJlbmRlcigpXTtcbiAgICAgICAgICAgIGJ1aWxkQ2hpbGRyZW5WTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXZub2RlLm5vZGUpIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5ub2RlID0gY3JlYXRlTm9kZSh2bm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZENoaWxkcmVuVk5vZGUodm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAodm5vZGUgJiYgdm5vZGUucGFyZW50ICYmICF2bm9kZS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdm5vZGUgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZub2RlID0gdm5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUob2xkLCB2bm9kZSkge1xuICAgIHJldHVybiBvbGQgJiYgdm5vZGUgJiYgdm5vZGUudHlwZSA9PT0gb2xkLnR5cGUgJiYgKCF2bm9kZS5rZXkgfHwgdm5vZGUua2V5ID09PSBvbGQua2V5KTtcbn1cbi8vIEBUT0RPOiBhZGQga2V5IGRpZmYgYWxnb3JpdGhtXG5mdW5jdGlvbiBidWlsZENoaWxkcmVuVk5vZGUocGFyZW50KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgIHZhciBvbGQgPSBwYXJlbnQub2xkID8gcGFyZW50Lm9sZC5maXJzdENoaWxkIDogbnVsbDtcbiAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAodm5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBzYW1lVHlwZSA9IGlzU2FtZVR5cGUob2xkLCB2bm9kZSk7XG4gICAgICAgIGlmIChzYW1lVHlwZSkge1xuICAgICAgICAgICAgdm5vZGUub2xkID0gb2xkO1xuICAgICAgICAgICAgdm5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdm5vZGUubm9kZSA9IG9sZC5ub2RlO1xuICAgICAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gb2xkLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZub2RlLmVmZmVjdCA9ICdVJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUgJiYgIXNhbWVUeXBlKSB7XG4gICAgICAgICAgICB2bm9kZS5vbGQgPSBudWxsO1xuICAgICAgICAgICAgdm5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdm5vZGUubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB2bm9kZS5lZmZlY3QgPSAnQSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZCAmJiAhc2FtZVR5cGUpIHtcbiAgICAgICAgICAgIFZOb2RlLnJlbW92YWxOb2Rlcy5wdXNoKG9sZCk7XG4gICAgICAgICAgICBvbGQuZWZmZWN0ID0gJ0QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGQpIHtcbiAgICAgICAgICAgIG9sZCA9IG9sZC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcGFyZW50LmZpcnN0Q2hpbGQgPSB2bm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2bm9kZSkge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IHZub2RlO1xuICAgIH0pO1xuICAgIHZhciBsYXN0Q2hpbGQgPSBsYXN0JDEoY2hpbGRyZW4pO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgIFZOb2RlLnJlbW92YWxOb2Rlcy5wdXNoKG9sZCk7XG4gICAgICAgICAgICBvbGQuZWZmZWN0ID0gJ0QnO1xuICAgICAgICAgICAgb2xkID0gb2xkLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG9sZCAmJiBsYXN0Q2hpbGQpIHtcbiAgICAgICAgaWYgKG9sZCAmJiBsYXN0Q2hpbGQub2xkICE9PSBvbGQpIHtcbiAgICAgICAgICAgIFZOb2RlLnJlbW92YWxOb2Rlcy5wdXNoKG9sZCk7XG4gICAgICAgICAgICBvbGQuZWZmZWN0ID0gJ0QnO1xuICAgICAgICAgICAgb2xkID0gb2xkLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3kodm5vZGUpIHtcbiAgICB2bm9kZS5lZmZlY3QgPSAnRCc7XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzID0gW3Zub2RlXTtcbiAgICBjb21taXQoKTtcbiAgICBWTm9kZS5yZW1vdmFsTm9kZXMgPSBbXTtcbn1cbmZ1bmN0aW9uIHJlcmVuZGVyKGNvbXApIHtcbiAgICB2YXIgcm9vdCA9IGNvbXAudm5vZGU7XG4gICAgcm9vdC5lZmZlY3QgPSAnVSc7XG4gICAgcm9vdC5vbGQgPSByb290O1xuICAgIC8vIHNraXAgZm9yIHVubmVjZXNzYXJ5IHJlY29uY2lsaWF0aW9uXG4gICAgaWYgKHJvb3QubmV4dCkge1xuICAgICAgICByb290Lm5leHQuc2tpcCA9IHRydWU7XG4gICAgfVxuICAgIFZOb2RlLnJlbW92YWxOb2RlcyA9IFtdO1xuICAgIGJ1aWxkVk5vZGUocm9vdCk7XG4gICAgY29tbWl0KHJvb3QpO1xuICAgIGlmIChyb290Lm5leHQpIHtcbiAgICAgICAgcm9vdC5uZXh0LnNraXAgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXIoY29udGFpbmVyLCB2bm9kZSkge1xuICAgIHZhciByb290ID0gbmV3IFZOb2RlKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCksIHt9LCBbdm5vZGVdKTtcbiAgICByb290Lm5vZGUgPSBjb250YWluZXI7XG4gICAgVk5vZGUucmVtb3ZhbE5vZGVzID0gW107XG4gICAgYnVpbGRWTm9kZShyb290KTtcbiAgICBjb21taXQocm9vdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlc3Ryb3kocm9vdC5maXJzdENoaWxkKTsgfTtcbn1cblxudmFyIENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICAgIHRoaXMucmVmcyA9IHt9O1xuICAgIH1cbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgdGhpcy5zdGF0ZSksIHN0YXRlKTtcbiAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICByZXJlbmRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbn0oKSk7XG5cbnZhciBTd2l0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoU3dpdGNoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBoaWRlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTd2l0Y2gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoaWRlOiBmYWxzZSB9KTtcbiAgICB9O1xuICAgIFN3aXRjaC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGhpZGU6IHRydWUgfSk7XG4gICAgfTtcbiAgICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZWRpdG9yVHlwZSA9IF9hLmVkaXRvclR5cGUsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRoIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGggPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwidGFiLWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwidGFiLWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwidGFiLWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCdtb2RlLXN3aXRjaCcpLCB0aGlzLnN0YXRlLmhpZGUgPyAnbm9uZScgOiAnYmxvY2snLCBlZGl0b3JUeXBlID09PSAnbWFya2Rvd24nID8gJyBhY3RpdmUnIDogJycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCduZWVkQ2hhbmdlTW9kZScsICdtYXJrZG93bicpO1xuICAgICAgICB9LCBpMThuLmdldCgnTWFya2Rvd24nKSwgZWRpdG9yVHlwZSA9PT0gJ3d5c2l3eWcnID8gJyBhY3RpdmUnIDogJycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCduZWVkQ2hhbmdlTW9kZScsICd3eXNpd3lnJyk7XG4gICAgICAgIH0sIGkxOG4uZ2V0KCdXWVNJV1lHJykpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaDtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRoO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBmbiB1bnRpbCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VjZWQgZnVuY3Rpb24gd2FzIGludm9rZWQuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHQubmhuLmNvbT5cbiAqL1xuXG4vKipcbiAqIEBtb2R1bGUgdHJpY2tzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGZuIHVudGlsIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZFxuICogc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VjZWQgZnVuY3Rpb24gd2FzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5XG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHJpY2tzXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZGVib3VuY2UgZnJvbSAndHVpLWNvZGUtc25pcHBldC90cmlja3MvZGVib3VuY2UnO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3RyaWNrcy9kZWJvdW5jZScpO1xuICpcbiAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIHt9XG4gKlxuICogY29uc3QgZGVib3VuY2VkID0gZGVib3VuY2Uoc29tZU1ldGhvZFRvSW52b2tlRGVib3VuY2VkLCAzMDApO1xuICpcbiAqIC8vIGludm9rZSByZXBlYXRlZGx5XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7XG4gKiBkZWJvdW5jZWQoKTtcbiAqIGRlYm91bmNlZCgpO1xuICogZGVib3VuY2VkKCk7ICAgIC8vIGxhc3QgaW52b2tlIG9mIGRlYm91bmNlZCgpXG4gKlxuICogLy8gaW52b2tlIHNvbWVNZXRob2RUb0ludm9rZURlYm91bmNlZCgpIGFmdGVyIDMwMCBtaWxsaXNlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlJDEoZm4sIGRlbGF5KSB7XG4gIHZhciB0aW1lciwgYXJncztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBkZWxheSA9IGRlbGF5IHx8IDA7XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCBkZWxheSk7XG4gIH1cblxuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG52YXIgZGVib3VuY2VfMSA9IGRlYm91bmNlJDE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGZuIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgaW50ZXJ2YWwgbWlsbGlzZWNvbmRzLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0Lm5obi5jb20+XG4gKi9cblxudmFyIGRlYm91bmNlID0gZGVib3VuY2VfMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGZuIGF0IG1vc3Qgb25jZSBwZXIgZXZlcnkgaW50ZXJ2YWwgbWlsbGlzZWNvbmRzLlxuICogWW91IGNhbiB1c2UgdGhpcyB0aHJvdHRsZSBzaG9ydCB0aW1lIHJlcGVhdGVkbHkgaW52b2tpbmcgZnVuY3Rpb25zLiAoZS5nIE1vdXNlTW92ZSwgUmVzaXplIC4uLilcbiAqIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHlvdSBtdXN0IHJlbW92ZSBzbHVncyAoZS5nLiBmbGFnIHZhcmlhYmxlKSByZWxhdGVkIHdpdGggdGhyb3R0bGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIHRocm90dGxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsPTBdIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHJldHVybnMge2Z1bmN0aW9ufSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHJpY2tzXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgdGhyb3R0bGUgZnJvbSAndHVpLWNvZGUtc25pcHBldC90cmlja3MvdGhyb3R0bGUnO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3RyaWNrcy90aHJvdHRsZScpO1xuICpcbiAqIGZ1bmN0aW9uIHNvbWVNZXRob2RUb0ludm9rZVRocm90dGxlZCgpIHt9XG4gKlxuICogY29uc3QgdGhyb3R0bGVkID0gdGhyb3R0bGUoc29tZU1ldGhvZFRvSW52b2tlVGhyb3R0bGVkLCAzMDApO1xuICpcbiAqIC8vIGludm9rZSByZXBlYXRlZGx5XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChsZWFkaW5nKVxuICogdGhyb3R0bGVkKCk7XG4gKiB0aHJvdHRsZWQoKTsgICAgLy8gaW52b2tlIChuZWFyIDMwMCBtaWxsaXNlY29uZHMpXG4gKiB0aHJvdHRsZWQoKTtcbiAqIHRocm90dGxlZCgpO1xuICogdGhyb3R0bGVkKCk7ICAgIC8vIGludm9rZSAobmVhciA2MDAgbWlsbGlzZWNvbmRzKVxuICogLy8gLi4uXG4gKiAvLyBpbnZva2UgKHRyYWlsaW5nKVxuICpcbiAqIC8vIGlmIHlvdSBuZWVkIHJldXNlIHRocm90dGxlZCBtZXRob2QuIHRoZW4gaW52b2tlIHJlc2V0KClcbiAqIHRocm90dGxlZC5yZXNldCgpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZSQxKGZuLCBpbnRlcnZhbCkge1xuICB2YXIgYmFzZTtcbiAgdmFyIGlzTGVhZGluZyA9IHRydWU7XG4gIHZhciB0aWNrID0gZnVuY3Rpb24oX2FyZ3MpIHtcbiAgICBmbi5hcHBseShudWxsLCBfYXJncyk7XG4gICAgYmFzZSA9IG51bGw7XG4gIH07XG4gIHZhciBkZWJvdW5jZWQsIHN0YW1wLCBhcmdzO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMDtcblxuICBkZWJvdW5jZWQgPSBkZWJvdW5jZSh0aWNrLCBpbnRlcnZhbCk7XG5cbiAgZnVuY3Rpb24gdGhyb3R0bGVkKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtanNkb2NcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmIChpc0xlYWRpbmcpIHtcbiAgICAgIHRpY2soYXJncyk7XG4gICAgICBpc0xlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YW1wID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXG4gICAgYmFzZSA9IGJhc2UgfHwgc3RhbXA7XG5cbiAgICAvLyBwYXNzIGFycmF5IGRpcmVjdGx5IGJlY2F1c2UgYGRlYm91bmNlKClgLCBgdGljaygpYCBhcmUgYWxyZWFkeSB1c2VcbiAgICAvLyBgYXBwbHkoKWAgbWV0aG9kIHRvIGludm9rZSBkZXZlbG9wZXIncyBgZm5gIGhhbmRsZXIuXG4gICAgLy9cbiAgICAvLyBhbHNvLCB0aGlzIGBkZWJvdW5jZWRgIGxpbmUgaW52b2tlZCBldmVyeSB0aW1lIGZvciBpbXBsZW1lbnRzXG4gICAgLy8gYHRyYWlsaW5nYCBmZWF0dXJlcy5cbiAgICBkZWJvdW5jZWQoYXJncyk7XG5cbiAgICBpZiAoKHN0YW1wIC0gYmFzZSkgPj0gaW50ZXJ2YWwpIHtcbiAgICAgIHRpY2soYXJncyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1qc2RvY1xuICAgIGlzTGVhZGluZyA9IHRydWU7XG4gICAgYmFzZSA9IG51bGw7XG4gIH1cblxuICB0aHJvdHRsZWQucmVzZXQgPSByZXNldDtcblxuICByZXR1cm4gdGhyb3R0bGVkO1xufVxuXG52YXIgdGhyb3R0bGVfMSA9IHRocm90dGxlJDE7XG5cbi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxudmFyIEhlYWRpbmdQb3B1cEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoSGVhZGluZ1BvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIZWFkaW5nUG9wdXBCb2R5KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEhlYWRpbmdQb3B1cEJvZHkucHJvdG90eXBlLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHZhciBlbCA9IGNsb3Nlc3QoZXYudGFyZ2V0LCAnbGknKTtcbiAgICAgICAgdGhpcy5wcm9wcy5leGVjQ29tbWFuZCgnaGVhZGluZycsIHtcbiAgICAgICAgICAgIGxldmVsOiBOdW1iZXIoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWxldmVsJykpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlYWRpbmdQb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQ4IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDggPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8dWxcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBhcmlhLXJvbGU9XFxcIm1lbnVcXFwiXFxuICAgICAgICBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgPlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgICA8bGkgZGF0YS10eXBlPVxcXCJQYXJhZ3JhcGhcXFwiIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiPlxcbiAgICAgICAgICA8ZGl2PlwiLCBcIjwvZGl2PlxcbiAgICAgICAgPC9saT5cXG4gICAgICA8L3VsPlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDx1bFxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIGFyaWEtcm9sZT1cXFwibWVudVxcXCJcXG4gICAgICAgIGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCJcXG4gICAgICA+XFxuICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA8bGkgZGF0YS10eXBlPVxcXCJQYXJhZ3JhcGhcXFwiIGFyaWEtcm9sZT1cXFwibWVudWl0ZW1cXFwiPlxcbiAgICAgICAgICA8ZGl2PlwiLCBcIjwvZGl2PlxcbiAgICAgICAgPC9saT5cXG4gICAgICA8L3VsPlxcbiAgICBcIl0pKSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5leGVjQ29tbWFuZChldik7IH0sIGkxOG4uZ2V0KCdIZWFkaW5ncycpLCBbMSwgMiwgMywgNCwgNSwgNl0ubWFwKGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRnIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGcgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICAgIDxsaSBkYXRhLWxldmVsPVxcXCJcIiwgXCJcXFwiIGRhdGEtdHlwZT1cXFwiSGVhZGluZ1xcXCIgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCI+XFxuICAgICAgICAgICAgICAgIDxcIiwgXCI+XCIsIFwiIFwiLCBcIjwvJD5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgICAgIDxsaSBkYXRhLWxldmVsPVxcXCJcIiwgXCJcXFwiIGRhdGEtdHlwZT1cXFwiSGVhZGluZ1xcXCIgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCI+XFxuICAgICAgICAgICAgICAgIDxcIiwgXCI+XCIsIFwiIFwiLCBcIjwvJD5cXG4gICAgICAgICAgICAgIDwvbGk+XFxuICAgICAgICAgICAgXCJdKSksIGxldmVsLCBcImhcIiArIGxldmVsLCBpMThuLmdldCgnSGVhZGluZycpLCBsZXZlbCk7XG4gICAgICAgIH0pLCBpMThuLmdldCgnUGFyYWdyYXBoJykpO1xuICAgIH07XG4gICAgcmV0dXJuIEhlYWRpbmdQb3B1cEJvZHk7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkZywgdGVtcGxhdGVPYmplY3RfMiQ4O1xuXG52YXIgVGFicyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUYWJzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYnMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFicy5wcm90b3R5cGUudG9nZ2xlVGFiID0gZnVuY3Rpb24gKGV2LCBhY3RpdmVUYWIpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKGV2LCBhY3RpdmVUYWIpO1xuICAgIH07XG4gICAgVGFicy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDcgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgYXJpYS1yb2xlPVxcXCJ0YWJwYW5lbFxcXCI+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIGFyaWEtcm9sZT1cXFwidGFicGFuZWxcXFwiPlxcbiAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCd0YWJzJyksIHRoaXMucHJvcHMudGFicy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHRleHQgPSBfYS50ZXh0O1xuICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gX3RoaXMucHJvcHMuYWN0aXZlVGFiID09PSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSRmIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwidGFiLWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICAgICAgYXJpYS1yb2xlPVxcXCJ0YWJcXFwiXFxuICAgICAgICAgICAgICBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICB0YWJpbmRleD1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJ0YWItaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgICBhcmlhLXJvbGU9XFxcInRhYlxcXCJcXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHRhYmluZGV4PVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIFwiXSkpLCBpc0FjdGl2ZSA/ICcgYWN0aXZlJyA6ICcnLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIF90aGlzLnRvZ2dsZVRhYihldiwgbmFtZSk7IH0sIGkxOG4uZ2V0KHRleHQpLCBpc0FjdGl2ZSA/ICd0cnVlJyA6ICdmYWxzZScsIGlzQWN0aXZlID8gJzAnIDogJy0xJywgaTE4bi5nZXQodGV4dCkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFicztcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSRmLCB0ZW1wbGF0ZU9iamVjdF8yJDc7XG5cbnZhciBUWVBFX1VJID0gJ3VpJztcbnZhciBJbWFnZVBvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShJbWFnZVBvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbWFnZVBvcHVwQm9keShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVUYWIgPT09IHZvaWQgMCkgeyBhY3RpdmVUYWIgPSAnZmlsZSc7IH1cbiAgICAgICAgICAgIHZhciB1cmxFbCA9IF90aGlzLnJlZnMudXJsO1xuICAgICAgICAgICAgdXJsRWwudmFsdWUgPSAnJztcbiAgICAgICAgICAgIF90aGlzLnJlZnMuYWx0VGV4dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgX3RoaXMucmVmcy5maWxlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICByZW1vdmVDbGFzc18xKHVybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgYWN0aXZlVGFiOiBhY3RpdmVUYWIsIGZpbGU6IG51bGwsIGZpbGVOYW1lRWxDbGFzc05hbWU6ICcnIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5leGVjQ29tbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5hY3RpdmVUYWIgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXRBZGRJbWFnZUJsb2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXRBZGRJbWFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b2dnbGVUYWIgPSBmdW5jdGlvbiAoXywgYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlVGFiICE9PSBfdGhpcy5zdGF0ZS5hY3RpdmVUYWIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbml0aWFsaXplKGFjdGl2ZVRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNob3dGaWxlU2VsZWN0Qm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVmcy5maWxlLmNsaWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNoYW5nZUZpbGUgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IGV2LnRhcmdldC5maWxlcztcbiAgICAgICAgICAgIGlmIChmaWxlcyA9PT0gbnVsbCB8fCBmaWxlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmaWxlOiBmaWxlc1swXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7IGFjdGl2ZVRhYjogJ2ZpbGUnLCBmaWxlOiBudWxsLCBmaWxlTmFtZUVsQ2xhc3NOYW1lOiAnJyB9O1xuICAgICAgICBfdGhpcy50YWJzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnZmlsZScsIHRleHQ6ICdGaWxlJyB9LFxuICAgICAgICAgICAgeyBuYW1lOiAndXJsJywgdGV4dDogJ1VSTCcgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbWFnZVBvcHVwQm9keS5wcm90b3R5cGUuZW1pdEFkZEltYWdlQmxvYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbGVzID0gdGhpcy5yZWZzLmZpbGUuZmlsZXM7XG4gICAgICAgIHZhciBhbHRUZXh0RWwgPSB0aGlzLnJlZnMuYWx0VGV4dDtcbiAgICAgICAgdmFyIGZpbGVOYW1lRWxDbGFzc05hbWUgPSAnIHdyb25nJztcbiAgICAgICAgaWYgKGZpbGVzID09PSBudWxsIHx8IGZpbGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lRWxDbGFzc05hbWUgPSAnJztcbiAgICAgICAgICAgIHZhciBpbWFnZUZpbGUgPSBmaWxlcy5pdGVtKDApO1xuICAgICAgICAgICAgdmFyIGhvb2tDYWxsYmFjayA9IGZ1bmN0aW9uICh1cmwsIHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuZXhlY0NvbW1hbmQoJ2FkZEltYWdlJywgeyBpbWFnZVVybDogdXJsLCBhbHRUZXh0OiB0ZXh0IHx8IGFsdFRleHRFbC52YWx1ZSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByb3BzLmV2ZW50RW1pdHRlci5lbWl0KCdhZGRJbWFnZUJsb2JIb29rJywgaW1hZ2VGaWxlLCBob29rQ2FsbGJhY2ssIFRZUEVfVUkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlTmFtZUVsQ2xhc3NOYW1lOiBmaWxlTmFtZUVsQ2xhc3NOYW1lIH0pO1xuICAgIH07XG4gICAgSW1hZ2VQb3B1cEJvZHkucHJvdG90eXBlLmVtaXRBZGRJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltYWdlVXJsRWwgPSB0aGlzLnJlZnMudXJsO1xuICAgICAgICB2YXIgYWx0VGV4dEVsID0gdGhpcy5yZWZzLmFsdFRleHQ7XG4gICAgICAgIHZhciBpbWFnZVVybCA9IGltYWdlVXJsRWwudmFsdWU7XG4gICAgICAgIHZhciBhbHRUZXh0ID0gYWx0VGV4dEVsLnZhbHVlIHx8ICdpbWFnZSc7XG4gICAgICAgIHJlbW92ZUNsYXNzXzEoaW1hZ2VVcmxFbCwgJ3dyb25nJyk7XG4gICAgICAgIGlmICghaW1hZ2VVcmwubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRDbGFzc18xKGltYWdlVXJsRWwsICd3cm9uZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZVVybCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5leGVjQ29tbWFuZCgnYWRkSW1hZ2UnLCB7IGltYWdlVXJsOiBpbWFnZVVybCwgYWx0VGV4dDogYWx0VGV4dCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VQb3B1cEJvZHkucHJvdG90eXBlLnByZXZlbnRTZWxlY3RTdGFydCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgSW1hZ2VQb3B1cEJvZHkucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93KSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW1hZ2VQb3B1cEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5zdGF0ZSwgYWN0aXZlVGFiID0gX2EuYWN0aXZlVGFiLCBmaWxlID0gX2EuZmlsZSwgZmlsZU5hbWVFbENsYXNzTmFtZSA9IF9hLmZpbGVOYW1lRWxDbGFzc05hbWU7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkZSB8fCAodGVtcGxhdGVPYmplY3RfMSRlID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPFwiLCBcIiB0YWJzPVwiLCBcIiBhY3RpdmVUYWI9XCIsIFwiIG9uQ2xpY2s9XCIsIFwiIC8+XFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlJbWFnZVVybElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBpZD1cXFwidG9hc3R1aUltYWdlVXJsSW5wdXRcXFwiXFxuICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6XCIsIFwiO3Bvc2l0aW9uOiByZWxhdGl2ZTtcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpSW1hZ2VGaWxlSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICAgIDxzcGFuXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICAgIG9uU2VsZWN0c3RhcnQ9XCIsIFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgaWQ9XFxcInRvYXN0dWlJbWFnZUZpbGVJbnB1dFxcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJmaWxlXFxcIlxcbiAgICAgICAgICAgIGFjY2VwdD1cXFwiaW1hZ2UvKlxcXCJcXG4gICAgICAgICAgICBvbkNoYW5nZT1cIiwgXCJcXG4gICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlBbHRUZXh0SW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlBbHRUZXh0SW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPFwiLCBcIiB0YWJzPVwiLCBcIiBhY3RpdmVUYWI9XCIsIFwiIG9uQ2xpY2s9XCIsIFwiIC8+XFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlJbWFnZVVybElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgICBpZD1cXFwidG9hc3R1aUltYWdlVXJsSW5wdXRcXFwiXFxuICAgICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcImRpc3BsYXk6XCIsIFwiO3Bvc2l0aW9uOiByZWxhdGl2ZTtcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpSW1hZ2VGaWxlSW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICAgIDxzcGFuXFxuICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICAgIG9uU2VsZWN0c3RhcnQ9XCIsIFwiXFxuICAgICAgICAgID5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGlucHV0XFxuICAgICAgICAgICAgaWQ9XFxcInRvYXN0dWlJbWFnZUZpbGVJbnB1dFxcXCJcXG4gICAgICAgICAgICB0eXBlPVxcXCJmaWxlXFxcIlxcbiAgICAgICAgICAgIGFjY2VwdD1cXFwiaW1hZ2UvKlxcXCJcXG4gICAgICAgICAgICBvbkNoYW5nZT1cIiwgXCJcXG4gICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIC8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlBbHRUZXh0SW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlBbHRUZXh0SW5wdXRcXFwiXFxuICAgICAgICAgIHR5cGU9XFxcInRleHRcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIlwiLCBcIlxcXCIgb25DbGljaz1cIiwgXCI+XFxuICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBpMThuLmdldCgnSW5zZXJ0IGltYWdlJyksIFRhYnMsIHRoaXMudGFicywgYWN0aXZlVGFiLCB0aGlzLnRvZ2dsZVRhYiwgYWN0aXZlVGFiID09PSAndXJsJyA/ICdibG9jaycgOiAnbm9uZScsIGkxOG4uZ2V0KCdJbWFnZSBVUkwnKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy51cmwgPSBlbCk7IH0sIGFjdGl2ZVRhYiA9PT0gJ2ZpbGUnID8gJ2Jsb2NrJyA6ICdub25lJywgaTE4bi5nZXQoJ1NlbGVjdCBpbWFnZSBmaWxlJyksIGNscygnZmlsZS1uYW1lJyksIGZpbGUgPyAnIGhhcy1maWxlJyA6IGZpbGVOYW1lRWxDbGFzc05hbWUsIHRoaXMuc2hvd0ZpbGVTZWxlY3RCb3gsIHRoaXMucHJldmVudFNlbGVjdFN0YXJ0LCBmaWxlID8gZmlsZS5uYW1lIDogaTE4bi5nZXQoJ05vIGZpbGUnKSwgY2xzKCdmaWxlLXNlbGVjdC1idXR0b24nKSwgdGhpcy5zaG93RmlsZVNlbGVjdEJveCwgaTE4bi5nZXQoJ0Nob29zZSBhIGZpbGUnKSwgdGhpcy5jaGFuZ2VGaWxlLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmZpbGUgPSBlbCk7IH0sIGkxOG4uZ2V0KCdEZXNjcmlwdGlvbicpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmFsdFRleHQgPSBlbCk7IH0sIGNscygnYnV0dG9uLWNvbnRhaW5lcicpLCBjbHMoJ2Nsb3NlLWJ1dHRvbicpLCB0aGlzLnByb3BzLmhpZGVQb3B1cCwgaTE4bi5nZXQoJ0NhbmNlbCcpLCBjbHMoJ29rLWJ1dHRvbicpLCB0aGlzLmV4ZWNDb21tYW5kLCBpMThuLmdldCgnT0snKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1hZ2VQb3B1cEJvZHk7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkZTtcblxudmFyIExpbmtQb3B1cEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGlua1BvcHVwQm9keSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rUG9wdXBCb2R5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGlua1VybEVsID0gX3RoaXMucmVmcy51cmw7XG4gICAgICAgICAgICB2YXIgbGlua1RleHRFbCA9IF90aGlzLnJlZnMudGV4dDtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEobGlua1VybEVsLCAnd3JvbmcnKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzXzEobGlua1RleHRFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICBpZiAobGlua1VybEVsLnZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc18xKGxpbmtVcmxFbCwgJ3dyb25nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoZWNrTGlua1RleHQgPSBpc1VuZGVmaW5lZF8xKF90aGlzLnByb3BzLmluaXRpYWxWYWx1ZXMubGlua1VybCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tMaW5rVGV4dCAmJiBsaW5rVGV4dEVsLnZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc18xKGxpbmtUZXh0RWwsICd3cm9uZycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnByb3BzLmV4ZWNDb21tYW5kKCdhZGRMaW5rJywge1xuICAgICAgICAgICAgICAgIGxpbmtVcmw6IGxpbmtVcmxFbC52YWx1ZSxcbiAgICAgICAgICAgICAgICBsaW5rVGV4dDogbGlua1RleHRFbC52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpbmtQb3B1cEJvZHkucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMuaW5pdGlhbFZhbHVlcywgbGlua1VybCA9IF9hLmxpbmtVcmwsIGxpbmtUZXh0ID0gX2EubGlua1RleHQ7XG4gICAgICAgIHZhciBsaW5rVXJsRWwgPSB0aGlzLnJlZnMudXJsO1xuICAgICAgICB2YXIgbGlua1RleHRFbCA9IHRoaXMucmVmcy50ZXh0O1xuICAgICAgICByZW1vdmVDbGFzc18xKGxpbmtVcmxFbCwgJ3dyb25nJyk7XG4gICAgICAgIHJlbW92ZUNsYXNzXzEobGlua1RleHRFbCwgJ3dyb25nJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgIGxpbmtUZXh0RWwucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICBpZiAobGlua1VybCkge1xuICAgICAgICAgICAgYWRkQ2xhc3NfMShsaW5rVGV4dEVsLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIGxpbmtUZXh0RWwuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmtVcmxFbC52YWx1ZSA9IGxpbmtVcmwgfHwgJyc7XG4gICAgICAgIGxpbmtUZXh0RWwudmFsdWUgPSBsaW5rVGV4dCB8fCAnJztcbiAgICB9O1xuICAgIExpbmtQb3B1cEJvZHkucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH07XG4gICAgTGlua1BvcHVwQm9keS5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKCFwcmV2UHJvcHMuc2hvdyAmJiB0aGlzLnByb3BzLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rUG9wdXBCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkZCB8fCAodGVtcGxhdGVPYmplY3RfMSRkID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUxpbmtVcmxJbnB1dFxcXCI+XCIsIFwiPC9sYWJlbD5cXG4gICAgICAgIDxpbnB1dFxcbiAgICAgICAgICBpZD1cXFwidG9hc3R1aUxpbmtVcmxJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRvYXN0dWlMaW5rVGV4dElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpTGlua1RleHRJbnB1dFxcXCJcXG4gICAgICAgICAgdHlwZT1cXFwidGV4dFxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBvbkNsaWNrPVwiLCBcIj5cXG4gICAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2IGFyaWEtbGFiZWw9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0b2FzdHVpTGlua1VybElucHV0XFxcIj5cIiwgXCI8L2xhYmVsPlxcbiAgICAgICAgPGlucHV0XFxuICAgICAgICAgIGlkPVxcXCJ0b2FzdHVpTGlua1VybElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidG9hc3R1aUxpbmtUZXh0SW5wdXRcXFwiPlwiLCBcIjwvbGFiZWw+XFxuICAgICAgICA8aW5wdXRcXG4gICAgICAgICAgaWQ9XFxcInRvYXN0dWlMaW5rVGV4dElucHV0XFxcIlxcbiAgICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJcIiwgXCJcXFwiIG9uQ2xpY2s9XCIsIFwiPlxcbiAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgaTE4bi5nZXQoJ0luc2VydCBsaW5rJyksIGkxOG4uZ2V0KCdVUkwnKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy51cmwgPSBlbCk7IH0sIGkxOG4uZ2V0KCdMaW5rIHRleHQnKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy50ZXh0ID0gZWwpOyB9LCBjbHMoJ2J1dHRvbi1jb250YWluZXInKSwgY2xzKCdjbG9zZS1idXR0b24nKSwgdGhpcy5wcm9wcy5oaWRlUG9wdXAsIGkxOG4uZ2V0KCdDYW5jZWwnKSwgY2xzKCdvay1idXR0b24nKSwgdGhpcy5leGVjQ29tbWFuZCwgaTE4bi5nZXQoJ09LJykpO1xuICAgIH07XG4gICAgcmV0dXJuIExpbmtQb3B1cEJvZHk7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkZDtcblxudmFyIENFTExfV0lEVEggPSAyMDtcbnZhciBDRUxMX0hFSUdIVCA9IDIwO1xudmFyIE1JTl9ST1dfSU5ERVggPSA1O1xudmFyIE1BWF9ST1dfSU5ERVggPSAxNDtcbnZhciBNSU5fQ09MX0lOREVYID0gNTtcbnZhciBNQVhfQ09MX0lOREVYID0gOTtcbnZhciBNSU5fUk9XX1NFTEVDVElPTl9JTkRFWCA9IDE7XG52YXIgTUlOX0NPTF9TRUxFQ1RJT05fSU5ERVggPSAxO1xudmFyIEJPUkRFUl9XSURUSCA9IDE7XG52YXIgVGFibGVQb3B1cEJvZHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGFibGVQb3B1cEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVQb3B1cEJvZHkocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4dGVuZFNlbGVjdGlvblJhbmdlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgcGFnZVggPSBfYS5wYWdlWCwgcGFnZVkgPSBfYS5wYWdlWTtcbiAgICAgICAgICAgIHZhciB4ID0gcGFnZVggLSBfdGhpcy5vZmZzZXRSZWN0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgeSA9IHBhZ2VZIC0gX3RoaXMub2Zmc2V0UmVjdC50b3A7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBfdGhpcy5nZXRTZWxlY3Rpb25SYW5nZUJ5T2Zmc2V0KHgsIHkpO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX19hc3NpZ24kMSh7fSwgcmFuZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5leGVjQ29tbWFuZCgnYWRkVGFibGUnLCB7XG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IF90aGlzLnN0YXRlLnJvd0lkeCArIDEsXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQ6IF90aGlzLnN0YXRlLmNvbElkeCArIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3dJZHg6IC0xLFxuICAgICAgICAgICAgY29sSWR4OiAtMSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbElkeCA9PT0gLTEgPyAnJyA6IHRoaXMuc3RhdGUuY29sSWR4ICsgMSArIFwiIHggXCIgKyAodGhpcy5zdGF0ZS5yb3dJZHggKyAxKTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXRCb3VuZEJ5UmFuZ2UgPSBmdW5jdGlvbiAoY29sSWR4LCByb3dJZHgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAoY29sSWR4ICsgMSkgKiBDRUxMX1dJRFRILFxuICAgICAgICAgICAgaGVpZ2h0OiAocm93SWR4ICsgMSkgKiBDRUxMX0hFSUdIVCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXRSYW5nZUJ5T2Zmc2V0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbElkeDogTWF0aC5mbG9vcih4IC8gQ0VMTF9XSURUSCksXG4gICAgICAgICAgICByb3dJZHg6IE1hdGguZmxvb3IoeSAvIENFTExfSEVJR0hUKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5nZXRUYWJsZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBvcmdDb2xJZHggPSBfYS5jb2xJZHgsIG9yZ1Jvd0lkeCA9IF9hLnJvd0lkeDtcbiAgICAgICAgdmFyIGNvbElkeCA9IE1hdGgubWF4KG9yZ0NvbElkeCwgTUlOX0NPTF9JTkRFWCk7XG4gICAgICAgIHZhciByb3dJZHggPSBNYXRoLm1heChvcmdSb3dJZHgsIE1JTl9ST1dfSU5ERVgpO1xuICAgICAgICBpZiAob3JnQ29sSWR4ID49IE1JTl9DT0xfSU5ERVggJiYgY29sSWR4IDwgTUFYX0NPTF9JTkRFWCkge1xuICAgICAgICAgICAgY29sSWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZ1Jvd0lkeCA+PSBNSU5fUk9XX0lOREVYICYmIHJvd0lkeCA8IE1BWF9ST1dfSU5ERVgpIHtcbiAgICAgICAgICAgIHJvd0lkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvbElkeDogY29sSWR4ICsgMSwgcm93SWR4OiByb3dJZHggKyAxIH07XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uQXJlYUJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldEJvdW5kQnlSYW5nZSh0aGlzLnN0YXRlLmNvbElkeCwgdGhpcy5zdGF0ZS5yb3dJZHgpLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcGxheTogJ25vbmUnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoIC0gQk9SREVSX1dJRFRILCBoZWlnaHQ6IGhlaWdodCAtIEJPUkRFUl9XSURUSCwgZGlzcGxheTogJ2Jsb2NrJyB9O1xuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmdldFNlbGVjdGlvblJhbmdlQnlPZmZzZXQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlQnlPZmZzZXQoeCwgeSk7XG4gICAgICAgIHJhbmdlLnJvd0lkeCA9IE1hdGgubWluKE1hdGgubWF4KHJhbmdlLnJvd0lkeCwgTUlOX1JPV19TRUxFQ1RJT05fSU5ERVgpLCBNQVhfUk9XX0lOREVYKTtcbiAgICAgICAgcmFuZ2UuY29sSWR4ID0gTWF0aC5taW4oTWF0aC5tYXgocmFuZ2UuY29sSWR4LCBNSU5fQ09MX1NFTEVDVElPTl9JTkRFWCksIE1BWF9DT0xfSU5ERVgpO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICBUYWJsZVBvcHVwQm9keS5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb2xJZHg6IC0xLCByb3dJZHg6IC0xIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY29sSWR4ID09PSAtMSAmJiB0aGlzLnN0YXRlLnJvd0lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMucmVmcy50YWJsZUVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsZWZ0ID0gX2EubGVmdCwgdG9wXzEgPSBfYS50b3A7XG4gICAgICAgICAgICB0aGlzLm9mZnNldFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0ICsgbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHdpbmRvdy5wYWdlWU9mZnNldCArIHRvcF8xLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGVQb3B1cEJvZHkucHJvdG90eXBlLmNyZWF0ZVRhYmxlQXJlYSA9IGZ1bmN0aW9uICh0YWJsZVJhbmdlKSB7XG4gICAgICAgIHZhciBjb2xJZHggPSB0YWJsZVJhbmdlLmNvbElkeCwgcm93SWR4ID0gdGFibGVSYW5nZS5yb3dJZHg7XG4gICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93SWR4OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xJZHg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsQ2xhc3NOYW1lcyA9IFwiXCIgKyBjbHMoJ3RhYmxlLWNlbGwnKSArIChpID4gMCA/ICcnIDogJyBoZWFkZXInKTtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKGh0bWwodGVtcGxhdGVPYmplY3RfMSRjIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJGMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPjwvZGl2PlwiXSwgW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj48L2Rpdj5cIl0pKSwgY2VsbENsYXNzTmFtZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChodG1sKHRlbXBsYXRlT2JqZWN0XzIkNiB8fCAodGVtcGxhdGVPYmplY3RfMiQ2ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L2Rpdj5cIl0sIFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9kaXY+XCJdKSksIGNscygndGFibGUtcm93JyksIGNlbGxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMyQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8zJDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvZGl2PlwiXSwgW1wiPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L2Rpdj5cIl0pKSwgY2xzKCd0YWJsZScpLCByb3dzKTtcbiAgICB9O1xuICAgIFRhYmxlUG9wdXBCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0YWJsZVJhbmdlID0gdGhpcy5nZXRUYWJsZVJhbmdlKCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25BcmVhQm91bmQgPSB0aGlzLmdldFNlbGVjdGlvbkFyZWFCb3VuZCgpO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF80JDEgfHwgKHRlbXBsYXRlT2JqZWN0XzQkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgYXJpYS1sYWJlbD1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlbW92ZT1cIiwgXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8cCBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cIiwgXCI8L3A+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBhcmlhLWxhYmVsPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2Vtb3ZlPVwiLCBcIlxcbiAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvcD5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGkxOG4uZ2V0KCdJbnNlcnQgdGFibGUnKSwgY2xzKCd0YWJsZS1zZWxlY3Rpb24nKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy50YWJsZUVsID0gZWwpOyB9LCB0aGlzLmV4dGVuZFNlbGVjdGlvblJhbmdlLCB0aGlzLmV4ZWNDb21tYW5kLCB0aGlzLmNyZWF0ZVRhYmxlQXJlYSh0YWJsZVJhbmdlKSwgY2xzKCd0YWJsZS1zZWxlY3Rpb24tbGF5ZXInKSwgc2VsZWN0aW9uQXJlYUJvdW5kLCBjbHMoJ3RhYmxlLWRlc2NyaXB0aW9uJyksIHRoaXMuZ2V0RGVzY3JpcHRpb24oKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVQb3B1cEJvZHk7XG59KENvbXBvbmVudCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkYywgdGVtcGxhdGVPYmplY3RfMiQ2LCB0ZW1wbGF0ZU9iamVjdF8zJDIsIHRlbXBsYXRlT2JqZWN0XzQkMTtcblxudmFyIEN1c3RvbVBvcHVwQm9keSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDdXN0b21Qb3B1cEJvZHksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tUG9wdXBCb2R5KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEN1c3RvbVBvcHVwQm9keS5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBjdXN0b20gcG9wdXAgYm9keSBlbGVtZW50XG4gICAgICAgIHRoaXMucmVmcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnByb3BzLmJvZHkpO1xuICAgIH07XG4gICAgQ3VzdG9tUG9wdXBCb2R5LnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICAvLyB1cGRhdGUgY3VzdG9tIHBvcHVwIGVsZW1lbnRcbiAgICAgICAgdGhpcy5yZWZzLmVsLnJlcGxhY2VDaGlsZCh0aGlzLnByb3BzLmJvZHksIHByZXZQcm9wcy5ib2R5KTtcbiAgICB9O1xuICAgIEN1c3RvbVBvcHVwQm9keS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJGIgfHwgKHRlbXBsYXRlT2JqZWN0XzEkYiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIjxkaXYgcmVmPVwiLCBcIj48L2Rpdj5cIl0sIFtcIjxkaXYgcmVmPVwiLCBcIj48L2Rpdj5cIl0pKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ3VzdG9tUG9wdXBCb2R5O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJGI7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2xiYXJJdGVtSW5mbyh0eXBlKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nXzEodHlwZSkgPyBjcmVhdGVEZWZhdWx0VG9vbGJhckl0ZW1JbmZvKHR5cGUpIDogdHlwZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjcm9sbFN5bmNUb29sYmFySXRlbSgpIHtcbiAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgdmFyIHRvZ2dsZVN3aXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSAnc2Nyb2xsLXN5bmMgYWN0aXZlJztcbiAgICBjaGVja2JveC50eXBlID0gJ2NoZWNrYm94JztcbiAgICBjaGVja2JveC5jaGVja2VkID0gdHJ1ZTtcbiAgICB0b2dnbGVTd2l0Y2guY2xhc3NOYW1lID0gJ3N3aXRjaCc7XG4gICAgdmFyIG9uTW91bnRlZCA9IGZ1bmN0aW9uIChleGVjQ29tbWFuZCkge1xuICAgICAgICByZXR1cm4gY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tlZCA9IGV2LnRhcmdldC5jaGVja2VkO1xuICAgICAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzc18xKGxhYmVsLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzc18xKGxhYmVsLCAnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleGVjQ29tbWFuZCgndG9nZ2xlU2Nyb2xsU3luYycsIHsgYWN0aXZlOiBjaGVja2VkIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGxhYmVsLmFwcGVuZENoaWxkKGNoZWNrYm94KTtcbiAgICBsYWJlbC5hcHBlbmRDaGlsZCh0b2dnbGVTd2l0Y2gpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdzY3JvbGxTeW5jJyxcbiAgICAgICAgZWw6IGxhYmVsLFxuICAgICAgICBvbk1vdW50ZWQ6IG9uTW91bnRlZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFRvb2xiYXJJdGVtSW5mbyh0eXBlKSB7XG4gICAgdmFyIGluZm87XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0hlYWRpbmdzJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9sZCc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0JvbGQnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N0cm9uZycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdpdGFsaWMnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0l0YWxpYycpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnZW1waCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJpa2UnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N0cmlrZScsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3N0cmlrZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ1N0cmlrZScpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAnc3RyaWtlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHInOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaHInLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2hybGluZScsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2hyJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnTGluZScpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndGhlbWF0aWNCcmVhaycsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3F1b3RlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3F1b3RlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdxdW90ZScsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2Jsb2NrUXVvdGUnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdCbG9ja3F1b3RlJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdibG9ja1F1b3RlJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndWwnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndWwnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2J1bGxldC1saXN0JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnYnVsbGV0TGlzdCcsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ1Vub3JkZXJlZCBsaXN0JyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdidWxsZXRMaXN0JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2wnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnb2wnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ29yZGVyZWQtbGlzdCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ29yZGVyZWRMaXN0JyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnT3JkZXJlZCBsaXN0JyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdvcmRlcmVkTGlzdCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Rhc2snOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndGFzaycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndGFzay1saXN0JyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndGFza0xpc3QnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdUYXNrJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICd0YXNrTGlzdCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICd0YWJsZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0luc2VydCB0YWJsZScpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndGFibGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJbnNlcnQgaW1hZ2UnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdsaW5rJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnSW5zZXJ0IGxpbmsnKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29kZScsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogaTE4bi5nZXQoJ0NvZGUnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2NvZGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2RlYmxvY2snOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29kZWJsb2NrJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdjb2RlYmxvY2snLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb2RlQmxvY2snLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJbnNlcnQgQ29kZUJsb2NrJyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjb2RlQmxvY2snLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbmRlbnQnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5kZW50JyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdpbmRlbnQnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdpbmRlbnQnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdJbmRlbnQnKSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2luZGVudCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ291dGRlbnQnOlxuICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnb3V0ZGVudCcsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnb3V0ZGVudCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ291dGRlbnQnLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IGkxOG4uZ2V0KCdPdXRkZW50JyksXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdvdXRkZW50JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2Nyb2xsU3luYyc6XG4gICAgICAgICAgICBpbmZvID0gY3JlYXRlU2Nyb2xsU3luY1Rvb2xiYXJJdGVtKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9yZSc6XG4gICAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdtb3JlJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdtb3JlJyxcbiAgICAgICAgICAgICAgICB0b29sdGlwOiBpMThuLmdldCgnTW9yZScpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIGlmIChpbmZvLm5hbWUgIT09ICdzY3JvbGxTeW5jJykge1xuICAgICAgICBpbmZvLmNsYXNzTmFtZSArPSBcIiBcIiArIGNscygndG9vbGJhci1pY29ucycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvcHVwSW5mbyh0eXBlLCBwYXlsb2FkKSB7XG4gICAgdmFyIGVsID0gcGF5bG9hZC5lbCwgcG9zID0gcGF5bG9hZC5wb3MsIHBvcHVwID0gcGF5bG9hZC5wb3B1cCwgaW5pdGlhbFZhbHVlcyA9IHBheWxvYWQuaW5pdGlhbFZhbHVlcztcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkYSB8fCAodGVtcGxhdGVPYmplY3RfMSRhID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdKSksIEhlYWRpbmdQb3B1cEJvZHksIHByb3BzKTsgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNscygncG9wdXAtYWRkLWhlYWRpbmcnKSxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkNSB8fCAodGVtcGxhdGVPYmplY3RfMiQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdKSksIExpbmtQb3B1cEJvZHksIHByb3BzKTsgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNscygncG9wdXAtYWRkLWxpbmsnKSxcbiAgICAgICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgICAgIHBvczogcG9zLFxuICAgICAgICAgICAgICAgIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzMkMSB8fCAodGVtcGxhdGVPYmplY3RfMyQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIgLi4uXCIsIFwiIC8+XCJdKSksIEltYWdlUG9wdXBCb2R5LCBwcm9wcyk7IH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHMoJ3BvcHVwLWFkZC1pbWFnZScpLFxuICAgICAgICAgICAgICAgIGZyb21FbDogZWwsXG4gICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzQgfHwgKHRlbXBsYXRlT2JqZWN0XzQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgLz5cIl0pKSwgVGFibGVQb3B1cEJvZHksIHByb3BzKTsgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGNscygncG9wdXAtYWRkLXRhYmxlJyksXG4gICAgICAgICAgICAgICAgZnJvbUVsOiBlbCxcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2N1c3RvbVBvcHVwQm9keSc6XG4gICAgICAgICAgICBpZiAoIXBvcHVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24kMSh7IHJlbmRlcjogZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzUgfHwgKHRlbXBsYXRlT2JqZWN0XzUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIC4uLlwiLCBcIiBib2R5PVwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiAuLi5cIiwgXCIgYm9keT1cIiwgXCIgLz5cIl0pKSwgQ3VzdG9tUG9wdXBCb2R5LCBwcm9wcywgcG9wdXAuYm9keSk7IH0sIGZyb21FbDogZWwsIHBvczogcG9zIH0sIHBvcHVwKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEdyb3VwU3RhdGUoZ3JvdXApIHtcbiAgICBncm91cC5oaWRkZW4gPSBncm91cC5sZW5ndGggPT09IGdyb3VwLmZpbHRlcihmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5oaWRkZW47IH0pLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGdyb3VwVG9vbGJhckl0ZW1zKHRvb2xiYXJJdGVtcywgaGlkZGVuU2Nyb2xsU3luYykge1xuICAgIHZhciB0b2dnbGVTY3JvbGxTeW5jU3RhdGUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLmhpZGRlbiA9IGl0ZW0ubmFtZSA9PT0gJ3Njcm9sbFN5bmMnICYmIGhpZGRlblNjcm9sbFN5bmM7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgcmV0dXJuIHRvb2xiYXJJdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICAgICAgICBhY2MucHVzaChpdGVtLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdG9nZ2xlU2Nyb2xsU3luY1N0YXRlKGNyZWF0ZVRvb2xiYXJJdGVtSW5mbyh0eXBlKSk7IH0pKTtcbiAgICAgICAgdmFyIGdyb3VwID0gYWNjWyhhY2MubGVuZ3RoIHx8IDEpIC0gMV07XG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgc2V0R3JvdXBTdGF0ZShncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiB0b2dnbGVTY3JvbGxTeW5jKHRvb2xiYXJJdGVtcywgaGlkZGVuU2Nyb2xsU3luYykge1xuICAgIHRvb2xiYXJJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICBncm91cC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoaXRlbS5oaWRkZW4gPSBpdGVtLm5hbWUgPT09ICdzY3JvbGxTeW5jJyAmJiBoaWRkZW5TY3JvbGxTeW5jKTsgfSk7XG4gICAgICAgIHNldEdyb3VwU3RhdGUoZ3JvdXApO1xuICAgIH0pO1xufVxudmFyIHRlbXBsYXRlT2JqZWN0XzEkYSwgdGVtcGxhdGVPYmplY3RfMiQ1LCB0ZW1wbGF0ZU9iamVjdF8zJDEsIHRlbXBsYXRlT2JqZWN0XzQsIHRlbXBsYXRlT2JqZWN0XzU7XG5cbnZhciBNQVJHSU5fRlJPTV9SSUdIVF9TSURFID0gMjA7XG52YXIgUG9wdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoUG9wdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9wdXAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmICghY2xvc2VzdChldi50YXJnZXQsIFwiLlwiICsgY2xzKCdwb3B1cCcpKSAmJlxuICAgICAgICAgICAgICAgICFjbG9zZXN0KGV2LnRhcmdldCwgX3RoaXMucHJvcHMuaW5mby5mcm9tRWwpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuaGlkZVBvcHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUG9wdXAucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICAgICAgdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjbG9zZVBvcHVwJywgdGhpcy5wcm9wcy5oaWRlUG9wdXApO1xuICAgIH07XG4gICAgUG9wdXAucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duKTtcbiAgICB9O1xuICAgIFBvcHVwLnByb3RvdHlwZS51cGRhdGVkID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzaG93ID0gX2Euc2hvdywgaW5mbyA9IF9hLmluZm87XG4gICAgICAgIGlmIChzaG93ICYmIGluZm8ucG9zICYmIHByZXZQcm9wcy5zaG93ICE9PSBzaG93KSB7XG4gICAgICAgICAgICB2YXIgcG9wdXBQb3MgPSBfX2Fzc2lnbiQxKHt9LCBpbmZvLnBvcyk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0V2lkdGggPSB0aGlzLnJlZnMuZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgdG9vbGJhckVsID0gY2xvc2VzdCh0aGlzLnJlZnMuZWwsIFwiLlwiICsgY2xzKCd0b29sYmFyJykpO1xuICAgICAgICAgICAgdmFyIHRvb2xiYXJPZmZzZXRXaWR0aCA9IHRvb2xiYXJFbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGlmIChwb3B1cFBvcy5sZWZ0ICsgb2Zmc2V0V2lkdGggPj0gdG9vbGJhck9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcG9wdXBQb3MubGVmdCA9IHRvb2xiYXJPZmZzZXRXaWR0aCAtIG9mZnNldFdpZHRoIC0gTUFSR0lOX0ZST01fUklHSFRfU0lERTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUucG9wdXBQb3MsIHBvcHVwUG9zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBwb3B1cFBvczogcG9wdXBQb3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcHVwLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGluZm8gPSBfYS5pbmZvLCBzaG93ID0gX2Euc2hvdywgaGlkZVBvcHVwID0gX2EuaGlkZVBvcHVwLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXIsIGV4ZWNDb21tYW5kID0gX2EuZXhlY0NvbW1hbmQ7XG4gICAgICAgIHZhciBfYiA9IGluZm8gfHwge30sIF9jID0gX2IuY2xhc3NOYW1lLCBjbGFzc05hbWUgPSBfYyA9PT0gdm9pZCAwID8gJycgOiBfYywgc3R5bGUgPSBfYi5zdHlsZSwgcmVuZGVyID0gX2IucmVuZGVyLCBfZCA9IF9iLmluaXRpYWxWYWx1ZXMsIGluaXRpYWxWYWx1ZXMgPSBfZCA9PT0gdm9pZCAwID8ge30gOiBfZDtcbiAgICAgICAgdmFyIHBvcHVwU3R5bGUgPSBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoeyBkaXNwbGF5OiBzaG93ID8gJ2Jsb2NrJyA6ICdub25lJyB9LCBzdHlsZSksIHRoaXMuc3RhdGUucG9wdXBQb3MpO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDkgfHwgKHRlbXBsYXRlT2JqZWN0XzEkOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICBhcmlhLXJvbGU9XFxcImRpYWxvZ1xcXCJcXG4gICAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICBhcmlhLXJvbGU9XFxcImRpYWxvZ1xcXCJcXG4gICAgICA+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgY2xzKCdwb3B1cCcpLCBjbGFzc05hbWUsIHBvcHVwU3R5bGUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIGNscygncG9wdXAtYm9keScpLCByZW5kZXIgJiYgcmVuZGVyKHsgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsIHNob3c6IHNob3csIGhpZGVQb3B1cDogaGlkZVBvcHVwLCBleGVjQ29tbWFuZDogZXhlY0NvbW1hbmQsIGluaXRpYWxWYWx1ZXM6IGluaXRpYWxWYWx1ZXMgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVwO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDk7XG5cbnZhciBUT09MVElQX0lOREVOVCA9IDY7XG5mdW5jdGlvbiBjb25uZWN0SE9DKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShCdXR0b25IT0MsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJ1dHRvbkhPQyhwcm9wcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciB0b29sdGlwID0gX3RoaXMucHJvcHMuaXRlbS50b29sdGlwO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuZGlzYWJsZWQgJiYgdG9vbHRpcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmQgPSBfdGhpcy5nZXRCb3VuZChlbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gYm91bmQubGVmdCArIFRPT0xUSVBfSU5ERU5UICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wXzEgPSBib3VuZC50b3AgKyBUT09MVElQX0lOREVOVCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgY3NzXzEoX3RoaXMucHJvcHMudG9vbHRpcFJlZi5jdXJyZW50LCB7IGRpc3BsYXk6ICdibG9jaycsIGxlZnQ6IGxlZnQsIHRvcDogdG9wXzEgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnRvb2x0aXBSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKCcudGV4dCcpLnRleHRDb250ZW50ID0gdG9vbHRpcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY3NzXzEoX3RoaXMucHJvcHMudG9vbHRpcFJlZi5jdXJyZW50LCAnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSB7IGFjdGl2ZTogZmFsc2UsIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9O1xuICAgICAgICAgICAgX3RoaXMuYWRkRXZlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICBCdXR0b25IT0MucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGl0ZW0gPSBfYS5pdGVtLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXI7XG4gICAgICAgICAgICBpZiAoaXRlbS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVRvb2xiYXJTdGF0ZScsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b29sYmFyU3RhdGUgPSBfYS50b29sYmFyU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYyA9IChfYiA9IHRvb2xiYXJTdGF0ZVtpdGVtLnN0YXRlXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sIGFjdGl2ZSA9IF9jLmFjdGl2ZSwgZGlzYWJsZWQgPSBfYy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBhY3RpdmU6ICEhYWN0aXZlLCBkaXNhYmxlZDogZGlzYWJsZWQgIT09IG51bGwgJiYgZGlzYWJsZWQgIT09IHZvaWQgMCA/IGRpc2FibGVkIDogX3RoaXMucHJvcHMuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJ1dHRvbkhPQy5wcm90b3R5cGUuZ2V0Qm91bmQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGdldFRvdGFsT2Zmc2V0KGVsLCBjbG9zZXN0KGVsLCBcIi5cIiArIGNscygndG9vbGJhcicpKSksIG9mZnNldExlZnQgPSBfYS5vZmZzZXRMZWZ0LCBvZmZzZXRUb3AgPSBfYS5vZmZzZXRUb3A7XG4gICAgICAgICAgICByZXR1cm4geyBsZWZ0OiBvZmZzZXRMZWZ0LCB0b3A6IGVsLm9mZnNldEhlaWdodCArIG9mZnNldFRvcCB9O1xuICAgICAgICB9O1xuICAgICAgICBCdXR0b25IT0MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkOCB8fCAodGVtcGxhdGVPYmplY3RfMSQ4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICBhY3RpdmU9XCIsIFwiXFxuICAgICAgICAgIHNob3dUb29sdGlwPVwiLCBcIlxcbiAgICAgICAgICBoaWRlVG9vbHRpcD1cIiwgXCJcXG4gICAgICAgICAgZ2V0Qm91bmQ9XCIsIFwiXFxuICAgICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICBcIl0sIFtcIlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgYWN0aXZlPVwiLCBcIlxcbiAgICAgICAgICBzaG93VG9vbHRpcD1cIiwgXCJcXG4gICAgICAgICAgaGlkZVRvb2x0aXA9XCIsIFwiXFxuICAgICAgICAgIGdldEJvdW5kPVwiLCBcIlxcbiAgICAgICAgICBkaXNhYmxlZD1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgXCJdKSksIFdyYXBwZWRDb21wb25lbnQsIHRoaXMucHJvcHMsIHRoaXMuc3RhdGUuYWN0aXZlLCB0aGlzLnNob3dUb29sdGlwLCB0aGlzLmhpZGVUb29sdGlwLCB0aGlzLmdldEJvdW5kLCB0aGlzLnN0YXRlLmRpc2FibGVkIHx8IHRoaXMucHJvcHMuZGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQnV0dG9uSE9DO1xuICAgIH0oQ29tcG9uZW50KSk7XG59XG52YXIgdGVtcGxhdGVPYmplY3RfMSQ4O1xuXG52YXIgREVGQVVMVF9XSURUSCA9IDgwO1xudmFyIFRvb2xiYXJCdXR0b25Db21wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRvb2xiYXJCdXR0b25Db21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXJCdXR0b25Db21wKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93VG9vbHRpcChfdGhpcy5yZWZzLmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZXhlY0NvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgaXRlbSA9IF9hLml0ZW0sIGV4ZWNDb21tYW5kID0gX2EuZXhlY0NvbW1hbmQsIHNldFBvcHVwSW5mbyA9IF9hLnNldFBvcHVwSW5mbywgZ2V0Qm91bmQgPSBfYS5nZXRCb3VuZCwgZXZlbnRFbWl0dGVyID0gX2EuZXZlbnRFbWl0dGVyO1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBpdGVtLmNvbW1hbmQsIG5hbWUgPSBpdGVtLm5hbWUsIHBvcHVwID0gaXRlbS5wb3B1cDtcbiAgICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgZXhlY0NvbW1hbmQoY29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9wdXBOYW1lID0gcG9wdXAgPyAnY3VzdG9tUG9wdXBCb2R5JyA6IG5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxWYWx1ZXMgPSBldmVudEVtaXR0ZXIuZW1pdCgncXVlcnknLCAnZ2V0UG9wdXBJbml0aWFsVmFsdWVzJywgeyBwb3B1cE5hbWU6IHBvcHVwTmFtZSB9KVswXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IGNyZWF0ZVBvcHVwSW5mbyhwb3B1cE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IF90aGlzLnJlZnMuZWwsXG4gICAgICAgICAgICAgICAgICAgIHBvczogZ2V0Qm91bmQoX3RoaXMucmVmcy5lbCksXG4gICAgICAgICAgICAgICAgICAgIHBvcHVwOiBwb3B1cCxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFZhbHVlczogaW5pdGlhbFZhbHVlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBzZXRQb3B1cEluZm8oaW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEl0ZW1XaWR0aCgpO1xuICAgIH07XG4gICAgVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMuaXRlbS5uYW1lICE9PSB0aGlzLnByb3BzLml0ZW0ubmFtZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRJdGVtV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbGJhckJ1dHRvbkNvbXAucHJvdG90eXBlLnNldEl0ZW1XaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgc2V0SXRlbVdpZHRoID0gX2Euc2V0SXRlbVdpZHRoLCBpdGVtID0gX2EuaXRlbTtcbiAgICAgICAgLy8gc2V0IHdpZHRoIG9ubHkgaWYgaXQgaXMgbm90IGEgZHJvcGRvd24gdG9vbGJhclxuICAgICAgICBpZiAoc2V0SXRlbVdpZHRoKSB7XG4gICAgICAgICAgICBzZXRJdGVtV2lkdGgoaXRlbS5uYW1lLCBnZXRPdXRlcldpZHRoKHRoaXMucmVmcy5lbCkgKyAoaXRlbS5oaWRkZW4gPyBERUZBVUxUX1dJRFRIIDogMCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBoaWRlVG9vbHRpcCA9IF9hLmhpZGVUb29sdGlwLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBpdGVtID0gX2EuaXRlbSwgYWN0aXZlID0gX2EuYWN0aXZlO1xuICAgICAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbiQxKHsgZGlzcGxheTogaXRlbS5oaWRkZW4gPyAnbm9uZScgOiBudWxsIH0sIGl0ZW0uc3R5bGUpO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFwiXCIgKyAoaXRlbS5jbGFzc05hbWUgfHwgJycpICsgKGFjdGl2ZSA/ICcgYWN0aXZlJyA6ICcnKTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ3IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDcgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8YnV0dG9uXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgYXJpYS1sYWJlbD1cIiwgXCJcXG4gICAgICA+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICA8L2J1dHRvbj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8YnV0dG9uXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICB0eXBlPVxcXCJidXR0b25cXFwiXFxuICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgIGNsYXNzPVwiLCBcIlxcbiAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW91dD1cIiwgXCJcXG4gICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgYXJpYS1sYWJlbD1cIiwgXCJcXG4gICAgICA+XFxuICAgICAgICBcIiwgXCJcXG4gICAgICA8L2J1dHRvbj5cXG4gICAgXCJdKSksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIHN0eWxlLCBjbGFzc05hbWVzLCB0aGlzLmV4ZWNDb21tYW5kLCB0aGlzLnNob3dUb29sdGlwLCBoaWRlVG9vbHRpcCwgISFkaXNhYmxlZCwgaXRlbS50ZXh0IHx8IGl0ZW0udG9vbHRpcCB8fCAnJywgaXRlbS50ZXh0IHx8ICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyQnV0dG9uQ29tcDtcbn0oQ29tcG9uZW50KSk7XG52YXIgVG9vbGJhckJ1dHRvbiA9IGNvbm5lY3RIT0MoVG9vbGJhckJ1dHRvbkNvbXApO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNztcblxudmFyIEN1c3RvbVRvb2xiYXJJdGVtQ29tcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDdXN0b21Ub29sYmFySXRlbUNvbXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tVG9vbGJhckl0ZW1Db21wKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvd1Rvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93VG9vbHRpcChfdGhpcy5yZWZzLmVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2hvd1BvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBjcmVhdGVQb3B1cEluZm8oJ2N1c3RvbVBvcHVwQm9keScsIHtcbiAgICAgICAgICAgICAgICBlbDogX3RoaXMucmVmcy5lbCxcbiAgICAgICAgICAgICAgICBwb3M6IF90aGlzLnByb3BzLmdldEJvdW5kKF90aGlzLnJlZnMuZWwpLFxuICAgICAgICAgICAgICAgIHBvcHVwOiBfdGhpcy5wcm9wcy5pdGVtLnBvcHVwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNldFBvcHVwSW5mbyhpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDdXN0b21Ub29sYmFySXRlbUNvbXAucHJvdG90eXBlLm1vdW50ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNldEl0ZW1XaWR0aCA9IF9hLnNldEl0ZW1XaWR0aCwgaXRlbSA9IF9hLml0ZW07XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgY3VzdG9tIGh0bWwgZWxlbWVudFxuICAgICAgICB0aGlzLnJlZnMuZWwuYXBwZW5kQ2hpbGQoaXRlbS5lbCk7XG4gICAgICAgIC8vIHNldCB3aWR0aCBvbmx5IGlmIGl0IGlzIG5vdCBhIGRyb3Bkb3duIHRvb2xiYXJcbiAgICAgICAgaWYgKHNldEl0ZW1XaWR0aCkge1xuICAgICAgICAgICAgc2V0SXRlbVdpZHRoKGl0ZW0ubmFtZSwgZ2V0T3V0ZXJXaWR0aCh0aGlzLnJlZnMuZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5vbk1vdW50ZWQpIHtcbiAgICAgICAgICAgIGl0ZW0ub25Nb3VudGVkKHRoaXMucHJvcHMuZXhlY0NvbW1hbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21Ub29sYmFySXRlbUNvbXAucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5wcm9wcywgaXRlbSA9IF9iLml0ZW0sIGFjdGl2ZSA9IF9iLmFjdGl2ZSwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZDtcbiAgICAgICAgaWYgKHByZXZQcm9wcy5hY3RpdmUgIT09IGFjdGl2ZSB8fCBwcmV2UHJvcHMuZGlzYWJsZWQgIT09IGRpc2FibGVkKSB7XG4gICAgICAgICAgICAoX2EgPSBpdGVtLm9uVXBkYXRlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaXRlbSwgeyBhY3RpdmU6IGFjdGl2ZSwgZGlzYWJsZWQ6IGRpc2FibGVkIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDdXN0b21Ub29sYmFySXRlbUNvbXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgaXRlbSA9IF9hLml0ZW07XG4gICAgICAgIHZhciBzdHlsZSA9IHsgZGlzcGxheTogaXRlbS5oaWRkZW4gPyAnbm9uZScgOiAnaW5saW5lLWJsb2NrJyB9O1xuICAgICAgICB2YXIgZ2V0TGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIChkaXNhYmxlZCA/IG51bGwgOiBsaXN0ZW5lcik7IH07XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkNiB8fCAodGVtcGxhdGVPYmplY3RfMSQ2ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3Zlcj1cIiwgXCJcXG4gICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgPjwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgID48L2Rpdj5cXG4gICAgXCJdKSksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIHN0eWxlLCBjbHMoJ3Rvb2xiYXItaXRlbS13cmFwcGVyJyksIGdldExpc3RlbmVyKHRoaXMuc2hvd1BvcHVwKSwgZ2V0TGlzdGVuZXIodGhpcy5zaG93VG9vbHRpcCksIGdldExpc3RlbmVyKHRoaXMucHJvcHMuaGlkZVRvb2x0aXApKTtcbiAgICB9O1xuICAgIHJldHVybiBDdXN0b21Ub29sYmFySXRlbUNvbXA7XG59KENvbXBvbmVudCkpO1xudmFyIEN1c3RvbVRvb2xiYXJJdGVtID0gY29ubmVjdEhPQyhDdXN0b21Ub29sYmFySXRlbUNvbXApO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNjtcblxudmFyIFRvb2xiYXJHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUb29sYmFyR3JvdXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhckdyb3VwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRvb2xiYXJHcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBncm91cCA9IF9hLmdyb3VwLCBoaWRkZW5EaXZpZGVyID0gX2EuaGlkZGVuRGl2aWRlcjtcbiAgICAgICAgdmFyIGdyb3VwU3R5bGUgPSBncm91cC5oaWRkZW4gPyB7IGRpc3BsYXk6ICdub25lJyB9IDogbnVsbDtcbiAgICAgICAgdmFyIGRpdmlkZXJTdHlsZSA9IGhpZGRlbkRpdmlkZXIgPyB7IGRpc3BsYXk6ICdub25lJyB9IDogbnVsbDtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj5cXG4gICAgICAgIFwiLCBcIlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSwgW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+XFxuICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdKSksIGNscygndG9vbGJhci1ncm91cCcpLCBncm91cFN0eWxlLCBncm91cC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBDb21wID0gaXRlbS5lbCA/IEN1c3RvbVRvb2xiYXJJdGVtIDogVG9vbGJhckJ1dHRvbjtcbiAgICAgICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzEkNSB8fCAodGVtcGxhdGVPYmplY3RfMSQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPFwiLCBcIiBrZXk9XCIsIFwiIC4uLlwiLCBcIiBpdGVtPVwiLCBcIiAvPlwiXSwgW1wiPFwiLCBcIiBrZXk9XCIsIFwiIC4uLlwiLCBcIiBpdGVtPVwiLCBcIiAvPlwiXSkpLCBDb21wLCBpdGVtLm5hbWUsIF90aGlzLnByb3BzLCBpdGVtKTtcbiAgICAgICAgfSksIGNscygndG9vbGJhci1kaXZpZGVyJyksIGRpdmlkZXJTdHlsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhckdyb3VwO1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDUsIHRlbXBsYXRlT2JqZWN0XzIkNDtcblxudmFyIFBPUFVQX0lOREVOVCA9IDQ7XG52YXIgRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyb3Bkb3duVG9vbGJhckJ1dHRvbkNvbXAocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrRG9jdW1lbnQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QodGFyZ2V0LCBcIi5cIiArIGNscygnZHJvcGRvd24tdG9vbGJhcicpKSAmJlxuICAgICAgICAgICAgICAgICFjbG9zZXN0KHRhcmdldCwgJy5tb3JlJykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNob3dEcm9wZG93bjogZmFsc2UsIGRyb3Bkb3duUG9zOiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dUb29sdGlwKF90aGlzLnJlZnMuZWwpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgc2hvd0Ryb3Bkb3duOiBmYWxzZSwgZHJvcGRvd25Qb3M6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEcm9wZG93blRvb2xiYXJCdXR0b25Db21wLnByb3RvdHlwZS5nZXRCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnByb3BzLmdldEJvdW5kKHRoaXMucmVmcy5lbCk7XG4gICAgICAgIHJlY3QudG9wICs9IFBPUFVQX0lOREVOVDtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduJDEoX19hc3NpZ24kMSh7fSwgcmVjdCksIHsgbGVmdDogbnVsbCwgcmlnaHQ6IDEwIH0pO1xuICAgIH07XG4gICAgRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRG9jdW1lbnQpO1xuICAgIH07XG4gICAgRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUudXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2hvd0Ryb3Bkb3duICYmICF0aGlzLnN0YXRlLmRyb3Bkb3duUG9zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZHJvcGRvd25Qb3M6IHRoaXMuZ2V0Qm91bmQoKSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRG9jdW1lbnQpO1xuICAgIH07XG4gICAgRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBzaG93RHJvcGRvd24gPSBfYS5zaG93RHJvcGRvd24sIGRyb3Bkb3duUG9zID0gX2EuZHJvcGRvd25Qb3M7XG4gICAgICAgIHZhciBfYiA9IHRoaXMucHJvcHMsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQsIGl0ZW0gPSBfYi5pdGVtLCBpdGVtcyA9IF9iLml0ZW1zLCBoaWRlVG9vbHRpcCA9IF9iLmhpZGVUb29sdGlwO1xuICAgICAgICB2YXIgdmlzaWJsZUl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChkcm9wZG93bkl0ZW0pIHsgcmV0dXJuICFkcm9wZG93bkl0ZW0uaGlkZGVuOyB9KTtcbiAgICAgICAgdmFyIGdyb3VwU3R5bGUgPSB2aXNpYmxlSXRlbXMubGVuZ3RoID8gbnVsbCA6IHsgZGlzcGxheTogJ25vbmUnIH07XG4gICAgICAgIHZhciBkcm9wZG93blN0eWxlID0gc2hvd0Ryb3Bkb3duID8gbnVsbCA6IHsgZGlzcGxheTogJ25vbmUnIH07XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzIkMyB8fCAodGVtcGxhdGVPYmplY3RfMiQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIiBzdHlsZT1cIiwgXCI+XFxuICAgICAgICA8YnV0dG9uXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgICBjbGFzcz1cIiwgXCJcXG4gICAgICAgICAgb25DbGljaz1cIiwgXCJcXG4gICAgICAgICAgb25Nb3VzZW92ZXI9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2VvdXQ9XCIsIFwiXFxuICAgICAgICAgIGRpc2FibGVkPVwiLCBcIlxcbiAgICAgICAgPjwvYnV0dG9uPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICBzdHlsZT1cIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiPlxcbiAgICAgICAgPGJ1dHRvblxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgICAgICAgY2xhc3M9XCIsIFwiXFxuICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgIG9uTW91c2VvdmVyPVwiLCBcIlxcbiAgICAgICAgICBvbk1vdXNlb3V0PVwiLCBcIlxcbiAgICAgICAgICBkaXNhYmxlZD1cIiwgXCJcXG4gICAgICAgID48L2J1dHRvbj5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgXCIsXG4gICAgICAgICAgICBcIlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3Rvb2xiYXItZ3JvdXAnKSwgZ3JvdXBTdHlsZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lbCA9IGVsKTsgfSwgaXRlbS5jbGFzc05hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNldFN0YXRlKHsgc2hvd0Ryb3Bkb3duOiB0cnVlIH0pOyB9LCB0aGlzLnNob3dUb29sdGlwLCBoaWRlVG9vbHRpcCwgZGlzYWJsZWQsIGNscygnZHJvcGRvd24tdG9vbGJhcicpLCBfX2Fzc2lnbiQxKF9fYXNzaWduJDEoe30sIGRyb3Bkb3duU3R5bGUpLCBkcm9wZG93blBvcyksIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZHJvcGRvd25FbCA9IGVsKTsgfSwgdmlzaWJsZUl0ZW1zLmxlbmd0aFxuICAgICAgICAgICAgPyB2aXNpYmxlSXRlbXMubWFwKGZ1bmN0aW9uIChncm91cCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMSQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgICBncm91cD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdmlkZXI9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2aWRlcj1cIixcbiAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgICAgIFwiXSkpLCBUb29sYmFyR3JvdXAsIGdyb3VwLCBpbmRleCA9PT0gdmlzaWJsZUl0ZW1zLmxlbmd0aCAtIDEgfHxcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IHZpc2libGVJdGVtc1tpbmRleCArIDFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZGVuKSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRHJvcGRvd25Ub29sYmFyQnV0dG9uQ29tcDtcbn0oQ29tcG9uZW50KSk7XG52YXIgRHJvcGRvd25Ub29sYmFyQnV0dG9uID0gY29ubmVjdEhPQyhEcm9wZG93blRvb2xiYXJCdXR0b25Db21wKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDQsIHRlbXBsYXRlT2JqZWN0XzIkMztcblxudmFyIElOTElORV9QQURESU5HID0gNTA7XG52YXIgVG9vbGJhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShUb29sYmFyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRvb2xiYXIocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRvZ2dsZVRhYiA9IGZ1bmN0aW9uIChfLCBhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgIHZhciBldmVudEVtaXR0ZXIgPSBfdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXI7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuYWN0aXZlVGFiICE9PSBhY3RpdmVUYWIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IGFjdGl2ZVRhYiA9PT0gJ3dyaXRlJyA/ICdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnIDogJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JztcbiAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdChldmVudF8xKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGFjdGl2ZVRhYjogYWN0aXZlVGFiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRJdGVtV2lkdGggPSBmdW5jdGlvbiAobmFtZSwgd2lkdGgpIHtcbiAgICAgICAgICAgIF90aGlzLml0ZW1XaWR0aE1hcFtuYW1lXSA9IHdpZHRoO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRQb3B1cEluZm8gPSBmdW5jdGlvbiAocG9wdXBJbmZvKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNob3dQb3B1cDogdHJ1ZSwgcG9wdXBJbmZvOiBwb3B1cEluZm8gfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9wZW5Qb3B1cCA9IGZ1bmN0aW9uIChwb3B1cE5hbWUsIGluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpbml0aWFsVmFsdWVzID09PSB2b2lkIDApIHsgaW5pdGlhbFZhbHVlcyA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgZWwgPSBfdGhpcy5yZWZzLmVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbHMoJ3Rvb2xiYXItZ3JvdXAnKSArIFwiIC5cIiArIHBvcHVwTmFtZSk7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXRUb3RhbE9mZnNldChlbCwgY2xvc2VzdChlbCwgXCIuXCIgKyBjbHMoJ3Rvb2xiYXInKSkpLCBvZmZzZXRMZWZ0ID0gX2Eub2Zmc2V0TGVmdCwgb2Zmc2V0VG9wID0gX2Eub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY3JlYXRlUG9wdXBJbmZvKHBvcHVwTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBlbDogZWwsXG4gICAgICAgICAgICAgICAgICAgIHBvczogeyBsZWZ0OiBvZmZzZXRMZWZ0LCB0b3A6IGVsLm9mZnNldEhlaWdodCArIG9mZnNldFRvcCB9LFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWVzOiBpbml0aWFsVmFsdWVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFBvcHVwSW5mbyhpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhpZGVQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zaG93UG9wdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNob3dQb3B1cDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmV4ZWNDb21tYW5kID0gZnVuY3Rpb24gKGNvbW1hbmQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEVtaXR0ZXIgPSBfdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXI7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIuZW1pdCgnY29tbWFuZCcsIGNvbW1hbmQsIHBheWxvYWQpO1xuICAgICAgICAgICAgX3RoaXMuaGlkZVBvcHVwKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRhYnMgPSBbXG4gICAgICAgICAgICB7IG5hbWU6ICd3cml0ZScsIHRleHQ6ICdXcml0ZScgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ3ByZXZpZXcnLCB0ZXh0OiAnUHJldmlldycgfSxcbiAgICAgICAgXTtcbiAgICAgICAgX3RoaXMuaXRlbVdpZHRoTWFwID0ge307XG4gICAgICAgIF90aGlzLmluaXRpYWxJdGVtcyA9IGdyb3VwVG9vbGJhckl0ZW1zKHByb3BzLnRvb2xiYXJJdGVtcyB8fCBbXSwgX3RoaXMuaGlkZGVuU2Nyb2xsU3luYygpKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpdGVtczogX3RoaXMuaW5pdGlhbEl0ZW1zLFxuICAgICAgICAgICAgZHJvcGRvd25JdGVtczogW10sXG4gICAgICAgICAgICBzaG93UG9wdXA6IGZhbHNlLFxuICAgICAgICAgICAgcG9wdXBJbmZvOiB7fSxcbiAgICAgICAgICAgIGFjdGl2ZVRhYjogJ3dyaXRlJyxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudG9vbHRpcFJlZiA9IHsgY3VycmVudDogbnVsbCB9O1xuICAgICAgICBfdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBpbmRleChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVSZXNpemUoKTsgfSk7XG4gICAgICAgIF90aGlzLmFkZEV2ZW50KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVG9vbGJhci5wcm90b3R5cGUuaW5zZXJ0VG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAoaW5kZXhMaXN0LCBpdGVtKSB7XG4gICAgICAgIHZhciBncm91cEluZGV4ID0gaW5kZXhMaXN0Lmdyb3VwSW5kZXgsIGl0ZW1JbmRleCA9IGluZGV4TGlzdC5pdGVtSW5kZXg7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMuaW5pdGlhbEl0ZW1zW2dyb3VwSW5kZXhdO1xuICAgICAgICBpdGVtID0gY3JlYXRlVG9vbGJhckl0ZW1JbmZvKGl0ZW0pO1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwLnNwbGljZShpdGVtSW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsSXRlbXMucHVzaChbaXRlbV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5jbGFzc2lmeVRvb2xiYXJJdGVtcygpKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbW92ZVRvb2xiYXJJdGVtID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZm9yRWFjaEFycmF5XzEodGhpcy5pbml0aWFsSXRlbXMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3JFYWNoQXJyYXlfMShncm91cCwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKF90aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXZlbnRFbWl0dGVyID0gdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gdGhyb3R0bGVfMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZXNldCB0b29sYmFyIGl0ZW1zIHRvIHJlLWxheW91dCB0b29sYmFyIGl0ZW1zIHdpdGggZWFjaCBjbGllbnRXaWR0aFxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpdGVtczogX3RoaXMuaW5pdGlhbEl0ZW1zLCBkcm9wZG93bkl0ZW1zOiBbXSB9KTtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKF90aGlzLmNsYXNzaWZ5VG9vbGJhckl0ZW1zKCkpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdvcGVuUG9wdXAnLCB0aGlzLm9wZW5Qb3B1cCk7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5hcHBlbmRUb29sdGlwVG9Sb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9vbHRpcCA9IFwiPGRpdiBjbGFzcz1cXFwiXCIgKyBjbHMoJ3Rvb2x0aXAnKSArIFwiXFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImFycm93XFxcIj48L2Rpdj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0ZXh0XFxcIj48L3NwYW4+XFxuICAgICAgPC9kaXY+XCI7XG4gICAgICAgIHRoaXMudG9vbHRpcFJlZi5jdXJyZW50ID0gY3JlYXRlRWxlbWVudFdpdGgodG9vbHRpcCwgdGhpcy5yZWZzLmVsKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmhpZGRlblNjcm9sbFN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmVkaXRvclR5cGUgPT09ICd3eXNpd3lnJyB8fCB0aGlzLnByb3BzLnByZXZpZXdTdHlsZSA9PT0gJ3RhYic7XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5tb3ZlUHJldkl0ZW1Ub0Ryb3Bkb3duVG9vbGJhciA9IGZ1bmN0aW9uIChpdGVtSW5kZXgsIGl0ZW1zLCBncm91cCwgZHJvcGRvd25Hcm91cCkge1xuICAgICAgICB2YXIgbW92ZUl0ZW0gPSBmdW5jdGlvbiAodGFyZ2V0R3JvdXApIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGFyZ2V0R3JvdXAucG9wKCk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3duR3JvdXAucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGl0ZW1JbmRleCA+IDEpIHtcbiAgICAgICAgICAgIG1vdmVJdGVtKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2R3JvdXAgPSBsYXN0JDEoaXRlbXMpO1xuICAgICAgICAgICAgaWYgKHByZXZHcm91cCkge1xuICAgICAgICAgICAgICAgIG1vdmVJdGVtKHByZXZHcm91cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmNsYXNzaWZ5VG9vbGJhckl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgIHZhciBjbGllbnRXaWR0aCA9IHRoaXMucmVmcy5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSB0aGlzLnJlZnMuZWwucXVlcnlTZWxlY3RvcihcIi5cIiArIGNscygndG9vbGJhci1kaXZpZGVyJykpO1xuICAgICAgICB2YXIgZGl2aWRlcldpZHRoID0gZGl2aWRlciA/IGdldE91dGVyV2lkdGgoZGl2aWRlcikgOiAwO1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIGRyb3Bkb3duSXRlbXMgPSBbXTtcbiAgICAgICAgdmFyIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGluaXRpYWxHcm91cCwgZ3JvdXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gW107XG4gICAgICAgICAgICB2YXIgZHJvcGRvd25Hcm91cCA9IFtdO1xuICAgICAgICAgICAgaW5pdGlhbEdyb3VwLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGl0ZW1JbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBfdGhpcy5pdGVtV2lkdGhNYXBbaXRlbS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPiBjbGllbnRXaWR0aCAtIElOTElORV9QQURESU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbW92ZSB0aGUgcHJldiBpdGVtIHRvIGRyb3Bkb3duIHRvb2xiYXIgZm9yIHBsYWNpbmcgdGhlIG1vcmUgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubW92ZVByZXZJdGVtVG9Ecm9wZG93blRvb2xiYXIoaXRlbUluZGV4LCBpdGVtcywgZ3JvdXAsIGRyb3Bkb3duR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duR3JvdXAucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChncm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZXRHcm91cFN0YXRlKGdyb3VwKTtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcm9wZG93bkdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEdyb3VwU3RhdGUoZHJvcGRvd25Hcm91cCk7XG4gICAgICAgICAgICAgICAgZHJvcGRvd25JdGVtcy5wdXNoKGRyb3Bkb3duR3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGRpdmlkZXIgd2lkdGhcbiAgICAgICAgICAgIGlmIChncm91cEluZGV4IDwgX3RoaXMuc3RhdGUuaXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gZGl2aWRlcldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgaXRlbXM6IGl0ZW1zLCBkcm9wZG93bkl0ZW1zOiBkcm9wZG93bkl0ZW1zIH07XG4gICAgfTtcbiAgICBUb29sYmFyLnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wcmV2aWV3U3R5bGUgPT09ICd0YWInKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGFzc2lmeSB0b29sYmFyIGFuZCBkcm9wZG93biB0b29sYmFyIGFmdGVyIERPTSBoYXMgYmVlbiByZW5kZXJlZFxuICAgICAgICB0aGlzLnNldFN0YXRlKHRoaXMuY2xhc3NpZnlUb29sYmFySXRlbXMoKSk7XG4gICAgICAgIHRoaXMuYXBwZW5kVG9vbHRpcFRvUm9vdCgpO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5yZWZzLmVsKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLnVwZGF0ZWQgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGVkaXRvclR5cGUgPSBfYS5lZGl0b3JUeXBlLCBwcmV2aWV3U3R5bGUgPSBfYS5wcmV2aWV3U3R5bGUsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlcjtcbiAgICAgICAgdmFyIGNoYW5nZWRTdHlsZSA9IHByZXZpZXdTdHlsZSAhPT0gcHJldlByb3BzLnByZXZpZXdTdHlsZTtcbiAgICAgICAgdmFyIGNoYW5nZWRUeXBlID0gZWRpdG9yVHlwZSAhPT0gcHJldlByb3BzLmVkaXRvclR5cGU7XG4gICAgICAgIGlmIChjaGFuZ2VkU3R5bGUgfHwgY2hhbmdlZFR5cGUpIHtcbiAgICAgICAgICAgIC8vIHNob3cgb3IgaGlkZSBzY3JvbGxTeW5jIGJ1dHRvblxuICAgICAgICAgICAgdG9nZ2xlU2Nyb2xsU3luYyh0aGlzLmluaXRpYWxJdGVtcywgdGhpcy5oaWRkZW5TY3JvbGxTeW5jKCkpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5jbGFzc2lmeVRvb2xiYXJJdGVtcygpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRTdHlsZSB8fCAocHJldmlld1N0eWxlID09PSAndGFiJyAmJiBlZGl0b3JUeXBlID09PSAnbWFya2Rvd24nKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnKTtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZS5hY3RpdmVUYWIgPSAnd3JpdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLmJlZm9yZURlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICByZW1vdmVOb2RlJDEodGhpcy50b29sdGlwUmVmLmN1cnJlbnQpO1xuICAgIH07XG4gICAgVG9vbGJhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBwcmV2aWV3U3R5bGUgPSBfYS5wcmV2aWV3U3R5bGUsIGV2ZW50RW1pdHRlciA9IF9hLmV2ZW50RW1pdHRlciwgZWRpdG9yVHlwZSA9IF9hLmVkaXRvclR5cGU7XG4gICAgICAgIHZhciBfYiA9IHRoaXMuc3RhdGUsIHBvcHVwSW5mbyA9IF9iLnBvcHVwSW5mbywgc2hvd1BvcHVwID0gX2Iuc2hvd1BvcHVwLCBhY3RpdmVUYWIgPSBfYi5hY3RpdmVUYWIsIGl0ZW1zID0gX2IuaXRlbXMsIGRyb3Bkb3duSXRlbXMgPSBfYi5kcm9wZG93bkl0ZW1zO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlcixcbiAgICAgICAgICAgIHRvb2x0aXBSZWY6IHRoaXMudG9vbHRpcFJlZixcbiAgICAgICAgICAgIGRpc2FibGVkOiBlZGl0b3JUeXBlID09PSAnbWFya2Rvd24nICYmIHByZXZpZXdTdHlsZSA9PT0gJ3RhYicgJiYgYWN0aXZlVGFiID09PSAncHJldmlldycsXG4gICAgICAgICAgICBleGVjQ29tbWFuZDogdGhpcy5leGVjQ29tbWFuZCxcbiAgICAgICAgICAgIHNldFBvcHVwSW5mbzogdGhpcy5zZXRQb3B1cEluZm8sXG4gICAgICAgIH07XG4gICAgICAgIHZhciB0b29sYmFyU3R5bGUgPSBwcmV2aWV3U3R5bGUgPT09ICd0YWInID8geyBib3JkZXJUb3BMZWZ0UmFkaXVzOiAwIH0gOiBudWxsO1xuICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8yJDIgfHwgKHRlbXBsYXRlT2JqZWN0XzIkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHN0eWxlPVxcXCJkaXNwbGF5OiBcIiwgXCJcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIDxcIiwgXCIgdGFicz1cIiwgXCIgYWN0aXZlVGFiPVwiLCBcIiBvbkNsaWNrPVwiLCBcIiAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgc3R5bGU9XCIsIFwiXFxuICAgICAgICA+XFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgICAgaXRlbT1cIiwgXCJcXG4gICAgICAgICAgICBpdGVtcz1cIiwgXCJcXG4gICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICBpbmZvPVwiLCBcIlxcbiAgICAgICAgICBzaG93PVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIGhpZGVQb3B1cD1cIiwgXCJcXG4gICAgICAgICAgZXhlY0NvbW1hbmQ9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0sIFtcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+XFxuICAgICAgICA8ZGl2XFxuICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgIHN0eWxlPVxcXCJkaXNwbGF5OiBcIixcbiAgICAgICAgICAgIFwiXFxcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8XCIsIFwiIHRhYnM9XCIsIFwiIGFjdGl2ZVRhYj1cIiwgXCIgb25DbGljaz1cIiwgXCIgLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXFxcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIHN0eWxlPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICBcIixcbiAgICAgICAgICAgIFwiXFxuICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICBpdGVtPVwiLCBcIlxcbiAgICAgICAgICAgIGl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICAgIC4uLlwiLCBcIlxcbiAgICAgICAgICAvPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIGluZm89XCIsIFwiXFxuICAgICAgICAgIHNob3c9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgaGlkZVBvcHVwPVwiLCBcIlxcbiAgICAgICAgICBleGVjQ29tbWFuZD1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgPC9kaXY+XFxuICAgIFwiXSkpLCBjbHMoJ3Rvb2xiYXInKSwgY2xzKCdtZC10YWItY29udGFpbmVyJyksIGVkaXRvclR5cGUgPT09ICd3eXNpd3lnJyB8fCBwcmV2aWV3U3R5bGUgPT09ICd2ZXJ0aWNhbCdcbiAgICAgICAgICAgID8gJ25vbmUnXG4gICAgICAgICAgICA6ICdibG9jaycsIFRhYnMsIHRoaXMudGFicywgYWN0aXZlVGFiLCB0aGlzLnRvZ2dsZVRhYiwgY2xzKCdkZWZhdWx0VUktdG9vbGJhcicpLCBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIChfdGhpcy5yZWZzLmVsID0gZWwpOyB9LCB0b29sYmFyU3R5bGUsIGl0ZW1zLm1hcChmdW5jdGlvbiAoZ3JvdXAsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDMgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICAgICAgICBncm91cD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2aWRlcj1cIiwgXCJcXG4gICAgICAgICAgICAgICAgc2V0SXRlbVdpZHRoPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAuLi5cIiwgXCJcXG4gICAgICAgICAgICAgIC8+XFxuICAgICAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgICAgICAgZ3JvdXA9XCIsIFwiXFxuICAgICAgICAgICAgICAgIGhpZGRlbkRpdmlkZXI9XCIsIFwiXFxuICAgICAgICAgICAgICAgIHNldEl0ZW1XaWR0aD1cIiwgXCJcXG4gICAgICAgICAgICAgICAgLi4uXCIsIFwiXFxuICAgICAgICAgICAgICAvPlxcbiAgICAgICAgICAgIFwiXSkpLCBUb29sYmFyR3JvdXAsIGdyb3VwLCBpbmRleCA9PT0gaXRlbXMubGVuZ3RoIC0gMSB8fCAoKF9hID0gaXRlbXNbaW5kZXggKyAxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhpZGRlbiksIF90aGlzLnNldEl0ZW1XaWR0aCwgcHJvcHMpO1xuICAgICAgICB9KSwgRHJvcGRvd25Ub29sYmFyQnV0dG9uLCBjcmVhdGVUb29sYmFySXRlbUluZm8oJ21vcmUnKSwgZHJvcGRvd25JdGVtcywgcHJvcHMsIFBvcHVwLCBwb3B1cEluZm8sIHNob3dQb3B1cCwgZXZlbnRFbWl0dGVyLCB0aGlzLmhpZGVQb3B1cCwgdGhpcy5leGVjQ29tbWFuZCk7XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhcjtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQzLCB0ZW1wbGF0ZU9iamVjdF8yJDI7XG5cbnZhciBDb250ZXh0TWVudSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMShDb250ZXh0TWVudSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250ZXh0TWVudShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0KGV2LnRhcmdldCwgXCIuXCIgKyBjbHMoJ2NvbnRleHQtbWVudScpKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgcG9zOiBudWxsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHBvczogbnVsbCxcbiAgICAgICAgICAgIG1lbnVHcm91cHM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9wcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hLnBvcywgbWVudUdyb3VwcyA9IF9hLm1lbnVHcm91cHM7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHBvczogcG9zLCBtZW51R3JvdXBzOiBtZW51R3JvdXBzIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRleHRNZW51LnByb3RvdHlwZS5tb3VudGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tEb2N1bWVudCk7XG4gICAgfTtcbiAgICBDb250ZXh0TWVudS5wcm90b3R5cGUuYmVmb3JlRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrRG9jdW1lbnQpO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLmdldE1lbnVHcm91cEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBwb3MgPSBfYS5wb3MsIG1lbnVHcm91cHMgPSBfYS5tZW51R3JvdXBzO1xuICAgICAgICByZXR1cm4gcG9zXG4gICAgICAgICAgICA/IG1lbnVHcm91cHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lbnVJdGVtID0gW107XG4gICAgICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gX2EubGFiZWwsIF9iID0gX2EuY2xhc3NOYW1lLCBjbGFzc05hbWUgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgb25DbGljayA9IF9hLm9uQ2xpY2s7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwb3M6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG1lbnVJdGVtLnB1c2goaHRtbCh0ZW1wbGF0ZU9iamVjdF8xJDIgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICAgICAgICA8bGlcXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPVwiLCBcIlxcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJtZW51LWl0ZW1cIiwgXCJcXFwiXFxuICAgICAgICAgICAgICAgICAgYXJpYS1yb2xlPVxcXCJtZW51aXRlbVxcXCJcXG4gICAgICAgICAgICAgICAgPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJcIiwgXCJcXFwiPlwiLCBcIjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgICAgICAgIDxsaVxcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9XCIsIFwiXFxuICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcIm1lbnUtaXRlbVwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgICAgICBhcmlhLXJvbGU9XFxcIm1lbnVpdGVtXFxcIlxcbiAgICAgICAgICAgICAgICA+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIlwiLCBcIlxcXCI+XCIsIFwiPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgICAgXCJdKSksIGhhbmRsZUNsaWNrLCBkaXNhYmxlZCA/ICcgZGlzYWJsZWQnIDogJycsIGNsYXNzTmFtZSwgbGFiZWwpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhY2MucHVzaChodG1sKHRlbXBsYXRlT2JqZWN0XzIkMSB8fCAodGVtcGxhdGVPYmplY3RfMiQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiPHVsIGNsYXNzPVxcXCJtZW51LWdyb3VwXFxcIj5cXG4gICAgICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICAgIDwvdWw+XCJdLCBbXCI8dWwgY2xhc3M9XFxcIm1lbnUtZ3JvdXBcXFwiPlxcbiAgICAgICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgICAgPC91bD5cIl0pKSwgbWVudUl0ZW0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICAgICA6IFtdO1xuICAgIH07XG4gICAgQ29udGV4dE1lbnUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gX19hc3NpZ24kMSh7IGRpc3BsYXk6IHRoaXMuc3RhdGUucG9zID8gJ2Jsb2NrJyA6ICdub25lJyB9LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIHJldHVybiBodG1sKHRlbXBsYXRlT2JqZWN0XzMgfHwgKHRlbXBsYXRlT2JqZWN0XzMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiIHN0eWxlPVwiLCBcIiBhcmlhLXJvbGU9XFxcIm1lbnVcXFwiPlxcbiAgICAgIFwiLCBcIlxcbiAgICA8L2Rpdj5cIl0sIFtcIjxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCIgc3R5bGU9XCIsIFwiIGFyaWEtcm9sZT1cXFwibWVudVxcXCI+XFxuICAgICAgXCIsIFwiXFxuICAgIDwvZGl2PlwiXSkpLCBjbHMoJ2NvbnRleHQtbWVudScpLCBzdHlsZSwgdGhpcy5nZXRNZW51R3JvdXBFbGVtZW50cygpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0TWVudTtcbn0oQ29tcG9uZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQyLCB0ZW1wbGF0ZU9iamVjdF8yJDEsIHRlbXBsYXRlT2JqZWN0XzM7XG5cbnZhciBMYXlvdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoTGF5b3V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExheW91dChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2hhbmdlTW9kZSA9IGZ1bmN0aW9uIChlZGl0b3JUeXBlKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yVHlwZSAhPT0gX3RoaXMuc3RhdGUuZWRpdG9yVHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZWRpdG9yVHlwZTogZWRpdG9yVHlwZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2hhbmdlUHJldmlld1N0eWxlID0gZnVuY3Rpb24gKHByZXZpZXdTdHlsZSkge1xuICAgICAgICAgICAgaWYgKHByZXZpZXdTdHlsZSAhPT0gX3RoaXMuc3RhdGUucHJldmlld1N0eWxlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2aWV3U3R5bGU6IHByZXZpZXdTdHlsZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaGlkZTogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaGlkZTogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlZGl0b3JUeXBlID0gcHJvcHMuZWRpdG9yVHlwZSwgcHJldmlld1N0eWxlID0gcHJvcHMucHJldmlld1N0eWxlO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGVkaXRvclR5cGU6IGVkaXRvclR5cGUsXG4gICAgICAgICAgICBwcmV2aWV3U3R5bGU6IHByZXZpZXdTdHlsZSxcbiAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5hZGRFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExheW91dC5wcm90b3R5cGUubW91bnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcy5zbG90cywgd3dFZGl0b3IgPSBfYS53d0VkaXRvciwgbWRFZGl0b3IgPSBfYS5tZEVkaXRvciwgbWRQcmV2aWV3ID0gX2EubWRQcmV2aWV3O1xuICAgICAgICB0aGlzLnJlZnMud3dDb250YWluZXIuYXBwZW5kQ2hpbGQod3dFZGl0b3IpO1xuICAgICAgICB0aGlzLnJlZnMubWRDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmJlZ2luJywgbWRFZGl0b3IpO1xuICAgICAgICB0aGlzLnJlZnMubWRDb250YWluZXIuYXBwZW5kQ2hpbGQobWRQcmV2aWV3KTtcbiAgICB9O1xuICAgIExheW91dC5wcm90b3R5cGUuaW5zZXJ0VG9vbGJhckl0ZW0gPSBmdW5jdGlvbiAoaW5kZXhMaXN0LCBpdGVtKSB7XG4gICAgICAgIHRoaXMudG9vbGJhci5pbnNlcnRUb29sYmFySXRlbShpbmRleExpc3QsIGl0ZW0pO1xuICAgIH07XG4gICAgTGF5b3V0LnByb3RvdHlwZS5yZW1vdmVUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHRoaXMudG9vbGJhci5yZW1vdmVUb29sYmFySXRlbShuYW1lKTtcbiAgICB9O1xuICAgIExheW91dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBldmVudEVtaXR0ZXIgPSBfYS5ldmVudEVtaXR0ZXIsIGhpZGVNb2RlU3dpdGNoID0gX2EuaGlkZU1vZGVTd2l0Y2gsIHRvb2xiYXJJdGVtcyA9IF9hLnRvb2xiYXJJdGVtcywgdGhlbWUgPSBfYS50aGVtZTtcbiAgICAgICAgdmFyIF9iID0gdGhpcy5zdGF0ZSwgaGlkZSA9IF9iLmhpZGUsIHByZXZpZXdTdHlsZSA9IF9iLnByZXZpZXdTdHlsZSwgZWRpdG9yVHlwZSA9IF9iLmVkaXRvclR5cGU7XG4gICAgICAgIHZhciBkaXNwbGF5Q2xhc3NOYW1lID0gaGlkZSA/ICcgaGlkZGVuJyA6ICcnO1xuICAgICAgICB2YXIgZWRpdG9yVHlwZUNsYXNzTmFtZSA9IGNscyhlZGl0b3JUeXBlID09PSAnbWFya2Rvd24nID8gJ21kLW1vZGUnIDogJ3d3LW1vZGUnKTtcbiAgICAgICAgdmFyIHByZXZpZXdDbGFzc05hbWUgPSBjbHMoJ21kJykgKyBcIi1cIiArIHByZXZpZXdTdHlsZSArIFwiLXN0eWxlXCI7XG4gICAgICAgIHZhciB0aGVtZUNsYXNzTmFtZSA9IGNscyhbdGhlbWUgIT09ICdsaWdodCcsIHRoZW1lICsgXCIgXCJdKTtcbiAgICAgICAgcmV0dXJuIGh0bWwodGVtcGxhdGVPYmplY3RfMiB8fCAodGVtcGxhdGVPYmplY3RfMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgIDxkaXZcXG4gICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcIiwgXCJcIiwgXCJcXFwiXFxuICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgPlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgcHJldmlld1N0eWxlPVwiLCBcIlxcbiAgICAgICAgICB0b29sYmFySXRlbXM9XCIsIFwiXFxuICAgICAgICAgIGVkaXRvclR5cGU9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgICAgPGRpdlxcbiAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCIgXCIsIFwiXFxcIlxcbiAgICAgICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIlwiLCBcIlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdlxcbiAgICAgICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgICAvPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCIsIFwiXFxuICAgICAgICA8XCIsIFwiIGV2ZW50RW1pdHRlcj1cIiwgXCIgLz5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCJdLCBbXCJcXG4gICAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwiXCIsIFwiXCIsIFwiXCIsIFwiXFxcIlxcbiAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgID5cXG4gICAgICAgIDxcIiwgXCJcXG4gICAgICAgICAgcmVmPVwiLCBcIlxcbiAgICAgICAgICBldmVudEVtaXR0ZXI9XCIsIFwiXFxuICAgICAgICAgIHByZXZpZXdTdHlsZT1cIiwgXCJcXG4gICAgICAgICAgdG9vbGJhckl0ZW1zPVwiLCBcIlxcbiAgICAgICAgICBlZGl0b3JUeXBlPVwiLCBcIlxcbiAgICAgICAgLz5cXG4gICAgICAgIDxkaXZcXG4gICAgICAgICAgY2xhc3M9XFxcIlwiLCBcIiBcIiwgXCJcXFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgID5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiXCIsIFwiXFxcIj5cXG4gICAgICAgICAgICA8ZGl2XFxuICAgICAgICAgICAgICBjbGFzcz1cXFwiXCIsIFwiIFwiLCBcIlxcXCJcXG4gICAgICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJcIiwgXCJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXZcXG4gICAgICAgICAgICAgIGNsYXNzPVxcXCJcIiwgXCJcXFwiXFxuICAgICAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgICAgLz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiLFxuICAgICAgICAgICAgXCJcXG4gICAgICAgIDxcIiwgXCIgZXZlbnRFbWl0dGVyPVwiLCBcIiAvPlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIl0pKSwgdGhlbWVDbGFzc05hbWUsIGNscygnZGVmYXVsdFVJJyksIGRpc3BsYXlDbGFzc05hbWUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMuZWwgPSBlbCk7IH0sIFRvb2xiYXIsIGZ1bmN0aW9uICh0b29sYmFyKSB7IHJldHVybiAoX3RoaXMudG9vbGJhciA9IHRvb2xiYXIpOyB9LCBldmVudEVtaXR0ZXIsIHByZXZpZXdTdHlsZSwgdG9vbGJhckl0ZW1zLCBlZGl0b3JUeXBlLCBjbHMoJ21haW4nKSwgZWRpdG9yVHlwZUNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy5lZGl0b3JTZWN0aW9uID0gZWwpOyB9LCBjbHMoJ21haW4tY29udGFpbmVyJyksIGNscygnbWQtY29udGFpbmVyJyksIHByZXZpZXdDbGFzc05hbWUsIGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKF90aGlzLnJlZnMubWRDb250YWluZXIgPSBlbCk7IH0sIGNscygnbWQtc3BsaXR0ZXInKSwgY2xzKCd3dy1jb250YWluZXInKSwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoX3RoaXMucmVmcy53d0NvbnRhaW5lciA9IGVsKTsgfSwgIWhpZGVNb2RlU3dpdGNoICYmIGh0bWwodGVtcGxhdGVPYmplY3RfMSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCI8XCIsIFwiIGV2ZW50RW1pdHRlcj1cIiwgXCIgZWRpdG9yVHlwZT1cIiwgXCIgLz5cIl0sIFtcIjxcIiwgXCIgZXZlbnRFbWl0dGVyPVwiLCBcIiBlZGl0b3JUeXBlPVwiLCBcIiAvPlwiXSkpLCBTd2l0Y2gsIGV2ZW50RW1pdHRlciwgZWRpdG9yVHlwZSksIENvbnRleHRNZW51LCBldmVudEVtaXR0ZXIpO1xuICAgIH07XG4gICAgTGF5b3V0LnByb3RvdHlwZS5hZGRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50RW1pdHRlciA9IHRoaXMucHJvcHMuZXZlbnRFbWl0dGVyO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdoaWRlJywgdGhpcy5oaWRlKTtcbiAgICAgICAgZXZlbnRFbWl0dGVyLmxpc3Rlbignc2hvdycsIHRoaXMuc2hvdyk7XG4gICAgICAgIGV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZU1vZGUnLCB0aGlzLmNoYW5nZU1vZGUpO1xuICAgICAgICBldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3U3R5bGUnLCB0aGlzLmNoYW5nZVByZXZpZXdTdHlsZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGF5b3V0O1xufShDb21wb25lbnQpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDEsIHRlbXBsYXRlT2JqZWN0XzI7XG5cbi8qKlxuICogVG9hc3RVSSBFZGl0b3JcbiAqIEBleHRlbmRzIFRvYXN0VUlFZGl0b3JDb3JlXG4gKi9cbnZhciBUb2FzdFVJRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxKFRvYXN0VUlFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9hc3RVSUVkaXRvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgdmFyIGxheW91dENvbXA7XG4gICAgICAgIHZhciBkZXN0cm95ID0gcmVuZGVyKF90aGlzLm9wdGlvbnMuZWwsIGh0bWwodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgPFwiLCBcIlxcbiAgICAgICAgICByZWY9XCIsIFwiXFxuICAgICAgICAgIGV2ZW50RW1pdHRlcj1cIiwgXCJcXG4gICAgICAgICAgc2xvdHM9XCIsIFwiXFxuICAgICAgICAgIGhpZGVNb2RlU3dpdGNoPVwiLCBcIlxcbiAgICAgICAgICB0b29sYmFySXRlbXM9XCIsIFwiXFxuICAgICAgICAgIHByZXZpZXdTdHlsZT1cIiwgXCJcXG4gICAgICAgICAgZWRpdG9yVHlwZT1cIiwgXCJcXG4gICAgICAgICAgdGhlbWU9XCIsIFwiXFxuICAgICAgICAvPlxcbiAgICAgIFwiXSwgW1wiXFxuICAgICAgICA8XCIsIFwiXFxuICAgICAgICAgIHJlZj1cIiwgXCJcXG4gICAgICAgICAgZXZlbnRFbWl0dGVyPVwiLCBcIlxcbiAgICAgICAgICBzbG90cz1cIiwgXCJcXG4gICAgICAgICAgaGlkZU1vZGVTd2l0Y2g9XCIsIFwiXFxuICAgICAgICAgIHRvb2xiYXJJdGVtcz1cIiwgXCJcXG4gICAgICAgICAgcHJldmlld1N0eWxlPVwiLCBcIlxcbiAgICAgICAgICBlZGl0b3JUeXBlPVwiLCBcIlxcbiAgICAgICAgICB0aGVtZT1cIiwgXCJcXG4gICAgICAgIC8+XFxuICAgICAgXCJdKSksIExheW91dCwgZnVuY3Rpb24gKGxheW91dCkgeyByZXR1cm4gKGxheW91dENvbXAgPSBsYXlvdXQpOyB9LCBfdGhpcy5ldmVudEVtaXR0ZXIsIF90aGlzLmdldEVkaXRvckVsZW1lbnRzKCksIF90aGlzLm9wdGlvbnMuaGlkZU1vZGVTd2l0Y2gsIF90aGlzLm9wdGlvbnMudG9vbGJhckl0ZW1zLCBfdGhpcy5vcHRpb25zLnByZXZpZXdTdHlsZSwgX3RoaXMub3B0aW9ucy5pbml0aWFsRWRpdFR5cGUsIF90aGlzLm9wdGlvbnMudGhlbWUpKTtcbiAgICAgICAgX3RoaXMuc2V0TWluSGVpZ2h0KF90aGlzLm9wdGlvbnMubWluSGVpZ2h0KTtcbiAgICAgICAgX3RoaXMuc2V0SGVpZ2h0KF90aGlzLm9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgX3RoaXMuZGVmYXVsdFVJID0ge1xuICAgICAgICAgICAgaW5zZXJ0VG9vbGJhckl0ZW06IGxheW91dENvbXAuaW5zZXJ0VG9vbGJhckl0ZW0uYmluZChsYXlvdXRDb21wKSxcbiAgICAgICAgICAgIHJlbW92ZVRvb2xiYXJJdGVtOiBsYXlvdXRDb21wLnJlbW92ZVRvb2xiYXJJdGVtLmJpbmQobGF5b3V0Q29tcCksXG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgICAgICB9O1xuICAgICAgICAoX2EgPSBfdGhpcy5wbHVnaW5JbmZvLnRvb2xiYXJJdGVtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKHRvb2xiYXJJdGVtKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBJbmRleCA9IHRvb2xiYXJJdGVtLmdyb3VwSW5kZXgsIGl0ZW1JbmRleCA9IHRvb2xiYXJJdGVtLml0ZW1JbmRleCwgaXRlbSA9IHRvb2xiYXJJdGVtLml0ZW07XG4gICAgICAgICAgICBfdGhpcy5kZWZhdWx0VUkuaW5zZXJ0VG9vbGJhckl0ZW0oeyBncm91cEluZGV4OiBncm91cEluZGV4LCBpdGVtSW5kZXg6IGl0ZW1JbmRleCB9LCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdsb2FkVUknLCBfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgZm9yIEVkaXRvclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbiBmb3IgaW5pdGlhbGl6ZSBUVUlFZGl0b3JcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUb2FzdFVJRWRpdG9yIG9yIFRvYXN0VUlFZGl0b3JWaWV3ZXJcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yLmZhY3RvcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy52aWV3ZXIgPyBuZXcgVG9hc3RVSUVkaXRvclZpZXdlcihvcHRpb25zKSA6IG5ldyBUb2FzdFVJRWRpdG9yKG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYWRkIHRvb2xiYXIgaXRlbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbmRleEluZm8gZ3JvdXAgaW5kZXggYW5kIGl0ZW0gaW5kZXggb2YgdGhlIHRvb2xiYXIgaXRlbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaXRlbSB0b29sYmFyIGl0ZW1cbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yLnByb3RvdHlwZS5pbnNlcnRUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChpbmRleEluZm8sIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0VUkuaW5zZXJ0VG9vbGJhckl0ZW0oaW5kZXhJbmZvLCBpdGVtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0b29sYmFyIGl0ZW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbU5hbWUgdG9vbGJhciBpdGVtIG5hbWVcbiAgICAgKi9cbiAgICBUb2FzdFVJRWRpdG9yLnByb3RvdHlwZS5yZW1vdmVUb29sYmFySXRlbSA9IGZ1bmN0aW9uIChpdGVtTmFtZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRVSS5yZW1vdmVUb29sYmFySXRlbShpdGVtTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IFRVSUVkaXRvciBmcm9tIGRvY3VtZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFVJLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdFVJRWRpdG9yO1xufShUb2FzdFVJRWRpdG9yQ29yZSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBJMThOIGZvciBFbmdsaXNoXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuVG9hc3RVSUVkaXRvckNvcmUuc2V0TGFuZ3VhZ2UoWydlbicsICdlbi1VUyddLCB7XG4gICAgTWFya2Rvd246ICdNYXJrZG93bicsXG4gICAgV1lTSVdZRzogJ1dZU0lXWUcnLFxuICAgIFdyaXRlOiAnV3JpdGUnLFxuICAgIFByZXZpZXc6ICdQcmV2aWV3JyxcbiAgICBIZWFkaW5nczogJ0hlYWRpbmdzJyxcbiAgICBQYXJhZ3JhcGg6ICdQYXJhZ3JhcGgnLFxuICAgIEJvbGQ6ICdCb2xkJyxcbiAgICBJdGFsaWM6ICdJdGFsaWMnLFxuICAgIFN0cmlrZTogJ1N0cmlrZScsXG4gICAgQ29kZTogJ0lubGluZSBjb2RlJyxcbiAgICBMaW5lOiAnTGluZScsXG4gICAgQmxvY2txdW90ZTogJ0Jsb2NrcXVvdGUnLFxuICAgICdVbm9yZGVyZWQgbGlzdCc6ICdVbm9yZGVyZWQgbGlzdCcsXG4gICAgJ09yZGVyZWQgbGlzdCc6ICdPcmRlcmVkIGxpc3QnLFxuICAgIFRhc2s6ICdUYXNrJyxcbiAgICBJbmRlbnQ6ICdJbmRlbnQnLFxuICAgIE91dGRlbnQ6ICdPdXRkZW50JyxcbiAgICAnSW5zZXJ0IGxpbmsnOiAnSW5zZXJ0IGxpbmsnLFxuICAgICdJbnNlcnQgQ29kZUJsb2NrJzogJ0luc2VydCBjb2RlQmxvY2snLFxuICAgICdJbnNlcnQgdGFibGUnOiAnSW5zZXJ0IHRhYmxlJyxcbiAgICAnSW5zZXJ0IGltYWdlJzogJ0luc2VydCBpbWFnZScsXG4gICAgSGVhZGluZzogJ0hlYWRpbmcnLFxuICAgICdJbWFnZSBVUkwnOiAnSW1hZ2UgVVJMJyxcbiAgICAnU2VsZWN0IGltYWdlIGZpbGUnOiAnU2VsZWN0IGltYWdlIGZpbGUnLFxuICAgICdDaG9vc2UgYSBmaWxlJzogJ0Nob29zZSBhIGZpbGUnLFxuICAgICdObyBmaWxlJzogJ05vIGZpbGUnLFxuICAgIERlc2NyaXB0aW9uOiAnRGVzY3JpcHRpb24nLFxuICAgIE9LOiAnT0snLFxuICAgIE1vcmU6ICdNb3JlJyxcbiAgICBDYW5jZWw6ICdDYW5jZWwnLFxuICAgIEZpbGU6ICdGaWxlJyxcbiAgICBVUkw6ICdVUkwnLFxuICAgICdMaW5rIHRleHQnOiAnTGluayB0ZXh0JyxcbiAgICAnQWRkIHJvdyB0byB1cCc6ICdBZGQgcm93IHRvIHVwJyxcbiAgICAnQWRkIHJvdyB0byBkb3duJzogJ0FkZCByb3cgdG8gZG93bicsXG4gICAgJ0FkZCBjb2x1bW4gdG8gbGVmdCc6ICdBZGQgY29sdW1uIHRvIGxlZnQnLFxuICAgICdBZGQgY29sdW1uIHRvIHJpZ2h0JzogJ0FkZCBjb2x1bW4gdG8gcmlnaHQnLFxuICAgICdSZW1vdmUgcm93JzogJ1JlbW92ZSByb3cnLFxuICAgICdSZW1vdmUgY29sdW1uJzogJ1JlbW92ZSBjb2x1bW4nLFxuICAgICdBbGlnbiBjb2x1bW4gdG8gbGVmdCc6ICdBbGlnbiBjb2x1bW4gdG8gbGVmdCcsXG4gICAgJ0FsaWduIGNvbHVtbiB0byBjZW50ZXInOiAnQWxpZ24gY29sdW1uIHRvIGNlbnRlcicsXG4gICAgJ0FsaWduIGNvbHVtbiB0byByaWdodCc6ICdBbGlnbiBjb2x1bW4gdG8gcmlnaHQnLFxuICAgICdSZW1vdmUgdGFibGUnOiAnUmVtb3ZlIHRhYmxlJyxcbiAgICAnV291bGQgeW91IGxpa2UgdG8gcGFzdGUgYXMgdGFibGU/JzogJ1dvdWxkIHlvdSBsaWtlIHRvIHBhc3RlIGFzIHRhYmxlPycsXG4gICAgJ1RleHQgY29sb3InOiAnVGV4dCBjb2xvcicsXG4gICAgJ0F1dG8gc2Nyb2xsIGVuYWJsZWQnOiAnQXV0byBzY3JvbGwgZW5hYmxlZCcsXG4gICAgJ0F1dG8gc2Nyb2xsIGRpc2FibGVkJzogJ0F1dG8gc2Nyb2xsIGRpc2FibGVkJyxcbiAgICAnQ2hvb3NlIGxhbmd1YWdlJzogJ0Nob29zZSBsYW5ndWFnZScsXG59KTtcblxuZXhwb3J0IHsgVG9hc3RVSUVkaXRvciBhcyBFZGl0b3IsIFRvYXN0VUlFZGl0b3JDb3JlIGFzIEVkaXRvckNvcmUsIFRvYXN0VUlFZGl0b3IgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * @toast-ui/editor\n * @version 3.2.2 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! prosemirror-inputrules */ \"(ssr)/./node_modules/prosemirror-inputrules/dist/index.cjs\"), __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.cjs\"), __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.cjs\"), __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.cjs\"), __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.cjs\"));\n\telse {}\n})(self, function(__WEBPACK_EXTERNAL_MODULE__479__, __WEBPACK_EXTERNAL_MODULE__481__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__814__, __WEBPACK_EXTERNAL_MODULE__311__) {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 368:\n/***/ (function(module) {\n\n/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */\n\n(function (global, factory) {\n    true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.3.3';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment,\n        getElementsByTagName = _document.getElementsByTagName;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = null;\n    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n\n    /* Parsing of strict XHTML documents */\n    var PARSER_MEDIA_TYPE = void 0;\n    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    var transformCaseFunc = void 0;\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n      PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n\n      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {\n        return x;\n      } : stringToLowerCase;\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      // We void attribute values for unremovable \"is\"\" attributes\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = transformCaseFunc(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Mitigate a problem with templates inside select */\n      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = transformCaseFunc(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = transformCaseFunc(currentNode.nodeName);\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = transformCaseFunc(tag);\n      var lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n/***/ }),\n\n/***/ 928:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_57109__) {\n\n\"use strict\";\n/* eslint-disable complexity */\n/**\n * @fileoverview Returns the first index at which a given element can be found in the array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_57109__(322);\n\n/**\n * @module array\n */\n\n/**\n * Returns the first index at which a given element can be found in the array\n * from start index(default 0), or -1 if it is not present.\n * It compares searchElement to elements of the Array using strict equality\n * (the same method used by the ===, or triple-equals, operator).\n * @param {*} searchElement Element to locate in the array\n * @param {Array} array Array that will be traversed.\n * @param {number} startIndex Start index in array for searching (default 0)\n * @returns {number} the First index at which a given element, or -1 if it is not present\n * @memberof module:array\n * @example\n * // ES6\n * import inArray from 'tui-code-snippet/array/inArray';\n * \n * // CommonJS\n * const inArray = require('tui-code-snippet/array/inArray');\n *\n * const arr = ['one', 'two', 'three', 'four'];\n * const idx1 = inArray('one', arr, 3); // -1\n * const idx2 = inArray('one', arr); // 0\n */\nfunction inArray(searchElement, array, startIndex) {\n  var i;\n  var length;\n  startIndex = startIndex || 0;\n\n  if (!isArray(array)) {\n    return -1;\n  }\n\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf.call(array, searchElement, startIndex);\n  }\n\n  length = array.length;\n  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {\n    if (array[i] === searchElement) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nmodule.exports = inArray;\n\n\n/***/ }),\n\n/***/ 690:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_58838__) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_58838__(322);\nvar forEachArray = __nested_webpack_require_58838__(893);\nvar forEachOwnProperties = __nested_webpack_require_58838__(956);\n\n/**\n * @module collection\n */\n\n/**\n * Execute the provided callback once for each property of object(or element of array) which actually exist.\n * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property(or The value of the element)\n *  2) The name of the property(or The index of the element)\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEach from 'tui-code-snippet/collection/forEach'; \n * \n * // CommonJS\n * const forEach = require('tui-code-snippet/collection/forEach'); \n *\n * let sum = 0;\n *\n * forEach([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n *\n * // In case of Array-like object\n * const array = Array.prototype.slice.call(arrayLike); // change to array\n * forEach(array, function(value){\n *   sum += value;\n * });\n */\nfunction forEach(obj, iteratee, context) {\n  if (isArray(obj)) {\n    forEachArray(obj, iteratee, context);\n  } else {\n    forEachOwnProperties(obj, iteratee, context);\n  }\n}\n\nmodule.exports = forEach;\n\n\n/***/ }),\n\n/***/ 893:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Execute the provided callback once for each element present\n * in the array(or Array-like object) in ascending order.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the element\n *  2) The index of the element\n *  3) The array(or Array-like object) being traversed\n * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed\n * @param {function} iteratee Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachArray from 'tui-code-snippet/collection/forEachArray';\n * \n * // CommonJS\n * const forEachArray = require('tui-code-snippet/collection/forEachArray'); \n *\n * let sum = 0;\n *\n * forEachArray([1,2,3], function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachArray(arr, iteratee, context) {\n  var index = 0;\n  var len = arr.length;\n\n  context = context || null;\n\n  for (; index < len; index += 1) {\n    if (iteratee.call(context, arr[index], index, arr) === false) {\n      break;\n    }\n  }\n}\n\nmodule.exports = forEachArray;\n\n\n/***/ }),\n\n/***/ 956:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Execute the provided callback once for each property of object which actually exist.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Execute the provided callback once for each property of object which actually exist.\n * If the callback function returns false, the loop will be stopped.\n * Callback function(iteratee) is invoked with three arguments:\n *  1) The value of the property\n *  2) The name of the property\n *  3) The object being traversed\n * @param {Object} obj The object that will be traversed\n * @param {function} iteratee  Callback function\n * @param {Object} [context] Context(this) of callback function\n * @memberof module:collection\n * @example\n * // ES6\n * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';\n * \n * // CommonJS\n * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); \n *\n * let sum = 0;\n *\n * forEachOwnProperties({a:1,b:2,c:3}, function(value){\n *   sum += value;\n * });\n * alert(sum); // 6\n */\nfunction forEachOwnProperties(obj, iteratee, context) {\n  var key;\n\n  context = context || null;\n\n  for (key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      if (iteratee.call(context, obj[key], key, obj) === false) {\n        break;\n      }\n    }\n  }\n}\n\nmodule.exports = forEachOwnProperties;\n\n\n/***/ }),\n\n/***/ 990:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_63561__) {\n\n\"use strict\";\n/**\n * @fileoverview Transform the Array-like object to Array.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachArray = __nested_webpack_require_63561__(893);\n\n/**\n * Transform the Array-like object to Array.\n * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.\n * @param {*} arrayLike Array-like object\n * @returns {Array} Array\n * @memberof module:collection\n * @example\n * // ES6\n * import toArray from 'tui-code-snippet/collection/toArray'; \n * \n * // CommonJS\n * const toArray = require('tui-code-snippet/collection/toArray'); \n *\n * const arrayLike = {\n *   0: 'one',\n *   1: 'two',\n *   2: 'three',\n *   3: 'four',\n *   length: 4\n * };\n * const result = toArray(arrayLike);\n *\n * alert(result instanceof Array); // true\n * alert(result); // one,two,three,four\n */\nfunction toArray(arrayLike) {\n  var arr;\n  try {\n    arr = Array.prototype.slice.call(arrayLike);\n  } catch (e) {\n    arr = [];\n    forEachArray(arrayLike, function(value) {\n      arr.push(value);\n    });\n  }\n\n  return arr;\n}\n\nmodule.exports = toArray;\n\n\n/***/ }),\n\n/***/ 755:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Get event collection for specific HTML element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} type - event type\n * @returns {array}\n * @private\n */\nfunction safeEvent(element, type) {\n  var events = element[EVENT_KEY];\n  var handlers;\n\n  if (!events) {\n    events = element[EVENT_KEY] = {};\n  }\n\n  handlers = events[type];\n  if (!handlers) {\n    handlers = events[type] = [];\n  }\n\n  return handlers;\n}\n\nmodule.exports = safeEvent;\n\n\n/***/ }),\n\n/***/ 349:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_65445__) {\n\n\"use strict\";\n/**\n * @fileoverview Unbind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_65445__(758);\nvar forEach = __nested_webpack_require_65445__(690);\n\nvar safeEvent = __nested_webpack_require_65445__(755);\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {function} [handler] - handler function\n * @memberof module:domEvent\n * @example\n * // Following the example of domEvent#on\n * \n * // Unbind one event from an element.\n * off(div, 'click', toggle);\n * \n * // Unbind multiple events with a same handler from multiple elements at once.\n * // Use event names splitted by a space.\n * off(element, 'mouseenter mouseleave', changeColor);\n * \n * // Unbind multiple events with different handlers from an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * off(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Unbind events without handlers.\n * off(div, 'drag');\n */\nfunction off(element, types, handler) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      unbindEvent(element, type, handler);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    unbindEvent(element, type, func);\n  });\n}\n\n/**\n * Unbind DOM events\n * If a handler function is not passed, remove all events of that type.\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} [handler] - handler function\n * @private\n */\nfunction unbindEvent(element, type, handler) {\n  var events = safeEvent(element, type);\n  var index;\n\n  if (!handler) {\n    forEach(events, function(item) {\n      removeHandler(element, type, item.wrappedHandler);\n    });\n    events.splice(0, events.length);\n  } else {\n    forEach(events, function(item, idx) {\n      if (handler === item.handler) {\n        removeHandler(element, type, item.wrappedHandler);\n        index = idx;\n\n        return false;\n      }\n\n      return true;\n    });\n    events.splice(index, 1);\n  }\n}\n\n/**\n * Remove an event handler\n * @param {HTMLElement} element - An element to remove an event\n * @param {string} type - event type\n * @param {function} handler - event handler\n * @private\n */\nfunction removeHandler(element, type, handler) {\n  if ('removeEventListener' in element) {\n    element.removeEventListener(type, handler);\n  } else if ('detachEvent' in element) {\n    element.detachEvent('on' + type, handler);\n  }\n}\n\nmodule.exports = off;\n\n\n/***/ }),\n\n/***/ 348:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_68232__) {\n\n\"use strict\";\n/**\n * @fileoverview Bind DOM events\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_68232__(758);\nvar forEach = __nested_webpack_require_68232__(690);\n\nvar safeEvent = __nested_webpack_require_68232__(755);\n\n/**\n * Bind DOM events.\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @memberof module:domEvent\n * @example\n * const div = document.querySelector('div');\n * \n * // Bind one event to an element.\n * on(div, 'click', toggle);\n * \n * // Bind multiple events with a same handler to multiple elements at once.\n * // Use event names splitted by a space.\n * on(div, 'mouseenter mouseleave', changeColor);\n * \n * // Bind multiple events with different handlers to an element at once.\n * // Use an object which of key is an event name and value is a handler function.\n * on(div, {\n *   keydown: highlight,\n *   keyup: dehighlight\n * });\n * \n * // Set a context for handler method.\n * const name = 'global';\n * const repository = {name: 'CodeSnippet'};\n * on(div, 'drag', function() {\n *   console.log(this.name);\n * }, repository);\n * // Result when you drag a div: \"CodeSnippet\"\n */\nfunction on(element, types, handler, context) {\n  if (isString(types)) {\n    forEach(types.split(/\\s+/g), function(type) {\n      bindEvent(element, type, handler, context);\n    });\n\n    return;\n  }\n\n  forEach(types, function(func, type) {\n    bindEvent(element, type, func, handler);\n  });\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler method\n * @param {object} [context] context - context for handler method.\n * @private\n */\nfunction bindEvent(element, type, handler, context) {\n  /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n  function eventHandler(e) {\n    handler.call(context || element, e || window.event);\n  }\n\n  if ('addEventListener' in element) {\n    element.addEventListener(type, eventHandler);\n  } else if ('attachEvent' in element) {\n    element.attachEvent('on' + type, eventHandler);\n  }\n  memorizeHandler(element, type, handler, eventHandler);\n}\n\n/**\n * Memorize DOM event handler for unbinding.\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function that user passed at on() use\n * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features\n * @private\n */\nfunction memorizeHandler(element, type, handler, wrappedHandler) {\n  var events = safeEvent(element, type);\n  var existInEvents = false;\n\n  forEach(events, function(obj) {\n    if (obj.handler === handler) {\n      existInEvents = true;\n\n      return false;\n    }\n\n    return true;\n  });\n\n  if (!existInEvents) {\n    events.push({\n      handler: handler,\n      wrappedHandler: wrappedHandler\n    });\n  }\n}\n\nmodule.exports = on;\n\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_71515__) {\n\n\"use strict\";\n/**\n * @fileoverview Set className value\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isArray = __nested_webpack_require_71515__(322);\nvar isUndefined = __nested_webpack_require_71515__(929);\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n * @private\n */\nfunction setClassName(element, cssClass) {\n  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n  cssClass = cssClass.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n  if (isUndefined(element.className.baseVal)) {\n    element.className = cssClass;\n\n    return;\n  }\n\n  element.className.baseVal = cssClass;\n}\n\nmodule.exports = setClassName;\n\n\n/***/ }),\n\n/***/ 204:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_72332__) {\n\n\"use strict\";\n/**\n * @fileoverview Add css class to element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEach = __nested_webpack_require_72332__(690);\nvar inArray = __nested_webpack_require_72332__(928);\nvar getClass = __nested_webpack_require_72332__(902);\nvar setClassName = __nested_webpack_require_72332__(24);\n\n/**\n * domUtil module\n * @module domUtil\n */\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @memberof module:domUtil\n */\nfunction addClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var newClass = [];\n  var origin;\n\n  if (classList) {\n    forEach(cssClass, function(name) {\n      element.classList.add(name);\n    });\n\n    return;\n  }\n\n  origin = getClass(element);\n\n  if (origin) {\n    cssClass = [].concat(origin.split(/\\s+/), cssClass);\n  }\n\n  forEach(cssClass, function(cls) {\n    if (inArray(cls, newClass) < 0) {\n      newClass.push(cls);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nmodule.exports = addClass;\n\n\n/***/ }),\n\n/***/ 522:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_73512__) {\n\n\"use strict\";\n/**\n * @fileoverview Setting element style\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isString = __nested_webpack_require_73512__(758);\nvar forEach = __nested_webpack_require_73512__(690);\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @memberof module:domUtil\n */\nfunction css(element, key, value) {\n  var style = element.style;\n\n  if (isString(key)) {\n    style[key] = value;\n\n    return;\n  }\n\n  forEach(key, function(v, k) {\n    style[k] = v;\n  });\n}\n\nmodule.exports = css;\n\n\n/***/ }),\n\n/***/ 902:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74279__) {\n\n\"use strict\";\n/**\n * @fileoverview Get HTML element's design classes.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_74279__(929);\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @memberof module:domUtil\n */\nfunction getClass(element) {\n  if (!element || !element.className) {\n    return '';\n  }\n\n  if (isUndefined(element.className.baseVal)) {\n    return element.className;\n  }\n\n  return element.className.baseVal;\n}\n\nmodule.exports = getClass;\n\n\n/***/ }),\n\n/***/ 714:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74973__) {\n\n\"use strict\";\n/**\n * @fileoverview Check element has specific css class\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar inArray = __nested_webpack_require_74973__(928);\nvar getClass = __nested_webpack_require_74973__(902);\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @memberof module:domUtil\n */\nfunction hasClass(element, cssClass) {\n  var origin;\n\n  if (element.classList) {\n    return element.classList.contains(cssClass);\n  }\n\n  origin = getClass(element).split(/\\s+/);\n\n  return inArray(cssClass, origin) > -1;\n}\n\nmodule.exports = hasClass;\n\n\n/***/ }),\n\n/***/ 471:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_75740__) {\n\n\"use strict\";\n/**\n * @fileoverview Check element match selector\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar inArray = __nested_webpack_require_75740__(928);\nvar toArray = __nested_webpack_require_75740__(990);\n\nvar elProto = Element.prototype;\nvar matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n      var doc = this.document || this.ownerDocument;\n\n      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @memberof module:domUtil\n */\nfunction matches(element, selector) {\n  return matchSelector.call(element, selector);\n}\n\nmodule.exports = matches;\n\n\n/***/ }),\n\n/***/ 462:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_76721__) {\n\n\"use strict\";\n/**\n * @fileoverview Remove css class from element\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachArray = __nested_webpack_require_76721__(893);\nvar inArray = __nested_webpack_require_76721__(928);\nvar getClass = __nested_webpack_require_76721__(902);\nvar setClassName = __nested_webpack_require_76721__(24);\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @memberof module:domUtil\n */\nfunction removeClass(element) {\n  var cssClass = Array.prototype.slice.call(arguments, 1);\n  var classList = element.classList;\n  var origin, newClass;\n\n  if (classList) {\n    forEachArray(cssClass, function(name) {\n      classList.remove(name);\n    });\n\n    return;\n  }\n\n  origin = getClass(element).split(/\\s+/);\n  newClass = [];\n  forEachArray(origin, function(name) {\n    if (inArray(name, cssClass) < 0) {\n      newClass.push(name);\n    }\n  });\n\n  setClassName(element, newClass);\n}\n\nmodule.exports = removeClass;\n\n\n/***/ }),\n\n/***/ 969:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Extend the target object from other objects.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * @module object\n */\n\n/**\n * Extend the target object from other objects.\n * @param {object} target - Object that will be extended\n * @param {...object} objects - Objects as sources\n * @returns {object} Extended object\n * @memberof module:object\n */\nfunction extend(target, objects) { // eslint-disable-line no-unused-vars\n  var hasOwnProp = Object.prototype.hasOwnProperty;\n  var source, prop, i, len;\n\n  for (i = 1, len = arguments.length; i < len; i += 1) {\n    source = arguments[i];\n    for (prop in source) {\n      if (hasOwnProp.call(source, prop)) {\n        target[prop] = source[prop];\n      }\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = extend;\n\n\n/***/ }),\n\n/***/ 254:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_78685__) {\n\n\"use strict\";\n/**\n * @fileoverview Request image ping.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar forEachOwnProperties = __nested_webpack_require_78685__(956);\n\n/**\n * @module request\n */\n\n/**\n * Request image ping.\n * @param {String} url url for ping request\n * @param {Object} trackingInfo infos for make query string\n * @returns {HTMLElement}\n * @memberof module:request\n * @example\n * // ES6\n * import imagePing from 'tui-code-snippet/request/imagePing';\n * \n * // CommonJS\n * const imagePing = require('tui-code-snippet/request/imagePing');\n *\n * imagePing('https://www.google-analytics.com/collect', {\n *   v: 1,\n *   t: 'event',\n *   tid: 'trackingid',\n *   cid: 'cid',\n *   dp: 'dp',\n *   dh: 'dh'\n * });\n */\nfunction imagePing(url, trackingInfo) {\n  var trackingElement = document.createElement('img');\n  var queryString = '';\n  forEachOwnProperties(trackingInfo, function(value, key) {\n    queryString += '&' + key + '=' + value;\n  });\n  queryString = queryString.substring(1);\n\n  trackingElement.src = url + '?' + queryString;\n\n  trackingElement.style.display = 'none';\n  document.body.appendChild(trackingElement);\n  document.body.removeChild(trackingElement);\n\n  return trackingElement;\n}\n\nmodule.exports = imagePing;\n\n\n/***/ }),\n\n/***/ 391:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_80027__) {\n\n\"use strict\";\n/**\n * @fileoverview Send hostname on DOMContentLoaded.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_80027__(929);\nvar imagePing = __nested_webpack_require_80027__(254);\n\nvar ms7days = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * Check if the date has passed 7 days\n * @param {number} date - milliseconds\n * @returns {boolean}\n * @private\n */\nfunction isExpired(date) {\n  var now = new Date().getTime();\n\n  return now - date > ms7days;\n}\n\n/**\n * Send hostname on DOMContentLoaded.\n * To prevent hostname set tui.usageStatistics to false.\n * @param {string} appName - application name\n * @param {string} trackingId - GA tracking ID\n * @ignore\n */\nfunction sendHostname(appName, trackingId) {\n  var url = 'https://www.google-analytics.com/collect';\n  var hostname = location.hostname;\n  var hitType = 'event';\n  var eventCategory = 'use';\n  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';\n  var date = window.localStorage.getItem(applicationKeyForStorage);\n\n  // skip if the flag is defined and is set to false explicitly\n  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {\n    return;\n  }\n\n  // skip if not pass seven days old\n  if (date && !isExpired(date)) {\n    return;\n  }\n\n  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());\n\n  setTimeout(function() {\n    if (document.readyState === 'interactive' || document.readyState === 'complete') {\n      imagePing(url, {\n        v: 1,\n        t: hitType,\n        tid: trackingId,\n        cid: hostname,\n        dp: hostname,\n        dh: appName,\n        el: appName,\n        ec: eventCategory\n      });\n    }\n  }, 1000);\n}\n\nmodule.exports = sendHostname;\n\n\n/***/ }),\n\n/***/ 322:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is an instance of Array or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is an instance of Array or not.\n * If the given variable is an instance of Array, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is array instance?\n * @memberof module:type\n */\nfunction isArray(obj) {\n  return obj instanceof Array;\n}\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ 65:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_82401__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is existing or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isUndefined = __nested_webpack_require_82401__(929);\nvar isNull = __nested_webpack_require_82401__(934);\n\n/**\n * Check whether the given variable is existing or not.\n * If the given variable is not null and not undefined, returns true.\n * @param {*} param - Target for checking\n * @returns {boolean} Is existy?\n * @memberof module:type\n * @example\n * // ES6\n * import isExisty from 'tui-code-snippet/type/isExisty');\n * \n * // CommonJS\n * const isExisty = require('tui-code-snippet/type/isExisty');\n *\n * isExisty(''); //true\n * isExisty(0); //true\n * isExisty([]); //true\n * isExisty({}); //true\n * isExisty(null); //false\n * isExisty(undefined); //false\n*/\nfunction isExisty(param) {\n  return !isUndefined(param) && !isNull(param);\n}\n\nmodule.exports = isExisty;\n\n\n/***/ }),\n\n/***/ 404:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_83394__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is falsy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isTruthy = __nested_webpack_require_83394__(790);\n\n/**\n * Check whether the given variable is falsy or not.\n * If the given variable is null or undefined or false, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is falsy?\n * @memberof module:type\n */\nfunction isFalsy(obj) {\n  return !isTruthy(obj);\n}\n\nmodule.exports = isFalsy;\n\n\n/***/ }),\n\n/***/ 294:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is a function or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is a function or not.\n * If the given variable is a function, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is function?\n * @memberof module:type\n */\nfunction isFunction(obj) {\n  return obj instanceof Function;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ 934:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is null or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is null or not.\n * If the given variable(arguments[0]) is null, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is null?\n * @memberof module:type\n */\nfunction isNull(obj) {\n  return obj === null;\n}\n\nmodule.exports = isNull;\n\n\n/***/ }),\n\n/***/ 758:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is a string or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is a string or not.\n * If the given variable is a string, return true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is string?\n * @memberof module:type\n */\nfunction isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nmodule.exports = isString;\n\n\n/***/ }),\n\n/***/ 790:\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_85531__) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is truthy or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\nvar isExisty = __nested_webpack_require_85531__(65);\n\n/**\n * Check whether the given variable is truthy or not.\n * If the given variable is not null or not undefined or not false, returns true.\n * (It regards 0 as true)\n * @param {*} obj - Target for checking\n * @returns {boolean} Is truthy?\n * @memberof module:type\n */\nfunction isTruthy(obj) {\n  return isExisty(obj) && obj !== false;\n}\n\nmodule.exports = isTruthy;\n\n\n/***/ }),\n\n/***/ 929:\n/***/ (function(module) {\n\n\"use strict\";\n/**\n * @fileoverview Check whether the given variable is undefined or not.\n * @author NHN FE Development Lab <dl_javascript@nhn.com>\n */\n\n\n\n/**\n * Check whether the given variable is undefined or not.\n * If the given variable is undefined, returns true.\n * @param {*} obj - Target for checking\n * @returns {boolean} Is undefined?\n * @memberof module:type\n */\nfunction isUndefined(obj) {\n  return obj === undefined; // eslint-disable-line no-undefined\n}\n\nmodule.exports = isUndefined;\n\n\n/***/ }),\n\n/***/ 479:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__479__;\n\n/***/ }),\n\n/***/ 481:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__481__;\n\n/***/ }),\n\n/***/ 43:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__43__;\n\n/***/ }),\n\n/***/ 814:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__814__;\n\n/***/ }),\n\n/***/ 311:\n/***/ (function(module) {\n\n\"use strict\";\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__311__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_87464__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_87464__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t!function() {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_87464__.n = function(module) {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\tfunction() { return module['default']; } :\n/******/ \t\t\t\tfunction() { return module; };\n/******/ \t\t\t__nested_webpack_require_87464__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_87464__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_87464__.o(definition, key) && !__nested_webpack_require_87464__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_87464__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_87464__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n!function() {\n\"use strict\";\n\n// EXPORTS\n__nested_webpack_require_87464__.d(__nested_webpack_exports__, {\n  \"default\": function() { return /* binding */ indexViewer; }\n});\n\n;// CONCATENATED MODULE: ../../node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar tslib_es6_assign = function() {\r\n    tslib_es6_assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return tslib_es6_assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n;// CONCATENATED MODULE: ../../libs/toastmark/dist/esm/index.js\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise */\nvar esm_extendStatics = function (d, b) {\n    esm_extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (Object.prototype.hasOwnProperty.call(b, p))\n                d[p] = b[p]; };\n    return esm_extendStatics(d, b);\n};\nfunction esm_extends(d, b) {\n    if (typeof b !== \"function\" && b !== null)\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    esm_extendStatics(d, b);\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar esm_assign = function () {\n    esm_assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p))\n                    t[p] = s[p];\n        }\n        return t;\n    };\n    return esm_assign.apply(this, arguments);\n};\nfunction esm_spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2)\n        for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n                if (!ar)\n                    ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n            }\n        }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __nested_webpack_require_87464__.g !== 'undefined' ? __nested_webpack_require_87464__.g : typeof self !== 'undefined' ? self : {};\nvar encodeCache = {};\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n    var i, ch, cache = encodeCache[exclude];\n    if (cache) {\n        return cache;\n    }\n    cache = encodeCache[exclude] = [];\n    for (i = 0; i < 128; i++) {\n        ch = String.fromCharCode(i);\n        if (/^[0-9a-z]$/i.test(ch)) {\n            // always allow unencoded alphanumeric characters\n            cache.push(ch);\n        }\n        else {\n            cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n        }\n    }\n    for (i = 0; i < exclude.length; i++) {\n        cache[exclude.charCodeAt(i)] = exclude[i];\n    }\n    return cache;\n}\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode$1(string, exclude, keepEscaped) {\n    var i, l, code, nextCode, cache, result = '';\n    if (typeof exclude !== 'string') {\n        // encode(string, keepEscaped)\n        keepEscaped = exclude;\n        exclude = encode$1.defaultChars;\n    }\n    if (typeof keepEscaped === 'undefined') {\n        keepEscaped = true;\n    }\n    cache = getEncodeCache(exclude);\n    for (i = 0, l = string.length; i < l; i++) {\n        code = string.charCodeAt(i);\n        if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n                result += string.slice(i, i + 3);\n                i += 2;\n                continue;\n            }\n        }\n        if (code < 128) {\n            result += cache[code];\n            continue;\n        }\n        if (code >= 0xD800 && code <= 0xDFFF) {\n            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n                nextCode = string.charCodeAt(i + 1);\n                if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n                    result += encodeURIComponent(string[i] + string[i + 1]);\n                    i++;\n                    continue;\n                }\n            }\n            result += '%EF%BF%BD';\n            continue;\n        }\n        result += encodeURIComponent(string[i]);\n    }\n    return result;\n}\nencode$1.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode$1.componentChars = \"-_.!~*'()\";\nvar encode_1 = encode$1;\nvar lib = {};\nvar decode = {};\nvar Aacute$1 = \"Á\";\nvar aacute$1 = \"á\";\nvar Abreve = \"Ă\";\nvar abreve = \"ă\";\nvar ac = \"∾\";\nvar acd = \"∿\";\nvar acE = \"∾̳\";\nvar Acirc$1 = \"Â\";\nvar acirc$1 = \"â\";\nvar acute$1 = \"´\";\nvar Acy = \"А\";\nvar acy = \"а\";\nvar AElig$1 = \"Æ\";\nvar aelig$1 = \"æ\";\nvar af = \"⁡\";\nvar Afr = \"𝔄\";\nvar afr = \"𝔞\";\nvar Agrave$1 = \"À\";\nvar agrave$1 = \"à\";\nvar alefsym = \"ℵ\";\nvar aleph = \"ℵ\";\nvar Alpha = \"Α\";\nvar alpha = \"α\";\nvar Amacr = \"Ā\";\nvar amacr = \"ā\";\nvar amalg = \"⨿\";\nvar amp$2 = \"&\";\nvar AMP$1 = \"&\";\nvar andand = \"⩕\";\nvar And = \"⩓\";\nvar and = \"∧\";\nvar andd = \"⩜\";\nvar andslope = \"⩘\";\nvar andv = \"⩚\";\nvar ang = \"∠\";\nvar ange = \"⦤\";\nvar angle = \"∠\";\nvar angmsdaa = \"⦨\";\nvar angmsdab = \"⦩\";\nvar angmsdac = \"⦪\";\nvar angmsdad = \"⦫\";\nvar angmsdae = \"⦬\";\nvar angmsdaf = \"⦭\";\nvar angmsdag = \"⦮\";\nvar angmsdah = \"⦯\";\nvar angmsd = \"∡\";\nvar angrt = \"∟\";\nvar angrtvb = \"⊾\";\nvar angrtvbd = \"⦝\";\nvar angsph = \"∢\";\nvar angst = \"Å\";\nvar angzarr = \"⍼\";\nvar Aogon = \"Ą\";\nvar aogon = \"ą\";\nvar Aopf = \"𝔸\";\nvar aopf = \"𝕒\";\nvar apacir = \"⩯\";\nvar ap = \"≈\";\nvar apE = \"⩰\";\nvar ape = \"≊\";\nvar apid = \"≋\";\nvar apos$1 = \"'\";\nvar ApplyFunction = \"⁡\";\nvar approx = \"≈\";\nvar approxeq = \"≊\";\nvar Aring$1 = \"Å\";\nvar aring$1 = \"å\";\nvar Ascr = \"𝒜\";\nvar ascr = \"𝒶\";\nvar Assign = \"≔\";\nvar ast = \"*\";\nvar asymp = \"≈\";\nvar asympeq = \"≍\";\nvar Atilde$1 = \"Ã\";\nvar atilde$1 = \"ã\";\nvar Auml$1 = \"Ä\";\nvar auml$1 = \"ä\";\nvar awconint = \"∳\";\nvar awint = \"⨑\";\nvar backcong = \"≌\";\nvar backepsilon = \"϶\";\nvar backprime = \"‵\";\nvar backsim = \"∽\";\nvar backsimeq = \"⋍\";\nvar Backslash = \"∖\";\nvar Barv = \"⫧\";\nvar barvee = \"⊽\";\nvar barwed = \"⌅\";\nvar Barwed = \"⌆\";\nvar barwedge = \"⌅\";\nvar bbrk = \"⎵\";\nvar bbrktbrk = \"⎶\";\nvar bcong = \"≌\";\nvar Bcy = \"Б\";\nvar bcy = \"б\";\nvar bdquo = \"„\";\nvar becaus = \"∵\";\nvar because = \"∵\";\nvar Because = \"∵\";\nvar bemptyv = \"⦰\";\nvar bepsi = \"϶\";\nvar bernou = \"ℬ\";\nvar Bernoullis = \"ℬ\";\nvar Beta = \"Β\";\nvar beta = \"β\";\nvar beth = \"ℶ\";\nvar between = \"≬\";\nvar Bfr = \"𝔅\";\nvar bfr = \"𝔟\";\nvar bigcap = \"⋂\";\nvar bigcirc = \"◯\";\nvar bigcup = \"⋃\";\nvar bigodot = \"⨀\";\nvar bigoplus = \"⨁\";\nvar bigotimes = \"⨂\";\nvar bigsqcup = \"⨆\";\nvar bigstar = \"★\";\nvar bigtriangledown = \"▽\";\nvar bigtriangleup = \"△\";\nvar biguplus = \"⨄\";\nvar bigvee = \"⋁\";\nvar bigwedge = \"⋀\";\nvar bkarow = \"⤍\";\nvar blacklozenge = \"⧫\";\nvar blacksquare = \"▪\";\nvar blacktriangle = \"▴\";\nvar blacktriangledown = \"▾\";\nvar blacktriangleleft = \"◂\";\nvar blacktriangleright = \"▸\";\nvar blank = \"␣\";\nvar blk12 = \"▒\";\nvar blk14 = \"░\";\nvar blk34 = \"▓\";\nvar block = \"█\";\nvar bne = \"=⃥\";\nvar bnequiv = \"≡⃥\";\nvar bNot = \"⫭\";\nvar bnot = \"⌐\";\nvar Bopf = \"𝔹\";\nvar bopf = \"𝕓\";\nvar bot = \"⊥\";\nvar bottom = \"⊥\";\nvar bowtie = \"⋈\";\nvar boxbox = \"⧉\";\nvar boxdl = \"┐\";\nvar boxdL = \"╕\";\nvar boxDl = \"╖\";\nvar boxDL = \"╗\";\nvar boxdr = \"┌\";\nvar boxdR = \"╒\";\nvar boxDr = \"╓\";\nvar boxDR = \"╔\";\nvar boxh = \"─\";\nvar boxH = \"═\";\nvar boxhd = \"┬\";\nvar boxHd = \"╤\";\nvar boxhD = \"╥\";\nvar boxHD = \"╦\";\nvar boxhu = \"┴\";\nvar boxHu = \"╧\";\nvar boxhU = \"╨\";\nvar boxHU = \"╩\";\nvar boxminus = \"⊟\";\nvar boxplus = \"⊞\";\nvar boxtimes = \"⊠\";\nvar boxul = \"┘\";\nvar boxuL = \"╛\";\nvar boxUl = \"╜\";\nvar boxUL = \"╝\";\nvar boxur = \"└\";\nvar boxuR = \"╘\";\nvar boxUr = \"╙\";\nvar boxUR = \"╚\";\nvar boxv = \"│\";\nvar boxV = \"║\";\nvar boxvh = \"┼\";\nvar boxvH = \"╪\";\nvar boxVh = \"╫\";\nvar boxVH = \"╬\";\nvar boxvl = \"┤\";\nvar boxvL = \"╡\";\nvar boxVl = \"╢\";\nvar boxVL = \"╣\";\nvar boxvr = \"├\";\nvar boxvR = \"╞\";\nvar boxVr = \"╟\";\nvar boxVR = \"╠\";\nvar bprime = \"‵\";\nvar breve = \"˘\";\nvar Breve = \"˘\";\nvar brvbar$1 = \"¦\";\nvar bscr = \"𝒷\";\nvar Bscr = \"ℬ\";\nvar bsemi = \"⁏\";\nvar bsim = \"∽\";\nvar bsime = \"⋍\";\nvar bsolb = \"⧅\";\nvar bsol = \"\\\\\";\nvar bsolhsub = \"⟈\";\nvar bull = \"•\";\nvar bullet = \"•\";\nvar bump = \"≎\";\nvar bumpE = \"⪮\";\nvar bumpe = \"≏\";\nvar Bumpeq = \"≎\";\nvar bumpeq = \"≏\";\nvar Cacute = \"Ć\";\nvar cacute = \"ć\";\nvar capand = \"⩄\";\nvar capbrcup = \"⩉\";\nvar capcap = \"⩋\";\nvar cap = \"∩\";\nvar Cap = \"⋒\";\nvar capcup = \"⩇\";\nvar capdot = \"⩀\";\nvar CapitalDifferentialD = \"ⅅ\";\nvar caps = \"∩︀\";\nvar caret = \"⁁\";\nvar caron = \"ˇ\";\nvar Cayleys = \"ℭ\";\nvar ccaps = \"⩍\";\nvar Ccaron = \"Č\";\nvar ccaron = \"č\";\nvar Ccedil$1 = \"Ç\";\nvar ccedil$1 = \"ç\";\nvar Ccirc = \"Ĉ\";\nvar ccirc = \"ĉ\";\nvar Cconint = \"∰\";\nvar ccups = \"⩌\";\nvar ccupssm = \"⩐\";\nvar Cdot = \"Ċ\";\nvar cdot = \"ċ\";\nvar cedil$1 = \"¸\";\nvar Cedilla = \"¸\";\nvar cemptyv = \"⦲\";\nvar cent$1 = \"¢\";\nvar centerdot = \"·\";\nvar CenterDot = \"·\";\nvar cfr = \"𝔠\";\nvar Cfr = \"ℭ\";\nvar CHcy = \"Ч\";\nvar chcy = \"ч\";\nvar check = \"✓\";\nvar checkmark = \"✓\";\nvar Chi = \"Χ\";\nvar chi = \"χ\";\nvar circ = \"ˆ\";\nvar circeq = \"≗\";\nvar circlearrowleft = \"↺\";\nvar circlearrowright = \"↻\";\nvar circledast = \"⊛\";\nvar circledcirc = \"⊚\";\nvar circleddash = \"⊝\";\nvar CircleDot = \"⊙\";\nvar circledR = \"®\";\nvar circledS = \"Ⓢ\";\nvar CircleMinus = \"⊖\";\nvar CirclePlus = \"⊕\";\nvar CircleTimes = \"⊗\";\nvar cir = \"○\";\nvar cirE = \"⧃\";\nvar cire = \"≗\";\nvar cirfnint = \"⨐\";\nvar cirmid = \"⫯\";\nvar cirscir = \"⧂\";\nvar ClockwiseContourIntegral = \"∲\";\nvar CloseCurlyDoubleQuote = \"”\";\nvar CloseCurlyQuote = \"’\";\nvar clubs = \"♣\";\nvar clubsuit = \"♣\";\nvar colon = \":\";\nvar Colon = \"∷\";\nvar Colone = \"⩴\";\nvar colone = \"≔\";\nvar coloneq = \"≔\";\nvar comma = \",\";\nvar commat = \"@\";\nvar comp = \"∁\";\nvar compfn = \"∘\";\nvar complement = \"∁\";\nvar complexes = \"ℂ\";\nvar cong = \"≅\";\nvar congdot = \"⩭\";\nvar Congruent = \"≡\";\nvar conint = \"∮\";\nvar Conint = \"∯\";\nvar ContourIntegral = \"∮\";\nvar copf = \"𝕔\";\nvar Copf = \"ℂ\";\nvar coprod = \"∐\";\nvar Coproduct = \"∐\";\nvar copy$1 = \"©\";\nvar COPY$1 = \"©\";\nvar copysr = \"℗\";\nvar CounterClockwiseContourIntegral = \"∳\";\nvar crarr = \"↵\";\nvar cross = \"✗\";\nvar Cross = \"⨯\";\nvar Cscr = \"𝒞\";\nvar cscr = \"𝒸\";\nvar csub = \"⫏\";\nvar csube = \"⫑\";\nvar csup = \"⫐\";\nvar csupe = \"⫒\";\nvar ctdot = \"⋯\";\nvar cudarrl = \"⤸\";\nvar cudarrr = \"⤵\";\nvar cuepr = \"⋞\";\nvar cuesc = \"⋟\";\nvar cularr = \"↶\";\nvar cularrp = \"⤽\";\nvar cupbrcap = \"⩈\";\nvar cupcap = \"⩆\";\nvar CupCap = \"≍\";\nvar cup = \"∪\";\nvar Cup = \"⋓\";\nvar cupcup = \"⩊\";\nvar cupdot = \"⊍\";\nvar cupor = \"⩅\";\nvar cups = \"∪︀\";\nvar curarr = \"↷\";\nvar curarrm = \"⤼\";\nvar curlyeqprec = \"⋞\";\nvar curlyeqsucc = \"⋟\";\nvar curlyvee = \"⋎\";\nvar curlywedge = \"⋏\";\nvar curren$1 = \"¤\";\nvar curvearrowleft = \"↶\";\nvar curvearrowright = \"↷\";\nvar cuvee = \"⋎\";\nvar cuwed = \"⋏\";\nvar cwconint = \"∲\";\nvar cwint = \"∱\";\nvar cylcty = \"⌭\";\nvar dagger = \"†\";\nvar Dagger = \"‡\";\nvar daleth = \"ℸ\";\nvar darr = \"↓\";\nvar Darr = \"↡\";\nvar dArr = \"⇓\";\nvar dash = \"‐\";\nvar Dashv = \"⫤\";\nvar dashv = \"⊣\";\nvar dbkarow = \"⤏\";\nvar dblac = \"˝\";\nvar Dcaron = \"Ď\";\nvar dcaron = \"ď\";\nvar Dcy = \"Д\";\nvar dcy = \"д\";\nvar ddagger = \"‡\";\nvar ddarr = \"⇊\";\nvar DD = \"ⅅ\";\nvar dd = \"ⅆ\";\nvar DDotrahd = \"⤑\";\nvar ddotseq = \"⩷\";\nvar deg$1 = \"°\";\nvar Del = \"∇\";\nvar Delta = \"Δ\";\nvar delta = \"δ\";\nvar demptyv = \"⦱\";\nvar dfisht = \"⥿\";\nvar Dfr = \"𝔇\";\nvar dfr = \"𝔡\";\nvar dHar = \"⥥\";\nvar dharl = \"⇃\";\nvar dharr = \"⇂\";\nvar DiacriticalAcute = \"´\";\nvar DiacriticalDot = \"˙\";\nvar DiacriticalDoubleAcute = \"˝\";\nvar DiacriticalGrave = \"`\";\nvar DiacriticalTilde = \"˜\";\nvar diam = \"⋄\";\nvar diamond = \"⋄\";\nvar Diamond = \"⋄\";\nvar diamondsuit = \"♦\";\nvar diams = \"♦\";\nvar die = \"¨\";\nvar DifferentialD = \"ⅆ\";\nvar digamma = \"ϝ\";\nvar disin = \"⋲\";\nvar div = \"÷\";\nvar divide$1 = \"÷\";\nvar divideontimes = \"⋇\";\nvar divonx = \"⋇\";\nvar DJcy = \"Ђ\";\nvar djcy = \"ђ\";\nvar dlcorn = \"⌞\";\nvar dlcrop = \"⌍\";\nvar dollar = \"$\";\nvar Dopf = \"𝔻\";\nvar dopf = \"𝕕\";\nvar Dot = \"¨\";\nvar dot = \"˙\";\nvar DotDot = \"⃜\";\nvar doteq = \"≐\";\nvar doteqdot = \"≑\";\nvar DotEqual = \"≐\";\nvar dotminus = \"∸\";\nvar dotplus = \"∔\";\nvar dotsquare = \"⊡\";\nvar doublebarwedge = \"⌆\";\nvar DoubleContourIntegral = \"∯\";\nvar DoubleDot = \"¨\";\nvar DoubleDownArrow = \"⇓\";\nvar DoubleLeftArrow = \"⇐\";\nvar DoubleLeftRightArrow = \"⇔\";\nvar DoubleLeftTee = \"⫤\";\nvar DoubleLongLeftArrow = \"⟸\";\nvar DoubleLongLeftRightArrow = \"⟺\";\nvar DoubleLongRightArrow = \"⟹\";\nvar DoubleRightArrow = \"⇒\";\nvar DoubleRightTee = \"⊨\";\nvar DoubleUpArrow = \"⇑\";\nvar DoubleUpDownArrow = \"⇕\";\nvar DoubleVerticalBar = \"∥\";\nvar DownArrowBar = \"⤓\";\nvar downarrow = \"↓\";\nvar DownArrow = \"↓\";\nvar Downarrow = \"⇓\";\nvar DownArrowUpArrow = \"⇵\";\nvar DownBreve = \"̑\";\nvar downdownarrows = \"⇊\";\nvar downharpoonleft = \"⇃\";\nvar downharpoonright = \"⇂\";\nvar DownLeftRightVector = \"⥐\";\nvar DownLeftTeeVector = \"⥞\";\nvar DownLeftVectorBar = \"⥖\";\nvar DownLeftVector = \"↽\";\nvar DownRightTeeVector = \"⥟\";\nvar DownRightVectorBar = \"⥗\";\nvar DownRightVector = \"⇁\";\nvar DownTeeArrow = \"↧\";\nvar DownTee = \"⊤\";\nvar drbkarow = \"⤐\";\nvar drcorn = \"⌟\";\nvar drcrop = \"⌌\";\nvar Dscr = \"𝒟\";\nvar dscr = \"𝒹\";\nvar DScy = \"Ѕ\";\nvar dscy = \"ѕ\";\nvar dsol = \"⧶\";\nvar Dstrok = \"Đ\";\nvar dstrok = \"đ\";\nvar dtdot = \"⋱\";\nvar dtri = \"▿\";\nvar dtrif = \"▾\";\nvar duarr = \"⇵\";\nvar duhar = \"⥯\";\nvar dwangle = \"⦦\";\nvar DZcy = \"Џ\";\nvar dzcy = \"џ\";\nvar dzigrarr = \"⟿\";\nvar Eacute$1 = \"É\";\nvar eacute$1 = \"é\";\nvar easter = \"⩮\";\nvar Ecaron = \"Ě\";\nvar ecaron = \"ě\";\nvar Ecirc$1 = \"Ê\";\nvar ecirc$1 = \"ê\";\nvar ecir = \"≖\";\nvar ecolon = \"≕\";\nvar Ecy = \"Э\";\nvar ecy = \"э\";\nvar eDDot = \"⩷\";\nvar Edot = \"Ė\";\nvar edot = \"ė\";\nvar eDot = \"≑\";\nvar ee = \"ⅇ\";\nvar efDot = \"≒\";\nvar Efr = \"𝔈\";\nvar efr = \"𝔢\";\nvar eg = \"⪚\";\nvar Egrave$1 = \"È\";\nvar egrave$1 = \"è\";\nvar egs = \"⪖\";\nvar egsdot = \"⪘\";\nvar el = \"⪙\";\nvar Element = \"∈\";\nvar elinters = \"⏧\";\nvar ell = \"ℓ\";\nvar els = \"⪕\";\nvar elsdot = \"⪗\";\nvar Emacr = \"Ē\";\nvar emacr = \"ē\";\nvar empty = \"∅\";\nvar emptyset = \"∅\";\nvar EmptySmallSquare = \"◻\";\nvar emptyv = \"∅\";\nvar EmptyVerySmallSquare = \"▫\";\nvar emsp13 = \" \";\nvar emsp14 = \" \";\nvar emsp = \" \";\nvar ENG = \"Ŋ\";\nvar eng = \"ŋ\";\nvar ensp = \" \";\nvar Eogon = \"Ę\";\nvar eogon = \"ę\";\nvar Eopf = \"𝔼\";\nvar eopf = \"𝕖\";\nvar epar = \"⋕\";\nvar eparsl = \"⧣\";\nvar eplus = \"⩱\";\nvar epsi = \"ε\";\nvar Epsilon = \"Ε\";\nvar epsilon = \"ε\";\nvar epsiv = \"ϵ\";\nvar eqcirc = \"≖\";\nvar eqcolon = \"≕\";\nvar eqsim = \"≂\";\nvar eqslantgtr = \"⪖\";\nvar eqslantless = \"⪕\";\nvar Equal = \"⩵\";\nvar equals = \"=\";\nvar EqualTilde = \"≂\";\nvar equest = \"≟\";\nvar Equilibrium = \"⇌\";\nvar equiv = \"≡\";\nvar equivDD = \"⩸\";\nvar eqvparsl = \"⧥\";\nvar erarr = \"⥱\";\nvar erDot = \"≓\";\nvar escr = \"ℯ\";\nvar Escr = \"ℰ\";\nvar esdot = \"≐\";\nvar Esim = \"⩳\";\nvar esim = \"≂\";\nvar Eta = \"Η\";\nvar eta = \"η\";\nvar ETH$1 = \"Ð\";\nvar eth$1 = \"ð\";\nvar Euml$1 = \"Ë\";\nvar euml$1 = \"ë\";\nvar euro = \"€\";\nvar excl = \"!\";\nvar exist = \"∃\";\nvar Exists = \"∃\";\nvar expectation = \"ℰ\";\nvar exponentiale = \"ⅇ\";\nvar ExponentialE = \"ⅇ\";\nvar fallingdotseq = \"≒\";\nvar Fcy = \"Ф\";\nvar fcy = \"ф\";\nvar female = \"♀\";\nvar ffilig = \"ﬃ\";\nvar fflig = \"ﬀ\";\nvar ffllig = \"ﬄ\";\nvar Ffr = \"𝔉\";\nvar ffr = \"𝔣\";\nvar filig = \"ﬁ\";\nvar FilledSmallSquare = \"◼\";\nvar FilledVerySmallSquare = \"▪\";\nvar fjlig = \"fj\";\nvar flat = \"♭\";\nvar fllig = \"ﬂ\";\nvar fltns = \"▱\";\nvar fnof = \"ƒ\";\nvar Fopf = \"𝔽\";\nvar fopf = \"𝕗\";\nvar forall = \"∀\";\nvar ForAll = \"∀\";\nvar fork = \"⋔\";\nvar forkv = \"⫙\";\nvar Fouriertrf = \"ℱ\";\nvar fpartint = \"⨍\";\nvar frac12$1 = \"½\";\nvar frac13 = \"⅓\";\nvar frac14$1 = \"¼\";\nvar frac15 = \"⅕\";\nvar frac16 = \"⅙\";\nvar frac18 = \"⅛\";\nvar frac23 = \"⅔\";\nvar frac25 = \"⅖\";\nvar frac34$1 = \"¾\";\nvar frac35 = \"⅗\";\nvar frac38 = \"⅜\";\nvar frac45 = \"⅘\";\nvar frac56 = \"⅚\";\nvar frac58 = \"⅝\";\nvar frac78 = \"⅞\";\nvar frasl = \"⁄\";\nvar frown = \"⌢\";\nvar fscr = \"𝒻\";\nvar Fscr = \"ℱ\";\nvar gacute = \"ǵ\";\nvar Gamma = \"Γ\";\nvar gamma = \"γ\";\nvar Gammad = \"Ϝ\";\nvar gammad = \"ϝ\";\nvar gap = \"⪆\";\nvar Gbreve = \"Ğ\";\nvar gbreve = \"ğ\";\nvar Gcedil = \"Ģ\";\nvar Gcirc = \"Ĝ\";\nvar gcirc = \"ĝ\";\nvar Gcy = \"Г\";\nvar gcy = \"г\";\nvar Gdot = \"Ġ\";\nvar gdot = \"ġ\";\nvar ge = \"≥\";\nvar gE = \"≧\";\nvar gEl = \"⪌\";\nvar gel = \"⋛\";\nvar geq = \"≥\";\nvar geqq = \"≧\";\nvar geqslant = \"⩾\";\nvar gescc = \"⪩\";\nvar ges = \"⩾\";\nvar gesdot = \"⪀\";\nvar gesdoto = \"⪂\";\nvar gesdotol = \"⪄\";\nvar gesl = \"⋛︀\";\nvar gesles = \"⪔\";\nvar Gfr = \"𝔊\";\nvar gfr = \"𝔤\";\nvar gg = \"≫\";\nvar Gg = \"⋙\";\nvar ggg = \"⋙\";\nvar gimel = \"ℷ\";\nvar GJcy = \"Ѓ\";\nvar gjcy = \"ѓ\";\nvar gla = \"⪥\";\nvar gl = \"≷\";\nvar glE = \"⪒\";\nvar glj = \"⪤\";\nvar gnap = \"⪊\";\nvar gnapprox = \"⪊\";\nvar gne = \"⪈\";\nvar gnE = \"≩\";\nvar gneq = \"⪈\";\nvar gneqq = \"≩\";\nvar gnsim = \"⋧\";\nvar Gopf = \"𝔾\";\nvar gopf = \"𝕘\";\nvar grave = \"`\";\nvar GreaterEqual = \"≥\";\nvar GreaterEqualLess = \"⋛\";\nvar GreaterFullEqual = \"≧\";\nvar GreaterGreater = \"⪢\";\nvar GreaterLess = \"≷\";\nvar GreaterSlantEqual = \"⩾\";\nvar GreaterTilde = \"≳\";\nvar Gscr = \"𝒢\";\nvar gscr = \"ℊ\";\nvar gsim = \"≳\";\nvar gsime = \"⪎\";\nvar gsiml = \"⪐\";\nvar gtcc = \"⪧\";\nvar gtcir = \"⩺\";\nvar gt$2 = \">\";\nvar GT$1 = \">\";\nvar Gt = \"≫\";\nvar gtdot = \"⋗\";\nvar gtlPar = \"⦕\";\nvar gtquest = \"⩼\";\nvar gtrapprox = \"⪆\";\nvar gtrarr = \"⥸\";\nvar gtrdot = \"⋗\";\nvar gtreqless = \"⋛\";\nvar gtreqqless = \"⪌\";\nvar gtrless = \"≷\";\nvar gtrsim = \"≳\";\nvar gvertneqq = \"≩︀\";\nvar gvnE = \"≩︀\";\nvar Hacek = \"ˇ\";\nvar hairsp = \" \";\nvar half = \"½\";\nvar hamilt = \"ℋ\";\nvar HARDcy = \"Ъ\";\nvar hardcy = \"ъ\";\nvar harrcir = \"⥈\";\nvar harr = \"↔\";\nvar hArr = \"⇔\";\nvar harrw = \"↭\";\nvar Hat = \"^\";\nvar hbar = \"ℏ\";\nvar Hcirc = \"Ĥ\";\nvar hcirc = \"ĥ\";\nvar hearts = \"♥\";\nvar heartsuit = \"♥\";\nvar hellip = \"…\";\nvar hercon = \"⊹\";\nvar hfr = \"𝔥\";\nvar Hfr = \"ℌ\";\nvar HilbertSpace = \"ℋ\";\nvar hksearow = \"⤥\";\nvar hkswarow = \"⤦\";\nvar hoarr = \"⇿\";\nvar homtht = \"∻\";\nvar hookleftarrow = \"↩\";\nvar hookrightarrow = \"↪\";\nvar hopf = \"𝕙\";\nvar Hopf = \"ℍ\";\nvar horbar = \"―\";\nvar HorizontalLine = \"─\";\nvar hscr = \"𝒽\";\nvar Hscr = \"ℋ\";\nvar hslash = \"ℏ\";\nvar Hstrok = \"Ħ\";\nvar hstrok = \"ħ\";\nvar HumpDownHump = \"≎\";\nvar HumpEqual = \"≏\";\nvar hybull = \"⁃\";\nvar hyphen = \"‐\";\nvar Iacute$1 = \"Í\";\nvar iacute$1 = \"í\";\nvar ic = \"⁣\";\nvar Icirc$1 = \"Î\";\nvar icirc$1 = \"î\";\nvar Icy = \"И\";\nvar icy = \"и\";\nvar Idot = \"İ\";\nvar IEcy = \"Е\";\nvar iecy = \"е\";\nvar iexcl$1 = \"¡\";\nvar iff = \"⇔\";\nvar ifr = \"𝔦\";\nvar Ifr = \"ℑ\";\nvar Igrave$1 = \"Ì\";\nvar igrave$1 = \"ì\";\nvar ii = \"ⅈ\";\nvar iiiint = \"⨌\";\nvar iiint = \"∭\";\nvar iinfin = \"⧜\";\nvar iiota = \"℩\";\nvar IJlig = \"Ĳ\";\nvar ijlig = \"ĳ\";\nvar Imacr = \"Ī\";\nvar imacr = \"ī\";\nvar esm_image = \"ℑ\";\nvar ImaginaryI = \"ⅈ\";\nvar imagline = \"ℐ\";\nvar imagpart = \"ℑ\";\nvar imath = \"ı\";\nvar Im = \"ℑ\";\nvar imof = \"⊷\";\nvar imped = \"Ƶ\";\nvar Implies = \"⇒\";\nvar incare = \"℅\";\nvar infin = \"∞\";\nvar infintie = \"⧝\";\nvar inodot = \"ı\";\nvar intcal = \"⊺\";\nvar esm_int = \"∫\";\nvar Int = \"∬\";\nvar integers = \"ℤ\";\nvar Integral = \"∫\";\nvar intercal = \"⊺\";\nvar Intersection = \"⋂\";\nvar intlarhk = \"⨗\";\nvar intprod = \"⨼\";\nvar InvisibleComma = \"⁣\";\nvar InvisibleTimes = \"⁢\";\nvar IOcy = \"Ё\";\nvar iocy = \"ё\";\nvar Iogon = \"Į\";\nvar iogon = \"į\";\nvar Iopf = \"𝕀\";\nvar iopf = \"𝕚\";\nvar Iota = \"Ι\";\nvar iota = \"ι\";\nvar iprod = \"⨼\";\nvar iquest$1 = \"¿\";\nvar iscr = \"𝒾\";\nvar Iscr = \"ℐ\";\nvar isin = \"∈\";\nvar isindot = \"⋵\";\nvar isinE = \"⋹\";\nvar isins = \"⋴\";\nvar isinsv = \"⋳\";\nvar isinv = \"∈\";\nvar it = \"⁢\";\nvar Itilde = \"Ĩ\";\nvar itilde = \"ĩ\";\nvar Iukcy = \"І\";\nvar iukcy = \"і\";\nvar Iuml$1 = \"Ï\";\nvar iuml$1 = \"ï\";\nvar Jcirc = \"Ĵ\";\nvar jcirc = \"ĵ\";\nvar Jcy = \"Й\";\nvar jcy = \"й\";\nvar Jfr = \"𝔍\";\nvar jfr = \"𝔧\";\nvar jmath = \"ȷ\";\nvar Jopf = \"𝕁\";\nvar jopf = \"𝕛\";\nvar Jscr = \"𝒥\";\nvar jscr = \"𝒿\";\nvar Jsercy = \"Ј\";\nvar jsercy = \"ј\";\nvar Jukcy = \"Є\";\nvar jukcy = \"є\";\nvar Kappa = \"Κ\";\nvar kappa = \"κ\";\nvar kappav = \"ϰ\";\nvar Kcedil = \"Ķ\";\nvar kcedil = \"ķ\";\nvar Kcy = \"К\";\nvar kcy = \"к\";\nvar Kfr = \"𝔎\";\nvar kfr = \"𝔨\";\nvar kgreen = \"ĸ\";\nvar KHcy = \"Х\";\nvar khcy = \"х\";\nvar KJcy = \"Ќ\";\nvar kjcy = \"ќ\";\nvar Kopf = \"𝕂\";\nvar kopf = \"𝕜\";\nvar Kscr = \"𝒦\";\nvar kscr = \"𝓀\";\nvar lAarr = \"⇚\";\nvar Lacute = \"Ĺ\";\nvar lacute = \"ĺ\";\nvar laemptyv = \"⦴\";\nvar lagran = \"ℒ\";\nvar Lambda = \"Λ\";\nvar lambda = \"λ\";\nvar lang = \"⟨\";\nvar Lang = \"⟪\";\nvar langd = \"⦑\";\nvar langle = \"⟨\";\nvar lap = \"⪅\";\nvar Laplacetrf = \"ℒ\";\nvar laquo$1 = \"«\";\nvar larrb = \"⇤\";\nvar larrbfs = \"⤟\";\nvar larr = \"←\";\nvar Larr = \"↞\";\nvar lArr = \"⇐\";\nvar larrfs = \"⤝\";\nvar larrhk = \"↩\";\nvar larrlp = \"↫\";\nvar larrpl = \"⤹\";\nvar larrsim = \"⥳\";\nvar larrtl = \"↢\";\nvar latail = \"⤙\";\nvar lAtail = \"⤛\";\nvar lat = \"⪫\";\nvar late = \"⪭\";\nvar lates = \"⪭︀\";\nvar lbarr = \"⤌\";\nvar lBarr = \"⤎\";\nvar lbbrk = \"❲\";\nvar lbrace = \"{\";\nvar lbrack = \"[\";\nvar lbrke = \"⦋\";\nvar lbrksld = \"⦏\";\nvar lbrkslu = \"⦍\";\nvar Lcaron = \"Ľ\";\nvar lcaron = \"ľ\";\nvar Lcedil = \"Ļ\";\nvar lcedil = \"ļ\";\nvar lceil = \"⌈\";\nvar lcub = \"{\";\nvar Lcy = \"Л\";\nvar lcy = \"л\";\nvar ldca = \"⤶\";\nvar ldquo = \"“\";\nvar ldquor = \"„\";\nvar ldrdhar = \"⥧\";\nvar ldrushar = \"⥋\";\nvar ldsh = \"↲\";\nvar le = \"≤\";\nvar lE = \"≦\";\nvar LeftAngleBracket = \"⟨\";\nvar LeftArrowBar = \"⇤\";\nvar leftarrow = \"←\";\nvar LeftArrow = \"←\";\nvar Leftarrow = \"⇐\";\nvar LeftArrowRightArrow = \"⇆\";\nvar leftarrowtail = \"↢\";\nvar LeftCeiling = \"⌈\";\nvar LeftDoubleBracket = \"⟦\";\nvar LeftDownTeeVector = \"⥡\";\nvar LeftDownVectorBar = \"⥙\";\nvar LeftDownVector = \"⇃\";\nvar LeftFloor = \"⌊\";\nvar leftharpoondown = \"↽\";\nvar leftharpoonup = \"↼\";\nvar leftleftarrows = \"⇇\";\nvar leftrightarrow = \"↔\";\nvar LeftRightArrow = \"↔\";\nvar Leftrightarrow = \"⇔\";\nvar leftrightarrows = \"⇆\";\nvar leftrightharpoons = \"⇋\";\nvar leftrightsquigarrow = \"↭\";\nvar LeftRightVector = \"⥎\";\nvar LeftTeeArrow = \"↤\";\nvar LeftTee = \"⊣\";\nvar LeftTeeVector = \"⥚\";\nvar leftthreetimes = \"⋋\";\nvar LeftTriangleBar = \"⧏\";\nvar LeftTriangle = \"⊲\";\nvar LeftTriangleEqual = \"⊴\";\nvar LeftUpDownVector = \"⥑\";\nvar LeftUpTeeVector = \"⥠\";\nvar LeftUpVectorBar = \"⥘\";\nvar LeftUpVector = \"↿\";\nvar LeftVectorBar = \"⥒\";\nvar LeftVector = \"↼\";\nvar lEg = \"⪋\";\nvar leg = \"⋚\";\nvar leq = \"≤\";\nvar leqq = \"≦\";\nvar leqslant = \"⩽\";\nvar lescc = \"⪨\";\nvar les = \"⩽\";\nvar lesdot = \"⩿\";\nvar lesdoto = \"⪁\";\nvar lesdotor = \"⪃\";\nvar lesg = \"⋚︀\";\nvar lesges = \"⪓\";\nvar lessapprox = \"⪅\";\nvar lessdot = \"⋖\";\nvar lesseqgtr = \"⋚\";\nvar lesseqqgtr = \"⪋\";\nvar LessEqualGreater = \"⋚\";\nvar LessFullEqual = \"≦\";\nvar LessGreater = \"≶\";\nvar lessgtr = \"≶\";\nvar LessLess = \"⪡\";\nvar lesssim = \"≲\";\nvar LessSlantEqual = \"⩽\";\nvar LessTilde = \"≲\";\nvar lfisht = \"⥼\";\nvar lfloor = \"⌊\";\nvar Lfr = \"𝔏\";\nvar lfr = \"𝔩\";\nvar lg = \"≶\";\nvar lgE = \"⪑\";\nvar lHar = \"⥢\";\nvar lhard = \"↽\";\nvar lharu = \"↼\";\nvar lharul = \"⥪\";\nvar lhblk = \"▄\";\nvar LJcy = \"Љ\";\nvar ljcy = \"љ\";\nvar llarr = \"⇇\";\nvar ll = \"≪\";\nvar Ll = \"⋘\";\nvar llcorner = \"⌞\";\nvar Lleftarrow = \"⇚\";\nvar llhard = \"⥫\";\nvar lltri = \"◺\";\nvar Lmidot = \"Ŀ\";\nvar lmidot = \"ŀ\";\nvar lmoustache = \"⎰\";\nvar lmoust = \"⎰\";\nvar lnap = \"⪉\";\nvar lnapprox = \"⪉\";\nvar lne = \"⪇\";\nvar lnE = \"≨\";\nvar lneq = \"⪇\";\nvar lneqq = \"≨\";\nvar lnsim = \"⋦\";\nvar loang = \"⟬\";\nvar loarr = \"⇽\";\nvar lobrk = \"⟦\";\nvar longleftarrow = \"⟵\";\nvar LongLeftArrow = \"⟵\";\nvar Longleftarrow = \"⟸\";\nvar longleftrightarrow = \"⟷\";\nvar LongLeftRightArrow = \"⟷\";\nvar Longleftrightarrow = \"⟺\";\nvar longmapsto = \"⟼\";\nvar longrightarrow = \"⟶\";\nvar LongRightArrow = \"⟶\";\nvar Longrightarrow = \"⟹\";\nvar looparrowleft = \"↫\";\nvar looparrowright = \"↬\";\nvar lopar = \"⦅\";\nvar Lopf = \"𝕃\";\nvar lopf = \"𝕝\";\nvar loplus = \"⨭\";\nvar lotimes = \"⨴\";\nvar lowast = \"∗\";\nvar lowbar = \"_\";\nvar LowerLeftArrow = \"↙\";\nvar LowerRightArrow = \"↘\";\nvar loz = \"◊\";\nvar lozenge = \"◊\";\nvar lozf = \"⧫\";\nvar lpar = \"(\";\nvar lparlt = \"⦓\";\nvar lrarr = \"⇆\";\nvar lrcorner = \"⌟\";\nvar lrhar = \"⇋\";\nvar lrhard = \"⥭\";\nvar lrm = \"‎\";\nvar lrtri = \"⊿\";\nvar lsaquo = \"‹\";\nvar lscr = \"𝓁\";\nvar Lscr = \"ℒ\";\nvar lsh = \"↰\";\nvar Lsh = \"↰\";\nvar lsim = \"≲\";\nvar lsime = \"⪍\";\nvar lsimg = \"⪏\";\nvar lsqb = \"[\";\nvar lsquo = \"‘\";\nvar lsquor = \"‚\";\nvar Lstrok = \"Ł\";\nvar lstrok = \"ł\";\nvar ltcc = \"⪦\";\nvar ltcir = \"⩹\";\nvar lt$2 = \"<\";\nvar LT$1 = \"<\";\nvar Lt = \"≪\";\nvar ltdot = \"⋖\";\nvar lthree = \"⋋\";\nvar ltimes = \"⋉\";\nvar ltlarr = \"⥶\";\nvar ltquest = \"⩻\";\nvar ltri = \"◃\";\nvar ltrie = \"⊴\";\nvar ltrif = \"◂\";\nvar ltrPar = \"⦖\";\nvar lurdshar = \"⥊\";\nvar luruhar = \"⥦\";\nvar lvertneqq = \"≨︀\";\nvar lvnE = \"≨︀\";\nvar macr$1 = \"¯\";\nvar male = \"♂\";\nvar malt = \"✠\";\nvar maltese = \"✠\";\nvar map = \"↦\";\nvar mapsto = \"↦\";\nvar mapstodown = \"↧\";\nvar mapstoleft = \"↤\";\nvar mapstoup = \"↥\";\nvar marker = \"▮\";\nvar mcomma = \"⨩\";\nvar Mcy = \"М\";\nvar mcy = \"м\";\nvar mdash = \"—\";\nvar mDDot = \"∺\";\nvar measuredangle = \"∡\";\nvar MediumSpace = \" \";\nvar Mellintrf = \"ℳ\";\nvar Mfr = \"𝔐\";\nvar mfr = \"𝔪\";\nvar mho = \"℧\";\nvar micro$1 = \"µ\";\nvar midast = \"*\";\nvar midcir = \"⫰\";\nvar mid = \"∣\";\nvar middot$1 = \"·\";\nvar minusb = \"⊟\";\nvar minus = \"−\";\nvar minusd = \"∸\";\nvar minusdu = \"⨪\";\nvar MinusPlus = \"∓\";\nvar mlcp = \"⫛\";\nvar mldr = \"…\";\nvar mnplus = \"∓\";\nvar models = \"⊧\";\nvar Mopf = \"𝕄\";\nvar mopf = \"𝕞\";\nvar mp = \"∓\";\nvar mscr = \"𝓂\";\nvar Mscr = \"ℳ\";\nvar mstpos = \"∾\";\nvar Mu = \"Μ\";\nvar mu = \"μ\";\nvar multimap = \"⊸\";\nvar mumap = \"⊸\";\nvar nabla = \"∇\";\nvar Nacute = \"Ń\";\nvar nacute = \"ń\";\nvar nang = \"∠⃒\";\nvar nap = \"≉\";\nvar napE = \"⩰̸\";\nvar napid = \"≋̸\";\nvar napos = \"ŉ\";\nvar napprox = \"≉\";\nvar natural = \"♮\";\nvar naturals = \"ℕ\";\nvar natur = \"♮\";\nvar nbsp$1 = \" \";\nvar nbump = \"≎̸\";\nvar nbumpe = \"≏̸\";\nvar ncap = \"⩃\";\nvar Ncaron = \"Ň\";\nvar ncaron = \"ň\";\nvar Ncedil = \"Ņ\";\nvar ncedil = \"ņ\";\nvar ncong = \"≇\";\nvar ncongdot = \"⩭̸\";\nvar ncup = \"⩂\";\nvar Ncy = \"Н\";\nvar ncy = \"н\";\nvar ndash = \"–\";\nvar nearhk = \"⤤\";\nvar nearr = \"↗\";\nvar neArr = \"⇗\";\nvar nearrow = \"↗\";\nvar ne = \"≠\";\nvar nedot = \"≐̸\";\nvar NegativeMediumSpace = \"​\";\nvar NegativeThickSpace = \"​\";\nvar NegativeThinSpace = \"​\";\nvar NegativeVeryThinSpace = \"​\";\nvar nequiv = \"≢\";\nvar nesear = \"⤨\";\nvar nesim = \"≂̸\";\nvar NestedGreaterGreater = \"≫\";\nvar NestedLessLess = \"≪\";\nvar NewLine = \"\\n\";\nvar nexist = \"∄\";\nvar nexists = \"∄\";\nvar Nfr = \"𝔑\";\nvar nfr = \"𝔫\";\nvar ngE = \"≧̸\";\nvar nge = \"≱\";\nvar ngeq = \"≱\";\nvar ngeqq = \"≧̸\";\nvar ngeqslant = \"⩾̸\";\nvar nges = \"⩾̸\";\nvar nGg = \"⋙̸\";\nvar ngsim = \"≵\";\nvar nGt = \"≫⃒\";\nvar ngt = \"≯\";\nvar ngtr = \"≯\";\nvar nGtv = \"≫̸\";\nvar nharr = \"↮\";\nvar nhArr = \"⇎\";\nvar nhpar = \"⫲\";\nvar ni = \"∋\";\nvar nis = \"⋼\";\nvar nisd = \"⋺\";\nvar niv = \"∋\";\nvar NJcy = \"Њ\";\nvar njcy = \"њ\";\nvar nlarr = \"↚\";\nvar nlArr = \"⇍\";\nvar nldr = \"‥\";\nvar nlE = \"≦̸\";\nvar nle = \"≰\";\nvar nleftarrow = \"↚\";\nvar nLeftarrow = \"⇍\";\nvar nleftrightarrow = \"↮\";\nvar nLeftrightarrow = \"⇎\";\nvar nleq = \"≰\";\nvar nleqq = \"≦̸\";\nvar nleqslant = \"⩽̸\";\nvar nles = \"⩽̸\";\nvar nless = \"≮\";\nvar nLl = \"⋘̸\";\nvar nlsim = \"≴\";\nvar nLt = \"≪⃒\";\nvar nlt = \"≮\";\nvar nltri = \"⋪\";\nvar nltrie = \"⋬\";\nvar nLtv = \"≪̸\";\nvar nmid = \"∤\";\nvar NoBreak = \"⁠\";\nvar NonBreakingSpace = \" \";\nvar nopf = \"𝕟\";\nvar Nopf = \"ℕ\";\nvar Not = \"⫬\";\nvar not$1 = \"¬\";\nvar NotCongruent = \"≢\";\nvar NotCupCap = \"≭\";\nvar NotDoubleVerticalBar = \"∦\";\nvar NotElement = \"∉\";\nvar NotEqual = \"≠\";\nvar NotEqualTilde = \"≂̸\";\nvar NotExists = \"∄\";\nvar NotGreater = \"≯\";\nvar NotGreaterEqual = \"≱\";\nvar NotGreaterFullEqual = \"≧̸\";\nvar NotGreaterGreater = \"≫̸\";\nvar NotGreaterLess = \"≹\";\nvar NotGreaterSlantEqual = \"⩾̸\";\nvar NotGreaterTilde = \"≵\";\nvar NotHumpDownHump = \"≎̸\";\nvar NotHumpEqual = \"≏̸\";\nvar notin = \"∉\";\nvar notindot = \"⋵̸\";\nvar notinE = \"⋹̸\";\nvar notinva = \"∉\";\nvar notinvb = \"⋷\";\nvar notinvc = \"⋶\";\nvar NotLeftTriangleBar = \"⧏̸\";\nvar NotLeftTriangle = \"⋪\";\nvar NotLeftTriangleEqual = \"⋬\";\nvar NotLess = \"≮\";\nvar NotLessEqual = \"≰\";\nvar NotLessGreater = \"≸\";\nvar NotLessLess = \"≪̸\";\nvar NotLessSlantEqual = \"⩽̸\";\nvar NotLessTilde = \"≴\";\nvar NotNestedGreaterGreater = \"⪢̸\";\nvar NotNestedLessLess = \"⪡̸\";\nvar notni = \"∌\";\nvar notniva = \"∌\";\nvar notnivb = \"⋾\";\nvar notnivc = \"⋽\";\nvar NotPrecedes = \"⊀\";\nvar NotPrecedesEqual = \"⪯̸\";\nvar NotPrecedesSlantEqual = \"⋠\";\nvar NotReverseElement = \"∌\";\nvar NotRightTriangleBar = \"⧐̸\";\nvar NotRightTriangle = \"⋫\";\nvar NotRightTriangleEqual = \"⋭\";\nvar NotSquareSubset = \"⊏̸\";\nvar NotSquareSubsetEqual = \"⋢\";\nvar NotSquareSuperset = \"⊐̸\";\nvar NotSquareSupersetEqual = \"⋣\";\nvar NotSubset = \"⊂⃒\";\nvar NotSubsetEqual = \"⊈\";\nvar NotSucceeds = \"⊁\";\nvar NotSucceedsEqual = \"⪰̸\";\nvar NotSucceedsSlantEqual = \"⋡\";\nvar NotSucceedsTilde = \"≿̸\";\nvar NotSuperset = \"⊃⃒\";\nvar NotSupersetEqual = \"⊉\";\nvar NotTilde = \"≁\";\nvar NotTildeEqual = \"≄\";\nvar NotTildeFullEqual = \"≇\";\nvar NotTildeTilde = \"≉\";\nvar NotVerticalBar = \"∤\";\nvar nparallel = \"∦\";\nvar npar = \"∦\";\nvar nparsl = \"⫽⃥\";\nvar npart = \"∂̸\";\nvar npolint = \"⨔\";\nvar npr = \"⊀\";\nvar nprcue = \"⋠\";\nvar nprec = \"⊀\";\nvar npreceq = \"⪯̸\";\nvar npre = \"⪯̸\";\nvar nrarrc = \"⤳̸\";\nvar nrarr = \"↛\";\nvar nrArr = \"⇏\";\nvar nrarrw = \"↝̸\";\nvar nrightarrow = \"↛\";\nvar nRightarrow = \"⇏\";\nvar nrtri = \"⋫\";\nvar nrtrie = \"⋭\";\nvar nsc = \"⊁\";\nvar nsccue = \"⋡\";\nvar nsce = \"⪰̸\";\nvar Nscr = \"𝒩\";\nvar nscr = \"𝓃\";\nvar nshortmid = \"∤\";\nvar nshortparallel = \"∦\";\nvar nsim = \"≁\";\nvar nsime = \"≄\";\nvar nsimeq = \"≄\";\nvar nsmid = \"∤\";\nvar nspar = \"∦\";\nvar nsqsube = \"⋢\";\nvar nsqsupe = \"⋣\";\nvar nsub = \"⊄\";\nvar nsubE = \"⫅̸\";\nvar nsube = \"⊈\";\nvar nsubset = \"⊂⃒\";\nvar nsubseteq = \"⊈\";\nvar nsubseteqq = \"⫅̸\";\nvar nsucc = \"⊁\";\nvar nsucceq = \"⪰̸\";\nvar nsup = \"⊅\";\nvar nsupE = \"⫆̸\";\nvar nsupe = \"⊉\";\nvar nsupset = \"⊃⃒\";\nvar nsupseteq = \"⊉\";\nvar nsupseteqq = \"⫆̸\";\nvar ntgl = \"≹\";\nvar Ntilde$1 = \"Ñ\";\nvar ntilde$1 = \"ñ\";\nvar ntlg = \"≸\";\nvar ntriangleleft = \"⋪\";\nvar ntrianglelefteq = \"⋬\";\nvar ntriangleright = \"⋫\";\nvar ntrianglerighteq = \"⋭\";\nvar Nu = \"Ν\";\nvar nu = \"ν\";\nvar num = \"#\";\nvar numero = \"№\";\nvar numsp = \" \";\nvar nvap = \"≍⃒\";\nvar nvdash = \"⊬\";\nvar nvDash = \"⊭\";\nvar nVdash = \"⊮\";\nvar nVDash = \"⊯\";\nvar nvge = \"≥⃒\";\nvar nvgt = \">⃒\";\nvar nvHarr = \"⤄\";\nvar nvinfin = \"⧞\";\nvar nvlArr = \"⤂\";\nvar nvle = \"≤⃒\";\nvar nvlt = \"<⃒\";\nvar nvltrie = \"⊴⃒\";\nvar nvrArr = \"⤃\";\nvar nvrtrie = \"⊵⃒\";\nvar nvsim = \"∼⃒\";\nvar nwarhk = \"⤣\";\nvar nwarr = \"↖\";\nvar nwArr = \"⇖\";\nvar nwarrow = \"↖\";\nvar nwnear = \"⤧\";\nvar Oacute$1 = \"Ó\";\nvar oacute$1 = \"ó\";\nvar oast = \"⊛\";\nvar Ocirc$1 = \"Ô\";\nvar ocirc$1 = \"ô\";\nvar ocir = \"⊚\";\nvar Ocy = \"О\";\nvar ocy = \"о\";\nvar odash = \"⊝\";\nvar Odblac = \"Ő\";\nvar odblac = \"ő\";\nvar odiv = \"⨸\";\nvar odot = \"⊙\";\nvar odsold = \"⦼\";\nvar OElig = \"Œ\";\nvar oelig = \"œ\";\nvar ofcir = \"⦿\";\nvar Ofr = \"𝔒\";\nvar ofr = \"𝔬\";\nvar ogon = \"˛\";\nvar Ograve$1 = \"Ò\";\nvar ograve$1 = \"ò\";\nvar ogt = \"⧁\";\nvar ohbar = \"⦵\";\nvar ohm = \"Ω\";\nvar oint = \"∮\";\nvar olarr = \"↺\";\nvar olcir = \"⦾\";\nvar olcross = \"⦻\";\nvar oline = \"‾\";\nvar olt = \"⧀\";\nvar Omacr = \"Ō\";\nvar omacr = \"ō\";\nvar Omega = \"Ω\";\nvar omega = \"ω\";\nvar Omicron = \"Ο\";\nvar omicron = \"ο\";\nvar omid = \"⦶\";\nvar ominus = \"⊖\";\nvar Oopf = \"𝕆\";\nvar oopf = \"𝕠\";\nvar opar = \"⦷\";\nvar OpenCurlyDoubleQuote = \"“\";\nvar OpenCurlyQuote = \"‘\";\nvar operp = \"⦹\";\nvar oplus = \"⊕\";\nvar orarr = \"↻\";\nvar Or = \"⩔\";\nvar or = \"∨\";\nvar ord = \"⩝\";\nvar order = \"ℴ\";\nvar orderof = \"ℴ\";\nvar ordf$1 = \"ª\";\nvar ordm$1 = \"º\";\nvar origof = \"⊶\";\nvar oror = \"⩖\";\nvar orslope = \"⩗\";\nvar orv = \"⩛\";\nvar oS = \"Ⓢ\";\nvar Oscr = \"𝒪\";\nvar oscr = \"ℴ\";\nvar Oslash$1 = \"Ø\";\nvar oslash$1 = \"ø\";\nvar osol = \"⊘\";\nvar Otilde$1 = \"Õ\";\nvar otilde$1 = \"õ\";\nvar otimesas = \"⨶\";\nvar Otimes = \"⨷\";\nvar otimes = \"⊗\";\nvar Ouml$1 = \"Ö\";\nvar ouml$1 = \"ö\";\nvar ovbar = \"⌽\";\nvar OverBar = \"‾\";\nvar OverBrace = \"⏞\";\nvar OverBracket = \"⎴\";\nvar OverParenthesis = \"⏜\";\nvar para$1 = \"¶\";\nvar parallel = \"∥\";\nvar par = \"∥\";\nvar parsim = \"⫳\";\nvar parsl = \"⫽\";\nvar part = \"∂\";\nvar PartialD = \"∂\";\nvar Pcy = \"П\";\nvar pcy = \"п\";\nvar percnt = \"%\";\nvar period = \".\";\nvar permil = \"‰\";\nvar perp = \"⊥\";\nvar pertenk = \"‱\";\nvar Pfr = \"𝔓\";\nvar pfr = \"𝔭\";\nvar Phi = \"Φ\";\nvar phi = \"φ\";\nvar phiv = \"ϕ\";\nvar phmmat = \"ℳ\";\nvar phone = \"☎\";\nvar Pi = \"Π\";\nvar pi = \"π\";\nvar pitchfork = \"⋔\";\nvar piv = \"ϖ\";\nvar planck = \"ℏ\";\nvar planckh = \"ℎ\";\nvar plankv = \"ℏ\";\nvar plusacir = \"⨣\";\nvar plusb = \"⊞\";\nvar pluscir = \"⨢\";\nvar plus = \"+\";\nvar plusdo = \"∔\";\nvar plusdu = \"⨥\";\nvar pluse = \"⩲\";\nvar PlusMinus = \"±\";\nvar plusmn$1 = \"±\";\nvar plussim = \"⨦\";\nvar plustwo = \"⨧\";\nvar pm = \"±\";\nvar Poincareplane = \"ℌ\";\nvar pointint = \"⨕\";\nvar popf = \"𝕡\";\nvar Popf = \"ℙ\";\nvar pound$1 = \"£\";\nvar prap = \"⪷\";\nvar Pr = \"⪻\";\nvar pr = \"≺\";\nvar prcue = \"≼\";\nvar precapprox = \"⪷\";\nvar prec = \"≺\";\nvar preccurlyeq = \"≼\";\nvar Precedes = \"≺\";\nvar PrecedesEqual = \"⪯\";\nvar PrecedesSlantEqual = \"≼\";\nvar PrecedesTilde = \"≾\";\nvar preceq = \"⪯\";\nvar precnapprox = \"⪹\";\nvar precneqq = \"⪵\";\nvar precnsim = \"⋨\";\nvar pre = \"⪯\";\nvar prE = \"⪳\";\nvar precsim = \"≾\";\nvar prime = \"′\";\nvar Prime = \"″\";\nvar primes = \"ℙ\";\nvar prnap = \"⪹\";\nvar prnE = \"⪵\";\nvar prnsim = \"⋨\";\nvar prod = \"∏\";\nvar Product = \"∏\";\nvar profalar = \"⌮\";\nvar profline = \"⌒\";\nvar profsurf = \"⌓\";\nvar prop = \"∝\";\nvar Proportional = \"∝\";\nvar Proportion = \"∷\";\nvar propto = \"∝\";\nvar prsim = \"≾\";\nvar prurel = \"⊰\";\nvar Pscr = \"𝒫\";\nvar pscr = \"𝓅\";\nvar Psi = \"Ψ\";\nvar psi = \"ψ\";\nvar puncsp = \" \";\nvar Qfr = \"𝔔\";\nvar qfr = \"𝔮\";\nvar qint = \"⨌\";\nvar qopf = \"𝕢\";\nvar Qopf = \"ℚ\";\nvar qprime = \"⁗\";\nvar Qscr = \"𝒬\";\nvar qscr = \"𝓆\";\nvar quaternions = \"ℍ\";\nvar quatint = \"⨖\";\nvar quest = \"?\";\nvar questeq = \"≟\";\nvar quot$2 = \"\\\"\";\nvar QUOT$1 = \"\\\"\";\nvar rAarr = \"⇛\";\nvar race = \"∽̱\";\nvar Racute = \"Ŕ\";\nvar racute = \"ŕ\";\nvar radic = \"√\";\nvar raemptyv = \"⦳\";\nvar rang = \"⟩\";\nvar Rang = \"⟫\";\nvar rangd = \"⦒\";\nvar range = \"⦥\";\nvar rangle = \"⟩\";\nvar raquo$1 = \"»\";\nvar rarrap = \"⥵\";\nvar rarrb = \"⇥\";\nvar rarrbfs = \"⤠\";\nvar rarrc = \"⤳\";\nvar rarr = \"→\";\nvar Rarr = \"↠\";\nvar rArr = \"⇒\";\nvar rarrfs = \"⤞\";\nvar rarrhk = \"↪\";\nvar rarrlp = \"↬\";\nvar rarrpl = \"⥅\";\nvar rarrsim = \"⥴\";\nvar Rarrtl = \"⤖\";\nvar rarrtl = \"↣\";\nvar rarrw = \"↝\";\nvar ratail = \"⤚\";\nvar rAtail = \"⤜\";\nvar ratio = \"∶\";\nvar rationals = \"ℚ\";\nvar rbarr = \"⤍\";\nvar rBarr = \"⤏\";\nvar RBarr = \"⤐\";\nvar rbbrk = \"❳\";\nvar rbrace = \"}\";\nvar rbrack = \"]\";\nvar rbrke = \"⦌\";\nvar rbrksld = \"⦎\";\nvar rbrkslu = \"⦐\";\nvar Rcaron = \"Ř\";\nvar rcaron = \"ř\";\nvar Rcedil = \"Ŗ\";\nvar rcedil = \"ŗ\";\nvar rceil = \"⌉\";\nvar rcub = \"}\";\nvar Rcy = \"Р\";\nvar rcy = \"р\";\nvar rdca = \"⤷\";\nvar rdldhar = \"⥩\";\nvar rdquo = \"”\";\nvar rdquor = \"”\";\nvar rdsh = \"↳\";\nvar real = \"ℜ\";\nvar realine = \"ℛ\";\nvar realpart = \"ℜ\";\nvar reals = \"ℝ\";\nvar Re = \"ℜ\";\nvar rect = \"▭\";\nvar reg$1 = \"®\";\nvar REG$1 = \"®\";\nvar ReverseElement = \"∋\";\nvar ReverseEquilibrium = \"⇋\";\nvar ReverseUpEquilibrium = \"⥯\";\nvar rfisht = \"⥽\";\nvar rfloor = \"⌋\";\nvar rfr = \"𝔯\";\nvar Rfr = \"ℜ\";\nvar rHar = \"⥤\";\nvar rhard = \"⇁\";\nvar rharu = \"⇀\";\nvar rharul = \"⥬\";\nvar Rho = \"Ρ\";\nvar rho = \"ρ\";\nvar rhov = \"ϱ\";\nvar RightAngleBracket = \"⟩\";\nvar RightArrowBar = \"⇥\";\nvar rightarrow = \"→\";\nvar RightArrow = \"→\";\nvar Rightarrow = \"⇒\";\nvar RightArrowLeftArrow = \"⇄\";\nvar rightarrowtail = \"↣\";\nvar RightCeiling = \"⌉\";\nvar RightDoubleBracket = \"⟧\";\nvar RightDownTeeVector = \"⥝\";\nvar RightDownVectorBar = \"⥕\";\nvar RightDownVector = \"⇂\";\nvar RightFloor = \"⌋\";\nvar rightharpoondown = \"⇁\";\nvar rightharpoonup = \"⇀\";\nvar rightleftarrows = \"⇄\";\nvar rightleftharpoons = \"⇌\";\nvar rightrightarrows = \"⇉\";\nvar rightsquigarrow = \"↝\";\nvar RightTeeArrow = \"↦\";\nvar RightTee = \"⊢\";\nvar RightTeeVector = \"⥛\";\nvar rightthreetimes = \"⋌\";\nvar RightTriangleBar = \"⧐\";\nvar RightTriangle = \"⊳\";\nvar RightTriangleEqual = \"⊵\";\nvar RightUpDownVector = \"⥏\";\nvar RightUpTeeVector = \"⥜\";\nvar RightUpVectorBar = \"⥔\";\nvar RightUpVector = \"↾\";\nvar RightVectorBar = \"⥓\";\nvar RightVector = \"⇀\";\nvar ring = \"˚\";\nvar risingdotseq = \"≓\";\nvar rlarr = \"⇄\";\nvar rlhar = \"⇌\";\nvar rlm = \"‏\";\nvar rmoustache = \"⎱\";\nvar rmoust = \"⎱\";\nvar rnmid = \"⫮\";\nvar roang = \"⟭\";\nvar roarr = \"⇾\";\nvar robrk = \"⟧\";\nvar ropar = \"⦆\";\nvar ropf = \"𝕣\";\nvar Ropf = \"ℝ\";\nvar roplus = \"⨮\";\nvar rotimes = \"⨵\";\nvar RoundImplies = \"⥰\";\nvar rpar = \")\";\nvar rpargt = \"⦔\";\nvar rppolint = \"⨒\";\nvar rrarr = \"⇉\";\nvar Rrightarrow = \"⇛\";\nvar rsaquo = \"›\";\nvar rscr = \"𝓇\";\nvar Rscr = \"ℛ\";\nvar rsh = \"↱\";\nvar Rsh = \"↱\";\nvar rsqb = \"]\";\nvar rsquo = \"’\";\nvar rsquor = \"’\";\nvar rthree = \"⋌\";\nvar rtimes = \"⋊\";\nvar rtri = \"▹\";\nvar rtrie = \"⊵\";\nvar rtrif = \"▸\";\nvar rtriltri = \"⧎\";\nvar RuleDelayed = \"⧴\";\nvar ruluhar = \"⥨\";\nvar rx = \"℞\";\nvar Sacute = \"Ś\";\nvar sacute = \"ś\";\nvar sbquo = \"‚\";\nvar scap = \"⪸\";\nvar Scaron = \"Š\";\nvar scaron = \"š\";\nvar Sc = \"⪼\";\nvar sc = \"≻\";\nvar sccue = \"≽\";\nvar sce = \"⪰\";\nvar scE = \"⪴\";\nvar Scedil = \"Ş\";\nvar scedil = \"ş\";\nvar Scirc = \"Ŝ\";\nvar scirc = \"ŝ\";\nvar scnap = \"⪺\";\nvar scnE = \"⪶\";\nvar scnsim = \"⋩\";\nvar scpolint = \"⨓\";\nvar scsim = \"≿\";\nvar Scy = \"С\";\nvar scy = \"с\";\nvar sdotb = \"⊡\";\nvar sdot = \"⋅\";\nvar sdote = \"⩦\";\nvar searhk = \"⤥\";\nvar searr = \"↘\";\nvar seArr = \"⇘\";\nvar searrow = \"↘\";\nvar sect$1 = \"§\";\nvar semi = \";\";\nvar seswar = \"⤩\";\nvar setminus = \"∖\";\nvar setmn = \"∖\";\nvar sext = \"✶\";\nvar Sfr = \"𝔖\";\nvar sfr = \"𝔰\";\nvar sfrown = \"⌢\";\nvar sharp = \"♯\";\nvar SHCHcy = \"Щ\";\nvar shchcy = \"щ\";\nvar SHcy = \"Ш\";\nvar shcy = \"ш\";\nvar ShortDownArrow = \"↓\";\nvar ShortLeftArrow = \"←\";\nvar shortmid = \"∣\";\nvar shortparallel = \"∥\";\nvar ShortRightArrow = \"→\";\nvar ShortUpArrow = \"↑\";\nvar shy$1 = \"­\";\nvar Sigma = \"Σ\";\nvar sigma = \"σ\";\nvar sigmaf = \"ς\";\nvar sigmav = \"ς\";\nvar sim = \"∼\";\nvar simdot = \"⩪\";\nvar sime = \"≃\";\nvar simeq = \"≃\";\nvar simg = \"⪞\";\nvar simgE = \"⪠\";\nvar siml = \"⪝\";\nvar simlE = \"⪟\";\nvar simne = \"≆\";\nvar simplus = \"⨤\";\nvar simrarr = \"⥲\";\nvar slarr = \"←\";\nvar SmallCircle = \"∘\";\nvar smallsetminus = \"∖\";\nvar smashp = \"⨳\";\nvar smeparsl = \"⧤\";\nvar smid = \"∣\";\nvar smile = \"⌣\";\nvar smt = \"⪪\";\nvar smte = \"⪬\";\nvar smtes = \"⪬︀\";\nvar SOFTcy = \"Ь\";\nvar softcy = \"ь\";\nvar solbar = \"⌿\";\nvar solb = \"⧄\";\nvar sol = \"/\";\nvar Sopf = \"𝕊\";\nvar sopf = \"𝕤\";\nvar spades = \"♠\";\nvar spadesuit = \"♠\";\nvar spar = \"∥\";\nvar sqcap = \"⊓\";\nvar sqcaps = \"⊓︀\";\nvar sqcup = \"⊔\";\nvar sqcups = \"⊔︀\";\nvar Sqrt = \"√\";\nvar sqsub = \"⊏\";\nvar sqsube = \"⊑\";\nvar sqsubset = \"⊏\";\nvar sqsubseteq = \"⊑\";\nvar sqsup = \"⊐\";\nvar sqsupe = \"⊒\";\nvar sqsupset = \"⊐\";\nvar sqsupseteq = \"⊒\";\nvar square = \"□\";\nvar Square = \"□\";\nvar SquareIntersection = \"⊓\";\nvar SquareSubset = \"⊏\";\nvar SquareSubsetEqual = \"⊑\";\nvar SquareSuperset = \"⊐\";\nvar SquareSupersetEqual = \"⊒\";\nvar SquareUnion = \"⊔\";\nvar squarf = \"▪\";\nvar squ = \"□\";\nvar squf = \"▪\";\nvar srarr = \"→\";\nvar Sscr = \"𝒮\";\nvar sscr = \"𝓈\";\nvar ssetmn = \"∖\";\nvar ssmile = \"⌣\";\nvar sstarf = \"⋆\";\nvar Star = \"⋆\";\nvar star = \"☆\";\nvar starf = \"★\";\nvar straightepsilon = \"ϵ\";\nvar straightphi = \"ϕ\";\nvar strns = \"¯\";\nvar sub = \"⊂\";\nvar Sub = \"⋐\";\nvar subdot = \"⪽\";\nvar subE = \"⫅\";\nvar sube = \"⊆\";\nvar subedot = \"⫃\";\nvar submult = \"⫁\";\nvar subnE = \"⫋\";\nvar subne = \"⊊\";\nvar subplus = \"⪿\";\nvar subrarr = \"⥹\";\nvar subset = \"⊂\";\nvar Subset = \"⋐\";\nvar subseteq = \"⊆\";\nvar subseteqq = \"⫅\";\nvar SubsetEqual = \"⊆\";\nvar subsetneq = \"⊊\";\nvar subsetneqq = \"⫋\";\nvar subsim = \"⫇\";\nvar subsub = \"⫕\";\nvar subsup = \"⫓\";\nvar succapprox = \"⪸\";\nvar succ = \"≻\";\nvar succcurlyeq = \"≽\";\nvar Succeeds = \"≻\";\nvar SucceedsEqual = \"⪰\";\nvar SucceedsSlantEqual = \"≽\";\nvar SucceedsTilde = \"≿\";\nvar succeq = \"⪰\";\nvar succnapprox = \"⪺\";\nvar succneqq = \"⪶\";\nvar succnsim = \"⋩\";\nvar succsim = \"≿\";\nvar SuchThat = \"∋\";\nvar sum = \"∑\";\nvar Sum = \"∑\";\nvar sung = \"♪\";\nvar sup1$1 = \"¹\";\nvar sup2$1 = \"²\";\nvar sup3$1 = \"³\";\nvar sup = \"⊃\";\nvar Sup = \"⋑\";\nvar supdot = \"⪾\";\nvar supdsub = \"⫘\";\nvar supE = \"⫆\";\nvar supe = \"⊇\";\nvar supedot = \"⫄\";\nvar Superset = \"⊃\";\nvar SupersetEqual = \"⊇\";\nvar suphsol = \"⟉\";\nvar suphsub = \"⫗\";\nvar suplarr = \"⥻\";\nvar supmult = \"⫂\";\nvar supnE = \"⫌\";\nvar supne = \"⊋\";\nvar supplus = \"⫀\";\nvar supset = \"⊃\";\nvar Supset = \"⋑\";\nvar supseteq = \"⊇\";\nvar supseteqq = \"⫆\";\nvar supsetneq = \"⊋\";\nvar supsetneqq = \"⫌\";\nvar supsim = \"⫈\";\nvar supsub = \"⫔\";\nvar supsup = \"⫖\";\nvar swarhk = \"⤦\";\nvar swarr = \"↙\";\nvar swArr = \"⇙\";\nvar swarrow = \"↙\";\nvar swnwar = \"⤪\";\nvar szlig$1 = \"ß\";\nvar Tab = \"\\t\";\nvar target = \"⌖\";\nvar Tau = \"Τ\";\nvar tau = \"τ\";\nvar tbrk = \"⎴\";\nvar Tcaron = \"Ť\";\nvar tcaron = \"ť\";\nvar Tcedil = \"Ţ\";\nvar tcedil = \"ţ\";\nvar Tcy = \"Т\";\nvar tcy = \"т\";\nvar tdot = \"⃛\";\nvar telrec = \"⌕\";\nvar Tfr = \"𝔗\";\nvar tfr = \"𝔱\";\nvar there4 = \"∴\";\nvar therefore = \"∴\";\nvar Therefore = \"∴\";\nvar Theta = \"Θ\";\nvar theta = \"θ\";\nvar thetasym = \"ϑ\";\nvar thetav = \"ϑ\";\nvar thickapprox = \"≈\";\nvar thicksim = \"∼\";\nvar ThickSpace = \"  \";\nvar ThinSpace = \" \";\nvar thinsp = \" \";\nvar thkap = \"≈\";\nvar thksim = \"∼\";\nvar THORN$1 = \"Þ\";\nvar thorn$1 = \"þ\";\nvar tilde = \"˜\";\nvar Tilde = \"∼\";\nvar TildeEqual = \"≃\";\nvar TildeFullEqual = \"≅\";\nvar TildeTilde = \"≈\";\nvar timesbar = \"⨱\";\nvar timesb = \"⊠\";\nvar times$1 = \"×\";\nvar timesd = \"⨰\";\nvar tint = \"∭\";\nvar toea = \"⤨\";\nvar topbot = \"⌶\";\nvar topcir = \"⫱\";\nvar esm_top = \"⊤\";\nvar Topf = \"𝕋\";\nvar topf = \"𝕥\";\nvar topfork = \"⫚\";\nvar tosa = \"⤩\";\nvar tprime = \"‴\";\nvar trade = \"™\";\nvar TRADE = \"™\";\nvar triangle = \"▵\";\nvar triangledown = \"▿\";\nvar triangleleft = \"◃\";\nvar trianglelefteq = \"⊴\";\nvar triangleq = \"≜\";\nvar triangleright = \"▹\";\nvar trianglerighteq = \"⊵\";\nvar tridot = \"◬\";\nvar trie = \"≜\";\nvar triminus = \"⨺\";\nvar TripleDot = \"⃛\";\nvar triplus = \"⨹\";\nvar trisb = \"⧍\";\nvar tritime = \"⨻\";\nvar trpezium = \"⏢\";\nvar Tscr = \"𝒯\";\nvar tscr = \"𝓉\";\nvar TScy = \"Ц\";\nvar tscy = \"ц\";\nvar TSHcy = \"Ћ\";\nvar tshcy = \"ћ\";\nvar Tstrok = \"Ŧ\";\nvar tstrok = \"ŧ\";\nvar twixt = \"≬\";\nvar twoheadleftarrow = \"↞\";\nvar twoheadrightarrow = \"↠\";\nvar Uacute$1 = \"Ú\";\nvar uacute$1 = \"ú\";\nvar uarr = \"↑\";\nvar Uarr = \"↟\";\nvar uArr = \"⇑\";\nvar Uarrocir = \"⥉\";\nvar Ubrcy = \"Ў\";\nvar ubrcy = \"ў\";\nvar Ubreve = \"Ŭ\";\nvar ubreve = \"ŭ\";\nvar Ucirc$1 = \"Û\";\nvar ucirc$1 = \"û\";\nvar Ucy = \"У\";\nvar ucy = \"у\";\nvar udarr = \"⇅\";\nvar Udblac = \"Ű\";\nvar udblac = \"ű\";\nvar udhar = \"⥮\";\nvar ufisht = \"⥾\";\nvar Ufr = \"𝔘\";\nvar ufr = \"𝔲\";\nvar Ugrave$1 = \"Ù\";\nvar ugrave$1 = \"ù\";\nvar uHar = \"⥣\";\nvar uharl = \"↿\";\nvar uharr = \"↾\";\nvar uhblk = \"▀\";\nvar ulcorn = \"⌜\";\nvar ulcorner = \"⌜\";\nvar ulcrop = \"⌏\";\nvar ultri = \"◸\";\nvar Umacr = \"Ū\";\nvar umacr = \"ū\";\nvar uml$1 = \"¨\";\nvar UnderBar = \"_\";\nvar UnderBrace = \"⏟\";\nvar UnderBracket = \"⎵\";\nvar UnderParenthesis = \"⏝\";\nvar Union = \"⋃\";\nvar UnionPlus = \"⊎\";\nvar Uogon = \"Ų\";\nvar uogon = \"ų\";\nvar Uopf = \"𝕌\";\nvar uopf = \"𝕦\";\nvar UpArrowBar = \"⤒\";\nvar uparrow = \"↑\";\nvar UpArrow = \"↑\";\nvar Uparrow = \"⇑\";\nvar UpArrowDownArrow = \"⇅\";\nvar updownarrow = \"↕\";\nvar UpDownArrow = \"↕\";\nvar Updownarrow = \"⇕\";\nvar UpEquilibrium = \"⥮\";\nvar upharpoonleft = \"↿\";\nvar upharpoonright = \"↾\";\nvar uplus = \"⊎\";\nvar UpperLeftArrow = \"↖\";\nvar UpperRightArrow = \"↗\";\nvar upsi = \"υ\";\nvar Upsi = \"ϒ\";\nvar upsih = \"ϒ\";\nvar Upsilon = \"Υ\";\nvar upsilon = \"υ\";\nvar UpTeeArrow = \"↥\";\nvar UpTee = \"⊥\";\nvar upuparrows = \"⇈\";\nvar urcorn = \"⌝\";\nvar urcorner = \"⌝\";\nvar urcrop = \"⌎\";\nvar Uring = \"Ů\";\nvar uring = \"ů\";\nvar urtri = \"◹\";\nvar Uscr = \"𝒰\";\nvar uscr = \"𝓊\";\nvar utdot = \"⋰\";\nvar Utilde = \"Ũ\";\nvar utilde = \"ũ\";\nvar utri = \"▵\";\nvar utrif = \"▴\";\nvar uuarr = \"⇈\";\nvar Uuml$1 = \"Ü\";\nvar uuml$1 = \"ü\";\nvar uwangle = \"⦧\";\nvar vangrt = \"⦜\";\nvar varepsilon = \"ϵ\";\nvar varkappa = \"ϰ\";\nvar varnothing = \"∅\";\nvar varphi = \"ϕ\";\nvar varpi = \"ϖ\";\nvar varpropto = \"∝\";\nvar varr = \"↕\";\nvar vArr = \"⇕\";\nvar varrho = \"ϱ\";\nvar varsigma = \"ς\";\nvar varsubsetneq = \"⊊︀\";\nvar varsubsetneqq = \"⫋︀\";\nvar varsupsetneq = \"⊋︀\";\nvar varsupsetneqq = \"⫌︀\";\nvar vartheta = \"ϑ\";\nvar vartriangleleft = \"⊲\";\nvar vartriangleright = \"⊳\";\nvar vBar = \"⫨\";\nvar Vbar = \"⫫\";\nvar vBarv = \"⫩\";\nvar Vcy = \"В\";\nvar vcy = \"в\";\nvar vdash = \"⊢\";\nvar vDash = \"⊨\";\nvar Vdash = \"⊩\";\nvar VDash = \"⊫\";\nvar Vdashl = \"⫦\";\nvar veebar = \"⊻\";\nvar vee = \"∨\";\nvar Vee = \"⋁\";\nvar veeeq = \"≚\";\nvar vellip = \"⋮\";\nvar verbar = \"|\";\nvar Verbar = \"‖\";\nvar vert = \"|\";\nvar Vert = \"‖\";\nvar VerticalBar = \"∣\";\nvar VerticalLine = \"|\";\nvar VerticalSeparator = \"❘\";\nvar VerticalTilde = \"≀\";\nvar VeryThinSpace = \" \";\nvar Vfr = \"𝔙\";\nvar vfr = \"𝔳\";\nvar vltri = \"⊲\";\nvar vnsub = \"⊂⃒\";\nvar vnsup = \"⊃⃒\";\nvar Vopf = \"𝕍\";\nvar vopf = \"𝕧\";\nvar vprop = \"∝\";\nvar vrtri = \"⊳\";\nvar Vscr = \"𝒱\";\nvar vscr = \"𝓋\";\nvar vsubnE = \"⫋︀\";\nvar vsubne = \"⊊︀\";\nvar vsupnE = \"⫌︀\";\nvar vsupne = \"⊋︀\";\nvar Vvdash = \"⊪\";\nvar vzigzag = \"⦚\";\nvar Wcirc = \"Ŵ\";\nvar wcirc = \"ŵ\";\nvar wedbar = \"⩟\";\nvar wedge = \"∧\";\nvar Wedge = \"⋀\";\nvar wedgeq = \"≙\";\nvar weierp = \"℘\";\nvar Wfr = \"𝔚\";\nvar wfr = \"𝔴\";\nvar Wopf = \"𝕎\";\nvar wopf = \"𝕨\";\nvar wp = \"℘\";\nvar wr = \"≀\";\nvar wreath = \"≀\";\nvar Wscr = \"𝒲\";\nvar wscr = \"𝓌\";\nvar xcap = \"⋂\";\nvar xcirc = \"◯\";\nvar xcup = \"⋃\";\nvar xdtri = \"▽\";\nvar Xfr = \"𝔛\";\nvar xfr = \"𝔵\";\nvar xharr = \"⟷\";\nvar xhArr = \"⟺\";\nvar Xi = \"Ξ\";\nvar xi = \"ξ\";\nvar xlarr = \"⟵\";\nvar xlArr = \"⟸\";\nvar xmap = \"⟼\";\nvar xnis = \"⋻\";\nvar xodot = \"⨀\";\nvar Xopf = \"𝕏\";\nvar xopf = \"𝕩\";\nvar xoplus = \"⨁\";\nvar xotime = \"⨂\";\nvar xrarr = \"⟶\";\nvar xrArr = \"⟹\";\nvar Xscr = \"𝒳\";\nvar xscr = \"𝓍\";\nvar xsqcup = \"⨆\";\nvar xuplus = \"⨄\";\nvar xutri = \"△\";\nvar xvee = \"⋁\";\nvar xwedge = \"⋀\";\nvar Yacute$1 = \"Ý\";\nvar yacute$1 = \"ý\";\nvar YAcy = \"Я\";\nvar yacy = \"я\";\nvar Ycirc = \"Ŷ\";\nvar ycirc = \"ŷ\";\nvar Ycy = \"Ы\";\nvar ycy = \"ы\";\nvar yen$1 = \"¥\";\nvar Yfr = \"𝔜\";\nvar yfr = \"𝔶\";\nvar YIcy = \"Ї\";\nvar yicy = \"ї\";\nvar Yopf = \"𝕐\";\nvar yopf = \"𝕪\";\nvar Yscr = \"𝒴\";\nvar yscr = \"𝓎\";\nvar YUcy = \"Ю\";\nvar yucy = \"ю\";\nvar yuml$1 = \"ÿ\";\nvar Yuml = \"Ÿ\";\nvar Zacute = \"Ź\";\nvar zacute = \"ź\";\nvar Zcaron = \"Ž\";\nvar zcaron = \"ž\";\nvar Zcy = \"З\";\nvar zcy = \"з\";\nvar Zdot = \"Ż\";\nvar zdot = \"ż\";\nvar zeetrf = \"ℨ\";\nvar ZeroWidthSpace = \"​\";\nvar Zeta = \"Ζ\";\nvar zeta = \"ζ\";\nvar zfr = \"𝔷\";\nvar Zfr = \"ℨ\";\nvar ZHcy = \"Ж\";\nvar zhcy = \"ж\";\nvar zigrarr = \"⇝\";\nvar zopf = \"𝕫\";\nvar Zopf = \"ℤ\";\nvar Zscr = \"𝒵\";\nvar zscr = \"𝓏\";\nvar zwj = \"‍\";\nvar zwnj = \"‌\";\nvar require$$1$1 = {\n    Aacute: Aacute$1,\n    aacute: aacute$1,\n    Abreve: Abreve,\n    abreve: abreve,\n    ac: ac,\n    acd: acd,\n    acE: acE,\n    Acirc: Acirc$1,\n    acirc: acirc$1,\n    acute: acute$1,\n    Acy: Acy,\n    acy: acy,\n    AElig: AElig$1,\n    aelig: aelig$1,\n    af: af,\n    Afr: Afr,\n    afr: afr,\n    Agrave: Agrave$1,\n    agrave: agrave$1,\n    alefsym: alefsym,\n    aleph: aleph,\n    Alpha: Alpha,\n    alpha: alpha,\n    Amacr: Amacr,\n    amacr: amacr,\n    amalg: amalg,\n    amp: amp$2,\n    AMP: AMP$1,\n    andand: andand,\n    And: And,\n    and: and,\n    andd: andd,\n    andslope: andslope,\n    andv: andv,\n    ang: ang,\n    ange: ange,\n    angle: angle,\n    angmsdaa: angmsdaa,\n    angmsdab: angmsdab,\n    angmsdac: angmsdac,\n    angmsdad: angmsdad,\n    angmsdae: angmsdae,\n    angmsdaf: angmsdaf,\n    angmsdag: angmsdag,\n    angmsdah: angmsdah,\n    angmsd: angmsd,\n    angrt: angrt,\n    angrtvb: angrtvb,\n    angrtvbd: angrtvbd,\n    angsph: angsph,\n    angst: angst,\n    angzarr: angzarr,\n    Aogon: Aogon,\n    aogon: aogon,\n    Aopf: Aopf,\n    aopf: aopf,\n    apacir: apacir,\n    ap: ap,\n    apE: apE,\n    ape: ape,\n    apid: apid,\n    apos: apos$1,\n    ApplyFunction: ApplyFunction,\n    approx: approx,\n    approxeq: approxeq,\n    Aring: Aring$1,\n    aring: aring$1,\n    Ascr: Ascr,\n    ascr: ascr,\n    Assign: Assign,\n    ast: ast,\n    asymp: asymp,\n    asympeq: asympeq,\n    Atilde: Atilde$1,\n    atilde: atilde$1,\n    Auml: Auml$1,\n    auml: auml$1,\n    awconint: awconint,\n    awint: awint,\n    backcong: backcong,\n    backepsilon: backepsilon,\n    backprime: backprime,\n    backsim: backsim,\n    backsimeq: backsimeq,\n    Backslash: Backslash,\n    Barv: Barv,\n    barvee: barvee,\n    barwed: barwed,\n    Barwed: Barwed,\n    barwedge: barwedge,\n    bbrk: bbrk,\n    bbrktbrk: bbrktbrk,\n    bcong: bcong,\n    Bcy: Bcy,\n    bcy: bcy,\n    bdquo: bdquo,\n    becaus: becaus,\n    because: because,\n    Because: Because,\n    bemptyv: bemptyv,\n    bepsi: bepsi,\n    bernou: bernou,\n    Bernoullis: Bernoullis,\n    Beta: Beta,\n    beta: beta,\n    beth: beth,\n    between: between,\n    Bfr: Bfr,\n    bfr: bfr,\n    bigcap: bigcap,\n    bigcirc: bigcirc,\n    bigcup: bigcup,\n    bigodot: bigodot,\n    bigoplus: bigoplus,\n    bigotimes: bigotimes,\n    bigsqcup: bigsqcup,\n    bigstar: bigstar,\n    bigtriangledown: bigtriangledown,\n    bigtriangleup: bigtriangleup,\n    biguplus: biguplus,\n    bigvee: bigvee,\n    bigwedge: bigwedge,\n    bkarow: bkarow,\n    blacklozenge: blacklozenge,\n    blacksquare: blacksquare,\n    blacktriangle: blacktriangle,\n    blacktriangledown: blacktriangledown,\n    blacktriangleleft: blacktriangleleft,\n    blacktriangleright: blacktriangleright,\n    blank: blank,\n    blk12: blk12,\n    blk14: blk14,\n    blk34: blk34,\n    block: block,\n    bne: bne,\n    bnequiv: bnequiv,\n    bNot: bNot,\n    bnot: bnot,\n    Bopf: Bopf,\n    bopf: bopf,\n    bot: bot,\n    bottom: bottom,\n    bowtie: bowtie,\n    boxbox: boxbox,\n    boxdl: boxdl,\n    boxdL: boxdL,\n    boxDl: boxDl,\n    boxDL: boxDL,\n    boxdr: boxdr,\n    boxdR: boxdR,\n    boxDr: boxDr,\n    boxDR: boxDR,\n    boxh: boxh,\n    boxH: boxH,\n    boxhd: boxhd,\n    boxHd: boxHd,\n    boxhD: boxhD,\n    boxHD: boxHD,\n    boxhu: boxhu,\n    boxHu: boxHu,\n    boxhU: boxhU,\n    boxHU: boxHU,\n    boxminus: boxminus,\n    boxplus: boxplus,\n    boxtimes: boxtimes,\n    boxul: boxul,\n    boxuL: boxuL,\n    boxUl: boxUl,\n    boxUL: boxUL,\n    boxur: boxur,\n    boxuR: boxuR,\n    boxUr: boxUr,\n    boxUR: boxUR,\n    boxv: boxv,\n    boxV: boxV,\n    boxvh: boxvh,\n    boxvH: boxvH,\n    boxVh: boxVh,\n    boxVH: boxVH,\n    boxvl: boxvl,\n    boxvL: boxvL,\n    boxVl: boxVl,\n    boxVL: boxVL,\n    boxvr: boxvr,\n    boxvR: boxvR,\n    boxVr: boxVr,\n    boxVR: boxVR,\n    bprime: bprime,\n    breve: breve,\n    Breve: Breve,\n    brvbar: brvbar$1,\n    bscr: bscr,\n    Bscr: Bscr,\n    bsemi: bsemi,\n    bsim: bsim,\n    bsime: bsime,\n    bsolb: bsolb,\n    bsol: bsol,\n    bsolhsub: bsolhsub,\n    bull: bull,\n    bullet: bullet,\n    bump: bump,\n    bumpE: bumpE,\n    bumpe: bumpe,\n    Bumpeq: Bumpeq,\n    bumpeq: bumpeq,\n    Cacute: Cacute,\n    cacute: cacute,\n    capand: capand,\n    capbrcup: capbrcup,\n    capcap: capcap,\n    cap: cap,\n    Cap: Cap,\n    capcup: capcup,\n    capdot: capdot,\n    CapitalDifferentialD: CapitalDifferentialD,\n    caps: caps,\n    caret: caret,\n    caron: caron,\n    Cayleys: Cayleys,\n    ccaps: ccaps,\n    Ccaron: Ccaron,\n    ccaron: ccaron,\n    Ccedil: Ccedil$1,\n    ccedil: ccedil$1,\n    Ccirc: Ccirc,\n    ccirc: ccirc,\n    Cconint: Cconint,\n    ccups: ccups,\n    ccupssm: ccupssm,\n    Cdot: Cdot,\n    cdot: cdot,\n    cedil: cedil$1,\n    Cedilla: Cedilla,\n    cemptyv: cemptyv,\n    cent: cent$1,\n    centerdot: centerdot,\n    CenterDot: CenterDot,\n    cfr: cfr,\n    Cfr: Cfr,\n    CHcy: CHcy,\n    chcy: chcy,\n    check: check,\n    checkmark: checkmark,\n    Chi: Chi,\n    chi: chi,\n    circ: circ,\n    circeq: circeq,\n    circlearrowleft: circlearrowleft,\n    circlearrowright: circlearrowright,\n    circledast: circledast,\n    circledcirc: circledcirc,\n    circleddash: circleddash,\n    CircleDot: CircleDot,\n    circledR: circledR,\n    circledS: circledS,\n    CircleMinus: CircleMinus,\n    CirclePlus: CirclePlus,\n    CircleTimes: CircleTimes,\n    cir: cir,\n    cirE: cirE,\n    cire: cire,\n    cirfnint: cirfnint,\n    cirmid: cirmid,\n    cirscir: cirscir,\n    ClockwiseContourIntegral: ClockwiseContourIntegral,\n    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,\n    CloseCurlyQuote: CloseCurlyQuote,\n    clubs: clubs,\n    clubsuit: clubsuit,\n    colon: colon,\n    Colon: Colon,\n    Colone: Colone,\n    colone: colone,\n    coloneq: coloneq,\n    comma: comma,\n    commat: commat,\n    comp: comp,\n    compfn: compfn,\n    complement: complement,\n    complexes: complexes,\n    cong: cong,\n    congdot: congdot,\n    Congruent: Congruent,\n    conint: conint,\n    Conint: Conint,\n    ContourIntegral: ContourIntegral,\n    copf: copf,\n    Copf: Copf,\n    coprod: coprod,\n    Coproduct: Coproduct,\n    copy: copy$1,\n    COPY: COPY$1,\n    copysr: copysr,\n    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,\n    crarr: crarr,\n    cross: cross,\n    Cross: Cross,\n    Cscr: Cscr,\n    cscr: cscr,\n    csub: csub,\n    csube: csube,\n    csup: csup,\n    csupe: csupe,\n    ctdot: ctdot,\n    cudarrl: cudarrl,\n    cudarrr: cudarrr,\n    cuepr: cuepr,\n    cuesc: cuesc,\n    cularr: cularr,\n    cularrp: cularrp,\n    cupbrcap: cupbrcap,\n    cupcap: cupcap,\n    CupCap: CupCap,\n    cup: cup,\n    Cup: Cup,\n    cupcup: cupcup,\n    cupdot: cupdot,\n    cupor: cupor,\n    cups: cups,\n    curarr: curarr,\n    curarrm: curarrm,\n    curlyeqprec: curlyeqprec,\n    curlyeqsucc: curlyeqsucc,\n    curlyvee: curlyvee,\n    curlywedge: curlywedge,\n    curren: curren$1,\n    curvearrowleft: curvearrowleft,\n    curvearrowright: curvearrowright,\n    cuvee: cuvee,\n    cuwed: cuwed,\n    cwconint: cwconint,\n    cwint: cwint,\n    cylcty: cylcty,\n    dagger: dagger,\n    Dagger: Dagger,\n    daleth: daleth,\n    darr: darr,\n    Darr: Darr,\n    dArr: dArr,\n    dash: dash,\n    Dashv: Dashv,\n    dashv: dashv,\n    dbkarow: dbkarow,\n    dblac: dblac,\n    Dcaron: Dcaron,\n    dcaron: dcaron,\n    Dcy: Dcy,\n    dcy: dcy,\n    ddagger: ddagger,\n    ddarr: ddarr,\n    DD: DD,\n    dd: dd,\n    DDotrahd: DDotrahd,\n    ddotseq: ddotseq,\n    deg: deg$1,\n    Del: Del,\n    Delta: Delta,\n    delta: delta,\n    demptyv: demptyv,\n    dfisht: dfisht,\n    Dfr: Dfr,\n    dfr: dfr,\n    dHar: dHar,\n    dharl: dharl,\n    dharr: dharr,\n    DiacriticalAcute: DiacriticalAcute,\n    DiacriticalDot: DiacriticalDot,\n    DiacriticalDoubleAcute: DiacriticalDoubleAcute,\n    DiacriticalGrave: DiacriticalGrave,\n    DiacriticalTilde: DiacriticalTilde,\n    diam: diam,\n    diamond: diamond,\n    Diamond: Diamond,\n    diamondsuit: diamondsuit,\n    diams: diams,\n    die: die,\n    DifferentialD: DifferentialD,\n    digamma: digamma,\n    disin: disin,\n    div: div,\n    divide: divide$1,\n    divideontimes: divideontimes,\n    divonx: divonx,\n    DJcy: DJcy,\n    djcy: djcy,\n    dlcorn: dlcorn,\n    dlcrop: dlcrop,\n    dollar: dollar,\n    Dopf: Dopf,\n    dopf: dopf,\n    Dot: Dot,\n    dot: dot,\n    DotDot: DotDot,\n    doteq: doteq,\n    doteqdot: doteqdot,\n    DotEqual: DotEqual,\n    dotminus: dotminus,\n    dotplus: dotplus,\n    dotsquare: dotsquare,\n    doublebarwedge: doublebarwedge,\n    DoubleContourIntegral: DoubleContourIntegral,\n    DoubleDot: DoubleDot,\n    DoubleDownArrow: DoubleDownArrow,\n    DoubleLeftArrow: DoubleLeftArrow,\n    DoubleLeftRightArrow: DoubleLeftRightArrow,\n    DoubleLeftTee: DoubleLeftTee,\n    DoubleLongLeftArrow: DoubleLongLeftArrow,\n    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,\n    DoubleLongRightArrow: DoubleLongRightArrow,\n    DoubleRightArrow: DoubleRightArrow,\n    DoubleRightTee: DoubleRightTee,\n    DoubleUpArrow: DoubleUpArrow,\n    DoubleUpDownArrow: DoubleUpDownArrow,\n    DoubleVerticalBar: DoubleVerticalBar,\n    DownArrowBar: DownArrowBar,\n    downarrow: downarrow,\n    DownArrow: DownArrow,\n    Downarrow: Downarrow,\n    DownArrowUpArrow: DownArrowUpArrow,\n    DownBreve: DownBreve,\n    downdownarrows: downdownarrows,\n    downharpoonleft: downharpoonleft,\n    downharpoonright: downharpoonright,\n    DownLeftRightVector: DownLeftRightVector,\n    DownLeftTeeVector: DownLeftTeeVector,\n    DownLeftVectorBar: DownLeftVectorBar,\n    DownLeftVector: DownLeftVector,\n    DownRightTeeVector: DownRightTeeVector,\n    DownRightVectorBar: DownRightVectorBar,\n    DownRightVector: DownRightVector,\n    DownTeeArrow: DownTeeArrow,\n    DownTee: DownTee,\n    drbkarow: drbkarow,\n    drcorn: drcorn,\n    drcrop: drcrop,\n    Dscr: Dscr,\n    dscr: dscr,\n    DScy: DScy,\n    dscy: dscy,\n    dsol: dsol,\n    Dstrok: Dstrok,\n    dstrok: dstrok,\n    dtdot: dtdot,\n    dtri: dtri,\n    dtrif: dtrif,\n    duarr: duarr,\n    duhar: duhar,\n    dwangle: dwangle,\n    DZcy: DZcy,\n    dzcy: dzcy,\n    dzigrarr: dzigrarr,\n    Eacute: Eacute$1,\n    eacute: eacute$1,\n    easter: easter,\n    Ecaron: Ecaron,\n    ecaron: ecaron,\n    Ecirc: Ecirc$1,\n    ecirc: ecirc$1,\n    ecir: ecir,\n    ecolon: ecolon,\n    Ecy: Ecy,\n    ecy: ecy,\n    eDDot: eDDot,\n    Edot: Edot,\n    edot: edot,\n    eDot: eDot,\n    ee: ee,\n    efDot: efDot,\n    Efr: Efr,\n    efr: efr,\n    eg: eg,\n    Egrave: Egrave$1,\n    egrave: egrave$1,\n    egs: egs,\n    egsdot: egsdot,\n    el: el,\n    Element: Element,\n    elinters: elinters,\n    ell: ell,\n    els: els,\n    elsdot: elsdot,\n    Emacr: Emacr,\n    emacr: emacr,\n    empty: empty,\n    emptyset: emptyset,\n    EmptySmallSquare: EmptySmallSquare,\n    emptyv: emptyv,\n    EmptyVerySmallSquare: EmptyVerySmallSquare,\n    emsp13: emsp13,\n    emsp14: emsp14,\n    emsp: emsp,\n    ENG: ENG,\n    eng: eng,\n    ensp: ensp,\n    Eogon: Eogon,\n    eogon: eogon,\n    Eopf: Eopf,\n    eopf: eopf,\n    epar: epar,\n    eparsl: eparsl,\n    eplus: eplus,\n    epsi: epsi,\n    Epsilon: Epsilon,\n    epsilon: epsilon,\n    epsiv: epsiv,\n    eqcirc: eqcirc,\n    eqcolon: eqcolon,\n    eqsim: eqsim,\n    eqslantgtr: eqslantgtr,\n    eqslantless: eqslantless,\n    Equal: Equal,\n    equals: equals,\n    EqualTilde: EqualTilde,\n    equest: equest,\n    Equilibrium: Equilibrium,\n    equiv: equiv,\n    equivDD: equivDD,\n    eqvparsl: eqvparsl,\n    erarr: erarr,\n    erDot: erDot,\n    escr: escr,\n    Escr: Escr,\n    esdot: esdot,\n    Esim: Esim,\n    esim: esim,\n    Eta: Eta,\n    eta: eta,\n    ETH: ETH$1,\n    eth: eth$1,\n    Euml: Euml$1,\n    euml: euml$1,\n    euro: euro,\n    excl: excl,\n    exist: exist,\n    Exists: Exists,\n    expectation: expectation,\n    exponentiale: exponentiale,\n    ExponentialE: ExponentialE,\n    fallingdotseq: fallingdotseq,\n    Fcy: Fcy,\n    fcy: fcy,\n    female: female,\n    ffilig: ffilig,\n    fflig: fflig,\n    ffllig: ffllig,\n    Ffr: Ffr,\n    ffr: ffr,\n    filig: filig,\n    FilledSmallSquare: FilledSmallSquare,\n    FilledVerySmallSquare: FilledVerySmallSquare,\n    fjlig: fjlig,\n    flat: flat,\n    fllig: fllig,\n    fltns: fltns,\n    fnof: fnof,\n    Fopf: Fopf,\n    fopf: fopf,\n    forall: forall,\n    ForAll: ForAll,\n    fork: fork,\n    forkv: forkv,\n    Fouriertrf: Fouriertrf,\n    fpartint: fpartint,\n    frac12: frac12$1,\n    frac13: frac13,\n    frac14: frac14$1,\n    frac15: frac15,\n    frac16: frac16,\n    frac18: frac18,\n    frac23: frac23,\n    frac25: frac25,\n    frac34: frac34$1,\n    frac35: frac35,\n    frac38: frac38,\n    frac45: frac45,\n    frac56: frac56,\n    frac58: frac58,\n    frac78: frac78,\n    frasl: frasl,\n    frown: frown,\n    fscr: fscr,\n    Fscr: Fscr,\n    gacute: gacute,\n    Gamma: Gamma,\n    gamma: gamma,\n    Gammad: Gammad,\n    gammad: gammad,\n    gap: gap,\n    Gbreve: Gbreve,\n    gbreve: gbreve,\n    Gcedil: Gcedil,\n    Gcirc: Gcirc,\n    gcirc: gcirc,\n    Gcy: Gcy,\n    gcy: gcy,\n    Gdot: Gdot,\n    gdot: gdot,\n    ge: ge,\n    gE: gE,\n    gEl: gEl,\n    gel: gel,\n    geq: geq,\n    geqq: geqq,\n    geqslant: geqslant,\n    gescc: gescc,\n    ges: ges,\n    gesdot: gesdot,\n    gesdoto: gesdoto,\n    gesdotol: gesdotol,\n    gesl: gesl,\n    gesles: gesles,\n    Gfr: Gfr,\n    gfr: gfr,\n    gg: gg,\n    Gg: Gg,\n    ggg: ggg,\n    gimel: gimel,\n    GJcy: GJcy,\n    gjcy: gjcy,\n    gla: gla,\n    gl: gl,\n    glE: glE,\n    glj: glj,\n    gnap: gnap,\n    gnapprox: gnapprox,\n    gne: gne,\n    gnE: gnE,\n    gneq: gneq,\n    gneqq: gneqq,\n    gnsim: gnsim,\n    Gopf: Gopf,\n    gopf: gopf,\n    grave: grave,\n    GreaterEqual: GreaterEqual,\n    GreaterEqualLess: GreaterEqualLess,\n    GreaterFullEqual: GreaterFullEqual,\n    GreaterGreater: GreaterGreater,\n    GreaterLess: GreaterLess,\n    GreaterSlantEqual: GreaterSlantEqual,\n    GreaterTilde: GreaterTilde,\n    Gscr: Gscr,\n    gscr: gscr,\n    gsim: gsim,\n    gsime: gsime,\n    gsiml: gsiml,\n    gtcc: gtcc,\n    gtcir: gtcir,\n    gt: gt$2,\n    GT: GT$1,\n    Gt: Gt,\n    gtdot: gtdot,\n    gtlPar: gtlPar,\n    gtquest: gtquest,\n    gtrapprox: gtrapprox,\n    gtrarr: gtrarr,\n    gtrdot: gtrdot,\n    gtreqless: gtreqless,\n    gtreqqless: gtreqqless,\n    gtrless: gtrless,\n    gtrsim: gtrsim,\n    gvertneqq: gvertneqq,\n    gvnE: gvnE,\n    Hacek: Hacek,\n    hairsp: hairsp,\n    half: half,\n    hamilt: hamilt,\n    HARDcy: HARDcy,\n    hardcy: hardcy,\n    harrcir: harrcir,\n    harr: harr,\n    hArr: hArr,\n    harrw: harrw,\n    Hat: Hat,\n    hbar: hbar,\n    Hcirc: Hcirc,\n    hcirc: hcirc,\n    hearts: hearts,\n    heartsuit: heartsuit,\n    hellip: hellip,\n    hercon: hercon,\n    hfr: hfr,\n    Hfr: Hfr,\n    HilbertSpace: HilbertSpace,\n    hksearow: hksearow,\n    hkswarow: hkswarow,\n    hoarr: hoarr,\n    homtht: homtht,\n    hookleftarrow: hookleftarrow,\n    hookrightarrow: hookrightarrow,\n    hopf: hopf,\n    Hopf: Hopf,\n    horbar: horbar,\n    HorizontalLine: HorizontalLine,\n    hscr: hscr,\n    Hscr: Hscr,\n    hslash: hslash,\n    Hstrok: Hstrok,\n    hstrok: hstrok,\n    HumpDownHump: HumpDownHump,\n    HumpEqual: HumpEqual,\n    hybull: hybull,\n    hyphen: hyphen,\n    Iacute: Iacute$1,\n    iacute: iacute$1,\n    ic: ic,\n    Icirc: Icirc$1,\n    icirc: icirc$1,\n    Icy: Icy,\n    icy: icy,\n    Idot: Idot,\n    IEcy: IEcy,\n    iecy: iecy,\n    iexcl: iexcl$1,\n    iff: iff,\n    ifr: ifr,\n    Ifr: Ifr,\n    Igrave: Igrave$1,\n    igrave: igrave$1,\n    ii: ii,\n    iiiint: iiiint,\n    iiint: iiint,\n    iinfin: iinfin,\n    iiota: iiota,\n    IJlig: IJlig,\n    ijlig: ijlig,\n    Imacr: Imacr,\n    imacr: imacr,\n    image: esm_image,\n    ImaginaryI: ImaginaryI,\n    imagline: imagline,\n    imagpart: imagpart,\n    imath: imath,\n    Im: Im,\n    imof: imof,\n    imped: imped,\n    Implies: Implies,\n    incare: incare,\n    \"in\": \"∈\",\n    infin: infin,\n    infintie: infintie,\n    inodot: inodot,\n    intcal: intcal,\n    int: esm_int,\n    Int: Int,\n    integers: integers,\n    Integral: Integral,\n    intercal: intercal,\n    Intersection: Intersection,\n    intlarhk: intlarhk,\n    intprod: intprod,\n    InvisibleComma: InvisibleComma,\n    InvisibleTimes: InvisibleTimes,\n    IOcy: IOcy,\n    iocy: iocy,\n    Iogon: Iogon,\n    iogon: iogon,\n    Iopf: Iopf,\n    iopf: iopf,\n    Iota: Iota,\n    iota: iota,\n    iprod: iprod,\n    iquest: iquest$1,\n    iscr: iscr,\n    Iscr: Iscr,\n    isin: isin,\n    isindot: isindot,\n    isinE: isinE,\n    isins: isins,\n    isinsv: isinsv,\n    isinv: isinv,\n    it: it,\n    Itilde: Itilde,\n    itilde: itilde,\n    Iukcy: Iukcy,\n    iukcy: iukcy,\n    Iuml: Iuml$1,\n    iuml: iuml$1,\n    Jcirc: Jcirc,\n    jcirc: jcirc,\n    Jcy: Jcy,\n    jcy: jcy,\n    Jfr: Jfr,\n    jfr: jfr,\n    jmath: jmath,\n    Jopf: Jopf,\n    jopf: jopf,\n    Jscr: Jscr,\n    jscr: jscr,\n    Jsercy: Jsercy,\n    jsercy: jsercy,\n    Jukcy: Jukcy,\n    jukcy: jukcy,\n    Kappa: Kappa,\n    kappa: kappa,\n    kappav: kappav,\n    Kcedil: Kcedil,\n    kcedil: kcedil,\n    Kcy: Kcy,\n    kcy: kcy,\n    Kfr: Kfr,\n    kfr: kfr,\n    kgreen: kgreen,\n    KHcy: KHcy,\n    khcy: khcy,\n    KJcy: KJcy,\n    kjcy: kjcy,\n    Kopf: Kopf,\n    kopf: kopf,\n    Kscr: Kscr,\n    kscr: kscr,\n    lAarr: lAarr,\n    Lacute: Lacute,\n    lacute: lacute,\n    laemptyv: laemptyv,\n    lagran: lagran,\n    Lambda: Lambda,\n    lambda: lambda,\n    lang: lang,\n    Lang: Lang,\n    langd: langd,\n    langle: langle,\n    lap: lap,\n    Laplacetrf: Laplacetrf,\n    laquo: laquo$1,\n    larrb: larrb,\n    larrbfs: larrbfs,\n    larr: larr,\n    Larr: Larr,\n    lArr: lArr,\n    larrfs: larrfs,\n    larrhk: larrhk,\n    larrlp: larrlp,\n    larrpl: larrpl,\n    larrsim: larrsim,\n    larrtl: larrtl,\n    latail: latail,\n    lAtail: lAtail,\n    lat: lat,\n    late: late,\n    lates: lates,\n    lbarr: lbarr,\n    lBarr: lBarr,\n    lbbrk: lbbrk,\n    lbrace: lbrace,\n    lbrack: lbrack,\n    lbrke: lbrke,\n    lbrksld: lbrksld,\n    lbrkslu: lbrkslu,\n    Lcaron: Lcaron,\n    lcaron: lcaron,\n    Lcedil: Lcedil,\n    lcedil: lcedil,\n    lceil: lceil,\n    lcub: lcub,\n    Lcy: Lcy,\n    lcy: lcy,\n    ldca: ldca,\n    ldquo: ldquo,\n    ldquor: ldquor,\n    ldrdhar: ldrdhar,\n    ldrushar: ldrushar,\n    ldsh: ldsh,\n    le: le,\n    lE: lE,\n    LeftAngleBracket: LeftAngleBracket,\n    LeftArrowBar: LeftArrowBar,\n    leftarrow: leftarrow,\n    LeftArrow: LeftArrow,\n    Leftarrow: Leftarrow,\n    LeftArrowRightArrow: LeftArrowRightArrow,\n    leftarrowtail: leftarrowtail,\n    LeftCeiling: LeftCeiling,\n    LeftDoubleBracket: LeftDoubleBracket,\n    LeftDownTeeVector: LeftDownTeeVector,\n    LeftDownVectorBar: LeftDownVectorBar,\n    LeftDownVector: LeftDownVector,\n    LeftFloor: LeftFloor,\n    leftharpoondown: leftharpoondown,\n    leftharpoonup: leftharpoonup,\n    leftleftarrows: leftleftarrows,\n    leftrightarrow: leftrightarrow,\n    LeftRightArrow: LeftRightArrow,\n    Leftrightarrow: Leftrightarrow,\n    leftrightarrows: leftrightarrows,\n    leftrightharpoons: leftrightharpoons,\n    leftrightsquigarrow: leftrightsquigarrow,\n    LeftRightVector: LeftRightVector,\n    LeftTeeArrow: LeftTeeArrow,\n    LeftTee: LeftTee,\n    LeftTeeVector: LeftTeeVector,\n    leftthreetimes: leftthreetimes,\n    LeftTriangleBar: LeftTriangleBar,\n    LeftTriangle: LeftTriangle,\n    LeftTriangleEqual: LeftTriangleEqual,\n    LeftUpDownVector: LeftUpDownVector,\n    LeftUpTeeVector: LeftUpTeeVector,\n    LeftUpVectorBar: LeftUpVectorBar,\n    LeftUpVector: LeftUpVector,\n    LeftVectorBar: LeftVectorBar,\n    LeftVector: LeftVector,\n    lEg: lEg,\n    leg: leg,\n    leq: leq,\n    leqq: leqq,\n    leqslant: leqslant,\n    lescc: lescc,\n    les: les,\n    lesdot: lesdot,\n    lesdoto: lesdoto,\n    lesdotor: lesdotor,\n    lesg: lesg,\n    lesges: lesges,\n    lessapprox: lessapprox,\n    lessdot: lessdot,\n    lesseqgtr: lesseqgtr,\n    lesseqqgtr: lesseqqgtr,\n    LessEqualGreater: LessEqualGreater,\n    LessFullEqual: LessFullEqual,\n    LessGreater: LessGreater,\n    lessgtr: lessgtr,\n    LessLess: LessLess,\n    lesssim: lesssim,\n    LessSlantEqual: LessSlantEqual,\n    LessTilde: LessTilde,\n    lfisht: lfisht,\n    lfloor: lfloor,\n    Lfr: Lfr,\n    lfr: lfr,\n    lg: lg,\n    lgE: lgE,\n    lHar: lHar,\n    lhard: lhard,\n    lharu: lharu,\n    lharul: lharul,\n    lhblk: lhblk,\n    LJcy: LJcy,\n    ljcy: ljcy,\n    llarr: llarr,\n    ll: ll,\n    Ll: Ll,\n    llcorner: llcorner,\n    Lleftarrow: Lleftarrow,\n    llhard: llhard,\n    lltri: lltri,\n    Lmidot: Lmidot,\n    lmidot: lmidot,\n    lmoustache: lmoustache,\n    lmoust: lmoust,\n    lnap: lnap,\n    lnapprox: lnapprox,\n    lne: lne,\n    lnE: lnE,\n    lneq: lneq,\n    lneqq: lneqq,\n    lnsim: lnsim,\n    loang: loang,\n    loarr: loarr,\n    lobrk: lobrk,\n    longleftarrow: longleftarrow,\n    LongLeftArrow: LongLeftArrow,\n    Longleftarrow: Longleftarrow,\n    longleftrightarrow: longleftrightarrow,\n    LongLeftRightArrow: LongLeftRightArrow,\n    Longleftrightarrow: Longleftrightarrow,\n    longmapsto: longmapsto,\n    longrightarrow: longrightarrow,\n    LongRightArrow: LongRightArrow,\n    Longrightarrow: Longrightarrow,\n    looparrowleft: looparrowleft,\n    looparrowright: looparrowright,\n    lopar: lopar,\n    Lopf: Lopf,\n    lopf: lopf,\n    loplus: loplus,\n    lotimes: lotimes,\n    lowast: lowast,\n    lowbar: lowbar,\n    LowerLeftArrow: LowerLeftArrow,\n    LowerRightArrow: LowerRightArrow,\n    loz: loz,\n    lozenge: lozenge,\n    lozf: lozf,\n    lpar: lpar,\n    lparlt: lparlt,\n    lrarr: lrarr,\n    lrcorner: lrcorner,\n    lrhar: lrhar,\n    lrhard: lrhard,\n    lrm: lrm,\n    lrtri: lrtri,\n    lsaquo: lsaquo,\n    lscr: lscr,\n    Lscr: Lscr,\n    lsh: lsh,\n    Lsh: Lsh,\n    lsim: lsim,\n    lsime: lsime,\n    lsimg: lsimg,\n    lsqb: lsqb,\n    lsquo: lsquo,\n    lsquor: lsquor,\n    Lstrok: Lstrok,\n    lstrok: lstrok,\n    ltcc: ltcc,\n    ltcir: ltcir,\n    lt: lt$2,\n    LT: LT$1,\n    Lt: Lt,\n    ltdot: ltdot,\n    lthree: lthree,\n    ltimes: ltimes,\n    ltlarr: ltlarr,\n    ltquest: ltquest,\n    ltri: ltri,\n    ltrie: ltrie,\n    ltrif: ltrif,\n    ltrPar: ltrPar,\n    lurdshar: lurdshar,\n    luruhar: luruhar,\n    lvertneqq: lvertneqq,\n    lvnE: lvnE,\n    macr: macr$1,\n    male: male,\n    malt: malt,\n    maltese: maltese,\n    \"Map\": \"⤅\",\n    map: map,\n    mapsto: mapsto,\n    mapstodown: mapstodown,\n    mapstoleft: mapstoleft,\n    mapstoup: mapstoup,\n    marker: marker,\n    mcomma: mcomma,\n    Mcy: Mcy,\n    mcy: mcy,\n    mdash: mdash,\n    mDDot: mDDot,\n    measuredangle: measuredangle,\n    MediumSpace: MediumSpace,\n    Mellintrf: Mellintrf,\n    Mfr: Mfr,\n    mfr: mfr,\n    mho: mho,\n    micro: micro$1,\n    midast: midast,\n    midcir: midcir,\n    mid: mid,\n    middot: middot$1,\n    minusb: minusb,\n    minus: minus,\n    minusd: minusd,\n    minusdu: minusdu,\n    MinusPlus: MinusPlus,\n    mlcp: mlcp,\n    mldr: mldr,\n    mnplus: mnplus,\n    models: models,\n    Mopf: Mopf,\n    mopf: mopf,\n    mp: mp,\n    mscr: mscr,\n    Mscr: Mscr,\n    mstpos: mstpos,\n    Mu: Mu,\n    mu: mu,\n    multimap: multimap,\n    mumap: mumap,\n    nabla: nabla,\n    Nacute: Nacute,\n    nacute: nacute,\n    nang: nang,\n    nap: nap,\n    napE: napE,\n    napid: napid,\n    napos: napos,\n    napprox: napprox,\n    natural: natural,\n    naturals: naturals,\n    natur: natur,\n    nbsp: nbsp$1,\n    nbump: nbump,\n    nbumpe: nbumpe,\n    ncap: ncap,\n    Ncaron: Ncaron,\n    ncaron: ncaron,\n    Ncedil: Ncedil,\n    ncedil: ncedil,\n    ncong: ncong,\n    ncongdot: ncongdot,\n    ncup: ncup,\n    Ncy: Ncy,\n    ncy: ncy,\n    ndash: ndash,\n    nearhk: nearhk,\n    nearr: nearr,\n    neArr: neArr,\n    nearrow: nearrow,\n    ne: ne,\n    nedot: nedot,\n    NegativeMediumSpace: NegativeMediumSpace,\n    NegativeThickSpace: NegativeThickSpace,\n    NegativeThinSpace: NegativeThinSpace,\n    NegativeVeryThinSpace: NegativeVeryThinSpace,\n    nequiv: nequiv,\n    nesear: nesear,\n    nesim: nesim,\n    NestedGreaterGreater: NestedGreaterGreater,\n    NestedLessLess: NestedLessLess,\n    NewLine: NewLine,\n    nexist: nexist,\n    nexists: nexists,\n    Nfr: Nfr,\n    nfr: nfr,\n    ngE: ngE,\n    nge: nge,\n    ngeq: ngeq,\n    ngeqq: ngeqq,\n    ngeqslant: ngeqslant,\n    nges: nges,\n    nGg: nGg,\n    ngsim: ngsim,\n    nGt: nGt,\n    ngt: ngt,\n    ngtr: ngtr,\n    nGtv: nGtv,\n    nharr: nharr,\n    nhArr: nhArr,\n    nhpar: nhpar,\n    ni: ni,\n    nis: nis,\n    nisd: nisd,\n    niv: niv,\n    NJcy: NJcy,\n    njcy: njcy,\n    nlarr: nlarr,\n    nlArr: nlArr,\n    nldr: nldr,\n    nlE: nlE,\n    nle: nle,\n    nleftarrow: nleftarrow,\n    nLeftarrow: nLeftarrow,\n    nleftrightarrow: nleftrightarrow,\n    nLeftrightarrow: nLeftrightarrow,\n    nleq: nleq,\n    nleqq: nleqq,\n    nleqslant: nleqslant,\n    nles: nles,\n    nless: nless,\n    nLl: nLl,\n    nlsim: nlsim,\n    nLt: nLt,\n    nlt: nlt,\n    nltri: nltri,\n    nltrie: nltrie,\n    nLtv: nLtv,\n    nmid: nmid,\n    NoBreak: NoBreak,\n    NonBreakingSpace: NonBreakingSpace,\n    nopf: nopf,\n    Nopf: Nopf,\n    Not: Not,\n    not: not$1,\n    NotCongruent: NotCongruent,\n    NotCupCap: NotCupCap,\n    NotDoubleVerticalBar: NotDoubleVerticalBar,\n    NotElement: NotElement,\n    NotEqual: NotEqual,\n    NotEqualTilde: NotEqualTilde,\n    NotExists: NotExists,\n    NotGreater: NotGreater,\n    NotGreaterEqual: NotGreaterEqual,\n    NotGreaterFullEqual: NotGreaterFullEqual,\n    NotGreaterGreater: NotGreaterGreater,\n    NotGreaterLess: NotGreaterLess,\n    NotGreaterSlantEqual: NotGreaterSlantEqual,\n    NotGreaterTilde: NotGreaterTilde,\n    NotHumpDownHump: NotHumpDownHump,\n    NotHumpEqual: NotHumpEqual,\n    notin: notin,\n    notindot: notindot,\n    notinE: notinE,\n    notinva: notinva,\n    notinvb: notinvb,\n    notinvc: notinvc,\n    NotLeftTriangleBar: NotLeftTriangleBar,\n    NotLeftTriangle: NotLeftTriangle,\n    NotLeftTriangleEqual: NotLeftTriangleEqual,\n    NotLess: NotLess,\n    NotLessEqual: NotLessEqual,\n    NotLessGreater: NotLessGreater,\n    NotLessLess: NotLessLess,\n    NotLessSlantEqual: NotLessSlantEqual,\n    NotLessTilde: NotLessTilde,\n    NotNestedGreaterGreater: NotNestedGreaterGreater,\n    NotNestedLessLess: NotNestedLessLess,\n    notni: notni,\n    notniva: notniva,\n    notnivb: notnivb,\n    notnivc: notnivc,\n    NotPrecedes: NotPrecedes,\n    NotPrecedesEqual: NotPrecedesEqual,\n    NotPrecedesSlantEqual: NotPrecedesSlantEqual,\n    NotReverseElement: NotReverseElement,\n    NotRightTriangleBar: NotRightTriangleBar,\n    NotRightTriangle: NotRightTriangle,\n    NotRightTriangleEqual: NotRightTriangleEqual,\n    NotSquareSubset: NotSquareSubset,\n    NotSquareSubsetEqual: NotSquareSubsetEqual,\n    NotSquareSuperset: NotSquareSuperset,\n    NotSquareSupersetEqual: NotSquareSupersetEqual,\n    NotSubset: NotSubset,\n    NotSubsetEqual: NotSubsetEqual,\n    NotSucceeds: NotSucceeds,\n    NotSucceedsEqual: NotSucceedsEqual,\n    NotSucceedsSlantEqual: NotSucceedsSlantEqual,\n    NotSucceedsTilde: NotSucceedsTilde,\n    NotSuperset: NotSuperset,\n    NotSupersetEqual: NotSupersetEqual,\n    NotTilde: NotTilde,\n    NotTildeEqual: NotTildeEqual,\n    NotTildeFullEqual: NotTildeFullEqual,\n    NotTildeTilde: NotTildeTilde,\n    NotVerticalBar: NotVerticalBar,\n    nparallel: nparallel,\n    npar: npar,\n    nparsl: nparsl,\n    npart: npart,\n    npolint: npolint,\n    npr: npr,\n    nprcue: nprcue,\n    nprec: nprec,\n    npreceq: npreceq,\n    npre: npre,\n    nrarrc: nrarrc,\n    nrarr: nrarr,\n    nrArr: nrArr,\n    nrarrw: nrarrw,\n    nrightarrow: nrightarrow,\n    nRightarrow: nRightarrow,\n    nrtri: nrtri,\n    nrtrie: nrtrie,\n    nsc: nsc,\n    nsccue: nsccue,\n    nsce: nsce,\n    Nscr: Nscr,\n    nscr: nscr,\n    nshortmid: nshortmid,\n    nshortparallel: nshortparallel,\n    nsim: nsim,\n    nsime: nsime,\n    nsimeq: nsimeq,\n    nsmid: nsmid,\n    nspar: nspar,\n    nsqsube: nsqsube,\n    nsqsupe: nsqsupe,\n    nsub: nsub,\n    nsubE: nsubE,\n    nsube: nsube,\n    nsubset: nsubset,\n    nsubseteq: nsubseteq,\n    nsubseteqq: nsubseteqq,\n    nsucc: nsucc,\n    nsucceq: nsucceq,\n    nsup: nsup,\n    nsupE: nsupE,\n    nsupe: nsupe,\n    nsupset: nsupset,\n    nsupseteq: nsupseteq,\n    nsupseteqq: nsupseteqq,\n    ntgl: ntgl,\n    Ntilde: Ntilde$1,\n    ntilde: ntilde$1,\n    ntlg: ntlg,\n    ntriangleleft: ntriangleleft,\n    ntrianglelefteq: ntrianglelefteq,\n    ntriangleright: ntriangleright,\n    ntrianglerighteq: ntrianglerighteq,\n    Nu: Nu,\n    nu: nu,\n    num: num,\n    numero: numero,\n    numsp: numsp,\n    nvap: nvap,\n    nvdash: nvdash,\n    nvDash: nvDash,\n    nVdash: nVdash,\n    nVDash: nVDash,\n    nvge: nvge,\n    nvgt: nvgt,\n    nvHarr: nvHarr,\n    nvinfin: nvinfin,\n    nvlArr: nvlArr,\n    nvle: nvle,\n    nvlt: nvlt,\n    nvltrie: nvltrie,\n    nvrArr: nvrArr,\n    nvrtrie: nvrtrie,\n    nvsim: nvsim,\n    nwarhk: nwarhk,\n    nwarr: nwarr,\n    nwArr: nwArr,\n    nwarrow: nwarrow,\n    nwnear: nwnear,\n    Oacute: Oacute$1,\n    oacute: oacute$1,\n    oast: oast,\n    Ocirc: Ocirc$1,\n    ocirc: ocirc$1,\n    ocir: ocir,\n    Ocy: Ocy,\n    ocy: ocy,\n    odash: odash,\n    Odblac: Odblac,\n    odblac: odblac,\n    odiv: odiv,\n    odot: odot,\n    odsold: odsold,\n    OElig: OElig,\n    oelig: oelig,\n    ofcir: ofcir,\n    Ofr: Ofr,\n    ofr: ofr,\n    ogon: ogon,\n    Ograve: Ograve$1,\n    ograve: ograve$1,\n    ogt: ogt,\n    ohbar: ohbar,\n    ohm: ohm,\n    oint: oint,\n    olarr: olarr,\n    olcir: olcir,\n    olcross: olcross,\n    oline: oline,\n    olt: olt,\n    Omacr: Omacr,\n    omacr: omacr,\n    Omega: Omega,\n    omega: omega,\n    Omicron: Omicron,\n    omicron: omicron,\n    omid: omid,\n    ominus: ominus,\n    Oopf: Oopf,\n    oopf: oopf,\n    opar: opar,\n    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,\n    OpenCurlyQuote: OpenCurlyQuote,\n    operp: operp,\n    oplus: oplus,\n    orarr: orarr,\n    Or: Or,\n    or: or,\n    ord: ord,\n    order: order,\n    orderof: orderof,\n    ordf: ordf$1,\n    ordm: ordm$1,\n    origof: origof,\n    oror: oror,\n    orslope: orslope,\n    orv: orv,\n    oS: oS,\n    Oscr: Oscr,\n    oscr: oscr,\n    Oslash: Oslash$1,\n    oslash: oslash$1,\n    osol: osol,\n    Otilde: Otilde$1,\n    otilde: otilde$1,\n    otimesas: otimesas,\n    Otimes: Otimes,\n    otimes: otimes,\n    Ouml: Ouml$1,\n    ouml: ouml$1,\n    ovbar: ovbar,\n    OverBar: OverBar,\n    OverBrace: OverBrace,\n    OverBracket: OverBracket,\n    OverParenthesis: OverParenthesis,\n    para: para$1,\n    parallel: parallel,\n    par: par,\n    parsim: parsim,\n    parsl: parsl,\n    part: part,\n    PartialD: PartialD,\n    Pcy: Pcy,\n    pcy: pcy,\n    percnt: percnt,\n    period: period,\n    permil: permil,\n    perp: perp,\n    pertenk: pertenk,\n    Pfr: Pfr,\n    pfr: pfr,\n    Phi: Phi,\n    phi: phi,\n    phiv: phiv,\n    phmmat: phmmat,\n    phone: phone,\n    Pi: Pi,\n    pi: pi,\n    pitchfork: pitchfork,\n    piv: piv,\n    planck: planck,\n    planckh: planckh,\n    plankv: plankv,\n    plusacir: plusacir,\n    plusb: plusb,\n    pluscir: pluscir,\n    plus: plus,\n    plusdo: plusdo,\n    plusdu: plusdu,\n    pluse: pluse,\n    PlusMinus: PlusMinus,\n    plusmn: plusmn$1,\n    plussim: plussim,\n    plustwo: plustwo,\n    pm: pm,\n    Poincareplane: Poincareplane,\n    pointint: pointint,\n    popf: popf,\n    Popf: Popf,\n    pound: pound$1,\n    prap: prap,\n    Pr: Pr,\n    pr: pr,\n    prcue: prcue,\n    precapprox: precapprox,\n    prec: prec,\n    preccurlyeq: preccurlyeq,\n    Precedes: Precedes,\n    PrecedesEqual: PrecedesEqual,\n    PrecedesSlantEqual: PrecedesSlantEqual,\n    PrecedesTilde: PrecedesTilde,\n    preceq: preceq,\n    precnapprox: precnapprox,\n    precneqq: precneqq,\n    precnsim: precnsim,\n    pre: pre,\n    prE: prE,\n    precsim: precsim,\n    prime: prime,\n    Prime: Prime,\n    primes: primes,\n    prnap: prnap,\n    prnE: prnE,\n    prnsim: prnsim,\n    prod: prod,\n    Product: Product,\n    profalar: profalar,\n    profline: profline,\n    profsurf: profsurf,\n    prop: prop,\n    Proportional: Proportional,\n    Proportion: Proportion,\n    propto: propto,\n    prsim: prsim,\n    prurel: prurel,\n    Pscr: Pscr,\n    pscr: pscr,\n    Psi: Psi,\n    psi: psi,\n    puncsp: puncsp,\n    Qfr: Qfr,\n    qfr: qfr,\n    qint: qint,\n    qopf: qopf,\n    Qopf: Qopf,\n    qprime: qprime,\n    Qscr: Qscr,\n    qscr: qscr,\n    quaternions: quaternions,\n    quatint: quatint,\n    quest: quest,\n    questeq: questeq,\n    quot: quot$2,\n    QUOT: QUOT$1,\n    rAarr: rAarr,\n    race: race,\n    Racute: Racute,\n    racute: racute,\n    radic: radic,\n    raemptyv: raemptyv,\n    rang: rang,\n    Rang: Rang,\n    rangd: rangd,\n    range: range,\n    rangle: rangle,\n    raquo: raquo$1,\n    rarrap: rarrap,\n    rarrb: rarrb,\n    rarrbfs: rarrbfs,\n    rarrc: rarrc,\n    rarr: rarr,\n    Rarr: Rarr,\n    rArr: rArr,\n    rarrfs: rarrfs,\n    rarrhk: rarrhk,\n    rarrlp: rarrlp,\n    rarrpl: rarrpl,\n    rarrsim: rarrsim,\n    Rarrtl: Rarrtl,\n    rarrtl: rarrtl,\n    rarrw: rarrw,\n    ratail: ratail,\n    rAtail: rAtail,\n    ratio: ratio,\n    rationals: rationals,\n    rbarr: rbarr,\n    rBarr: rBarr,\n    RBarr: RBarr,\n    rbbrk: rbbrk,\n    rbrace: rbrace,\n    rbrack: rbrack,\n    rbrke: rbrke,\n    rbrksld: rbrksld,\n    rbrkslu: rbrkslu,\n    Rcaron: Rcaron,\n    rcaron: rcaron,\n    Rcedil: Rcedil,\n    rcedil: rcedil,\n    rceil: rceil,\n    rcub: rcub,\n    Rcy: Rcy,\n    rcy: rcy,\n    rdca: rdca,\n    rdldhar: rdldhar,\n    rdquo: rdquo,\n    rdquor: rdquor,\n    rdsh: rdsh,\n    real: real,\n    realine: realine,\n    realpart: realpart,\n    reals: reals,\n    Re: Re,\n    rect: rect,\n    reg: reg$1,\n    REG: REG$1,\n    ReverseElement: ReverseElement,\n    ReverseEquilibrium: ReverseEquilibrium,\n    ReverseUpEquilibrium: ReverseUpEquilibrium,\n    rfisht: rfisht,\n    rfloor: rfloor,\n    rfr: rfr,\n    Rfr: Rfr,\n    rHar: rHar,\n    rhard: rhard,\n    rharu: rharu,\n    rharul: rharul,\n    Rho: Rho,\n    rho: rho,\n    rhov: rhov,\n    RightAngleBracket: RightAngleBracket,\n    RightArrowBar: RightArrowBar,\n    rightarrow: rightarrow,\n    RightArrow: RightArrow,\n    Rightarrow: Rightarrow,\n    RightArrowLeftArrow: RightArrowLeftArrow,\n    rightarrowtail: rightarrowtail,\n    RightCeiling: RightCeiling,\n    RightDoubleBracket: RightDoubleBracket,\n    RightDownTeeVector: RightDownTeeVector,\n    RightDownVectorBar: RightDownVectorBar,\n    RightDownVector: RightDownVector,\n    RightFloor: RightFloor,\n    rightharpoondown: rightharpoondown,\n    rightharpoonup: rightharpoonup,\n    rightleftarrows: rightleftarrows,\n    rightleftharpoons: rightleftharpoons,\n    rightrightarrows: rightrightarrows,\n    rightsquigarrow: rightsquigarrow,\n    RightTeeArrow: RightTeeArrow,\n    RightTee: RightTee,\n    RightTeeVector: RightTeeVector,\n    rightthreetimes: rightthreetimes,\n    RightTriangleBar: RightTriangleBar,\n    RightTriangle: RightTriangle,\n    RightTriangleEqual: RightTriangleEqual,\n    RightUpDownVector: RightUpDownVector,\n    RightUpTeeVector: RightUpTeeVector,\n    RightUpVectorBar: RightUpVectorBar,\n    RightUpVector: RightUpVector,\n    RightVectorBar: RightVectorBar,\n    RightVector: RightVector,\n    ring: ring,\n    risingdotseq: risingdotseq,\n    rlarr: rlarr,\n    rlhar: rlhar,\n    rlm: rlm,\n    rmoustache: rmoustache,\n    rmoust: rmoust,\n    rnmid: rnmid,\n    roang: roang,\n    roarr: roarr,\n    robrk: robrk,\n    ropar: ropar,\n    ropf: ropf,\n    Ropf: Ropf,\n    roplus: roplus,\n    rotimes: rotimes,\n    RoundImplies: RoundImplies,\n    rpar: rpar,\n    rpargt: rpargt,\n    rppolint: rppolint,\n    rrarr: rrarr,\n    Rrightarrow: Rrightarrow,\n    rsaquo: rsaquo,\n    rscr: rscr,\n    Rscr: Rscr,\n    rsh: rsh,\n    Rsh: Rsh,\n    rsqb: rsqb,\n    rsquo: rsquo,\n    rsquor: rsquor,\n    rthree: rthree,\n    rtimes: rtimes,\n    rtri: rtri,\n    rtrie: rtrie,\n    rtrif: rtrif,\n    rtriltri: rtriltri,\n    RuleDelayed: RuleDelayed,\n    ruluhar: ruluhar,\n    rx: rx,\n    Sacute: Sacute,\n    sacute: sacute,\n    sbquo: sbquo,\n    scap: scap,\n    Scaron: Scaron,\n    scaron: scaron,\n    Sc: Sc,\n    sc: sc,\n    sccue: sccue,\n    sce: sce,\n    scE: scE,\n    Scedil: Scedil,\n    scedil: scedil,\n    Scirc: Scirc,\n    scirc: scirc,\n    scnap: scnap,\n    scnE: scnE,\n    scnsim: scnsim,\n    scpolint: scpolint,\n    scsim: scsim,\n    Scy: Scy,\n    scy: scy,\n    sdotb: sdotb,\n    sdot: sdot,\n    sdote: sdote,\n    searhk: searhk,\n    searr: searr,\n    seArr: seArr,\n    searrow: searrow,\n    sect: sect$1,\n    semi: semi,\n    seswar: seswar,\n    setminus: setminus,\n    setmn: setmn,\n    sext: sext,\n    Sfr: Sfr,\n    sfr: sfr,\n    sfrown: sfrown,\n    sharp: sharp,\n    SHCHcy: SHCHcy,\n    shchcy: shchcy,\n    SHcy: SHcy,\n    shcy: shcy,\n    ShortDownArrow: ShortDownArrow,\n    ShortLeftArrow: ShortLeftArrow,\n    shortmid: shortmid,\n    shortparallel: shortparallel,\n    ShortRightArrow: ShortRightArrow,\n    ShortUpArrow: ShortUpArrow,\n    shy: shy$1,\n    Sigma: Sigma,\n    sigma: sigma,\n    sigmaf: sigmaf,\n    sigmav: sigmav,\n    sim: sim,\n    simdot: simdot,\n    sime: sime,\n    simeq: simeq,\n    simg: simg,\n    simgE: simgE,\n    siml: siml,\n    simlE: simlE,\n    simne: simne,\n    simplus: simplus,\n    simrarr: simrarr,\n    slarr: slarr,\n    SmallCircle: SmallCircle,\n    smallsetminus: smallsetminus,\n    smashp: smashp,\n    smeparsl: smeparsl,\n    smid: smid,\n    smile: smile,\n    smt: smt,\n    smte: smte,\n    smtes: smtes,\n    SOFTcy: SOFTcy,\n    softcy: softcy,\n    solbar: solbar,\n    solb: solb,\n    sol: sol,\n    Sopf: Sopf,\n    sopf: sopf,\n    spades: spades,\n    spadesuit: spadesuit,\n    spar: spar,\n    sqcap: sqcap,\n    sqcaps: sqcaps,\n    sqcup: sqcup,\n    sqcups: sqcups,\n    Sqrt: Sqrt,\n    sqsub: sqsub,\n    sqsube: sqsube,\n    sqsubset: sqsubset,\n    sqsubseteq: sqsubseteq,\n    sqsup: sqsup,\n    sqsupe: sqsupe,\n    sqsupset: sqsupset,\n    sqsupseteq: sqsupseteq,\n    square: square,\n    Square: Square,\n    SquareIntersection: SquareIntersection,\n    SquareSubset: SquareSubset,\n    SquareSubsetEqual: SquareSubsetEqual,\n    SquareSuperset: SquareSuperset,\n    SquareSupersetEqual: SquareSupersetEqual,\n    SquareUnion: SquareUnion,\n    squarf: squarf,\n    squ: squ,\n    squf: squf,\n    srarr: srarr,\n    Sscr: Sscr,\n    sscr: sscr,\n    ssetmn: ssetmn,\n    ssmile: ssmile,\n    sstarf: sstarf,\n    Star: Star,\n    star: star,\n    starf: starf,\n    straightepsilon: straightepsilon,\n    straightphi: straightphi,\n    strns: strns,\n    sub: sub,\n    Sub: Sub,\n    subdot: subdot,\n    subE: subE,\n    sube: sube,\n    subedot: subedot,\n    submult: submult,\n    subnE: subnE,\n    subne: subne,\n    subplus: subplus,\n    subrarr: subrarr,\n    subset: subset,\n    Subset: Subset,\n    subseteq: subseteq,\n    subseteqq: subseteqq,\n    SubsetEqual: SubsetEqual,\n    subsetneq: subsetneq,\n    subsetneqq: subsetneqq,\n    subsim: subsim,\n    subsub: subsub,\n    subsup: subsup,\n    succapprox: succapprox,\n    succ: succ,\n    succcurlyeq: succcurlyeq,\n    Succeeds: Succeeds,\n    SucceedsEqual: SucceedsEqual,\n    SucceedsSlantEqual: SucceedsSlantEqual,\n    SucceedsTilde: SucceedsTilde,\n    succeq: succeq,\n    succnapprox: succnapprox,\n    succneqq: succneqq,\n    succnsim: succnsim,\n    succsim: succsim,\n    SuchThat: SuchThat,\n    sum: sum,\n    Sum: Sum,\n    sung: sung,\n    sup1: sup1$1,\n    sup2: sup2$1,\n    sup3: sup3$1,\n    sup: sup,\n    Sup: Sup,\n    supdot: supdot,\n    supdsub: supdsub,\n    supE: supE,\n    supe: supe,\n    supedot: supedot,\n    Superset: Superset,\n    SupersetEqual: SupersetEqual,\n    suphsol: suphsol,\n    suphsub: suphsub,\n    suplarr: suplarr,\n    supmult: supmult,\n    supnE: supnE,\n    supne: supne,\n    supplus: supplus,\n    supset: supset,\n    Supset: Supset,\n    supseteq: supseteq,\n    supseteqq: supseteqq,\n    supsetneq: supsetneq,\n    supsetneqq: supsetneqq,\n    supsim: supsim,\n    supsub: supsub,\n    supsup: supsup,\n    swarhk: swarhk,\n    swarr: swarr,\n    swArr: swArr,\n    swarrow: swarrow,\n    swnwar: swnwar,\n    szlig: szlig$1,\n    Tab: Tab,\n    target: target,\n    Tau: Tau,\n    tau: tau,\n    tbrk: tbrk,\n    Tcaron: Tcaron,\n    tcaron: tcaron,\n    Tcedil: Tcedil,\n    tcedil: tcedil,\n    Tcy: Tcy,\n    tcy: tcy,\n    tdot: tdot,\n    telrec: telrec,\n    Tfr: Tfr,\n    tfr: tfr,\n    there4: there4,\n    therefore: therefore,\n    Therefore: Therefore,\n    Theta: Theta,\n    theta: theta,\n    thetasym: thetasym,\n    thetav: thetav,\n    thickapprox: thickapprox,\n    thicksim: thicksim,\n    ThickSpace: ThickSpace,\n    ThinSpace: ThinSpace,\n    thinsp: thinsp,\n    thkap: thkap,\n    thksim: thksim,\n    THORN: THORN$1,\n    thorn: thorn$1,\n    tilde: tilde,\n    Tilde: Tilde,\n    TildeEqual: TildeEqual,\n    TildeFullEqual: TildeFullEqual,\n    TildeTilde: TildeTilde,\n    timesbar: timesbar,\n    timesb: timesb,\n    times: times$1,\n    timesd: timesd,\n    tint: tint,\n    toea: toea,\n    topbot: topbot,\n    topcir: topcir,\n    top: esm_top,\n    Topf: Topf,\n    topf: topf,\n    topfork: topfork,\n    tosa: tosa,\n    tprime: tprime,\n    trade: trade,\n    TRADE: TRADE,\n    triangle: triangle,\n    triangledown: triangledown,\n    triangleleft: triangleleft,\n    trianglelefteq: trianglelefteq,\n    triangleq: triangleq,\n    triangleright: triangleright,\n    trianglerighteq: trianglerighteq,\n    tridot: tridot,\n    trie: trie,\n    triminus: triminus,\n    TripleDot: TripleDot,\n    triplus: triplus,\n    trisb: trisb,\n    tritime: tritime,\n    trpezium: trpezium,\n    Tscr: Tscr,\n    tscr: tscr,\n    TScy: TScy,\n    tscy: tscy,\n    TSHcy: TSHcy,\n    tshcy: tshcy,\n    Tstrok: Tstrok,\n    tstrok: tstrok,\n    twixt: twixt,\n    twoheadleftarrow: twoheadleftarrow,\n    twoheadrightarrow: twoheadrightarrow,\n    Uacute: Uacute$1,\n    uacute: uacute$1,\n    uarr: uarr,\n    Uarr: Uarr,\n    uArr: uArr,\n    Uarrocir: Uarrocir,\n    Ubrcy: Ubrcy,\n    ubrcy: ubrcy,\n    Ubreve: Ubreve,\n    ubreve: ubreve,\n    Ucirc: Ucirc$1,\n    ucirc: ucirc$1,\n    Ucy: Ucy,\n    ucy: ucy,\n    udarr: udarr,\n    Udblac: Udblac,\n    udblac: udblac,\n    udhar: udhar,\n    ufisht: ufisht,\n    Ufr: Ufr,\n    ufr: ufr,\n    Ugrave: Ugrave$1,\n    ugrave: ugrave$1,\n    uHar: uHar,\n    uharl: uharl,\n    uharr: uharr,\n    uhblk: uhblk,\n    ulcorn: ulcorn,\n    ulcorner: ulcorner,\n    ulcrop: ulcrop,\n    ultri: ultri,\n    Umacr: Umacr,\n    umacr: umacr,\n    uml: uml$1,\n    UnderBar: UnderBar,\n    UnderBrace: UnderBrace,\n    UnderBracket: UnderBracket,\n    UnderParenthesis: UnderParenthesis,\n    Union: Union,\n    UnionPlus: UnionPlus,\n    Uogon: Uogon,\n    uogon: uogon,\n    Uopf: Uopf,\n    uopf: uopf,\n    UpArrowBar: UpArrowBar,\n    uparrow: uparrow,\n    UpArrow: UpArrow,\n    Uparrow: Uparrow,\n    UpArrowDownArrow: UpArrowDownArrow,\n    updownarrow: updownarrow,\n    UpDownArrow: UpDownArrow,\n    Updownarrow: Updownarrow,\n    UpEquilibrium: UpEquilibrium,\n    upharpoonleft: upharpoonleft,\n    upharpoonright: upharpoonright,\n    uplus: uplus,\n    UpperLeftArrow: UpperLeftArrow,\n    UpperRightArrow: UpperRightArrow,\n    upsi: upsi,\n    Upsi: Upsi,\n    upsih: upsih,\n    Upsilon: Upsilon,\n    upsilon: upsilon,\n    UpTeeArrow: UpTeeArrow,\n    UpTee: UpTee,\n    upuparrows: upuparrows,\n    urcorn: urcorn,\n    urcorner: urcorner,\n    urcrop: urcrop,\n    Uring: Uring,\n    uring: uring,\n    urtri: urtri,\n    Uscr: Uscr,\n    uscr: uscr,\n    utdot: utdot,\n    Utilde: Utilde,\n    utilde: utilde,\n    utri: utri,\n    utrif: utrif,\n    uuarr: uuarr,\n    Uuml: Uuml$1,\n    uuml: uuml$1,\n    uwangle: uwangle,\n    vangrt: vangrt,\n    varepsilon: varepsilon,\n    varkappa: varkappa,\n    varnothing: varnothing,\n    varphi: varphi,\n    varpi: varpi,\n    varpropto: varpropto,\n    varr: varr,\n    vArr: vArr,\n    varrho: varrho,\n    varsigma: varsigma,\n    varsubsetneq: varsubsetneq,\n    varsubsetneqq: varsubsetneqq,\n    varsupsetneq: varsupsetneq,\n    varsupsetneqq: varsupsetneqq,\n    vartheta: vartheta,\n    vartriangleleft: vartriangleleft,\n    vartriangleright: vartriangleright,\n    vBar: vBar,\n    Vbar: Vbar,\n    vBarv: vBarv,\n    Vcy: Vcy,\n    vcy: vcy,\n    vdash: vdash,\n    vDash: vDash,\n    Vdash: Vdash,\n    VDash: VDash,\n    Vdashl: Vdashl,\n    veebar: veebar,\n    vee: vee,\n    Vee: Vee,\n    veeeq: veeeq,\n    vellip: vellip,\n    verbar: verbar,\n    Verbar: Verbar,\n    vert: vert,\n    Vert: Vert,\n    VerticalBar: VerticalBar,\n    VerticalLine: VerticalLine,\n    VerticalSeparator: VerticalSeparator,\n    VerticalTilde: VerticalTilde,\n    VeryThinSpace: VeryThinSpace,\n    Vfr: Vfr,\n    vfr: vfr,\n    vltri: vltri,\n    vnsub: vnsub,\n    vnsup: vnsup,\n    Vopf: Vopf,\n    vopf: vopf,\n    vprop: vprop,\n    vrtri: vrtri,\n    Vscr: Vscr,\n    vscr: vscr,\n    vsubnE: vsubnE,\n    vsubne: vsubne,\n    vsupnE: vsupnE,\n    vsupne: vsupne,\n    Vvdash: Vvdash,\n    vzigzag: vzigzag,\n    Wcirc: Wcirc,\n    wcirc: wcirc,\n    wedbar: wedbar,\n    wedge: wedge,\n    Wedge: Wedge,\n    wedgeq: wedgeq,\n    weierp: weierp,\n    Wfr: Wfr,\n    wfr: wfr,\n    Wopf: Wopf,\n    wopf: wopf,\n    wp: wp,\n    wr: wr,\n    wreath: wreath,\n    Wscr: Wscr,\n    wscr: wscr,\n    xcap: xcap,\n    xcirc: xcirc,\n    xcup: xcup,\n    xdtri: xdtri,\n    Xfr: Xfr,\n    xfr: xfr,\n    xharr: xharr,\n    xhArr: xhArr,\n    Xi: Xi,\n    xi: xi,\n    xlarr: xlarr,\n    xlArr: xlArr,\n    xmap: xmap,\n    xnis: xnis,\n    xodot: xodot,\n    Xopf: Xopf,\n    xopf: xopf,\n    xoplus: xoplus,\n    xotime: xotime,\n    xrarr: xrarr,\n    xrArr: xrArr,\n    Xscr: Xscr,\n    xscr: xscr,\n    xsqcup: xsqcup,\n    xuplus: xuplus,\n    xutri: xutri,\n    xvee: xvee,\n    xwedge: xwedge,\n    Yacute: Yacute$1,\n    yacute: yacute$1,\n    YAcy: YAcy,\n    yacy: yacy,\n    Ycirc: Ycirc,\n    ycirc: ycirc,\n    Ycy: Ycy,\n    ycy: ycy,\n    yen: yen$1,\n    Yfr: Yfr,\n    yfr: yfr,\n    YIcy: YIcy,\n    yicy: yicy,\n    Yopf: Yopf,\n    yopf: yopf,\n    Yscr: Yscr,\n    yscr: yscr,\n    YUcy: YUcy,\n    yucy: yucy,\n    yuml: yuml$1,\n    Yuml: Yuml,\n    Zacute: Zacute,\n    zacute: zacute,\n    Zcaron: Zcaron,\n    zcaron: zcaron,\n    Zcy: Zcy,\n    zcy: zcy,\n    Zdot: Zdot,\n    zdot: zdot,\n    zeetrf: zeetrf,\n    ZeroWidthSpace: ZeroWidthSpace,\n    Zeta: Zeta,\n    zeta: zeta,\n    zfr: zfr,\n    Zfr: Zfr,\n    ZHcy: ZHcy,\n    zhcy: zhcy,\n    zigrarr: zigrarr,\n    zopf: zopf,\n    Zopf: Zopf,\n    Zscr: Zscr,\n    zscr: zscr,\n    zwj: zwj,\n    zwnj: zwnj\n};\nvar Aacute = \"Á\";\nvar aacute = \"á\";\nvar Acirc = \"Â\";\nvar acirc = \"â\";\nvar acute = \"´\";\nvar AElig = \"Æ\";\nvar aelig = \"æ\";\nvar Agrave = \"À\";\nvar agrave = \"à\";\nvar amp$1 = \"&\";\nvar AMP = \"&\";\nvar Aring = \"Å\";\nvar aring = \"å\";\nvar Atilde = \"Ã\";\nvar atilde = \"ã\";\nvar Auml = \"Ä\";\nvar auml = \"ä\";\nvar brvbar = \"¦\";\nvar Ccedil = \"Ç\";\nvar ccedil = \"ç\";\nvar cedil = \"¸\";\nvar cent = \"¢\";\nvar copy = \"©\";\nvar COPY = \"©\";\nvar curren = \"¤\";\nvar deg = \"°\";\nvar divide = \"÷\";\nvar Eacute = \"É\";\nvar eacute = \"é\";\nvar Ecirc = \"Ê\";\nvar ecirc = \"ê\";\nvar Egrave = \"È\";\nvar egrave = \"è\";\nvar ETH = \"Ð\";\nvar eth = \"ð\";\nvar Euml = \"Ë\";\nvar euml = \"ë\";\nvar frac12 = \"½\";\nvar frac14 = \"¼\";\nvar frac34 = \"¾\";\nvar gt$1 = \">\";\nvar GT = \">\";\nvar Iacute = \"Í\";\nvar iacute = \"í\";\nvar Icirc = \"Î\";\nvar icirc = \"î\";\nvar iexcl = \"¡\";\nvar Igrave = \"Ì\";\nvar igrave = \"ì\";\nvar iquest = \"¿\";\nvar Iuml = \"Ï\";\nvar iuml = \"ï\";\nvar laquo = \"«\";\nvar lt$1 = \"<\";\nvar LT = \"<\";\nvar macr = \"¯\";\nvar micro = \"µ\";\nvar middot = \"·\";\nvar nbsp = \" \";\nvar not = \"¬\";\nvar Ntilde = \"Ñ\";\nvar ntilde = \"ñ\";\nvar Oacute = \"Ó\";\nvar oacute = \"ó\";\nvar Ocirc = \"Ô\";\nvar ocirc = \"ô\";\nvar Ograve = \"Ò\";\nvar ograve = \"ò\";\nvar ordf = \"ª\";\nvar ordm = \"º\";\nvar Oslash = \"Ø\";\nvar oslash = \"ø\";\nvar Otilde = \"Õ\";\nvar otilde = \"õ\";\nvar Ouml = \"Ö\";\nvar ouml = \"ö\";\nvar para = \"¶\";\nvar plusmn = \"±\";\nvar pound = \"£\";\nvar quot$1 = \"\\\"\";\nvar QUOT = \"\\\"\";\nvar raquo = \"»\";\nvar reg = \"®\";\nvar REG = \"®\";\nvar sect = \"§\";\nvar shy = \"­\";\nvar sup1 = \"¹\";\nvar sup2 = \"²\";\nvar sup3 = \"³\";\nvar szlig = \"ß\";\nvar THORN = \"Þ\";\nvar thorn = \"þ\";\nvar times = \"×\";\nvar Uacute = \"Ú\";\nvar uacute = \"ú\";\nvar Ucirc = \"Û\";\nvar ucirc = \"û\";\nvar Ugrave = \"Ù\";\nvar ugrave = \"ù\";\nvar uml = \"¨\";\nvar Uuml = \"Ü\";\nvar uuml = \"ü\";\nvar Yacute = \"Ý\";\nvar yacute = \"ý\";\nvar yen = \"¥\";\nvar yuml = \"ÿ\";\nvar require$$1 = {\n    Aacute: Aacute,\n    aacute: aacute,\n    Acirc: Acirc,\n    acirc: acirc,\n    acute: acute,\n    AElig: AElig,\n    aelig: aelig,\n    Agrave: Agrave,\n    agrave: agrave,\n    amp: amp$1,\n    AMP: AMP,\n    Aring: Aring,\n    aring: aring,\n    Atilde: Atilde,\n    atilde: atilde,\n    Auml: Auml,\n    auml: auml,\n    brvbar: brvbar,\n    Ccedil: Ccedil,\n    ccedil: ccedil,\n    cedil: cedil,\n    cent: cent,\n    copy: copy,\n    COPY: COPY,\n    curren: curren,\n    deg: deg,\n    divide: divide,\n    Eacute: Eacute,\n    eacute: eacute,\n    Ecirc: Ecirc,\n    ecirc: ecirc,\n    Egrave: Egrave,\n    egrave: egrave,\n    ETH: ETH,\n    eth: eth,\n    Euml: Euml,\n    euml: euml,\n    frac12: frac12,\n    frac14: frac14,\n    frac34: frac34,\n    gt: gt$1,\n    GT: GT,\n    Iacute: Iacute,\n    iacute: iacute,\n    Icirc: Icirc,\n    icirc: icirc,\n    iexcl: iexcl,\n    Igrave: Igrave,\n    igrave: igrave,\n    iquest: iquest,\n    Iuml: Iuml,\n    iuml: iuml,\n    laquo: laquo,\n    lt: lt$1,\n    LT: LT,\n    macr: macr,\n    micro: micro,\n    middot: middot,\n    nbsp: nbsp,\n    not: not,\n    Ntilde: Ntilde,\n    ntilde: ntilde,\n    Oacute: Oacute,\n    oacute: oacute,\n    Ocirc: Ocirc,\n    ocirc: ocirc,\n    Ograve: Ograve,\n    ograve: ograve,\n    ordf: ordf,\n    ordm: ordm,\n    Oslash: Oslash,\n    oslash: oslash,\n    Otilde: Otilde,\n    otilde: otilde,\n    Ouml: Ouml,\n    ouml: ouml,\n    para: para,\n    plusmn: plusmn,\n    pound: pound,\n    quot: quot$1,\n    QUOT: QUOT,\n    raquo: raquo,\n    reg: reg,\n    REG: REG,\n    sect: sect,\n    shy: shy,\n    sup1: sup1,\n    sup2: sup2,\n    sup3: sup3,\n    szlig: szlig,\n    THORN: THORN,\n    thorn: thorn,\n    times: times,\n    Uacute: Uacute,\n    uacute: uacute,\n    Ucirc: Ucirc,\n    ucirc: ucirc,\n    Ugrave: Ugrave,\n    ugrave: ugrave,\n    uml: uml,\n    Uuml: Uuml,\n    uuml: uuml,\n    Yacute: Yacute,\n    yacute: yacute,\n    yen: yen,\n    yuml: yuml\n};\nvar amp = \"&\";\nvar apos = \"'\";\nvar gt = \">\";\nvar lt = \"<\";\nvar quot = \"\\\"\";\nvar require$$0$1 = {\n    amp: amp,\n    apos: apos,\n    gt: gt,\n    lt: lt,\n    quot: quot\n};\nvar decode_codepoint = {};\nvar require$$0 = {\n    \"0\": 65533,\n    \"128\": 8364,\n    \"130\": 8218,\n    \"131\": 402,\n    \"132\": 8222,\n    \"133\": 8230,\n    \"134\": 8224,\n    \"135\": 8225,\n    \"136\": 710,\n    \"137\": 8240,\n    \"138\": 352,\n    \"139\": 8249,\n    \"140\": 338,\n    \"142\": 381,\n    \"145\": 8216,\n    \"146\": 8217,\n    \"147\": 8220,\n    \"148\": 8221,\n    \"149\": 8226,\n    \"150\": 8211,\n    \"151\": 8212,\n    \"152\": 732,\n    \"153\": 8482,\n    \"154\": 353,\n    \"155\": 8250,\n    \"156\": 339,\n    \"158\": 382,\n    \"159\": 376\n};\nvar __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode_codepoint, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault$2(require$$0);\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint$2 = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint$2(codePoint);\n}\ndecode_codepoint.default = decodeCodePoint;\nvar __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(decode, \"__esModule\", { value: true });\ndecode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;\nvar entities_json_1$1 = __importDefault$1(require$$1$1);\nvar legacy_json_1 = __importDefault$1(require$$1);\nvar xml_json_1$1 = __importDefault$1(require$$0$1);\nvar decode_codepoint_1 = __importDefault$1(decode_codepoint);\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\ndecode.decodeXML = getStrictDecoder(xml_json_1$1.default);\ndecode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\ndecode.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1$1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1$1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\nvar encode = {};\nvar esm_importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(encode, \"__esModule\", { value: true });\nencode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;\nvar xml_json_1 = esm_importDefault(require$$0$1);\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = esm_importDefault(require$$1$1);\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nencode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction esm_escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nencode.escape = esm_escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nencode.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n(function (exports) {\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\n    var decode_1 = decode;\n    var encode_1 = encode;\n    /**\n     * Decodes a string with entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeXML` or `decodeHTML` directly.\n     */\n    function decode$1(data, level) {\n        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n    }\n    exports.decode = decode$1;\n    /**\n     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n     *\n     * @param data String to decode.\n     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n     */\n    function decodeStrict(data, level) {\n        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n    }\n    exports.decodeStrict = decodeStrict;\n    /**\n     * Encodes a string with entities.\n     *\n     * @param data String to encode.\n     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n     */\n    function encode$1(data, level) {\n        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n    }\n    exports.encode = encode$1;\n    var encode_2 = encode;\n    Object.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\n    Object.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    Object.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\n    Object.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\n    Object.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    Object.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\n    var decode_2 = decode;\n    Object.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n    Object.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    // Legacy aliases (deprecated)\n    Object.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\n    Object.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    Object.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n    Object.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n}(lib));\nvar ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';\nvar C_BACKSLASH$1 = 92;\nvar reBackslashOrAmp = /[\\\\&]/;\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\nvar reEntityOrEscapedChar = new RegExp(\"\\\\\\\\\" + ESCAPABLE + \"|\" + ENTITY, 'gi');\nvar XMLSPECIAL = '[&<>\"]';\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\nvar unescapeChar = function (s) {\n    if (s.charCodeAt(0) === C_BACKSLASH$1) {\n        return s.charAt(1);\n    }\n    return lib.decodeHTML(s);\n};\n// Replace entities and backslash escapes with literal characters.\nfunction unescapeString(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    }\n    return s;\n}\nfunction normalizeURI(uri) {\n    try {\n        return encode_1(uri);\n    }\n    catch (err) {\n        return uri;\n    }\n}\nfunction replaceUnsafeChar(s) {\n    switch (s) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return s;\n    }\n}\nfunction escapeXml(s) {\n    if (reXmlSpecial.test(s)) {\n        return s.replace(reXmlSpecial, replaceUnsafeChar);\n    }\n    return s;\n}\nfunction repeat(str, count) {\n    var arr = [];\n    for (var i = 0; i < count; i++) {\n        arr.push(str);\n    }\n    return arr.join('');\n}\nfunction isEmpty(str) {\n    if (!str) {\n        return true;\n    }\n    return !/[^ \\t]+/.test(str);\n}\nvar NodeWalker = /** @class */ (function () {\n    function NodeWalker(root) {\n        this.current = root;\n        this.root = root;\n        this.entering = true;\n    }\n    NodeWalker.prototype.next = function () {\n        var cur = this.current;\n        var entering = this.entering;\n        if (cur === null) {\n            return null;\n        }\n        var container = isContainer(cur);\n        if (entering && container) {\n            if (cur.firstChild) {\n                this.current = cur.firstChild;\n                this.entering = true;\n            }\n            else {\n                // stay on node but exit\n                this.entering = false;\n            }\n        }\n        else if (cur === this.root) {\n            this.current = null;\n        }\n        else if (cur.next === null) {\n            this.current = cur.parent;\n            this.entering = false;\n        }\n        else {\n            this.current = cur.next;\n            this.entering = true;\n        }\n        return { entering: entering, node: cur };\n    };\n    NodeWalker.prototype.resumeAt = function (node, entering) {\n        this.current = node;\n        this.entering = entering === true;\n    };\n    return NodeWalker;\n}());\nfunction isContainer(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nvar lastNodeId = 1;\nvar nodeMap = {};\nfunction getNodeById(id) {\n    return nodeMap[id];\n}\nfunction removeNodeById(id) {\n    delete nodeMap[id];\n}\nfunction removeAllNode() {\n    nodeMap = {};\n}\nvar esm_Node = /** @class */ (function () {\n    function Node(nodeType, sourcepos) {\n        this.parent = null;\n        this.prev = null;\n        this.next = null;\n        // only for container node\n        this.firstChild = null;\n        this.lastChild = null;\n        // only for leaf node\n        this.literal = null;\n        if (nodeType === 'document') {\n            this.id = -1;\n        }\n        else {\n            this.id = lastNodeId++;\n        }\n        this.type = nodeType;\n        this.sourcepos = sourcepos;\n        nodeMap[this.id] = this;\n    }\n    Node.prototype.isContainer = function () {\n        return isContainer(this);\n    };\n    Node.prototype.unlink = function () {\n        if (this.prev) {\n            this.prev.next = this.next;\n        }\n        else if (this.parent) {\n            this.parent.firstChild = this.next;\n        }\n        if (this.next) {\n            this.next.prev = this.prev;\n        }\n        else if (this.parent) {\n            this.parent.lastChild = this.prev;\n        }\n        this.parent = null;\n        this.next = null;\n        this.prev = null;\n    };\n    Node.prototype.replaceWith = function (node) {\n        this.insertBefore(node);\n        this.unlink();\n    };\n    Node.prototype.insertAfter = function (sibling) {\n        sibling.unlink();\n        sibling.next = this.next;\n        if (sibling.next) {\n            sibling.next.prev = sibling;\n        }\n        sibling.prev = this;\n        this.next = sibling;\n        if (this.parent) {\n            sibling.parent = this.parent;\n            if (!sibling.next) {\n                sibling.parent.lastChild = sibling;\n            }\n        }\n    };\n    Node.prototype.insertBefore = function (sibling) {\n        sibling.unlink();\n        sibling.prev = this.prev;\n        if (sibling.prev) {\n            sibling.prev.next = sibling;\n        }\n        sibling.next = this;\n        this.prev = sibling;\n        sibling.parent = this.parent;\n        if (!sibling.prev) {\n            sibling.parent.firstChild = sibling;\n        }\n    };\n    Node.prototype.appendChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.lastChild) {\n            this.lastChild.next = child;\n            child.prev = this.lastChild;\n            this.lastChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.prependChild = function (child) {\n        child.unlink();\n        child.parent = this;\n        if (this.firstChild) {\n            this.firstChild.prev = child;\n            child.next = this.firstChild;\n            this.firstChild = child;\n        }\n        else {\n            this.firstChild = child;\n            this.lastChild = child;\n        }\n    };\n    Node.prototype.walker = function () {\n        return new NodeWalker(this);\n    };\n    return Node;\n}());\nvar BlockNode = /** @class */ (function (_super) {\n    esm_extends(BlockNode, _super);\n    function BlockNode(nodeType, sourcepos) {\n        var _this = _super.call(this, nodeType, sourcepos) || this;\n        // temporal data (for parsing)\n        _this.open = true;\n        _this.lineOffsets = null;\n        _this.stringContent = null;\n        _this.lastLineBlank = false;\n        _this.lastLineChecked = false;\n        _this.type = nodeType;\n        return _this;\n    }\n    return BlockNode;\n}(esm_Node));\nvar ListNode = /** @class */ (function (_super) {\n    esm_extends(ListNode, _super);\n    function ListNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.listData = null;\n        return _this;\n    }\n    return ListNode;\n}(BlockNode));\nvar HeadingNode = /** @class */ (function (_super) {\n    esm_extends(HeadingNode, _super);\n    function HeadingNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.level = 0;\n        _this.headingType = 'atx';\n        return _this;\n    }\n    return HeadingNode;\n}(BlockNode));\nvar CodeBlockNode = /** @class */ (function (_super) {\n    esm_extends(CodeBlockNode, _super);\n    function CodeBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isFenced = false;\n        _this.fenceChar = null;\n        _this.fenceLength = 0;\n        _this.fenceOffset = -1;\n        _this.info = null;\n        _this.infoPadding = 0;\n        return _this;\n    }\n    return CodeBlockNode;\n}(BlockNode));\nvar TableNode = /** @class */ (function (_super) {\n    esm_extends(TableNode, _super);\n    function TableNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.columns = [];\n        return _this;\n    }\n    return TableNode;\n}(BlockNode));\nvar TableCellNode = /** @class */ (function (_super) {\n    esm_extends(TableCellNode, _super);\n    function TableCellNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.startIdx = 0;\n        _this.endIdx = 0;\n        _this.paddingLeft = 0;\n        _this.paddingRight = 0;\n        _this.ignored = false;\n        return _this;\n    }\n    return TableCellNode;\n}(BlockNode));\nvar RefDefNode = /** @class */ (function (_super) {\n    esm_extends(RefDefNode, _super);\n    function RefDefNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.title = '';\n        _this.dest = '';\n        _this.label = '';\n        return _this;\n    }\n    return RefDefNode;\n}(BlockNode));\nvar CustomBlockNode = /** @class */ (function (_super) {\n    esm_extends(CustomBlockNode, _super);\n    function CustomBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.syntaxLength = 0;\n        _this.offset = -1;\n        _this.info = '';\n        return _this;\n    }\n    return CustomBlockNode;\n}(BlockNode));\nvar HtmlBlockNode = /** @class */ (function (_super) {\n    esm_extends(HtmlBlockNode, _super);\n    function HtmlBlockNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.htmlBlockType = -1;\n        return _this;\n    }\n    return HtmlBlockNode;\n}(BlockNode));\nvar LinkNode = /** @class */ (function (_super) {\n    esm_extends(LinkNode, _super);\n    function LinkNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destination = null;\n        _this.title = null;\n        _this.extendedAutolink = false;\n        return _this;\n    }\n    return LinkNode;\n}(esm_Node));\nvar CodeNode = /** @class */ (function (_super) {\n    esm_extends(CodeNode, _super);\n    function CodeNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.tickCount = 0;\n        return _this;\n    }\n    return CodeNode;\n}(esm_Node));\nvar CustomInlineNode = /** @class */ (function (_super) {\n    esm_extends(CustomInlineNode, _super);\n    function CustomInlineNode() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.info = '';\n        return _this;\n    }\n    return CustomInlineNode;\n}(esm_Node));\nfunction createNode(type, sourcepos) {\n    switch (type) {\n        case 'heading':\n            return new HeadingNode(type, sourcepos);\n        case 'list':\n        case 'item':\n            return new ListNode(type, sourcepos);\n        case 'link':\n        case 'image':\n            return new LinkNode(type, sourcepos);\n        case 'codeBlock':\n            return new CodeBlockNode(type, sourcepos);\n        case 'htmlBlock':\n            return new HtmlBlockNode(type, sourcepos);\n        case 'table':\n            return new TableNode(type, sourcepos);\n        case 'tableCell':\n            return new TableCellNode(type, sourcepos);\n        case 'document':\n        case 'paragraph':\n        case 'blockQuote':\n        case 'thematicBreak':\n        case 'tableRow':\n        case 'tableBody':\n        case 'tableHead':\n        case 'frontMatter':\n            return new BlockNode(type, sourcepos);\n        case 'code':\n            return new CodeNode(type, sourcepos);\n        case 'refDef':\n            return new RefDefNode(type, sourcepos);\n        case 'customBlock':\n            return new CustomBlockNode(type, sourcepos);\n        case 'customInline':\n            return new CustomInlineNode(type, sourcepos);\n        default:\n            return new esm_Node(type, sourcepos);\n    }\n}\nfunction isCodeBlock(node) {\n    return node.type === 'codeBlock';\n}\nfunction isHtmlBlock(node) {\n    return node.type === 'htmlBlock';\n}\nfunction isHeading(node) {\n    return node.type === 'heading';\n}\nfunction isList(node) {\n    return node.type === 'list';\n}\nfunction isTable(node) {\n    return node.type === 'table';\n}\nfunction isRefDef(node) {\n    return node.type === 'refDef';\n}\nfunction isCustomBlock(node) {\n    return node.type === 'customBlock';\n}\nfunction isCustomInline(node) {\n    return node.type === 'customInline';\n}\nfunction esm_text(s, sourcepos) {\n    var node = createNode('text', sourcepos);\n    node.literal = s;\n    return node;\n}\nvar TAGNAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';\nvar DECLARATION = '<![A-Z]+\\\\s+[^>]*>';\nvar CDATA = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" + PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar reHtmlTag = new RegExp(\"^\" + HTMLTAG, 'i');\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nvar fromCodePoint;\nif (String.fromCodePoint) {\n    fromCodePoint = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xfffd);\n            }\n            throw e;\n        }\n    };\n}\nelse {\n    var stringFromCharCode_1 = String.fromCharCode;\n    var floor_1 = Math.floor;\n    fromCodePoint = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = args.length;\n        if (!length) {\n            return '';\n        }\n        var result = '';\n        while (++index < length) {\n            var codePoint = Number(args[index]);\n            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                codePoint < 0 || // not a valid Unicode code point\n                codePoint > 0x10ffff || // not a valid Unicode code point\n                floor_1(codePoint) !== codePoint // not an integer\n            ) {\n                return String.fromCharCode(0xfffd);\n            }\n            if (codePoint <= 0xffff) {\n                // BMP code point\n                codeUnits.push(codePoint);\n            }\n            else {\n                // Astral code point; split in surrogate halves\n                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                codePoint -= 0x10000;\n                highSurrogate = (codePoint >> 10) + 0xd800;\n                lowSurrogate = (codePoint % 0x400) + 0xdc00;\n                codeUnits.push(highSurrogate, lowSurrogate);\n            }\n            if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n                result += stringFromCharCode_1.apply(void 0, codeUnits);\n                codeUnits.length = 0;\n            }\n        }\n        return result;\n    };\n}\nvar fromCodePoint$1 = fromCodePoint;\nvar DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';\nvar PATH = '[^<\\\\s]*[^<?!.,:*_?~\\\\s]';\nvar EMAIL = '[\\\\w.+-]+@(?:[\\\\w-]+\\\\.)+[\\\\w-]+';\nfunction trimUnmatchedTrailingParens(source) {\n    var trailingParen = /\\)+$/.exec(source);\n    if (trailingParen) {\n        var count = 0;\n        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {\n            var ch = source_1[_i];\n            if (ch === '(') {\n                if (count < 0) {\n                    count = 1;\n                }\n                else {\n                    count += 1;\n                }\n            }\n            else if (ch === ')') {\n                count -= 1;\n            }\n        }\n        if (count < 0) {\n            var trimCount = Math.min(-count, trailingParen[0].length);\n            return source.substring(0, source.length - trimCount);\n        }\n    }\n    return source;\n}\nfunction trimTrailingEntity(source) {\n    return source.replace(/&[A-Za-z0-9]+;$/, '');\n}\nfunction parseEmailLink(source) {\n    var reEmailLink = new RegExp(EMAIL, 'g');\n    var result = [];\n    var m;\n    while ((m = reEmailLink.exec(source))) {\n        var text_1 = m[0];\n        if (!/[_-]+$/.test(text_1)) {\n            result.push({\n                text: text_1,\n                range: [m.index, m.index + text_1.length - 1],\n                url: \"mailto:\" + text_1,\n            });\n        }\n    }\n    return result;\n}\nfunction parseUrlLink(source) {\n    var reWwwAutolink = new RegExp(\"(www|https?://).\" + DOMAIN + PATH, 'g');\n    var result = [];\n    var m;\n    while ((m = reWwwAutolink.exec(source))) {\n        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));\n        var scheme = m[1] === 'www' ? 'http://' : '';\n        result.push({\n            text: text_2,\n            range: [m.index, m.index + text_2.length - 1],\n            url: \"\" + scheme + text_2,\n        });\n    }\n    return result;\n}\nfunction baseAutolinkParser(source) {\n    return esm_spreadArray(esm_spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });\n}\nfunction convertExtAutoLinks(walker, autolinkParser) {\n    if (typeof autolinkParser === 'boolean') {\n        autolinkParser = baseAutolinkParser;\n    }\n    var event;\n    var _loop_1 = function () {\n        var entering = event.entering, node = event.node;\n        if (entering && node.type === 'text' && node.parent.type !== 'link') {\n            var literal = node.literal;\n            var linkInfos = autolinkParser(literal);\n            if (!linkInfos || !linkInfos.length) {\n                return \"continue\";\n            }\n            var lastIdx = 0;\n            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];\n            var sourcepos = function (startIdx, endIdx) {\n                return [\n                    [lineNum_1, chPos_1 + startIdx],\n                    [lineNum_1, chPos_1 + endIdx],\n                ];\n            };\n            var newNodes = [];\n            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {\n                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;\n                if (range[0] > lastIdx) {\n                    newNodes.push(esm_text(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));\n                }\n                var linkNode = createNode('link', sourcepos.apply(void 0, range));\n                linkNode.appendChild(esm_text(linkText, sourcepos.apply(void 0, range)));\n                linkNode.destination = url;\n                linkNode.extendedAutolink = true;\n                newNodes.push(linkNode);\n                lastIdx = range[1] + 1;\n            }\n            if (lastIdx < literal.length) {\n                newNodes.push(esm_text(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));\n            }\n            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {\n                var newNode = newNodes_1[_c];\n                node.insertBefore(newNode);\n            }\n            node.unlink();\n        }\n    };\n    while ((event = walker.next())) {\n        _loop_1();\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n// normalize a reference in reference link (remove []s, trim,\n// collapse internal space, unicode case fold.\n// See commonmark/commonmark.js#168.\nfunction normalizeReference(str) {\n    return str\n        .slice(1, str.length - 1)\n        .trim()\n        .replace(/[ \\t\\r\\n]+/, ' ')\n        .toLowerCase()\n        .toUpperCase();\n}\nfunction iterateObject(obj, iteratee) {\n    Object.keys(obj).forEach(function (key) {\n        iteratee(key, obj[key]);\n    });\n}\nfunction omit(obj) {\n    var propNames = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        propNames[_i - 1] = arguments[_i];\n    }\n    var resultMap = esm_assign({}, obj);\n    propNames.forEach(function (key) {\n        delete resultMap[key];\n    });\n    return resultMap;\n}\nfunction isEmptyObj(obj) {\n    return !Object.keys(obj).length;\n}\nfunction clearObj(obj) {\n    Object.keys(obj).forEach(function (key) {\n        delete obj[key];\n    });\n}\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET$1 = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_TILDE = 126;\nvar C_LESSTHAN$1 = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\nvar C_DOLLAR = 36;\n// Some regexps used in inline parser:\nvar ESCAPED_CHAR = \"\\\\\\\\\" + ESCAPABLE;\nvar rePunctuation = new RegExp(/[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]|\\uD800[\\uDD00-\\uDD02\\uDF9F\\uDFD0]|\\uD801\\uDD6F|\\uD802[\\uDC57\\uDD1F\\uDD3F\\uDE50-\\uDE58\\uDE7F\\uDEF0-\\uDEF6\\uDF39-\\uDF3F\\uDF99-\\uDF9C]|\\uD804[\\uDC47-\\uDC4D\\uDCBB\\uDCBC\\uDCBE-\\uDCC1\\uDD40-\\uDD43\\uDD74\\uDD75\\uDDC5-\\uDDC9\\uDDCD\\uDDDB\\uDDDD-\\uDDDF\\uDE38-\\uDE3D\\uDEA9]|\\uD805[\\uDCC6\\uDDC1-\\uDDD7\\uDE41-\\uDE43\\uDF3C-\\uDF3E]|\\uD809[\\uDC70-\\uDC74]|\\uD81A[\\uDE6E\\uDE6F\\uDEF5\\uDF37-\\uDF3B\\uDF44]|\\uD82F\\uDC9F|\\uD836[\\uDE87-\\uDE8B]/);\nvar reLinkTitle = new RegExp(\"^(?:\\\"(\" + ESCAPED_CHAR + \"|[^\\\"\\\\x00])*\\\"\" +\n    \"|\" +\n    (\"'(\" + ESCAPED_CHAR + \"|[^'\\\\x00])*'\") +\n    \"|\" +\n    (\"\\\\((\" + ESCAPED_CHAR + \"|[^()\\\\x00])*\\\\))\"));\nvar reLinkDestinationBraces = /^(?:<(?:[^<>\\n\\\\\\x00]|\\\\.)*>)/;\nvar reEscapable = new RegExp(\"^\" + ESCAPABLE);\nvar reEntityHere = new RegExp(\"^\" + ENTITY, 'i');\nvar reTicks = /`+/;\nvar reTicksHere = /^`+/;\nvar reEllipses = /\\.\\.\\./g;\nvar reDash = /--+/g;\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\\x00-\\x20]*>/i;\nvar reSpnl = /^ *(?:\\n *)?/;\nvar reWhitespaceChar = /^[ \\t\\n\\x0b\\x0c\\x0d]/;\nvar reUnicodeWhitespaceChar = /^\\s/;\nvar reFinalSpace = / *$/;\nvar reInitialSpace = /^ */;\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\.){0,1000}\\]/;\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"~$]+/m;\nvar InlineParser = /** @class */ (function () {\n    function InlineParser(options) {\n        // An InlineParser keeps track of a subject (a string to be parsed)\n        // and a position in that subject.\n        this.subject = '';\n        this.delimiters = null; // used by handleDelim method\n        this.brackets = null;\n        this.pos = 0;\n        this.lineStartNum = 0;\n        this.lineIdx = 0;\n        this.lineOffsets = [0];\n        this.linePosOffset = 0;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.options = options;\n    }\n    InlineParser.prototype.sourcepos = function (start, end) {\n        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];\n        var lineNum = this.lineStartNum + this.lineIdx;\n        var startpos = [lineNum, start + linePosOffset];\n        if (typeof end === 'number') {\n            return [startpos, [lineNum, end + linePosOffset]];\n        }\n        return startpos;\n    };\n    InlineParser.prototype.nextLine = function () {\n        this.lineIdx += 1;\n        this.linePosOffset = -this.pos;\n    };\n    // If re matches at current position in the subject, advance\n    // position in subject and return the match; otherwise return null.\n    InlineParser.prototype.match = function (re) {\n        var m = re.exec(this.subject.slice(this.pos));\n        if (m === null) {\n            return null;\n        }\n        this.pos += m.index + m[0].length;\n        return m[0];\n    };\n    // Returns the code for the character at the current subject position, or -1\n    // there are no more characters.\n    InlineParser.prototype.peek = function () {\n        if (this.pos < this.subject.length) {\n            return this.subject.charCodeAt(this.pos);\n        }\n        return -1;\n    };\n    // Parse zero or more space characters, including at most one newline\n    InlineParser.prototype.spnl = function () {\n        this.match(reSpnl);\n        return true;\n    };\n    // All of the parsers below try to match something at the current position\n    // in the subject.  If they succeed in matching anything, they\n    // return the inline matched, advancing the subject.\n    // Attempt to parse backticks, adding either a backtick code span or a\n    // literal sequence of backticks.\n    InlineParser.prototype.parseBackticks = function (block) {\n        var startpos = this.pos + 1;\n        var ticks = this.match(reTicksHere);\n        if (ticks === null) {\n            return false;\n        }\n        var afterOpenTicks = this.pos;\n        var matched;\n        while ((matched = this.match(reTicks)) !== null) {\n            if (matched === ticks) {\n                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);\n                var sourcepos = this.sourcepos(startpos, this.pos);\n                var lines = contents.split('\\n');\n                if (lines.length > 1) {\n                    var lastLine = last(lines);\n                    this.lineIdx += lines.length - 1;\n                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);\n                    sourcepos[1] = this.sourcepos(this.pos);\n                    contents = lines.join(' ');\n                }\n                var node = createNode('code', sourcepos);\n                if (contents.length > 0 &&\n                    contents.match(/[^ ]/) !== null &&\n                    contents[0] == ' ' &&\n                    contents[contents.length - 1] == ' ') {\n                    node.literal = contents.slice(1, contents.length - 1);\n                }\n                else {\n                    node.literal = contents;\n                }\n                node.tickCount = ticks.length;\n                block.appendChild(node);\n                return true;\n            }\n        }\n        // If we got here, we didn't match a closing backtick sequence.\n        this.pos = afterOpenTicks;\n        block.appendChild(esm_text(ticks, this.sourcepos(startpos, this.pos - 1)));\n        return true;\n    };\n    // Parse a backslash-escaped special character, adding either the escaped\n    // character, a hard line break (if the backslash is followed by a newline),\n    // or a literal backslash to the block's children.  Assumes current character\n    // is a backslash.\n    InlineParser.prototype.parseBackslash = function (block) {\n        var subj = this.subject;\n        var node;\n        this.pos += 1;\n        var startpos = this.pos;\n        if (this.peek() === C_NEWLINE) {\n            this.pos += 1;\n            node = createNode('linebreak', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            this.nextLine();\n        }\n        else if (reEscapable.test(subj.charAt(this.pos))) {\n            block.appendChild(esm_text(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));\n            this.pos += 1;\n        }\n        else {\n            block.appendChild(esm_text('\\\\', this.sourcepos(startpos, startpos)));\n        }\n        return true;\n    };\n    // Attempt to parse an autolink (URL or email in pointy brackets).\n    InlineParser.prototype.parseAutolink = function (block) {\n        var m;\n        var dest;\n        var node;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEmailAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(\"mailto:\" + dest);\n            node.title = '';\n            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        if ((m = this.match(reAutolink))) {\n            dest = m.slice(1, m.length - 1);\n            node = createNode('link', this.sourcepos(startpos, this.pos));\n            node.destination = normalizeURI(dest);\n            node.title = '';\n            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));\n            block.appendChild(node);\n            return true;\n        }\n        return false;\n    };\n    // Attempt to parse a raw HTML tag.\n    InlineParser.prototype.parseHtmlTag = function (block) {\n        var startpos = this.pos + 1;\n        var m = this.match(reHtmlTag);\n        if (m === null) {\n            return false;\n        }\n        var node = createNode('htmlInline', this.sourcepos(startpos, this.pos));\n        node.literal = m;\n        block.appendChild(node);\n        return true;\n    };\n    // Scan a sequence of characters with code cc, and return information about\n    // the number of delimiters and whether they are positioned such that\n    // they can open and/or close emphasis or strong emphasis.  A utility\n    // function for strong/emph parsing.\n    InlineParser.prototype.scanDelims = function (cc) {\n        var numdelims = 0;\n        var startpos = this.pos;\n        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            numdelims++;\n            this.pos++;\n        }\n        else {\n            while (this.peek() === cc) {\n                numdelims++;\n                this.pos++;\n            }\n        }\n        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {\n            this.pos = startpos;\n            return null;\n        }\n        var charBefore = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n        var ccAfter = this.peek();\n        var charAfter;\n        if (ccAfter === -1) {\n            charAfter = '\\n';\n        }\n        else {\n            charAfter = fromCodePoint$1(ccAfter);\n        }\n        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);\n        var afterIsPunctuation = rePunctuation.test(charAfter);\n        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);\n        var beforeIsPunctuation = rePunctuation.test(charBefore);\n        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);\n        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);\n        var canOpen;\n        var canClose;\n        if (cc === C_UNDERSCORE) {\n            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);\n            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);\n        }\n        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n            canOpen = leftFlanking && !rightFlanking;\n            canClose = rightFlanking;\n        }\n        else if (cc === C_DOLLAR) {\n            canOpen = !afterIsWhitespace;\n            canClose = !beforeIsWhitespace;\n        }\n        else {\n            canOpen = leftFlanking;\n            canClose = rightFlanking;\n        }\n        this.pos = startpos;\n        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };\n    };\n    // Handle a delimiter marker for emphasis or a quote.\n    InlineParser.prototype.handleDelim = function (cc, block) {\n        var res = this.scanDelims(cc);\n        if (!res) {\n            return false;\n        }\n        var numdelims = res.numdelims;\n        var startpos = this.pos + 1;\n        var contents;\n        this.pos += numdelims;\n        if (cc === C_SINGLEQUOTE) {\n            contents = '\\u2019';\n        }\n        else if (cc === C_DOUBLEQUOTE) {\n            contents = '\\u201C';\n        }\n        else {\n            contents = this.subject.slice(startpos - 1, this.pos);\n        }\n        var node = esm_text(contents, this.sourcepos(startpos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        if ((res.canOpen || res.canClose) &&\n            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {\n            this.delimiters = {\n                cc: cc,\n                numdelims: numdelims,\n                origdelims: numdelims,\n                node: node,\n                previous: this.delimiters,\n                next: null,\n                canOpen: res.canOpen,\n                canClose: res.canClose,\n            };\n            if (this.delimiters.previous) {\n                this.delimiters.previous.next = this.delimiters;\n            }\n        }\n        return true;\n    };\n    InlineParser.prototype.removeDelimiter = function (delim) {\n        if (delim.previous !== null) {\n            delim.previous.next = delim.next;\n        }\n        if (delim.next === null) {\n            // top of stack\n            this.delimiters = delim.previous;\n        }\n        else {\n            delim.next.previous = delim.previous;\n        }\n    };\n    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {\n        if (bottom.next !== top) {\n            bottom.next = top;\n            top.previous = bottom;\n        }\n    };\n    /**\n     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)\n     * If the smart punctuation options is true,\n     * convert single/double quotes to corresponding unicode characters.\n     **/\n    InlineParser.prototype.processEmphasis = function (stackBottom) {\n        var _a;\n        var opener;\n        var closer;\n        var oldCloser;\n        var openerInl, closerInl;\n        var openerFound;\n        var oddMatch = false;\n        var openersBottom = (_a = {},\n            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],\n            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],\n            _a[C_SINGLEQUOTE] = [stackBottom],\n            _a[C_DOUBLEQUOTE] = [stackBottom],\n            _a[C_TILDE] = [stackBottom],\n            _a[C_DOLLAR] = [stackBottom],\n            _a);\n        // find first closer above stackBottom:\n        closer = this.delimiters;\n        while (closer !== null && closer.previous !== stackBottom) {\n            closer = closer.previous;\n        }\n        // move forward, looking for closers, and handling each\n        while (closer !== null) {\n            var closercc = closer.cc;\n            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;\n            if (!closer.canClose) {\n                closer = closer.next;\n            }\n            else {\n                // found emphasis closer. now look back for first matching opener:\n                opener = closer.previous;\n                openerFound = false;\n                while (opener !== null &&\n                    opener !== stackBottom &&\n                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {\n                    oddMatch =\n                        closerEmph &&\n                            (closer.canOpen || opener.canClose) &&\n                            closer.origdelims % 3 !== 0 &&\n                            (opener.origdelims + closer.origdelims) % 3 === 0;\n                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {\n                        openerFound = true;\n                        break;\n                    }\n                    opener = opener.previous;\n                }\n                oldCloser = closer;\n                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {\n                    if (!openerFound) {\n                        closer = closer.next;\n                    }\n                    else if (opener) {\n                        // (null opener check for type narrowing)\n                        // calculate actual number of delimiters used from closer\n                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;\n                        var emptyDelims = closerEmph ? 0 : 1;\n                        openerInl = opener.node;\n                        closerInl = closer.node;\n                        // build contents for new emph element\n                        var nodeType = closerEmph\n                            ? useDelims === 1\n                                ? 'emph'\n                                : 'strong'\n                            : 'strike';\n                        if (closercc === C_DOLLAR) {\n                            nodeType = 'customInline';\n                        }\n                        var newNode = createNode(nodeType);\n                        var openerEndPos = openerInl.sourcepos[1];\n                        var closerStartPos = closerInl.sourcepos[0];\n                        newNode.sourcepos = [\n                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],\n                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],\n                        ];\n                        openerInl.sourcepos[1][1] -= useDelims;\n                        closerInl.sourcepos[0][1] += useDelims;\n                        openerInl.literal = openerInl.literal.slice(useDelims);\n                        closerInl.literal = closerInl.literal.slice(useDelims);\n                        opener.numdelims -= useDelims;\n                        closer.numdelims -= useDelims;\n                        // remove used delimiters from stack elts and inlines\n                        var tmp = openerInl.next;\n                        var next = void 0;\n                        while (tmp && tmp !== closerInl) {\n                            next = tmp.next;\n                            tmp.unlink();\n                            newNode.appendChild(tmp);\n                            tmp = next;\n                        }\n                        // build custom inline node\n                        if (closercc === C_DOLLAR) {\n                            var textNode = newNode.firstChild;\n                            var literal = textNode.literal || '';\n                            var info = literal.split(/\\s/)[0];\n                            newNode.info = info;\n                            if (literal.length <= info.length) {\n                                textNode.unlink();\n                            }\n                            else {\n                                textNode.sourcepos[0][1] += info.length;\n                                textNode.literal = literal.replace(info + \" \", '');\n                            }\n                        }\n                        openerInl.insertAfter(newNode);\n                        // remove elts between opener and closer in delimiters stack\n                        this.removeDelimitersBetween(opener, closer);\n                        // if opener has 0 delims, remove it and the inline\n                        // if opener has 1 delims and character is tilde, remove delimiter only\n                        if (opener.numdelims <= emptyDelims) {\n                            if (opener.numdelims === 0) {\n                                openerInl.unlink();\n                            }\n                            this.removeDelimiter(opener);\n                        }\n                        // if closer has 0 delims, remove it and the inline\n                        // if closer has 1 delims and character is tilde, remove delimiter only\n                        if (closer.numdelims <= emptyDelims) {\n                            if (closer.numdelims === 0) {\n                                closerInl.unlink();\n                            }\n                            var tempstack = closer.next;\n                            this.removeDelimiter(closer);\n                            closer = tempstack;\n                        }\n                    }\n                }\n                else if (closercc === C_SINGLEQUOTE) {\n                    closer.node.literal = '\\u2019';\n                    if (openerFound) {\n                        opener.node.literal = '\\u2018';\n                    }\n                    closer = closer.next;\n                }\n                else if (closercc === C_DOUBLEQUOTE) {\n                    closer.node.literal = '\\u201D';\n                    if (openerFound) {\n                        opener.node.literal = '\\u201C';\n                    }\n                    closer = closer.next;\n                }\n                if (!openerFound) {\n                    // Set lower bound for future searches for openers:\n                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;\n                    if (!oldCloser.canOpen) {\n                        // We can remove a closer that can't be an opener,\n                        // once we've seen there's no matching opener:\n                        this.removeDelimiter(oldCloser);\n                    }\n                }\n            }\n        }\n        // remove all delimiters\n        while (this.delimiters !== null && this.delimiters !== stackBottom) {\n            this.removeDelimiter(this.delimiters);\n        }\n    };\n    // Attempt to parse link title (sans quotes), returning the string\n    // or null if no match.\n    InlineParser.prototype.parseLinkTitle = function () {\n        var title = this.match(reLinkTitle);\n        if (title === null) {\n            return null;\n        }\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    };\n    // Attempt to parse link destination, returning the string or null if no match.\n    InlineParser.prototype.parseLinkDestination = function () {\n        var res = this.match(reLinkDestinationBraces);\n        if (res === null) {\n            if (this.peek() === C_LESSTHAN$1) {\n                return null;\n            }\n            // @TODO handrolled parser; res should be null or the string\n            var savepos = this.pos;\n            var openparens = 0;\n            var c = void 0;\n            while ((c = this.peek()) !== -1) {\n                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {\n                    this.pos += 1;\n                    if (this.peek() !== -1) {\n                        this.pos += 1;\n                    }\n                }\n                else if (c === C_OPEN_PAREN) {\n                    this.pos += 1;\n                    openparens += 1;\n                }\n                else if (c === C_CLOSE_PAREN) {\n                    if (openparens < 1) {\n                        break;\n                    }\n                    else {\n                        this.pos += 1;\n                        openparens -= 1;\n                    }\n                }\n                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {\n                    break;\n                }\n                else {\n                    this.pos += 1;\n                }\n            }\n            if (this.pos === savepos && c !== C_CLOSE_PAREN) {\n                return null;\n            }\n            if (openparens !== 0) {\n                return null;\n            }\n            res = this.subject.substr(savepos, this.pos - savepos);\n            return normalizeURI(unescapeString(res));\n        } // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    };\n    // Attempt to parse a link label, returning number of characters parsed.\n    InlineParser.prototype.parseLinkLabel = function () {\n        var m = this.match(reLinkLabel);\n        if (m === null || m.length > 1001) {\n            return 0;\n        }\n        return m.length;\n    };\n    // Add open bracket to delimiter stack and add a text node to block's children.\n    InlineParser.prototype.parseOpenBracket = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        var node = esm_text('[', this.sourcepos(this.pos, this.pos));\n        block.appendChild(node);\n        // Add entry to stack for this opener\n        this.addBracket(node, startpos, false);\n        return true;\n    };\n    // IF next character is [, and ! delimiter to delimiter stack and\n    // add a text node to block's children.  Otherwise just add a text node.\n    InlineParser.prototype.parseBang = function (block) {\n        var startpos = this.pos;\n        this.pos += 1;\n        if (this.peek() === C_OPEN_BRACKET$1) {\n            this.pos += 1;\n            var node = esm_text('![', this.sourcepos(this.pos - 1, this.pos));\n            block.appendChild(node);\n            // Add entry to stack for this opener\n            this.addBracket(node, startpos + 1, true);\n        }\n        else {\n            var node = esm_text('!', this.sourcepos(this.pos, this.pos));\n            block.appendChild(node);\n        }\n        return true;\n    };\n    // Try to match close bracket against an opening in the delimiter\n    // stack.  Add either a link or image, or a plain [ character,\n    // to block's children.  If there is a matching delimiter,\n    // remove it from the delimiter stack.\n    InlineParser.prototype.parseCloseBracket = function (block) {\n        var dest = null;\n        var title = null;\n        var matched = false;\n        this.pos += 1;\n        var startpos = this.pos;\n        // get last [ or ![\n        var opener = this.brackets;\n        if (opener === null) {\n            // no matched opener, just return a literal\n            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n            return true;\n        }\n        if (!opener.active) {\n            // no matched opener, just return a literal\n            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n            // take opener off brackets stack\n            this.removeBracket();\n            return true;\n        }\n        // If we got here, open is a potential opener\n        var isImage = opener.image;\n        // Check to see if we have a link/image\n        var savepos = this.pos;\n        // Inline link?\n        if (this.peek() === C_OPEN_PAREN) {\n            this.pos++;\n            if (this.spnl() &&\n                (dest = this.parseLinkDestination()) !== null &&\n                this.spnl() &&\n                // make sure there's a space before the title:\n                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n                    (title = this.parseLinkTitle())) ||\n                    true) &&\n                this.spnl() &&\n                this.peek() === C_CLOSE_PAREN) {\n                this.pos += 1;\n                matched = true;\n            }\n            else {\n                this.pos = savepos;\n            }\n        }\n        var refLabel = '';\n        if (!matched) {\n            // Next, see if there's a link label\n            var beforelabel = this.pos;\n            var n = this.parseLinkLabel();\n            if (n > 2) {\n                refLabel = this.subject.slice(beforelabel, beforelabel + n);\n            }\n            else if (!opener.bracketAfter) {\n                // Empty or missing second label means to use the first label as the reference.\n                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.\n                refLabel = this.subject.slice(opener.index, startpos);\n            }\n            if (n === 0) {\n                // If shortcut reference link, rewind before spaces we skipped.\n                this.pos = savepos;\n            }\n            if (refLabel) {\n                refLabel = normalizeReference(refLabel);\n                // lookup rawlabel in refMap\n                var link = this.refMap[refLabel];\n                if (link) {\n                    dest = link.destination;\n                    title = link.title;\n                    matched = true;\n                }\n            }\n        }\n        if (matched) {\n            var node = createNode(isImage ? 'image' : 'link');\n            node.destination = dest;\n            node.title = title || '';\n            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];\n            var tmp = opener.node.next;\n            var next = void 0;\n            while (tmp) {\n                next = tmp.next;\n                tmp.unlink();\n                node.appendChild(tmp);\n                tmp = next;\n            }\n            block.appendChild(node);\n            this.processEmphasis(opener.previousDelimiter);\n            this.removeBracket();\n            opener.node.unlink();\n            // We remove this bracket and processEmphasis will remove later delimiters.\n            // Now, for a link, we also deactivate earlier link openers.\n            // (no links in links)\n            if (!isImage) {\n                opener = this.brackets;\n                while (opener !== null) {\n                    if (!opener.image) {\n                        opener.active = false; // deactivate this opener\n                    }\n                    opener = opener.previous;\n                }\n            }\n            if (this.options.referenceDefinition) {\n                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n            }\n            return true;\n        } // no match\n        this.removeBracket(); // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));\n        if (this.options.referenceDefinition) {\n            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };\n        }\n        return true;\n    };\n    InlineParser.prototype.addBracket = function (node, index, image) {\n        if (this.brackets !== null) {\n            this.brackets.bracketAfter = true;\n        }\n        this.brackets = {\n            node: node,\n            startpos: this.sourcepos(index + (image ? 0 : 1)),\n            previous: this.brackets,\n            previousDelimiter: this.delimiters,\n            index: index,\n            image: image,\n            active: true,\n        };\n    };\n    InlineParser.prototype.removeBracket = function () {\n        if (this.brackets) {\n            this.brackets = this.brackets.previous;\n        }\n    };\n    // Attempt to parse an entity.\n    InlineParser.prototype.parseEntity = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reEntityHere))) {\n            block.appendChild(esm_text(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));\n            return true;\n        }\n        return false;\n    };\n    // Parse a run of ordinary characters, or a single character with\n    // a special meaning in markdown, as a plain string.\n    InlineParser.prototype.parseString = function (block) {\n        var m;\n        var startpos = this.pos + 1;\n        if ((m = this.match(reMain))) {\n            if (this.options.smart) {\n                var lit = m.replace(reEllipses, '\\u2026').replace(reDash, function (chars) {\n                    var enCount = 0;\n                    var emCount = 0;\n                    if (chars.length % 3 === 0) {\n                        // If divisible by 3, use all em dashes\n                        emCount = chars.length / 3;\n                    }\n                    else if (chars.length % 2 === 0) {\n                        // If divisible by 2, use all en dashes\n                        enCount = chars.length / 2;\n                    }\n                    else if (chars.length % 3 === 2) {\n                        // If 2 extra dashes, use en dash for last 2; em dashes for rest\n                        enCount = 1;\n                        emCount = (chars.length - 2) / 3;\n                    }\n                    else {\n                        // Use en dashes for last 4 hyphens; em dashes for rest\n                        enCount = 2;\n                        emCount = (chars.length - 4) / 3;\n                    }\n                    return repeat('\\u2014', emCount) + repeat('\\u2013', enCount);\n                });\n                block.appendChild(esm_text(lit, this.sourcepos(startpos, this.pos)));\n            }\n            else {\n                var node = esm_text(m, this.sourcepos(startpos, this.pos));\n                block.appendChild(node);\n            }\n            return true;\n        }\n        return false;\n    };\n    // Parse a newline.  If it was preceded by two spaces, return a hard\n    // line break; otherwise a soft line break.\n    InlineParser.prototype.parseNewline = function (block) {\n        this.pos += 1; // assume we're at a \\n\n        // check previous node for trailing spaces\n        var lastc = block.lastChild;\n        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {\n            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';\n            var litLen = lastc.literal.length;\n            lastc.literal = lastc.literal.replace(reFinalSpace, '');\n            var finalSpaceLen = litLen - lastc.literal.length;\n            lastc.sourcepos[1][1] -= finalSpaceLen;\n            block.appendChild(createNode(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));\n        }\n        else {\n            block.appendChild(createNode('softbreak', this.sourcepos(this.pos, this.pos)));\n        }\n        this.nextLine();\n        this.match(reInitialSpace); // gobble leading spaces in next line\n        return true;\n    };\n    // Attempt to parse a link reference, modifying refmap.\n    InlineParser.prototype.parseReference = function (block, refMap) {\n        if (!this.options.referenceDefinition) {\n            return 0;\n        }\n        this.subject = block.stringContent;\n        this.pos = 0;\n        var title = null;\n        var startpos = this.pos;\n        // label:\n        var matchChars = this.parseLinkLabel();\n        if (matchChars === 0) {\n            return 0;\n        }\n        var rawlabel = this.subject.substr(0, matchChars);\n        // colon:\n        if (this.peek() === C_COLON) {\n            this.pos++;\n        }\n        else {\n            this.pos = startpos;\n            return 0;\n        }\n        //  link url\n        this.spnl();\n        var dest = this.parseLinkDestination();\n        if (dest === null) {\n            this.pos = startpos;\n            return 0;\n        }\n        var beforetitle = this.pos;\n        this.spnl();\n        if (this.pos !== beforetitle) {\n            title = this.parseLinkTitle();\n        }\n        if (title === null) {\n            title = '';\n            // rewind before spaces\n            this.pos = beforetitle;\n        }\n        // make sure we're at line end:\n        var atLineEnd = true;\n        if (this.match(reSpaceAtEndOfLine) === null) {\n            if (title === '') {\n                atLineEnd = false;\n            }\n            else {\n                // the potential title we found is not at the line end,\n                // but it could still be a legal link reference if we\n                // discard the title\n                title = '';\n                // rewind before spaces\n                this.pos = beforetitle;\n                // and instead check if the link URL is at the line end\n                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;\n            }\n        }\n        if (!atLineEnd) {\n            this.pos = startpos;\n            return 0;\n        }\n        var normalLabel = normalizeReference(rawlabel);\n        if (normalLabel === '') {\n            // label must contain non-whitespace characters\n            this.pos = startpos;\n            return 0;\n        }\n        var sourcepos = this.getReferenceDefSourcepos(block);\n        block.sourcepos[0][0] = sourcepos[1][0] + 1;\n        var node = createNode('refDef', sourcepos);\n        node.title = title;\n        node.dest = dest;\n        node.label = normalLabel;\n        block.insertBefore(node);\n        if (!refMap[normalLabel]) {\n            refMap[normalLabel] = createRefDefState(node);\n        }\n        else {\n            this.refDefCandidateMap[node.id] = node;\n        }\n        return this.pos - startpos;\n    };\n    InlineParser.prototype.mergeTextNodes = function (walker) {\n        var event;\n        var textNodes = [];\n        while ((event = walker.next())) {\n            var entering = event.entering, node = event.node;\n            if (entering && node.type === 'text') {\n                textNodes.push(node);\n            }\n            else if (textNodes.length === 1) {\n                textNodes = [];\n            }\n            else if (textNodes.length > 1) {\n                var firstNode = textNodes[0];\n                var lastNode = textNodes[textNodes.length - 1];\n                if (firstNode.sourcepos && lastNode.sourcepos) {\n                    firstNode.sourcepos[1] = lastNode.sourcepos[1];\n                }\n                firstNode.next = lastNode.next;\n                if (firstNode.next) {\n                    firstNode.next.prev = firstNode;\n                }\n                for (var i = 1; i < textNodes.length; i += 1) {\n                    firstNode.literal += textNodes[i].literal;\n                    textNodes[i].unlink();\n                }\n                textNodes = [];\n            }\n        }\n    };\n    InlineParser.prototype.getReferenceDefSourcepos = function (block) {\n        var lines = block.stringContent.split(/\\n|\\r\\n/);\n        var passedUrlLine = false;\n        var quotationCount = 0;\n        var lastLineOffset = { line: 0, ch: 0 };\n        for (var i = 0; i < lines.length; i += 1) {\n            var line = lines[i];\n            if (reWhitespaceChar.test(line)) {\n                break;\n            }\n            if (/\\:/.test(line) && quotationCount === 0) {\n                if (passedUrlLine) {\n                    break;\n                }\n                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;\n                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };\n                passedUrlLine = true;\n            }\n            // should consider extendable title\n            var matched = line.match(/'|\"/g);\n            if (matched) {\n                quotationCount += matched.length;\n            }\n            if (quotationCount === 2) {\n                lastLineOffset = { line: i, ch: line.length };\n                break;\n            }\n        }\n        return [\n            [block.sourcepos[0][0], block.sourcepos[0][1]],\n            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],\n        ];\n    };\n    // Parse the next inline element in subject, advancing subject position.\n    // On success, add the result to block's children and return true.\n    // On failure, return false.\n    InlineParser.prototype.parseInline = function (block) {\n        var _a;\n        var res = false;\n        var c = this.peek();\n        if (c === -1) {\n            return false;\n        }\n        switch (c) {\n            case C_NEWLINE:\n                res = this.parseNewline(block);\n                break;\n            case C_BACKSLASH:\n                res = this.parseBackslash(block);\n                break;\n            case C_BACKTICK:\n                res = this.parseBackticks(block);\n                break;\n            case C_ASTERISK:\n            case C_UNDERSCORE:\n            case C_TILDE:\n            case C_DOLLAR:\n                res = this.handleDelim(c, block);\n                break;\n            case C_SINGLEQUOTE:\n            case C_DOUBLEQUOTE:\n                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);\n                break;\n            case C_OPEN_BRACKET$1:\n                res = this.parseOpenBracket(block);\n                break;\n            case C_BANG:\n                res = this.parseBang(block);\n                break;\n            case C_CLOSE_BRACKET:\n                res = this.parseCloseBracket(block);\n                break;\n            case C_LESSTHAN$1:\n                res = this.parseAutolink(block) || this.parseHtmlTag(block);\n                break;\n            case C_AMPERSAND:\n                if (!block.disabledEntityParse) {\n                    res = this.parseEntity(block);\n                }\n                break;\n            default:\n                res = this.parseString(block);\n                break;\n        }\n        if (!res) {\n            this.pos += 1;\n            block.appendChild(esm_text(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));\n        }\n        return true;\n    };\n    // Parse string content in block into inline children,\n    // using refmap to resolve references.\n    InlineParser.prototype.parse = function (block) {\n        this.subject = block.stringContent.trim();\n        this.pos = 0;\n        this.delimiters = null;\n        this.brackets = null;\n        this.lineOffsets = block.lineOffsets || [0];\n        this.lineIdx = 0;\n        this.linePosOffset = 0;\n        this.lineStartNum = block.sourcepos[0][0];\n        if (isHeading(block)) {\n            this.lineOffsets[0] += block.level + 1;\n        }\n        while (this.parseInline(block)) { }\n        block.stringContent = null; // allow raw string to be garbage collected\n        this.processEmphasis(null);\n        this.mergeTextNodes(block.walker());\n        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;\n        if (extendedAutolinks) {\n            convertExtAutoLinks(block.walker(), extendedAutolinks);\n        }\n        if (customParser && block.firstChild) {\n            var event_1;\n            var walker = block.firstChild.walker();\n            while ((event_1 = walker.next())) {\n                var node = event_1.node, entering = event_1.entering;\n                if (customParser[node.type]) {\n                    customParser[node.type](node, { entering: entering, options: this.options });\n                }\n            }\n        }\n    };\n    return InlineParser;\n}());\nvar reTaskListItemMarker = /^\\[([ \\txX])\\][ \\t]+/;\n// finalize for block handler\nfunction taskListItemFinalize(_, block) {\n    if (block.firstChild && block.firstChild.type === 'paragraph') {\n        var p = block.firstChild;\n        var m = p.stringContent.match(reTaskListItemMarker);\n        if (m) {\n            var mLen = m[0].length;\n            p.stringContent = p.stringContent.substring(mLen - 1);\n            p.sourcepos[0][1] += mLen;\n            p.lineOffsets[0] += mLen;\n            block.listData.task = true;\n            block.listData.checked = /[xX]/.test(m[1]);\n        }\n    }\n}\nvar table = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableHead' || t === 'tableBody';\n    },\n    acceptsLines: false,\n};\nvar tableBody$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow';\n    },\n    acceptsLines: false,\n};\nvar tableHead$1 = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableRow' || t === 'tableDelimRow';\n    },\n    acceptsLines: false,\n};\nvar tableDelimRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableDelimCell';\n    },\n    acceptsLines: false,\n};\nvar tableDelimCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar tableRow = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t === 'tableCell';\n    },\n    acceptsLines: false,\n};\nvar tableCell = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar CODE_INDENT = 4;\nvar C_TAB = 9;\nvar C_GREATERTHAN = 62;\nvar C_LESSTHAN = 60;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nfunction endsWithBlankLine(block) {\n    var curBlock = block;\n    while (curBlock) {\n        if (curBlock.lastLineBlank) {\n            return true;\n        }\n        var t = curBlock.type;\n        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {\n            curBlock.lastLineChecked = true;\n            curBlock = curBlock.lastChild;\n        }\n        else {\n            curBlock.lastLineChecked = true;\n            break;\n        }\n    }\n    return false;\n}\nfunction peek(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    }\n    return -1;\n}\n// Returns true if string contains only space characters.\nfunction isBlank(s) {\n    return !reNonSpace.test(s);\n}\nfunction isSpaceOrTab(c) {\n    return c === C_SPACE || c === C_TAB;\n}\nvar reClosingCustomBlock = /^\\$\\$$/;\nvar customBlock$1 = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reClosingCustomBlock);\n        if (match) {\n            // closing custom block\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        // skip optional spaces of custom block offset\n        var i = container.offset;\n        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {\n            parser.advanceOffset(1, true);\n            i--;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        // first line becomes info string\n        var content = block.stringContent;\n        var newlinePos = content.indexOf('\\n');\n        var firstLine = content.slice(0, newlinePos);\n        var rest = content.slice(newlinePos + 1);\n        var infoString = firstLine.match(/^(\\s*)(.*)/);\n        block.info = unescapeString(infoString[2].trim());\n        block.literal = rest;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar noop = {\n    continue: function () {\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar document$1 = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar list = {\n    continue: function () {\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var item = block.firstChild;\n        while (item) {\n            // check for non-final list item ending with blank line:\n            if (endsWithBlankLine(item) && item.next) {\n                block.listData.tight = false;\n                break;\n            }\n            // recurse into children of list item, to see if there are\n            // spaces between any of them:\n            var subitem = item.firstChild;\n            while (subitem) {\n                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {\n                    block.listData.tight = false;\n                    break;\n                }\n                subitem = subitem.next;\n            }\n            item = item.next;\n        }\n    },\n    canContain: function (t) {\n        return t === 'item';\n    },\n    acceptsLines: false,\n};\nvar blockQuote$1 = {\n    continue: function (parser) {\n        var ln = parser.currentLine;\n        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.advanceNextNonspace();\n            parser.advanceOffset(1, false);\n            if (isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n            }\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function () { },\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar item = {\n    continue: function (parser, container) {\n        if (parser.blank) {\n            if (container.firstChild === null) {\n                // Blank line after empty list item\n                return 1 /* Stop */;\n            }\n            parser.advanceNextNonspace();\n        }\n        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {\n            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);\n        }\n        else {\n            return 1 /* Stop */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: taskListItemFinalize,\n    canContain: function (t) {\n        return t !== 'item';\n    },\n    acceptsLines: false,\n};\nvar heading = {\n    continue: function () {\n        // a heading can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar thematicBreak$1 = {\n    continue: function () {\n        // a thematic break can never container > 1 line, so fail to match:\n        return 1 /* Stop */;\n    },\n    finalize: function () { },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: false,\n};\nvar codeBlock = {\n    continue: function (parser, container) {\n        var ln = parser.currentLine;\n        var indent = parser.indent;\n        if (container.isFenced) {\n            // fenced\n            var match = indent <= 3 &&\n                ln.charAt(parser.nextNonspace) === container.fenceChar &&\n                ln.slice(parser.nextNonspace).match(reClosingCodeFence);\n            if (match && match[0].length >= container.fenceLength) {\n                // closing fence - we're at end of line, so we can return\n                parser.lastLineLength = parser.offset + indent + match[0].length;\n                parser.finalize(container, parser.lineNumber);\n                return 2 /* Finished */;\n            }\n            // skip optional spaces of fence offset\n            var i = container.fenceOffset;\n            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {\n                parser.advanceOffset(1, true);\n                i--;\n            }\n        }\n        else {\n            // indented\n            if (indent >= CODE_INDENT) {\n                parser.advanceOffset(CODE_INDENT, true);\n            }\n            else if (parser.blank) {\n                parser.advanceNextNonspace();\n            }\n            else {\n                return 1 /* Stop */;\n            }\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        if (block.stringContent === null) {\n            return;\n        }\n        if (block.isFenced) {\n            // fenced\n            // first line becomes info string\n            var content = block.stringContent;\n            var newlinePos = content.indexOf('\\n');\n            var firstLine = content.slice(0, newlinePos);\n            var rest = content.slice(newlinePos + 1);\n            var infoString = firstLine.match(/^(\\s*)(.*)/);\n            block.infoPadding = infoString[1].length;\n            block.info = unescapeString(infoString[2].trim());\n            block.literal = rest;\n        }\n        else {\n            // indented\n            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '\\n');\n        }\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar htmlBlock$1 = {\n    continue: function (parser, container) {\n        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)\n            ? 1 /* Stop */\n            : 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        var _a;\n        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\\n *)+$/, '')) || null;\n        block.stringContent = null; // allow GC\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar paragraph = {\n    continue: function (parser) {\n        return parser.blank ? 1 /* Stop */ : 0 /* Go */;\n    },\n    finalize: function (parser, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        var pos;\n        var hasReferenceDefs = false;\n        // try parsing the beginning as link reference definitions:\n        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {\n            block.stringContent = block.stringContent.slice(pos);\n            hasReferenceDefs = true;\n        }\n        if (hasReferenceDefs && isBlank(block.stringContent)) {\n            block.unlink();\n        }\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar refDef = noop;\nvar frontMatter$2 = noop;\nvar blockHandlers = {\n    document: document$1,\n    list: list,\n    blockQuote: blockQuote$1,\n    item: item,\n    heading: heading,\n    thematicBreak: thematicBreak$1,\n    codeBlock: codeBlock,\n    htmlBlock: htmlBlock$1,\n    paragraph: paragraph,\n    table: table,\n    tableBody: tableBody$1,\n    tableHead: tableHead$1,\n    tableRow: tableRow,\n    tableCell: tableCell,\n    tableDelimRow: tableDelimRow,\n    tableDelimCell: tableDelimCell,\n    refDef: refDef,\n    customBlock: customBlock$1,\n    frontMatter: frontMatter$2,\n};\nfunction parseRowContent(content) {\n    var startIdx = 0;\n    var offset = 0;\n    var cells = [];\n    for (var i = 0; i < content.length; i += 1) {\n        if (content[i] === '|' && content[i - 1] !== '\\\\') {\n            var cell = content.substring(startIdx, i);\n            if (startIdx === 0 && isEmpty(cell)) {\n                offset = i + 1;\n            }\n            else {\n                cells.push(cell);\n            }\n            startIdx = i + 1;\n        }\n    }\n    if (startIdx < content.length) {\n        var cell = content.substring(startIdx, content.length);\n        if (!isEmpty(cell)) {\n            cells.push(cell);\n        }\n    }\n    return [offset, cells];\n}\nfunction generateTableCells(cellType, contents, lineNum, chPos) {\n    var cells = [];\n    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {\n        var content = contents_1[_i];\n        var preSpaces = content.match(/^[ \\t]+/);\n        var paddingLeft = preSpaces ? preSpaces[0].length : 0;\n        var paddingRight = void 0, trimmed = void 0;\n        if (paddingLeft === content.length) {\n            paddingLeft = 0;\n            paddingRight = 0;\n            trimmed = '';\n        }\n        else {\n            var postSpaces = content.match(/[ \\t]+$/);\n            paddingRight = postSpaces ? postSpaces[0].length : 0;\n            trimmed = content.slice(paddingLeft, content.length - paddingRight);\n        }\n        var chPosStart = chPos + paddingLeft;\n        var tableCell = createNode(cellType, [\n            [lineNum, chPos],\n            [lineNum, chPos + content.length - 1],\n        ]);\n        tableCell.stringContent = trimmed.replace(/\\\\\\|/g, '|'); // replace esacped pipe(\\|)\n        tableCell.startIdx = cells.length;\n        tableCell.endIdx = cells.length;\n        tableCell.lineOffsets = [chPosStart - 1];\n        tableCell.paddingLeft = paddingLeft;\n        tableCell.paddingRight = paddingRight;\n        cells.push(tableCell);\n        chPos += content.length + 1;\n    }\n    return cells;\n}\nfunction getColumnFromDelimCell(cellNode) {\n    var align = null;\n    var content = cellNode.stringContent;\n    var firstCh = content[0];\n    var lastCh = content[content.length - 1];\n    if (lastCh === ':') {\n        align = firstCh === ':' ? 'center' : 'right';\n    }\n    else if (firstCh === ':') {\n        align = 'left';\n    }\n    return { align: align };\n}\nvar tableHead = function (parser, container) {\n    var stringContent = container.stringContent;\n    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {\n        var lastNewLineIdx = stringContent.length - 1;\n        var lastLineStartIdx = stringContent.lastIndexOf('\\n', lastNewLineIdx - 1) + 1;\n        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);\n        var delimContent = parser.currentLine.slice(parser.nextNonspace);\n        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];\n        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];\n        var reValidDelimCell_1 = /^[ \\t]*:?-+:?[ \\t]*$/;\n        if (\n        // not checking if the number of header cells and delimiter cells are the same\n        // to consider the case of merged-column (via plugin)\n        !headerCells.length ||\n            !delimCells.length ||\n            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||\n            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option\n            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {\n            return 0 /* None */;\n        }\n        var lineOffsets = container.lineOffsets;\n        var firstLineNum = parser.lineNumber - 1;\n        var firstLineStart = last(lineOffsets) + 1;\n        var table = createNode('table', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        // eslint-disable-next-line arrow-body-style\n        table.columns = delimCells.map(function () { return ({ align: null }); });\n        container.insertAfter(table);\n        if (lineOffsets.length === 1) {\n            container.unlink();\n        }\n        else {\n            container.stringContent = stringContent.slice(0, lastLineStartIdx);\n            var paraLastLineStartIdx = stringContent.lastIndexOf('\\n', lastLineStartIdx - 2) + 1;\n            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;\n            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;\n            parser.finalize(container, firstLineNum - 1);\n        }\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        var tableHead_1 = createNode('tableHead', [\n            [firstLineNum, firstLineStart],\n            [parser.lineNumber, parser.offset],\n        ]);\n        table.appendChild(tableHead_1);\n        var tableHeadRow_1 = createNode('tableRow', [\n            [firstLineNum, firstLineStart],\n            [firstLineNum, firstLineStart + headerContent.length - 1],\n        ]);\n        var tableDelimRow_1 = createNode('tableDelimRow', [\n            [parser.lineNumber, parser.nextNonspace + 1],\n            [parser.lineNumber, parser.offset],\n        ]);\n        tableHead_1.appendChild(tableHeadRow_1);\n        tableHead_1.appendChild(tableDelimRow_1);\n        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {\n            tableHeadRow_1.appendChild(cellNode);\n        });\n        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);\n        delimCellNodes.forEach(function (cellNode) {\n            tableDelimRow_1.appendChild(cellNode);\n        });\n        table.columns = delimCellNodes.map(getColumnFromDelimCell);\n        parser.tip = table;\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar tableBody = function (parser, container) {\n    if ((container.type !== 'table' && container.type !== 'tableBody') ||\n        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {\n        return 0 /* None */;\n    }\n    parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n    if (parser.blank) {\n        var table_1 = container;\n        if (container.type === 'tableBody') {\n            table_1 = container.parent;\n            parser.finalize(container, parser.lineNumber - 1);\n        }\n        parser.finalize(table_1, parser.lineNumber - 1);\n        return 0 /* None */;\n    }\n    var tableBody = container;\n    if (container.type === 'table') {\n        tableBody = parser.addChild('tableBody', parser.nextNonspace);\n        tableBody.stringContent = null;\n    }\n    var tableRow = createNode('tableRow', [\n        [parser.lineNumber, parser.nextNonspace + 1],\n        [parser.lineNumber, parser.currentLine.length],\n    ]);\n    tableBody.appendChild(tableRow);\n    var table = tableBody.parent;\n    var content = parser.currentLine.slice(parser.nextNonspace);\n    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];\n    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {\n        if (idx >= table.columns.length) {\n            cellNode.ignored = true;\n        }\n        tableRow.appendChild(cellNode);\n    });\n    return 2 /* Leaf */;\n};\nvar reCustomBlock = /^(\\$\\$)(\\s*[a-zA-Z])+/;\nvar reCanBeCustomInline = /^(\\$\\$)(\\s*[a-zA-Z])+.*(\\$\\$)/;\nvar customBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        !reCanBeCustomInline.test(parser.currentLine) &&\n        (match = parser.currentLine.match(reCustomBlock))) {\n        var syntaxLength = match[1].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('customBlock', parser.nextNonspace);\n        container.syntaxLength = syntaxLength;\n        container.offset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(syntaxLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;\nvar reHtmlBlockOpen = [\n    /./,\n    /^<(?:script|pre|style)(?:\\s|>|$)/i,\n    /^<!--/,\n    /^<[?]/,\n    /^<![A-Z]/,\n    /^<!\\[CDATA\\[/,\n    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|[/]?[>]|$)/i,\n    new RegExp(\"^(?:\" + OPENTAG + \"|\" + CLOSETAG + \")\\\\s*$\", 'i'),\n];\nvar reSetextHeadingLine = /^(?:=+|-+)[ \\t]*$/;\nvar reATXHeadingMarker = /^#{1,6}(?:[ \\t]+|$)/;\nvar reThematicBreak = /^(?:(?:\\*[ \\t]*){3,}|(?:_[ \\t]*){3,}|(?:-[ \\t]*){3,})[ \\t]*$/;\nvar reBulletListMarker = /^[*+-]/;\nvar reOrderedListMarker = /^(\\d{1,9})([.)])/;\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nfunction parseListMarker(parser, container) {\n    var rest = parser.currentLine.slice(parser.nextNonspace);\n    var match;\n    var nextc;\n    var data = {\n        type: 'bullet',\n        tight: true,\n        bulletChar: '',\n        start: 0,\n        delimiter: '',\n        padding: 0,\n        markerOffset: parser.indent,\n        // GFM: Task List Item\n        task: false,\n        checked: false,\n    };\n    if (parser.indent >= 4) {\n        return null;\n    }\n    if ((match = rest.match(reBulletListMarker))) {\n        data.type = 'bullet';\n        data.bulletChar = match[0][0];\n    }\n    else if ((match = rest.match(reOrderedListMarker)) &&\n        (container.type !== 'paragraph' || match[1] === '1')) {\n        data.type = 'ordered';\n        data.start = parseInt(match[1], 10);\n        data.delimiter = match[2];\n    }\n    else {\n        return null;\n    }\n    // make sure we have spaces after\n    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);\n    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {\n        return null;\n    }\n    // if it interrupts paragraph, make sure first line isn't blank\n    if (container.type === 'paragraph' &&\n        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {\n        return null;\n    }\n    // we've got a match! advance offset and calculate padding\n    parser.advanceNextNonspace(); // to start of marker\n    parser.advanceOffset(match[0].length, true); // to end of marker\n    var spacesStartCol = parser.column;\n    var spacesStartOffset = parser.offset;\n    do {\n        parser.advanceOffset(1, true);\n        nextc = peek(parser.currentLine, parser.offset);\n    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));\n    var blankItem = peek(parser.currentLine, parser.offset) === -1;\n    var spacesAfterMarker = parser.column - spacesStartCol;\n    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {\n        data.padding = match[0].length + 1;\n        parser.column = spacesStartCol;\n        parser.offset = spacesStartOffset;\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n    }\n    else {\n        data.padding = match[0].length + spacesAfterMarker;\n    }\n    return data;\n}\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nfunction listsMatch(listData, itemData) {\n    return (listData.type === itemData.type &&\n        listData.delimiter === itemData.delimiter &&\n        listData.bulletChar === itemData.bulletChar);\n}\nfunction isDisallowedDeepHeading(parser, node) {\n    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');\n}\nvar blockQuote = function (parser) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(1, false);\n        // optional following space\n        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {\n            parser.advanceOffset(1, true);\n        }\n        parser.closeUnmatchedBlocks();\n        parser.addChild('blockQuote', parser.nextNonspace);\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\nvar atxHeading = function (parser, container) {\n    var match;\n    if (!parser.indented &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {\n        parser.advanceNextNonspace();\n        parser.advanceOffset(match[0].length, false);\n        parser.closeUnmatchedBlocks();\n        var heading = parser.addChild('heading', parser.nextNonspace);\n        heading.level = match[0].trim().length; // number of #s\n        heading.headingType = 'atx';\n        // remove trailing ###s:\n        heading.stringContent = parser.currentLine\n            .slice(parser.offset)\n            .replace(/^[ \\t]*#+[ \\t]*$/, '')\n            .replace(/[ \\t]+#+[ \\t]*$/, '');\n        parser.advanceOffset(parser.currentLine.length - parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar fencedCodeBlock = function (parser) {\n    var match;\n    if (!parser.indented &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n        var fenceLength = match[0].length;\n        parser.closeUnmatchedBlocks();\n        var container = parser.addChild('codeBlock', parser.nextNonspace);\n        container.isFenced = true;\n        container.fenceLength = fenceLength;\n        container.fenceChar = match[0][0];\n        container.fenceOffset = parser.indent;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(fenceLength, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar htmlBlock = function (parser, container) {\n    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {\n        var s = parser.currentLine.slice(parser.nextNonspace);\n        var disallowedTags = parser.options.disallowedHtmlBlockTags;\n        var blockType = void 0;\n        for (blockType = 1; blockType <= 7; blockType++) {\n            var matched = s.match(reHtmlBlockOpen[blockType]);\n            if (matched) {\n                if (blockType === 7) {\n                    if (container.type === 'paragraph') {\n                        return 0 /* None */;\n                    }\n                    if (disallowedTags.length > 0) {\n                        var reDisallowedTags = new RegExp(\"</?(?:\" + disallowedTags.join('|') + \")\", 'i');\n                        if (reDisallowedTags.test(matched[0])) {\n                            return 0 /* None */;\n                        }\n                    }\n                }\n                parser.closeUnmatchedBlocks();\n                // We don't adjust parser.offset;\n                // spaces are part of the HTML block:\n                var b = parser.addChild('htmlBlock', parser.offset);\n                b.htmlBlockType = blockType;\n                return 2 /* Leaf */;\n            }\n        }\n    }\n    return 0 /* None */;\n};\nvar seTextHeading = function (parser, container) {\n    var match;\n    if (container.stringContent !== null &&\n        !parser.indented &&\n        container.type === 'paragraph' &&\n        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option\n        !isDisallowedDeepHeading(parser, container.parent) &&\n        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {\n        parser.closeUnmatchedBlocks();\n        // resolve reference link definitions\n        var pos = void 0;\n        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&\n            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {\n            container.stringContent = container.stringContent.slice(pos);\n        }\n        if (container.stringContent.length > 0) {\n            var heading = createNode('heading', container.sourcepos);\n            heading.level = match[0][0] === '=' ? 1 : 2;\n            heading.headingType = 'setext';\n            heading.stringContent = container.stringContent;\n            container.insertAfter(heading);\n            container.unlink();\n            parser.tip = heading;\n            parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n            return 2 /* Leaf */;\n        }\n        return 0 /* None */;\n    }\n    return 0 /* None */;\n};\nvar thematicBreak = function (parser) {\n    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {\n        parser.closeUnmatchedBlocks();\n        parser.addChild('thematicBreak', parser.nextNonspace);\n        parser.advanceOffset(parser.currentLine.length - parser.offset, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar listItem = function (parser, container) {\n    var data;\n    var currNode = container;\n    if ((!parser.indented || container.type === 'list') &&\n        (data = parseListMarker(parser, currNode))) {\n        parser.closeUnmatchedBlocks();\n        // add the list if needed\n        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {\n            currNode = parser.addChild('list', parser.nextNonspace);\n            currNode.listData = data;\n        }\n        // add the list item\n        currNode = parser.addChild('item', parser.nextNonspace);\n        currNode.listData = data;\n        return 1 /* Container */;\n    }\n    return 0 /* None */;\n};\n// indented code block\nvar indentedCodeBlock = function (parser) {\n    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {\n        // indented code\n        parser.advanceOffset(CODE_INDENT, true);\n        parser.closeUnmatchedBlocks();\n        parser.addChild('codeBlock', parser.offset);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar blockStarts = [\n    blockQuote,\n    atxHeading,\n    fencedCodeBlock,\n    htmlBlock,\n    seTextHeading,\n    thematicBreak,\n    listItem,\n    indentedCodeBlock,\n    tableHead,\n    tableBody,\n    customBlock,\n];\n// `---` for YAML, `+++` for TOML, `;;;` for JSON\nvar reFrontMatter = /^(-{3}|\\+{3}|;{3})$/;\nvar frontMatter$1 = function (parser, container) {\n    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;\n    if (lineNumber === 1 &&\n        !indented &&\n        container.type === 'document' &&\n        reFrontMatter.test(currentLine)) {\n        parser.closeUnmatchedBlocks();\n        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);\n        frontMatter_1.stringContent = currentLine;\n        parser.advanceNextNonspace();\n        parser.advanceOffset(currentLine.length, false);\n        return 2 /* Leaf */;\n    }\n    return 0 /* None */;\n};\nvar frontMatter = {\n    continue: function (parser, container) {\n        var line = parser.currentLine;\n        var match = line.match(reFrontMatter);\n        if (container.type === 'frontMatter' && match) {\n            container.stringContent += line;\n            parser.lastLineLength = match[0].length;\n            parser.finalize(container, parser.lineNumber);\n            return 2 /* Finished */;\n        }\n        return 0 /* Go */;\n    },\n    finalize: function (_, block) {\n        if (block.stringContent === null) {\n            return;\n        }\n        block.literal = block.stringContent;\n        block.stringContent = null;\n    },\n    canContain: function () {\n        return false;\n    },\n    acceptsLines: true,\n};\nvar reHtmlBlockClose = [\n    /./,\n    /<\\/(?:script|pre|style)>/i,\n    /-->/,\n    /\\?>/,\n    />/,\n    /\\]\\]>/,\n];\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;\nvar reLineEnding$1 = /\\r\\n|\\n|\\r/;\nfunction esm_document() {\n    return createNode('document', [\n        [1, 1],\n        [0, 0],\n    ]);\n}\nvar defaultOptions$1 = {\n    smart: false,\n    tagFilter: false,\n    extendedAutolinks: false,\n    disallowedHtmlBlockTags: [],\n    referenceDefinition: false,\n    disallowDeepHeading: false,\n    customParser: null,\n    frontMatter: false,\n};\nvar Parser = /** @class */ (function () {\n    function Parser(options) {\n        this.options = esm_assign(esm_assign({}, defaultOptions$1), options);\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.oldtip = this.doc;\n        this.lineNumber = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.nextNonspace = 0;\n        this.nextNonspaceColumn = 0;\n        this.indent = 0;\n        this.currentLine = '';\n        this.indented = false;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.allClosed = true;\n        this.lastMatchedContainer = this.doc;\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.lastLineLength = 0;\n        this.lines = [];\n        if (this.options.frontMatter) {\n            blockHandlers.frontMatter = frontMatter;\n            blockStarts.unshift(frontMatter$1);\n        }\n        this.inlineParser = new InlineParser(this.options);\n    }\n    Parser.prototype.advanceOffset = function (count, columns) {\n        if (columns === void 0) {\n            columns = false;\n        }\n        var currentLine = this.currentLine;\n        var charsToTab, charsToAdvance;\n        var c;\n        while (count > 0 && (c = currentLine[this.offset])) {\n            if (c === '\\t') {\n                charsToTab = 4 - (this.column % 4);\n                if (columns) {\n                    this.partiallyConsumedTab = charsToTab > count;\n                    charsToAdvance = charsToTab > count ? count : charsToTab;\n                    this.column += charsToAdvance;\n                    this.offset += this.partiallyConsumedTab ? 0 : 1;\n                    count -= charsToAdvance;\n                }\n                else {\n                    this.partiallyConsumedTab = false;\n                    this.column += charsToTab;\n                    this.offset += 1;\n                    count -= 1;\n                }\n            }\n            else {\n                this.partiallyConsumedTab = false;\n                this.offset += 1;\n                this.column += 1; // assume ascii; block starts are ascii\n                count -= 1;\n            }\n        }\n    };\n    Parser.prototype.advanceNextNonspace = function () {\n        this.offset = this.nextNonspace;\n        this.column = this.nextNonspaceColumn;\n        this.partiallyConsumedTab = false;\n    };\n    Parser.prototype.findNextNonspace = function () {\n        var currentLine = this.currentLine;\n        var i = this.offset;\n        var cols = this.column;\n        var c;\n        while ((c = currentLine.charAt(i)) !== '') {\n            if (c === ' ') {\n                i++;\n                cols++;\n            }\n            else if (c === '\\t') {\n                i++;\n                cols += 4 - (cols % 4);\n            }\n            else {\n                break;\n            }\n        }\n        this.blank = c === '\\n' || c === '\\r' || c === '';\n        this.nextNonspace = i;\n        this.nextNonspaceColumn = cols;\n        this.indent = this.nextNonspaceColumn - this.column;\n        this.indented = this.indent >= CODE_INDENT;\n    };\n    // Add a line to the block at the tip.  We assume the tip\n    // can accept lines -- that check should be done before calling this.\n    Parser.prototype.addLine = function () {\n        if (this.partiallyConsumedTab) {\n            this.offset += 1; // skip over tab\n            // add space characters:\n            var charsToTab = 4 - (this.column % 4);\n            this.tip.stringContent += repeat(' ', charsToTab);\n        }\n        if (this.tip.lineOffsets) {\n            this.tip.lineOffsets.push(this.offset);\n        }\n        else {\n            this.tip.lineOffsets = [this.offset];\n        }\n        this.tip.stringContent += this.currentLine.slice(this.offset) + \"\\n\";\n    };\n    // Add block of type tag as a child of the tip.  If the tip can't\n    // accept children, close and finalize it and try its parent,\n    // and so on til we find a block that can accept children.\n    Parser.prototype.addChild = function (tag, offset) {\n        while (!blockHandlers[this.tip.type].canContain(tag)) {\n            this.finalize(this.tip, this.lineNumber - 1);\n        }\n        var columnNumber = offset + 1; // offset 0 = column 1\n        var newBlock = createNode(tag, [\n            [this.lineNumber, columnNumber],\n            [0, 0],\n        ]);\n        newBlock.stringContent = '';\n        this.tip.appendChild(newBlock);\n        this.tip = newBlock;\n        return newBlock;\n    };\n    // Finalize and close any unmatched blocks.\n    Parser.prototype.closeUnmatchedBlocks = function () {\n        if (!this.allClosed) {\n            // finalize any blocks not matched\n            while (this.oldtip !== this.lastMatchedContainer) {\n                var parent_1 = this.oldtip.parent;\n                this.finalize(this.oldtip, this.lineNumber - 1);\n                this.oldtip = parent_1;\n            }\n            this.allClosed = true;\n        }\n    };\n    // Finalize a block.  Close it and do any necessary postprocessing,\n    // e.g. creating stringContent from strings, setting the 'tight'\n    // or 'loose' status of a list, and parsing the beginnings\n    // of paragraphs for reference definitions.  Reset the tip to the\n    // parent of the closed block.\n    Parser.prototype.finalize = function (block, lineNumber) {\n        var above = block.parent;\n        block.open = false;\n        block.sourcepos[1] = [lineNumber, this.lastLineLength];\n        blockHandlers[block.type].finalize(this, block);\n        this.tip = above;\n    };\n    // Walk through a block & children recursively, parsing string content\n    // into inline content where appropriate.\n    Parser.prototype.processInlines = function (block) {\n        var event;\n        var customParser = this.options.customParser;\n        var walker = block.walker();\n        this.inlineParser.refMap = this.refMap;\n        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;\n        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;\n        this.inlineParser.options = this.options;\n        while ((event = walker.next())) {\n            var node = event.node, entering = event.entering;\n            var t = node.type;\n            if (customParser && customParser[t]) {\n                customParser[t](node, { entering: entering, options: this.options });\n            }\n            if (!entering &&\n                (t === 'paragraph' ||\n                    t === 'heading' ||\n                    (t === 'tableCell' && !node.ignored))) {\n                this.inlineParser.parse(node);\n            }\n        }\n    };\n    // Analyze a line of text and update the document appropriately.\n    // We parse markdown text by calling this on each line of input,\n    // then finalizing the document.\n    Parser.prototype.incorporateLine = function (ln) {\n        var container = this.doc;\n        this.oldtip = this.tip;\n        this.offset = 0;\n        this.column = 0;\n        this.blank = false;\n        this.partiallyConsumedTab = false;\n        this.lineNumber += 1;\n        // replace NUL characters for security\n        if (ln.indexOf('\\u0000') !== -1) {\n            ln = ln.replace(/\\0/g, '\\uFFFD');\n        }\n        this.currentLine = ln;\n        // For each containing block, try to parse the associated line start.\n        // Bail out on failure: container will point to the last matching block.\n        // Set allMatched to false if not all containers match.\n        var allMatched = true;\n        var lastChild;\n        while ((lastChild = container.lastChild) && lastChild.open) {\n            container = lastChild;\n            this.findNextNonspace();\n            switch (blockHandlers[container.type]['continue'](this, container)) {\n                case 0 /* Go */: // we've matched, keep going\n                    break;\n                case 1 /* Stop */: // we've failed to match a block\n                    allMatched = false;\n                    break;\n                case 2 /* Finished */: // we've hit end of line for fenced code close and can return\n                    this.lastLineLength = ln.length;\n                    return;\n                default:\n                    throw new Error('continue returned illegal value, must be 0, 1, or 2');\n            }\n            if (!allMatched) {\n                container = container.parent; // back up to last matching block\n                break;\n            }\n        }\n        this.allClosed = container === this.oldtip;\n        this.lastMatchedContainer = container;\n        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;\n        var blockStartsLen = blockStarts.length;\n        // Unless last matched container is a code block, try new container starts,\n        // adding children to the last matched container:\n        while (!matchedLeaf) {\n            this.findNextNonspace();\n            // this is a little performance optimization:\n            if (container.type !== 'table' &&\n                container.type !== 'tableBody' &&\n                container.type !== 'paragraph' &&\n                !this.indented &&\n                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n                this.advanceNextNonspace();\n                break;\n            }\n            var i = 0;\n            while (i < blockStartsLen) {\n                var res = blockStarts[i](this, container);\n                if (res === 1 /* Container */) {\n                    container = this.tip;\n                    break;\n                }\n                else if (res === 2 /* Leaf */) {\n                    container = this.tip;\n                    matchedLeaf = true;\n                    break;\n                }\n                else {\n                    i++;\n                }\n            }\n            if (i === blockStartsLen) {\n                // nothing matched\n                this.advanceNextNonspace();\n                break;\n            }\n        }\n        // What remains at the offset is a text line.  Add the text to the\n        // appropriate container.\n        // First check for a lazy paragraph continuation:\n        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {\n            // lazy paragraph continuation\n            this.addLine();\n        }\n        else {\n            // not a lazy continuation\n            // finalize any blocks not matched\n            this.closeUnmatchedBlocks();\n            if (this.blank && container.lastChild) {\n                container.lastChild.lastLineBlank = true;\n            }\n            var t = container.type;\n            // Block quote lines are never blank as they start with >\n            // and we don't count blanks in fenced code for purposes of tight/loose\n            // lists or breaking out of lists. We also don't set _lastLineBlank\n            // on an empty list item, or if we just closed a fenced block.\n            var lastLineBlank = this.blank &&\n                !(t === 'blockQuote' ||\n                    (isCodeBlock(container) && container.isFenced) ||\n                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));\n            // propagate lastLineBlank up through parents:\n            var cont = container;\n            while (cont) {\n                cont.lastLineBlank = lastLineBlank;\n                cont = cont.parent;\n            }\n            if (blockHandlers[t].acceptsLines) {\n                this.addLine();\n                // if HtmlBlock, check for end condition\n                if (isHtmlBlock(container) &&\n                    container.htmlBlockType >= 1 &&\n                    container.htmlBlockType <= 5 &&\n                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {\n                    this.lastLineLength = ln.length;\n                    this.finalize(container, this.lineNumber);\n                }\n            }\n            else if (this.offset < ln.length && !this.blank) {\n                // create paragraph container for line\n                container = this.addChild('paragraph', this.offset);\n                this.advanceNextNonspace();\n                this.addLine();\n            }\n        }\n        this.lastLineLength = ln.length;\n    };\n    // The main parsing function.  Returns a parsed document AST.\n    Parser.prototype.parse = function (input, lineTexts) {\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.lineNumber = 0;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var lines = input.split(reLineEnding$1);\n        var len = lines.length;\n        this.lines = lineTexts ? lineTexts : lines;\n        if (this.options.referenceDefinition) {\n            this.clearRefMaps();\n        }\n        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n            // ignore last blank line created by final newline\n            len -= 1;\n        }\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        while (this.tip) {\n            this.finalize(this.tip, len);\n        }\n        this.processInlines(this.doc);\n        return this.doc;\n    };\n    Parser.prototype.partialParseStart = function (lineNumber, lines) {\n        this.doc = esm_document();\n        this.tip = this.doc;\n        this.lineNumber = lineNumber - 1;\n        this.lastLineLength = 0;\n        this.offset = 0;\n        this.column = 0;\n        this.lastMatchedContainer = this.doc;\n        this.currentLine = '';\n        var len = lines.length;\n        for (var i = 0; i < len; i++) {\n            this.incorporateLine(lines[i]);\n        }\n        return this.doc;\n    };\n    Parser.prototype.partialParseExtends = function (lines) {\n        for (var i = 0; i < lines.length; i++) {\n            this.incorporateLine(lines[i]);\n        }\n    };\n    Parser.prototype.partialParseFinish = function () {\n        while (this.tip) {\n            this.finalize(this.tip, this.lineNumber);\n        }\n        this.processInlines(this.doc);\n    };\n    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {\n        this.refMap = refMap;\n        this.refLinkCandidateMap = refLinkCandidateMap;\n        this.refDefCandidateMap = refDefCandidateMap;\n    };\n    Parser.prototype.clearRefMaps = function () {\n        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {\n            clearObj(map);\n        });\n    };\n    return Parser;\n}());\nfunction comparePos(p1, p2) {\n    if (p1[0] < p2[0]) {\n        return 1 /* LT */;\n    }\n    if (p1[0] > p2[0]) {\n        return -1 /* GT */;\n    }\n    if (p1[1] < p2[1]) {\n        return 1 /* LT */;\n    }\n    if (p1[1] > p2[1]) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction compareRangeAndPos(_a, pos) {\n    var startPos = _a[0], endPos = _a[1];\n    if (comparePos(endPos, pos) === 1 /* LT */) {\n        return 1 /* LT */;\n    }\n    if (comparePos(startPos, pos) === -1 /* GT */) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction removeNextUntil(node, last) {\n    if (node.parent !== last.parent || node === last) {\n        return;\n    }\n    var next = node.next;\n    while (next && next !== last) {\n        var temp = next.next;\n        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {\n            var type = _a[_i];\n            if (next[type]) {\n                removeNodeById(next[type].id);\n                next[type] = null;\n            }\n        }\n        next = temp;\n    }\n    node.next = last.next;\n    if (last.next) {\n        last.next.prev = node;\n    }\n    else {\n        node.parent.lastChild = node;\n    }\n}\nfunction getChildNodes(parent) {\n    var nodes = [];\n    var curr = parent.firstChild;\n    while (curr) {\n        nodes.push(curr);\n        curr = curr.next;\n    }\n    return nodes;\n}\nfunction insertNodesBefore(target, nodes) {\n    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n        var node = nodes_1[_i];\n        target.insertBefore(node);\n    }\n}\nfunction prependChildNodes(parent, nodes) {\n    for (var i = nodes.length - 1; i >= 0; i -= 1) {\n        parent.prependChild(nodes[i]);\n    }\n}\nfunction updateNextLineNumbers(base, diff) {\n    if (!base || !base.parent || diff === 0) {\n        return;\n    }\n    var walker = base.parent.walker();\n    walker.resumeAt(base, true);\n    var event;\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            node.sourcepos[0][0] += diff;\n            node.sourcepos[1][0] += diff;\n        }\n    }\n}\nfunction compareRangeAndLine(_a, line) {\n    var startPos = _a[0], endPos = _a[1];\n    if (endPos[0] < line) {\n        return 1 /* LT */;\n    }\n    if (startPos[0] > line) {\n        return -1 /* GT */;\n    }\n    return 0 /* EQ */;\n}\nfunction findChildNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            return node;\n        }\n        if (comp === -1 /* GT */) {\n            // To consider that top line is blank line\n            return node.prev || node;\n        }\n        node = node.next;\n    }\n    return parent.lastChild;\n}\nfunction lastLeafNode(node) {\n    while (node.lastChild) {\n        node = node.lastChild;\n    }\n    return node;\n}\nfunction sameLineTopAncestor(node) {\n    while (node.parent &&\n        node.parent.type !== 'document' &&\n        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {\n        node = node.parent;\n    }\n    return node;\n}\nfunction findFirstNodeAtLine(parent, line) {\n    var node = parent.firstChild;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndLine(node.sourcepos, line);\n        if (comp === 0 /* EQ */) {\n            if (node.sourcepos[0][0] === line || !node.firstChild) {\n                return node;\n            }\n            prev = node;\n            node = node.firstChild;\n        }\n        else if (comp === -1 /* GT */) {\n            break;\n        }\n        else {\n            prev = node;\n            node = node.next;\n        }\n    }\n    if (prev) {\n        return sameLineTopAncestor(lastLeafNode(prev));\n    }\n    return null;\n}\nfunction findNodeAtPosition(parent, pos) {\n    var node = parent;\n    var prev = null;\n    while (node) {\n        var comp = compareRangeAndPos(node.sourcepos, pos);\n        if (comp === 0 /* EQ */) {\n            if (node.firstChild) {\n                prev = node;\n                node = node.firstChild;\n            }\n            else {\n                return node;\n            }\n        }\n        else if (comp === -1 /* GT */) {\n            return prev;\n        }\n        else if (node.next) {\n            node = node.next;\n        }\n        else {\n            return prev;\n        }\n    }\n    return node;\n}\nfunction findNodeById(id) {\n    return getNodeById(id) || null;\n}\nfunction invokeNextUntil(callback, start, end) {\n    if (end === void 0) {\n        end = null;\n    }\n    if (start) {\n        var walker = start.walker();\n        while (start && start !== end) {\n            callback(start);\n            var next = walker.next();\n            if (next) {\n                start = next.node;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\nfunction isUnlinked(id) {\n    var node = findNodeById(id);\n    if (!node) {\n        return true;\n    }\n    while (node && node.type !== 'document') {\n        // eslint-disable-next-line no-loop-func\n        if (!node.parent && !node.prev && !node.next) {\n            return true;\n        }\n        node = node.parent;\n    }\n    return false;\n}\nvar reLineEnding = /\\r\\n|\\n|\\r/;\nfunction canBeContinuedListItem(lineText) {\n    var spaceMatch = lineText.match(/^[ \\t]+/);\n    if (spaceMatch && (spaceMatch[0].length >= 2 || /\\t/.test(spaceMatch[0]))) {\n        return true;\n    }\n    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;\n    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);\n}\nfunction canBeContinuedTableBody(lineText) {\n    return !isBlank(lineText) && lineText.indexOf('|') !== -1;\n}\nfunction createRefDefState(node) {\n    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;\n    return {\n        id: id,\n        title: title,\n        sourcepos: sourcepos,\n        unlinked: false,\n        destination: dest,\n    };\n}\nvar ToastMark = /** @class */ (function () {\n    function ToastMark(contents, options) {\n        this.refMap = {};\n        this.refLinkCandidateMap = {};\n        this.refDefCandidateMap = {};\n        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);\n        this.parser = new Parser(options);\n        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);\n        this.eventHandlerMap = { change: [] };\n        contents = contents || '';\n        this.lineTexts = contents.split(reLineEnding);\n        this.root = this.parser.parse(contents, this.lineTexts);\n    }\n    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {\n        var _a;\n        var startLine = startPos[0], startCol = startPos[1];\n        var endLine = endPos[0], endCol = endPos[1];\n        var newLines = newText.split(reLineEnding);\n        var newLineLen = newLines.length;\n        var startLineText = this.lineTexts[startLine - 1];\n        var endLineText = this.lineTexts[endLine - 1];\n        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];\n        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);\n        var removedLineLen = endLine - startLine + 1;\n        (_a = this.lineTexts).splice.apply(_a, esm_spreadArray([startLine - 1, removedLineLen], newLines));\n        return newLineLen - removedLineLen;\n    };\n    ToastMark.prototype.updateRootNodeState = function () {\n        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {\n            this.root.lastLineBlank = true;\n            this.root.sourcepos = [\n                [1, 1],\n                [1, 0],\n            ];\n            return;\n        }\n        if (this.root.lastChild) {\n            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;\n        }\n        var lineTexts = this.lineTexts;\n        var idx = lineTexts.length - 1;\n        while (lineTexts[idx] === '') {\n            idx -= 1;\n        }\n        if (lineTexts.length - 2 > idx) {\n            idx += 1;\n        }\n        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];\n    };\n    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {\n        if (!startNode) {\n            if (endNode) {\n                insertNodesBefore(endNode, newNodes);\n                removeNodeById(endNode.id);\n                endNode.unlink();\n            }\n            else {\n                prependChildNodes(this.root, newNodes);\n            }\n        }\n        else {\n            insertNodesBefore(startNode, newNodes);\n            removeNextUntil(startNode, endNode);\n            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });\n            startNode.unlink();\n        }\n    };\n    ToastMark.prototype.getNodeRange = function (startPos, endPos) {\n        var startNode = findChildNodeAtLine(this.root, startPos[0]);\n        var endNode = findChildNodeAtLine(this.root, endPos[0]);\n        // extend node range to include a following block which doesn't have preceding blank line\n        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {\n            endNode = endNode.next;\n        }\n        return [startNode, endNode];\n    };\n    ToastMark.prototype.trigger = function (eventName, param) {\n        this.eventHandlerMap[eventName].forEach(function (handler) {\n            handler(param);\n        });\n    };\n    ToastMark.prototype.extendEndLine = function (line) {\n        while (this.lineTexts[line] === '') {\n            line += 1;\n        }\n        return line;\n    };\n    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {\n        // extends starting range if the first node can be a continued list item\n        if (startNode &&\n            startNode.prev &&\n            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||\n                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {\n            startNode = startNode.prev;\n            startLine = startNode.sourcepos[0][0];\n        }\n        var editedLines = this.lineTexts.slice(startLine - 1, endLine);\n        var root = this.parser.partialParseStart(startLine, editedLines);\n        // extends ending range if the following node can be a fenced code block or a continued list item\n        var nextNode = endNode ? endNode.next : this.root.firstChild;\n        var lastChild = root.lastChild;\n        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;\n        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;\n        var isLastChildList = lastChild && isList(lastChild);\n        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||\n            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {\n            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);\n            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));\n            if (!startNode) {\n                startNode = endNode;\n            }\n            endNode = nextNode;\n            endLine = newEndLine;\n            nextNode = nextNode.next;\n        }\n        this.parser.partialParseFinish();\n        var newNodes = getChildNodes(root);\n        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };\n    };\n    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {\n        if (!extStartNode ||\n            (extStartNode && isRefDef(extStartNode)) ||\n            (extEndNode && isRefDef(extEndNode))) {\n            return null;\n        }\n        return {\n            id: [extStartNode.id, extEndNode.id],\n            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],\n        };\n    };\n    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var markDeleted = function (node) {\n                if (isRefDef(node)) {\n                    var refDefState = _this.refMap[node.label];\n                    if (refDefState && node.id === refDefState.id) {\n                        refDefState.unlinked = true;\n                    }\n                }\n            };\n            if (extStartNode) {\n                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);\n            }\n            if (extEndNode) {\n                invokeNextUntil(markDeleted, extEndNode);\n            }\n        }\n    };\n    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {\n        var _this = this;\n        if (!isEmptyObj(this.refMap)) {\n            var replaceWith_1 = function (node) {\n                if (isRefDef(node)) {\n                    var label = node.label;\n                    var refDefState = _this.refMap[label];\n                    if (!refDefState || refDefState.unlinked) {\n                        _this.refMap[label] = createRefDefState(node);\n                    }\n                }\n            };\n            nodes.forEach(function (node) {\n                invokeNextUntil(replaceWith_1, node);\n            });\n        }\n    };\n    ToastMark.prototype.replaceWithRefDefCandidate = function () {\n        var _this = this;\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            iterateObject(this.refDefCandidateMap, function (_, candidate) {\n                var label = candidate.label, sourcepos = candidate.sourcepos;\n                var refDefState = _this.refMap[label];\n                if (!refDefState ||\n                    refDefState.unlinked ||\n                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {\n                    _this.refMap[label] = createRefDefState(candidate);\n                }\n            });\n        }\n    };\n    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {\n        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {\n            var prevNode = findChildNodeAtLine(this.root, startLine - 1);\n            var nextNode = findChildNodeAtLine(this.root, endLine + 1);\n            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {\n                startNode = prevNode;\n                startLine = startNode.sourcepos[0][0];\n            }\n            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {\n                endNode = nextNode;\n                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);\n            }\n        }\n        return [startNode, endNode, startLine, endLine];\n    };\n    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {\n        if (lineDiff === void 0) {\n            lineDiff = 0;\n        }\n        var range = this.getNodeRange(startPos, endPos);\n        var startNode = range[0], endNode = range[1];\n        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];\n        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);\n        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));\n        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;\n        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);\n        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;\n        if (this.referenceDefinition) {\n            this.markDeletedRefMap(extStartNode, extEndNode);\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n            this.replaceWithNewRefDefState(newNodes);\n        }\n        else {\n            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);\n        }\n        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };\n    };\n    ToastMark.prototype.parseRefLink = function () {\n        var _this = this;\n        var result = [];\n        if (!isEmptyObj(this.refMap)) {\n            iterateObject(this.refMap, function (label, value) {\n                if (value.unlinked) {\n                    delete _this.refMap[label];\n                }\n                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {\n                    var node = candidate.node, refLabel = candidate.refLabel;\n                    if (refLabel === label) {\n                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));\n                    }\n                });\n            });\n        }\n        return result;\n    };\n    ToastMark.prototype.removeUnlinkedCandidate = function () {\n        if (!isEmptyObj(this.refDefCandidateMap)) {\n            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {\n                iterateObject(candidateMap, function (id) {\n                    if (isUnlinked(id)) {\n                        delete candidateMap[id];\n                    }\n                });\n            });\n        }\n    };\n    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {\n        var lineDiff = this.updateLineTexts(startPos, endPos, newText);\n        var parseResult = this.parse(startPos, endPos, lineDiff);\n        var editResult = omit(parseResult, 'nextNode');\n        updateNextLineNumbers(parseResult.nextNode, lineDiff);\n        this.updateRootNodeState();\n        var result = [editResult];\n        if (this.referenceDefinition) {\n            this.removeUnlinkedCandidate();\n            this.replaceWithRefDefCandidate();\n            result = result.concat(this.parseRefLink());\n        }\n        this.trigger('change', result);\n        return result;\n    };\n    ToastMark.prototype.getLineTexts = function () {\n        return this.lineTexts;\n    };\n    ToastMark.prototype.getRootNode = function () {\n        return this.root;\n    };\n    ToastMark.prototype.findNodeAtPosition = function (pos) {\n        var node = findNodeAtPosition(this.root, pos);\n        if (!node || node === this.root) {\n            return null;\n        }\n        return node;\n    };\n    ToastMark.prototype.findFirstNodeAtLine = function (line) {\n        return findFirstNodeAtLine(this.root, line);\n    };\n    ToastMark.prototype.on = function (eventName, callback) {\n        this.eventHandlerMap[eventName].push(callback);\n    };\n    ToastMark.prototype.off = function (eventName, callback) {\n        var handlers = this.eventHandlerMap[eventName];\n        var idx = handlers.indexOf(callback);\n        handlers.splice(idx, 1);\n    };\n    ToastMark.prototype.findNodeById = function (id) {\n        return findNodeById(id);\n    };\n    ToastMark.prototype.removeAllNode = function () {\n        removeAllNode();\n    };\n    return ToastMark;\n}());\nvar disallowedTags = [\n    'title',\n    'textarea',\n    'style',\n    'xmp',\n    'iframe',\n    'noembed',\n    'noframes',\n    'script',\n    'plaintext',\n];\nvar reDisallowedTag = new RegExp(\"<(/?(?:\" + disallowedTags.join('|') + \")[^>]*>)\", 'ig');\nfunction filterDisallowedTags(str) {\n    if (reDisallowedTag.test(str)) {\n        return str.replace(reDisallowedTag, function (_, group) { return \"&lt;\" + group; });\n    }\n    return str;\n}\nvar baseConvertors = {\n    heading: function (node, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: \"h\" + node.level,\n            outerNewLine: true,\n        };\n    },\n    text: function (node) {\n        return {\n            type: 'text',\n            content: node.literal,\n        };\n    },\n    softbreak: function (_, _a) {\n        var options = _a.options;\n        return {\n            type: 'html',\n            content: options.softbreak,\n        };\n    },\n    linebreak: function () {\n        return {\n            type: 'html',\n            content: '<br />\\n',\n        };\n    },\n    emph: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'em',\n        };\n    },\n    strong: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'strong',\n        };\n    },\n    paragraph: function (node, _a) {\n        var _b;\n        var entering = _a.entering;\n        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;\n        if (grandparent && grandparent.type === 'list') {\n            if (grandparent.listData.tight) {\n                return null;\n            }\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'p',\n            outerNewLine: true,\n        };\n    },\n    thematicBreak: function () {\n        return {\n            type: 'openTag',\n            tagName: 'hr',\n            outerNewLine: true,\n            selfClose: true,\n        };\n    },\n    blockQuote: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'blockquote',\n            outerNewLine: true,\n            innerNewLine: true,\n        };\n    },\n    list: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, type = _b.type, start = _b.start;\n        var tagName = type === 'bullet' ? 'ul' : 'ol';\n        var attributes = {};\n        if (tagName === 'ol' && start !== null && start !== 1) {\n            attributes.start = start.toString();\n        }\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: tagName,\n            attributes: attributes,\n            outerNewLine: true,\n        };\n    },\n    item: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    htmlInline: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        return { type: 'html', content: content };\n    },\n    htmlBlock: function (node, _a) {\n        var options = _a.options;\n        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;\n        if (options.nodeId) {\n            return [\n                { type: 'openTag', tagName: 'div', outerNewLine: true },\n                { type: 'html', content: content },\n                { type: 'closeTag', tagName: 'div', outerNewLine: true },\n            ];\n        }\n        return { type: 'html', content: content, outerNewLine: true };\n    },\n    code: function (node) {\n        return [\n            { type: 'openTag', tagName: 'code' },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var infoStr = node.info;\n        var infoWords = infoStr ? infoStr.split(/\\s+/) : [];\n        var codeClassNames = [];\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            codeClassNames.push(\"language-\" + escapeXml(infoWords[0]));\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', outerNewLine: true },\n            { type: 'openTag', tagName: 'code', classNames: codeClassNames },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre', outerNewLine: true },\n        ];\n    },\n    link: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var _b = node, title = _b.title, destination = _b.destination;\n            return {\n                type: 'openTag',\n                tagName: 'a',\n                attributes: esm_assign({ href: escapeXml(destination) }, (title && { title: escapeXml(title) })),\n            };\n        }\n        return { type: 'closeTag', tagName: 'a' };\n    },\n    image: function (node, _a) {\n        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;\n        var _b = node, title = _b.title, destination = _b.destination;\n        skipChildren();\n        return {\n            type: 'openTag',\n            tagName: 'img',\n            selfClose: true,\n            attributes: esm_assign({ src: escapeXml(destination), alt: getChildrenText(node) }, (title && { title: escapeXml(title) })),\n        };\n    },\n    customBlock: function (node, context, convertors) {\n        var info = node.info.trim().toLowerCase();\n        var customConvertor = convertors[info];\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + info + \" block node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return [\n            { type: 'openTag', tagName: 'div', outerNewLine: true },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    frontMatter: function (node) {\n        return [\n            {\n                type: 'openTag',\n                tagName: 'div',\n                outerNewLine: true,\n                // Because front matter is metadata, it should not be render.\n                attributes: { style: 'white-space: pre; display: none;' },\n            },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'div', outerNewLine: true },\n        ];\n    },\n    customInline: function (node, context, convertors) {\n        var _a = node, info = _a.info, firstChild = _a.firstChild;\n        var nomalizedInfo = info.trim().toLowerCase();\n        var customConvertor = convertors[nomalizedInfo];\n        var entering = context.entering;\n        if (customConvertor) {\n            try {\n                return customConvertor(node, context);\n            }\n            catch (e) {\n                console.warn(\"[@toast-ui/editor] - The error occurred when \" + nomalizedInfo + \" inline node was parsed in markdown renderer: \" + e);\n            }\n        }\n        return entering\n            ? [\n                { type: 'openTag', tagName: 'span' },\n                { type: 'text', content: \"$$\" + info + (firstChild ? ' ' : '') },\n            ]\n            : [\n                { type: 'text', content: '$$' },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n    },\n};\nvar gfmConvertors = {\n    strike: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'del',\n        };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        var _b = node.listData, checked = _b.checked, task = _b.task;\n        if (entering) {\n            var itemTag = {\n                type: 'openTag',\n                tagName: 'li',\n                outerNewLine: true,\n            };\n            if (task) {\n                return [\n                    itemTag,\n                    {\n                        type: 'openTag',\n                        tagName: 'input',\n                        selfClose: true,\n                        attributes: esm_assign(esm_assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),\n                    },\n                    {\n                        type: 'text',\n                        content: ' ',\n                    },\n                ];\n            }\n            return itemTag;\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    table: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'table',\n            outerNewLine: true,\n        };\n    },\n    tableHead: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'thead',\n            outerNewLine: true,\n        };\n    },\n    tableBody: function (_, _a) {\n        var entering = _a.entering;\n        return {\n            type: entering ? 'openTag' : 'closeTag',\n            tagName: 'tbody',\n            outerNewLine: true,\n        };\n    },\n    tableRow: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            return {\n                type: 'openTag',\n                tagName: 'tr',\n                outerNewLine: true,\n            };\n        }\n        var result = [];\n        if (node.lastChild) {\n            var columnLen = node.parent.parent.columns.length;\n            var lastColIdx = node.lastChild.endIdx;\n            for (var i = lastColIdx + 1; i < columnLen; i += 1) {\n                result.push({\n                    type: 'openTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                }, {\n                    type: 'closeTag',\n                    tagName: 'td',\n                    outerNewLine: true,\n                });\n            }\n        }\n        result.push({\n            type: 'closeTag',\n            tagName: 'tr',\n            outerNewLine: true,\n        });\n        return result;\n    },\n    tableCell: function (node, _a) {\n        var entering = _a.entering;\n        if (node.ignored) {\n            return {\n                type: 'text',\n                content: '',\n            };\n        }\n        var tablePart = node.parent.parent;\n        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';\n        var table = tablePart.parent;\n        var columnInfo = table.columns[node.startIdx];\n        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;\n        if (entering) {\n            return esm_assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));\n        }\n        return {\n            type: 'closeTag',\n            tagName: tagName,\n            outerNewLine: true,\n        };\n    },\n};\nvar defaultOptions = {\n    softbreak: '\\n',\n    gfm: false,\n    tagFilter: false,\n    nodeId: false,\n};\nfunction getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var node_1 = event.node;\n        if (node_1.type === 'text') {\n            buffer.push(node_1.literal);\n        }\n    }\n    return buffer.join('');\n}\nvar Renderer = /** @class */ (function () {\n    function Renderer(customOptions) {\n        this.buffer = [];\n        this.options = esm_assign(esm_assign({}, defaultOptions), customOptions);\n        this.convertors = this.createConvertors();\n        delete this.options.convertors;\n    }\n    Renderer.prototype.createConvertors = function () {\n        var convertors = esm_assign({}, baseConvertors);\n        if (this.options.gfm) {\n            convertors = esm_assign(esm_assign({}, convertors), gfmConvertors);\n        }\n        if (this.options.convertors) {\n            var customConvertors_1 = this.options.convertors;\n            var nodeTypes = Object.keys(customConvertors_1);\n            var defaultConvertors_1 = esm_assign(esm_assign({}, baseConvertors), gfmConvertors);\n            nodeTypes.forEach(function (nodeType) {\n                var orgConvertor = convertors[nodeType];\n                var convertor = customConvertors_1[nodeType];\n                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1\n                    ? nodeType.toLowerCase()\n                    : nodeType;\n                if (orgConvertor) {\n                    convertors[convertorType] = function (node, context, convertors) {\n                        context.origin = function () { return orgConvertor(node, context, convertors); };\n                        return convertor(node, context);\n                    };\n                }\n                else {\n                    convertors[convertorType] = convertor;\n                }\n            });\n        }\n        return convertors;\n    };\n    Renderer.prototype.getConvertors = function () {\n        return this.convertors;\n    };\n    Renderer.prototype.getOptions = function () {\n        return this.options;\n    };\n    Renderer.prototype.render = function (rootNode) {\n        var _this = this;\n        this.buffer = [];\n        var walker = rootNode.walker();\n        var event = null;\n        var _loop_1 = function () {\n            var node = event.node, entering = event.entering;\n            var convertor = this_1.convertors[node.type];\n            if (!convertor) {\n                return \"continue\";\n            }\n            var skipped = false;\n            var context = {\n                entering: entering,\n                leaf: !isContainer(node),\n                options: this_1.options,\n                getChildrenText: getChildrenText,\n                skipChildren: function () {\n                    skipped = true;\n                },\n            };\n            var converted = isCustomBlock(node) || isCustomInline(node)\n                ? convertor(node, context, this_1.convertors)\n                : convertor(node, context);\n            if (converted) {\n                var htmlNodes = Array.isArray(converted) ? converted : [converted];\n                htmlNodes.forEach(function (htmlNode, index) {\n                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {\n                        if (!htmlNode.attributes) {\n                            htmlNode.attributes = {};\n                        }\n                        htmlNode.attributes['data-nodeid'] = String(node.id);\n                    }\n                    _this.renderHTMLNode(htmlNode);\n                });\n                if (skipped) {\n                    walker.resumeAt(node, false);\n                    walker.next();\n                }\n            }\n        };\n        var this_1 = this;\n        while ((event = walker.next())) {\n            _loop_1();\n        }\n        this.addNewLine();\n        return this.buffer.join('');\n    };\n    Renderer.prototype.renderHTMLNode = function (node) {\n        switch (node.type) {\n            case 'openTag':\n            case 'closeTag':\n                this.renderElementNode(node);\n                break;\n            case 'text':\n                this.renderTextNode(node);\n                break;\n            case 'html':\n                this.renderRawHtmlNode(node);\n                break;\n            // no-default-case\n        }\n    };\n    Renderer.prototype.generateOpenTagString = function (node) {\n        var _this = this;\n        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;\n        this.buffer.push(\"<\" + tagName);\n        if (classNames && classNames.length > 0) {\n            this.buffer.push(\" class=\\\"\" + classNames.join(' ') + \"\\\"\");\n        }\n        if (attributes) {\n            Object.keys(attributes).forEach(function (attrName) {\n                var attrValue = attributes[attrName];\n                _this.buffer.push(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\");\n            });\n        }\n        if (node.selfClose) {\n            this.buffer.push(' /');\n        }\n        this.buffer.push('>');\n    };\n    Renderer.prototype.generateCloseTagString = function (_a) {\n        var tagName = _a.tagName;\n        this.buffer.push(\"</\" + tagName + \">\");\n    };\n    Renderer.prototype.addNewLine = function () {\n        if (this.buffer.length && last(last(this.buffer)) !== '\\n') {\n            this.buffer.push('\\n');\n        }\n    };\n    Renderer.prototype.addOuterNewLine = function (node) {\n        if (node.outerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.addInnerNewLine = function (node) {\n        if (node.innerNewLine) {\n            this.addNewLine();\n        }\n    };\n    Renderer.prototype.renderTextNode = function (node) {\n        this.buffer.push(escapeXml(node.content));\n    };\n    Renderer.prototype.renderRawHtmlNode = function (node) {\n        this.addOuterNewLine(node);\n        this.buffer.push(node.content);\n        this.addOuterNewLine(node);\n    };\n    Renderer.prototype.renderElementNode = function (node) {\n        if (node.type === 'openTag') {\n            this.addOuterNewLine(node);\n            this.generateOpenTagString(node);\n            if (node.selfClose) {\n                this.addOuterNewLine(node);\n            }\n            else {\n                this.addInnerNewLine(node);\n            }\n        }\n        else {\n            this.addInnerNewLine(node);\n            this.generateCloseTagString(node);\n            this.addOuterNewLine(node);\n        }\n    };\n    return Renderer;\n}());\n\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/forEachOwnProperties.js\nvar collection_forEachOwnProperties = __nested_webpack_require_87464__(956);\nvar forEachOwnProperties_default = /*#__PURE__*/__nested_webpack_require_87464__.n(collection_forEachOwnProperties);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/object/extend.js\nvar extend = __nested_webpack_require_87464__(969);\nvar extend_default = /*#__PURE__*/__nested_webpack_require_87464__.n(extend);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/on.js\nvar on = __nested_webpack_require_87464__(348);\nvar on_default = /*#__PURE__*/__nested_webpack_require_87464__.n(on);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/off.js\nvar off = __nested_webpack_require_87464__(349);\nvar off_default = /*#__PURE__*/__nested_webpack_require_87464__.n(off);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/addClass.js\nvar addClass = __nested_webpack_require_87464__(204);\nvar addClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(addClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/removeClass.js\nvar removeClass = __nested_webpack_require_87464__(462);\nvar removeClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(removeClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/css.js\nvar css = __nested_webpack_require_87464__(522);\nvar css_default = /*#__PURE__*/__nested_webpack_require_87464__.n(css);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/toArray.js\nvar collection_toArray = __nested_webpack_require_87464__(990);\nvar toArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(collection_toArray);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isArray.js\nvar type_isArray = __nested_webpack_require_87464__(322);\nvar isArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isArray);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isString.js\nvar type_isString = __nested_webpack_require_87464__(758);\nvar isString_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isString);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isUndefined.js\nvar type_isUndefined = __nested_webpack_require_87464__(929);\nvar isUndefined_default = /*#__PURE__*/__nested_webpack_require_87464__.n(type_isUndefined);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/hasClass.js\nvar hasClass = __nested_webpack_require_87464__(714);\nvar hasClass_default = /*#__PURE__*/__nested_webpack_require_87464__.n(hasClass);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/matches.js\nvar domUtil_matches = __nested_webpack_require_87464__(471);\n;// CONCATENATED MODULE: ./src/utils/constants.ts\nvar TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';\nvar ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTED_VALUE = '[^\"\\'=<>`\\\\x00-\\\\x20]+';\nvar SINGLE_QUOTED_VALUE = \"'[^']*'\";\nvar DOUBLE_QUOTED_VALUE = '\"[^\"]*\"';\nvar ATTRIBUTE_VALUE = \"(?:\" + UNQUOTED_VALUE + \"|\" + SINGLE_QUOTED_VALUE + \"|\" + DOUBLE_QUOTED_VALUE + \")\";\nvar ATTRIBUTE_VALUE_SPEC = \"\" + '(?:\\\\s*=\\\\s*' + ATTRIBUTE_VALUE + \")\";\nvar constants_ATTRIBUTE = \"\" + '(?:\\\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + \"?)\";\nvar constants_OPEN_TAG = \"<(\" + TAG_NAME + \")(\" + constants_ATTRIBUTE + \")*\\\\s*/?>\";\nvar CLOSE_TAG = \"</(\" + TAG_NAME + \")\\\\s*[>]\";\nvar constants_HTML_TAG = \"(?:\" + constants_OPEN_TAG + \"|\" + CLOSE_TAG + \")\";\nvar reHTMLTag = new RegExp(\"^\" + constants_HTML_TAG, 'i');\nvar constants_reBR = /<br\\s*\\/*>/i;\nvar reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar constants_ALTERNATIVE_TAG_FOR_BR = '</p><p>';\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isNull.js\nvar type_isNull = __nested_webpack_require_87464__(934);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/request/sendHostname.js\nvar request_sendHostname = __nested_webpack_require_87464__(391);\n;// CONCATENATED MODULE: ./src/utils/common.ts\n\n\n\n\n\nvar isMac = /Mac/.test(navigator.platform);\nvar reSpaceMoreThanOne = /[\\u0020]+/g;\nvar common_reEscapeChars = /[>(){}[\\]+-.!#|]/g;\nvar reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\\-._]*)(\\s|[^\\\\>])*\\/?>|<(\\/)([a-zA-Z_][a-zA-Z0-9\\-._]*)\\s*\\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\\-.:/]*)>/g;\nvar reEscapeBackSlash = /\\\\[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]/g;\nvar reEscapePairedChars = /[*_~`]/g;\nvar reMdImageSyntax = /!\\[.*\\]\\(.*\\)/g;\nvar reEscapedCharInLinkSyntax = /[[\\]]/g;\nvar reEscapeBackSlashInSentence = /(?:^|[^\\\\])\\\\(?!\\\\)/g;\nvar common_XMLSPECIAL = '[&<>\"]';\nvar common_reXmlSpecial = new RegExp(common_XMLSPECIAL, 'g');\nfunction common_replaceUnsafeChar(char) {\n    switch (char) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        default:\n            return char;\n    }\n}\nfunction common_escapeXml(text) {\n    if (common_reXmlSpecial.test(text)) {\n        return text.replace(common_reXmlSpecial, common_replaceUnsafeChar);\n    }\n    return text;\n}\nfunction sendHostName() {\n    sendHostname('editor', 'UA-129966929-1');\n}\nfunction common_includes(arr, targetItem) {\n    return arr.indexOf(targetItem) !== -1;\n}\nvar availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];\nvar reMarkdownTextToEscapeMap = {\n    codeblock: /(^ {4}[^\\n]+\\n*)+/,\n    thematicBreak: /^ *((\\* *){3,}|(- *){3,} *|(_ *){3,}) */,\n    atxHeading: /^(#{1,6}) +[\\s\\S]+/,\n    seTextheading: /^([^\\n]+)\\n *(=|-){2,} */,\n    blockquote: /^( *>[^\\n]+.*)+/,\n    list: /^ *(\\*+|-+|\\d+\\.) [\\s\\S]+/,\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? */,\n    link: /!?\\[.*\\]\\(.*\\)/,\n    reflink: /!?\\[.*\\]\\s*\\[([^\\]]*)\\]/,\n    verticalBar: /\\u007C/,\n    fencedCodeblock: /^((`|~){3,})/,\n};\nfunction sanitizeLinkAttribute(attribute) {\n    if (!attribute) {\n        return null;\n    }\n    var linkAttributes = {};\n    availableLinkAttributes.forEach(function (key) {\n        if (!isUndefined_default()(attribute[key])) {\n            linkAttributes[key] = attribute[key];\n        }\n    });\n    return linkAttributes;\n}\nfunction common_repeat(text, count) {\n    var result = '';\n    for (var i = 0; i < count; i += 1) {\n        result += text;\n    }\n    return result;\n}\nfunction isNeedEscapeText(text) {\n    var needEscape = false;\n    forEachOwnProperties(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {\n        if (reMarkdownTextToEscape.test(text)) {\n            needEscape = true;\n        }\n        return !needEscape;\n    });\n    return needEscape;\n}\nfunction escapeTextForLink(text) {\n    var imageSyntaxRanges = [];\n    var result = reMdImageSyntax.exec(text);\n    while (result) {\n        imageSyntaxRanges.push([result.index, result.index + result[0].length]);\n        result = reMdImageSyntax.exec(text);\n    }\n    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {\n        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });\n        return isDelimiter ? matched : \"\\\\\" + matched;\n    });\n}\nfunction common_escape(text) {\n    var aheadReplacer = function (matched) { return \"\\\\\" + matched; };\n    var behindReplacer = function (matched) { return matched + \"\\\\\"; };\n    var escapedText = text.replace(reSpaceMoreThanOne, ' ');\n    if (reEscapeBackSlash.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);\n    }\n    if (reEscapeBackSlashInSentence.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);\n    }\n    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);\n    if (reEscapeHTML.test(escapedText)) {\n        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);\n    }\n    if (isNeedEscapeText(escapedText)) {\n        escapedText = escapedText.replace(common_reEscapeChars, aheadReplacer);\n    }\n    return escapedText;\n}\nfunction quote(text) {\n    var result;\n    if (text.indexOf('\"') === -1) {\n        result = '\"\"';\n    }\n    else {\n        result = text.indexOf(\"'\") === -1 ? \"''\" : '()';\n    }\n    return result[0] + text + result[1];\n}\nfunction common_isNil(value) {\n    return isNull(value) || isUndefined(value);\n}\nfunction shallowEqual(o1, o2) {\n    if (o1 === null && o1 === o2) {\n        return true;\n    }\n    if (typeof o1 !== 'object' || typeof o2 !== 'object' || common_isNil(o1) || common_isNil(o2)) {\n        return o1 === o2;\n    }\n    for (var key in o1) {\n        if (o1[key] !== o2[key]) {\n            return false;\n        }\n    }\n    for (var key in o2) {\n        if (!(key in o1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction common_last(arr) {\n    return arr[arr.length - 1];\n}\nfunction common_between(value, min, max) {\n    return value >= min && value <= max;\n}\nfunction isObject(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\nfunction deepMergedCopy(targetObj, obj) {\n    var resultObj = tslib_es6_assign({}, targetObj);\n    if (targetObj && obj) {\n        Object.keys(obj).forEach(function (prop) {\n            if (isObject(resultObj[prop])) {\n                if (Array.isArray(obj[prop])) {\n                    resultObj[prop] = deepCopyArray(obj[prop]);\n                }\n                else if (resultObj.hasOwnProperty(prop)) {\n                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);\n                }\n                else {\n                    resultObj[prop] = deepCopy(obj[prop]);\n                }\n            }\n            else {\n                resultObj[prop] = obj[prop];\n            }\n        });\n    }\n    return resultObj;\n}\nfunction deepCopyArray(items) {\n    return items.map(function (item) {\n        if (isObject(item)) {\n            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);\n        }\n        return item;\n    });\n}\nfunction deepCopy(obj) {\n    var keys = Object.keys(obj);\n    if (!keys.length) {\n        return obj;\n    }\n    return keys.reduce(function (acc, prop) {\n        if (isObject(obj[prop])) {\n            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);\n        }\n        else {\n            acc[prop] = obj[prop];\n        }\n        return acc;\n    }, {});\n}\nfunction common_assign(targetObj, obj) {\n    if (obj === void 0) { obj = {}; }\n    Object.keys(obj).forEach(function (prop) {\n        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {\n            if (Array.isArray(obj[prop])) {\n                targetObj[prop] = obj[prop];\n            }\n            else {\n                common_assign(targetObj[prop], obj[prop]);\n            }\n        }\n        else {\n            targetObj[prop] = obj[prop];\n        }\n    });\n    return targetObj;\n}\nfunction getSortedNumPair(valueA, valueB) {\n    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];\n}\n\n;// CONCATENATED MODULE: ./src/utils/dom.ts\n\n\n\n\n\n\n\n\n\n\nfunction isPositionInBox(style, offsetX, offsetY) {\n    var left = parseInt(style.left, 10);\n    var top = parseInt(style.top, 10);\n    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);\n    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);\n    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;\n}\nvar CLS_PREFIX = 'toastui-editor-';\nfunction cls() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {\n        var name = names_1[_a];\n        var className = void 0;\n        if (Array.isArray(name)) {\n            className = name[0] ? name[1] : null;\n        }\n        else {\n            className = name;\n        }\n        if (className) {\n            result.push(\"\" + CLS_PREFIX + className);\n        }\n    }\n    return result.join(' ');\n}\nfunction clsWithMdPrefix() {\n    var names = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        names[_i] = arguments[_i];\n    }\n    return names.map(function (className) { return CLS_PREFIX + \"md-\" + className; }).join(' ');\n}\nfunction isTextNode(node) {\n    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;\n}\nfunction isElemNode(node) {\n    return node && node.nodeType === Node.ELEMENT_NODE;\n}\nfunction findNodes(element, selector) {\n    var nodeList = toArray(element.querySelectorAll(selector));\n    if (nodeList.length) {\n        return nodeList;\n    }\n    return [];\n}\nfunction appendNodes(node, nodesToAppend) {\n    nodesToAppend = isArray(nodesToAppend) ? toArray(nodesToAppend) : [nodesToAppend];\n    nodesToAppend.forEach(function (nodeToAppend) {\n        node.appendChild(nodeToAppend);\n    });\n}\nfunction insertBeforeNode(insertedNode, node) {\n    if (node.parentNode) {\n        node.parentNode.insertBefore(insertedNode, node);\n    }\n}\nfunction removeNode(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction unwrapNode(node) {\n    var result = [];\n    while (node.firstChild) {\n        result.push(node.firstChild);\n        if (node.parentNode) {\n            node.parentNode.insertBefore(node.firstChild, node);\n        }\n    }\n    removeNode(node);\n    return result;\n}\nfunction toggleClass(element, className, state) {\n    if (isUndefined_default()(state)) {\n        state = !hasClass_default()(element, className);\n    }\n    var toggleFn = state ? (addClass_default()) : (removeClass_default());\n    toggleFn(element, className);\n}\nfunction createElementWith(contents, target) {\n    var container = document.createElement('div');\n    if (isString_default()(contents)) {\n        container.innerHTML = contents;\n    }\n    else {\n        container.appendChild(contents);\n    }\n    var firstChild = container.firstChild;\n    if (target) {\n        target.appendChild(firstChild);\n    }\n    return firstChild;\n}\nfunction getOuterWidth(el) {\n    var computed = window.getComputedStyle(el);\n    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);\n}\nfunction closest(node, found) {\n    var condition;\n    if (isString(found)) {\n        condition = function (target) { return matches(target, found); };\n    }\n    else {\n        condition = function (target) { return target === found; };\n    }\n    while (node && node !== document) {\n        if (isElemNode(node) && condition(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nfunction getTotalOffset(el, root) {\n    var offsetTop = 0;\n    var offsetLeft = 0;\n    while (el && el !== root) {\n        var top = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;\n        offsetTop += top;\n        offsetLeft += left;\n        if (offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.offsetParent;\n    }\n    return { offsetTop: offsetTop, offsetLeft: offsetLeft };\n}\nfunction finalizeHtml(html, needHtmlText) {\n    var result;\n    if (needHtmlText) {\n        result = html.innerHTML;\n    }\n    else {\n        var frag = document.createDocumentFragment();\n        var childNodes = toArray(html.childNodes);\n        var length = childNodes.length;\n        for (var i = 0; i < length; i += 1) {\n            frag.appendChild(childNodes[i]);\n        }\n        result = frag;\n    }\n    return result;\n}\nfunction dom_empty(node) {\n    while (node.firstChild) {\n        node.removeChild(node.firstChild);\n    }\n}\nfunction appendNode(node, appended) {\n    if (isString(appended)) {\n        node.insertAdjacentHTML('beforeend', appended);\n    }\n    else {\n        var nodes = appended.length\n            ? toArray(appended)\n            : [appended];\n        for (var i = 0, len = nodes.length; i < len; i += 1) {\n            node.appendChild(nodes[i]);\n        }\n    }\n}\nfunction prependNode(node, appended) {\n    if (isString(appended)) {\n        node.insertAdjacentHTML('afterbegin', appended);\n    }\n    else {\n        var nodes = appended.length\n            ? toArray(appended)\n            : [appended];\n        for (var i = nodes.length - 1, len = 0; i >= len; i -= 1) {\n            node.insertBefore(nodes[i], node.firstChild);\n        }\n    }\n}\nfunction setAttributes(attributes, element) {\n    Object.keys(attributes).forEach(function (attrName) {\n        if (isNil(attributes[attrName])) {\n            element.removeAttribute(attrName);\n        }\n        else {\n            element.setAttribute(attrName, attributes[attrName]);\n        }\n    });\n}\nfunction replaceBRWithEmptyBlock(html) {\n    // remove br in paragraph to compatible with markdown\n    var replacedHTML = html.replace(/<p><br\\s*\\/*><\\/p>/gi, '<p></p>');\n    var reHTMLTag = new RegExp(HTML_TAG, 'ig');\n    var htmlTagMatched = replacedHTML.match(reHTMLTag);\n    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {\n        if (reBR.test(htmlTag)) {\n            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;\n            if (index) {\n                var prevTag = htmlTagMatched[index - 1];\n                var openTagMatched = prevTag.match(OPEN_TAG);\n                if (openTagMatched && !/br/i.test(openTagMatched[1])) {\n                    var tagName = openTagMatched[1];\n                    alternativeTag = \"</\" + tagName + \"><\" + tagName + \">\";\n                }\n            }\n            replacedHTML = replacedHTML.replace(reBR, alternativeTag);\n        }\n    });\n    return replacedHTML;\n}\nfunction removeProseMirrorHackNodes(html) {\n    var reProseMirrorImage = /<img class=\"ProseMirror-separator\" alt=\"\">/g;\n    var reProseMirrorTrailingBreak = / class=\"ProseMirror-trailingBreak\"/g;\n    var resultHTML = html;\n    resultHTML = resultHTML.replace(reProseMirrorImage, '');\n    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');\n    return resultHTML;\n}\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFunction.js\nvar isFunction = __nested_webpack_require_87464__(294);\nvar isFunction_default = /*#__PURE__*/__nested_webpack_require_87464__.n(isFunction);\n;// CONCATENATED MODULE: ./src/utils/markdown.ts\n\nfunction hasSpecificTypeAncestor(mdNode) {\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        types[_i - 1] = arguments[_i];\n    }\n    while (mdNode && mdNode.parent && mdNode.parent.type !== 'document') {\n        if (includes(types, mdNode.parent.type)) {\n            return true;\n        }\n        mdNode = mdNode.parent;\n    }\n    return false;\n}\nfunction markdown_getMdStartLine(mdNode) {\n    return mdNode.sourcepos[0][0];\n}\nfunction markdown_getMdEndLine(mdNode) {\n    return mdNode.sourcepos[1][0];\n}\nfunction getMdStartCh(mdNode) {\n    return mdNode.sourcepos[0][1];\n}\nfunction getMdEndCh(mdNode) {\n    return mdNode.sourcepos[1][1];\n}\nfunction isMultiLineNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'codeBlock' || type === 'paragraph';\n}\nfunction isHTMLNode(mdNode) {\n    var type = mdNode.type;\n    return type === 'htmlBlock' || type === 'htmlInline';\n}\nfunction markdown_isStyledInlineNode(mdNode) {\n    var type = mdNode.type;\n    return (type === 'strike' ||\n        type === 'strong' ||\n        type === 'emph' ||\n        type === 'code' ||\n        type === 'link' ||\n        type === 'image');\n}\nfunction isCodeBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'codeBlock';\n}\nfunction isCustomBlockNode(mdNode) {\n    return mdNode && mdNode.type === 'customBlock';\n}\nfunction isListNode(mdNode) {\n    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');\n}\nfunction isOrderedListNode(mdNode) {\n    return isListNode(mdNode) && mdNode.listData.type === 'ordered';\n}\nfunction isBulletListNode(mdNode) {\n    return isListNode(mdNode) && mdNode.listData.type !== 'ordered';\n}\nfunction isTableCellNode(mdNode) {\n    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');\n}\nfunction isInlineNode(mdNode) {\n    switch (mdNode.type) {\n        case 'code':\n        case 'text':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'htmlInline':\n        case 'linebreak':\n        case 'softbreak':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction findClosestNode(mdNode, condition, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        if (condition(mdNode)) {\n            return mdNode;\n        }\n        mdNode = mdNode.parent;\n    }\n    return null;\n}\nfunction traverseParentNodes(mdNode, iteratee, includeSelf) {\n    if (includeSelf === void 0) { includeSelf = true; }\n    mdNode = includeSelf ? mdNode : mdNode.parent;\n    while (mdNode && mdNode.type !== 'document') {\n        iteratee(mdNode);\n        mdNode = mdNode.parent;\n    }\n}\nfunction addOffsetPos(originPos, offset) {\n    return [originPos[0], originPos[1] + offset];\n}\nfunction setOffsetPos(originPos, newOffset) {\n    return [originPos[0], newOffset];\n}\nfunction getInlineMarkdownText(mdNode) {\n    var text = mdNode.firstChild.literal;\n    switch (mdNode.type) {\n        case 'emph':\n            return \"*\" + text + \"*\";\n        case 'strong':\n            return \"**\" + text + \"**\";\n        case 'strike':\n            return \"~~\" + text + \"~~\";\n        case 'code':\n            return \"`\" + text + \"`\";\n        case 'link':\n        case 'image':\n            /* eslint-disable no-case-declarations */\n            var _a = mdNode, destination = _a.destination, title = _a.title;\n            var delim = mdNode.type === 'link' ? '' : '!';\n            return delim + \"[\" + text + \"](\" + destination + (title ? \" \\\"\" + title + \"\\\"\" : '') + \")\";\n        default:\n            return null;\n    }\n}\nfunction markdown_isContainer(node) {\n    switch (node.type) {\n        case 'document':\n        case 'blockQuote':\n        case 'list':\n        case 'item':\n        case 'paragraph':\n        case 'heading':\n        case 'emph':\n        case 'strong':\n        case 'strike':\n        case 'link':\n        case 'image':\n        case 'table':\n        case 'tableHead':\n        case 'tableBody':\n        case 'tableRow':\n        case 'tableCell':\n        case 'tableDelimRow':\n        case 'customInline':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction markdown_getChildrenText(node) {\n    var buffer = [];\n    var walker = node.walker();\n    var event = null;\n    while ((event = walker.next())) {\n        var childNode = event.node;\n        if (childNode.type === 'text') {\n            buffer.push(childNode.literal);\n        }\n    }\n    return buffer.join('');\n}\n\n;// CONCATENATED MODULE: ./src/widget/rules.ts\n\nvar widgetRules = (/* unused pure expression or super */ null && (0));\nvar widgetRuleMap = {};\nvar reWidgetPrefix = /\\$\\$widget\\d+\\s/;\nfunction unwrapWidgetSyntax(text) {\n    var index = text.search(reWidgetPrefix);\n    if (index !== -1) {\n        var rest = text.substring(index);\n        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');\n        text = text.substring(0, index);\n        text += unwrapWidgetSyntax(replaced);\n    }\n    return text;\n}\nfunction createWidgetContent(info, text) {\n    return \"$$\" + info + \" \" + text + \"$$\";\n}\nfunction widgetToDOM(info, text) {\n    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;\n    var matches = unwrapWidgetSyntax(text).match(rule);\n    if (matches) {\n        text = matches[0];\n    }\n    return toDOM(text);\n}\nfunction getWidgetRules() {\n    return widgetRules;\n}\nfunction setWidgetRules(rules) {\n    widgetRules = rules;\n    widgetRules.forEach(function (rule, index) {\n        widgetRuleMap[\"widget\" + index] = rule;\n    });\n}\nfunction mergeNodes(nodes, text, schema, ruleIndex) {\n    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));\n}\n/**\n * create nodes with plain text and replace text matched to the widget rules with the widget node\n * For example, in case the text and widget rules as below\n *\n * text: $test plain text #test\n * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]\n *\n * The creating node process is recursive and is as follows.\n *\n * in first widget rule(/$.+/)\n *  $test -> widget node\n *  plain text -> match with next widget rule\n *  #test -> match with next widget rule\n *\n * in second widget rule(/#.+/)\n *  plain text -> text node(no rule for matching)\n *  #test -> widget node\n */\nfunction createNodesWithWidget(text, schema, ruleIndex) {\n    if (ruleIndex === void 0) { ruleIndex = 0; }\n    var nodes = [];\n    var rule = (widgetRules[ruleIndex] || {}).rule;\n    var nextRuleIndex = ruleIndex + 1;\n    text = unwrapWidgetSyntax(text);\n    if (rule && rule.test(text)) {\n        var index = void 0;\n        while ((index = text.search(rule)) !== -1) {\n            var prev = text.substring(0, index);\n            // get widget node on first splitted text using next widget rule\n            if (prev) {\n                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);\n            }\n            // build widget node using current widget rule\n            text = text.substring(index);\n            var literal = text.match(rule)[0];\n            var info = \"widget\" + ruleIndex;\n            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));\n            text = text.substring(literal.length);\n        }\n        // get widget node on last splitted text using next widget rule\n        if (text) {\n            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);\n        }\n    }\n    else if (text) {\n        nodes =\n            ruleIndex < widgetRules.length - 1\n                ? mergeNodes(nodes, text, schema, nextRuleIndex)\n                : [schema.text(text)];\n    }\n    return nodes;\n}\nfunction getWidgetContent(widgetNode) {\n    var event;\n    var text = '';\n    var walker = widgetNode.walker();\n    while ((event = walker.next())) {\n        var node = event.node, entering = event.entering;\n        if (entering) {\n            if (node !== widgetNode && node.type !== 'text') {\n                text += getInlineMarkdownText(node);\n                // skip the children\n                walker.resumeAt(widgetNode, false);\n                walker.next();\n            }\n            else if (node.type === 'text') {\n                text += node.literal;\n            }\n        }\n    }\n    return text;\n}\n\n// EXTERNAL MODULE: ../../node_modules/dompurify/dist/purify.js\nvar purify = __nested_webpack_require_87464__(368);\nvar purify_default = /*#__PURE__*/__nested_webpack_require_87464__.n(purify);\n;// CONCATENATED MODULE: ./src/sanitizer/htmlSanitizer.ts\n\n\n\nvar CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];\nvar whiteTagList = [];\nfunction htmlSanitizer_registerTagWhitelistIfPossible(tagName) {\n    if (common_includes(CAN_BE_WHITE_TAG_LIST, tagName)) {\n        whiteTagList.push(tagName.toLowerCase());\n    }\n}\nfunction sanitizeHTML(html, options) {\n    return purify_default().sanitize(html, tslib_es6_assign({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [\n            'input',\n            'script',\n            'textarea',\n            'form',\n            'button',\n            'select',\n            'meta',\n            'style',\n            'link',\n            'title',\n            'object',\n            'base',\n        ] }, options));\n}\n\n;// CONCATENATED MODULE: ./src/wysiwyg/nodes/html.ts\n\n\n\n\nfunction getChildrenHTML(node, typeName) {\n    return node\n        .literal.replace(new RegExp(\"(<\\\\s*\" + typeName + \"[^>]*>)|(</\" + typeName + \"\\\\s*[>])\", 'ig'), '')\n        .trim();\n}\nfunction getHTMLAttrsByHTMLString(html) {\n    html = html.match(reHTMLTag)[0];\n    var attrs = html.match(new RegExp(constants_ATTRIBUTE, 'g'));\n    return attrs\n        ? attrs.reduce(function (acc, attr) {\n            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);\n            if (values.length) {\n                acc[name] = values.join('=').replace(/'|\"/g, '').trim();\n            }\n            return acc;\n        }, {})\n        : {};\n}\nfunction getHTMLAttrs(dom) {\n    return toArray_default()(dom.attributes).reduce(function (acc, attr) {\n        acc[attr.nodeName] = attr.nodeValue;\n        return acc;\n    }, {});\n}\nfunction sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {\n    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);\n    var html = sanitizer(dom.outerHTML);\n    var container = document.createElement('div');\n    container.innerHTML = html;\n    dom = container.firstChild;\n    var htmlAttrs = getHTMLAttrs(dom);\n    return { dom: dom, htmlAttrs: htmlAttrs };\n}\nvar schemaFactory = {\n    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            atom: true,\n            content: 'block+',\n            group: 'block',\n            attrs: {\n                htmlAttrs: { default: {} },\n                childrenHTML: { default: '' },\n                htmlBlock: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                            childrenHTML: dom.innerHTML,\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;\n                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + \" html-block\" : 'html-block';\n                return __spreadArray([typeName, htmlAttrs], toArray_default()(dom.childNodes));\n            },\n        };\n    },\n    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {\n        return {\n            attrs: {\n                htmlAttrs: { default: {} },\n                htmlInline: { default: true },\n            },\n            parseDOM: [\n                {\n                    tag: typeName,\n                    getAttrs: function (dom) {\n                        return {\n                            htmlAttrs: getHTMLAttrs(dom),\n                        };\n                    },\n                },\n            ],\n            toDOM: function (node) {\n                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;\n                return [typeName, htmlAttrs, 0];\n            },\n        };\n    },\n};\nfunction createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {\n    var htmlSchemaMap = { nodes: {}, marks: {} };\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            Object.keys(convertorMap[htmlType]).forEach(function (type) {\n                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';\n                // register tag white list for preventing to remove the html in sanitizer\n                registerTagWhitelistIfPossible(type);\n                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);\n            });\n        }\n    });\n    return htmlSchemaMap;\n}\n\n;// CONCATENATED MODULE: ./src/markdown/htmlRenderConvertors.ts\n\n\n\n\n\n\nvar reCloseTag = /^\\s*<\\s*\\//;\nvar htmlRenderConvertors_baseConvertors = {\n    paragraph: function (_, _a) {\n        var entering = _a.entering, origin = _a.origin, options = _a.options;\n        if (options.nodeId) {\n            return {\n                type: entering ? 'openTag' : 'closeTag',\n                outerNewLine: true,\n                tagName: 'p',\n            };\n        }\n        return origin();\n    },\n    softbreak: function (node) {\n        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';\n        var isPrevBR = isPrevNodeHTML && /<br ?\\/?>/.test(node.prev.literal);\n        var content = isPrevBR ? '\\n' : '<br>\\n';\n        return { type: 'html', content: content };\n    },\n    item: function (node, _a) {\n        var entering = _a.entering;\n        if (entering) {\n            var attributes = {};\n            var classNames = [];\n            if (node.listData.task) {\n                attributes['data-task'] = '';\n                classNames.push('task-list-item');\n                if (node.listData.checked) {\n                    classNames.push('checked');\n                    attributes['data-task-checked'] = '';\n                }\n            }\n            return {\n                type: 'openTag',\n                tagName: 'li',\n                classNames: classNames,\n                attributes: attributes,\n                outerNewLine: true,\n            };\n        }\n        return {\n            type: 'closeTag',\n            tagName: 'li',\n            outerNewLine: true,\n        };\n    },\n    code: function (node) {\n        var attributes = { 'data-backticks': String(node.tickCount) };\n        return [\n            { type: 'openTag', tagName: 'code', attributes: attributes },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n        ];\n    },\n    codeBlock: function (node) {\n        var _a = node, fenceLength = _a.fenceLength, info = _a.info;\n        var infoWords = info ? info.split(/\\s+/) : [];\n        var preClasses = [];\n        var codeAttrs = {};\n        if (fenceLength > 3) {\n            codeAttrs['data-backticks'] = fenceLength;\n        }\n        if (infoWords.length > 0 && infoWords[0].length > 0) {\n            var lang = infoWords[0];\n            preClasses.push(\"lang-\" + lang);\n            codeAttrs['data-language'] = lang;\n        }\n        return [\n            { type: 'openTag', tagName: 'pre', classNames: preClasses },\n            { type: 'openTag', tagName: 'code', attributes: codeAttrs },\n            { type: 'text', content: node.literal },\n            { type: 'closeTag', tagName: 'code' },\n            { type: 'closeTag', tagName: 'pre' },\n        ];\n    },\n    customInline: function (node, _a) {\n        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;\n        var info = node.info;\n        if (info.indexOf('widget') !== -1 && entering) {\n            skipChildren();\n            var content = getWidgetContent(node);\n            var htmlInline = widgetToDOM(info, content).outerHTML;\n            return [\n                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },\n                { type: 'html', content: htmlInline },\n                { type: 'closeTag', tagName: 'span' },\n            ];\n        }\n        return origin();\n    },\n};\nfunction getHTMLRenderConvertors(linkAttributes, customConvertors) {\n    var convertors = tslib_es6_assign({}, htmlRenderConvertors_baseConvertors);\n    if (linkAttributes) {\n        convertors.link = function (_, _a) {\n            var entering = _a.entering, origin = _a.origin;\n            var result = origin();\n            if (entering) {\n                result.attributes = tslib_es6_assign(tslib_es6_assign({}, result.attributes), linkAttributes);\n            }\n            return result;\n        };\n    }\n    if (customConvertors) {\n        Object.keys(customConvertors).forEach(function (nodeType) {\n            var orgConvertor = convertors[nodeType];\n            var customConvertor = customConvertors[nodeType];\n            if (orgConvertor && isFunction_default()(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var newContext = tslib_es6_assign({}, context);\n                    newContext.origin = function () { return orgConvertor(node, context); };\n                    return customConvertor(node, newContext);\n                };\n            }\n            else if (common_includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_default()(customConvertor)) {\n                convertors[nodeType] = function (node, context) {\n                    var matched = node.literal.match(reHTMLTag);\n                    if (matched) {\n                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];\n                        var typeName = (openTagName || closeTagName).toLowerCase();\n                        var htmlConvertor = customConvertor[typeName];\n                        var childrenHTML = getChildrenHTML(node, typeName);\n                        if (htmlConvertor) {\n                            // copy for preventing to overwrite the originial property\n                            var newNode = tslib_es6_assign({}, node);\n                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);\n                            newNode.childrenHTML = childrenHTML;\n                            newNode.type = typeName;\n                            context.entering = !reCloseTag.test(node.literal);\n                            return htmlConvertor(newNode, context);\n                        }\n                    }\n                    return context.origin();\n                };\n            }\n            else {\n                convertors[nodeType] = customConvertor;\n            }\n        });\n    }\n    return convertors;\n}\n\n;// CONCATENATED MODULE: ./src/markdown/scroll/dom.ts\n\n\nvar nestableTypes = (/* unused pure expression or super */ null && (0));\nvar nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];\nfunction isBlankLine(doc, index) {\n    var _a;\n    var pmNode = doc.child(index);\n    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));\n}\nfunction getEditorRangeHeightInfo(doc, mdNode, children) {\n    var start = getMdStartLine(mdNode) - 1;\n    var end = getMdEndLine(mdNode) - 1;\n    var rect = children[start].getBoundingClientRect();\n    var height = children[end].offsetTop -\n        children[start].offsetTop +\n        children[end].clientHeight;\n    return {\n        height: height <= 0\n            ? children[start].clientHeight\n            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),\n        rect: rect,\n    };\n}\nfunction getBlankLinesHeight(doc, children, start) {\n    var end = doc.childCount - 1;\n    var height = 0;\n    while (start <= end && isBlankLine(doc, start)) {\n        height += children[start].clientHeight;\n        start += 1;\n    }\n    return height;\n}\nfunction findAncestorHavingId(el, root) {\n    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {\n        el = el.parentElement;\n    }\n    return el;\n}\nfunction dom_getTotalOffsetTop(el, root) {\n    var offsetTop = 0;\n    while (el && el !== root) {\n        if (!common_includes(nestableTagNames, el.tagName)) {\n            offsetTop += el.offsetTop;\n        }\n        if (el.offsetParent === root.offsetParent) {\n            break;\n        }\n        el = el.parentElement;\n    }\n    return offsetTop;\n}\nfunction findAdjacentElementToScrollTop(scrollTop, root) {\n    var el = root;\n    var prev = null;\n    while (el) {\n        var firstElementChild = el.firstElementChild;\n        if (!firstElementChild) {\n            break;\n        }\n        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, dom_getTotalOffsetTop(el, root));\n        prev = el;\n        el = lastSibling;\n    }\n    var adjacentEl = el || prev;\n    return adjacentEl === root ? null : adjacentEl;\n}\nfunction findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {\n    if (el && scrollTop > offsetTop + el.offsetTop) {\n        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);\n    }\n    return null;\n}\nfunction getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {\n    var ratio = Math.min((scrollTop - offsetTop) / height, 1);\n    return ratio * targetNodeHeight;\n}\nfunction getParentNodeObj(previewContent, mdNode) {\n    var el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    while (!el || isStyledInlineNode(mdNode)) {\n        mdNode = mdNode.parent;\n        el = previewContent.querySelector(\"[data-nodeid=\\\"\" + mdNode.id + \"\\\"]\");\n    }\n    return getNonNestableNodeObj({ mdNode: mdNode, el: el });\n}\nfunction getNonNestableNodeObj(_a) {\n    var mdNode = _a.mdNode, el = _a.el;\n    while ((includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {\n        mdNode = mdNode.firstChild;\n        el = el.firstElementChild;\n    }\n    return { mdNode: mdNode, el: el };\n}\n\n;// CONCATENATED MODULE: ./src/markdown/scroll/offset.ts\n\n\nvar offsetInfoMap = {};\nfunction setHeight(id, height) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].height = height;\n}\nfunction setOffsetTop(id, offsetTop) {\n    offsetInfoMap[id] = offsetInfoMap[id] || {};\n    offsetInfoMap[id].offsetTop = offsetTop;\n}\nfunction getHeight(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].height;\n}\nfunction getOffsetTop(id) {\n    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;\n}\nfunction removeOffsetInfoByNode(node) {\n    if (node) {\n        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];\n        toArray_default()(node.children).forEach(function (child) {\n            removeOffsetInfoByNode(child);\n        });\n    }\n}\nfunction getAndSaveOffsetInfo(node, root, mdNodeId) {\n    var cachedHeight = getHeight(mdNodeId);\n    var cachedTop = getOffsetTop(mdNodeId);\n    var nodeHeight = cachedHeight || node.clientHeight;\n    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;\n    if (!cachedHeight) {\n        setHeight(mdNodeId, nodeHeight);\n    }\n    if (!cachedTop) {\n        setOffsetTop(mdNodeId, offsetTop);\n    }\n    return { nodeHeight: nodeHeight, offsetTop: offsetTop };\n}\n\n;// CONCATENATED MODULE: ./src/markdown/mdPreview.ts\n\n\n\n\n\n\n\n\n\n\n\nvar CLASS_HIGHLIGHT = cls('md-preview-highlight');\nfunction findTableCell(tableRow, chOffset) {\n    var cell = tableRow.firstChild;\n    while (cell && cell.next) {\n        if (getMdStartCh(cell.next) > chOffset + 1) {\n            break;\n        }\n        cell = cell.next;\n    }\n    return cell;\n}\n/**\n * Class Markdown Preview\n * @param {HTMLElement} el - base element\n * @param {eventEmitter} eventEmitter - event manager\n * @param {object} options\n * @param {boolean} options.isViewer - true for view-only mode\n * @param {boolean} options.highlight - true for using live-highlight feature\n * @param {object} opitons.linkAttributes - attributes for link element\n * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions\n *\n * @ignore\n */\nvar MarkdownPreview = /** @class */ (function () {\n    function MarkdownPreview(eventEmitter, options) {\n        var el = document.createElement('div');\n        this.el = el;\n        this.eventEmitter = eventEmitter;\n        this.isViewer = !!options.isViewer;\n        this.el.className = cls('md-preview');\n        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;\n        this.renderer = new Renderer({\n            gfm: true,\n            nodeId: true,\n            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),\n        });\n        this.cursorNodeId = null;\n        this.sanitizer = sanitizer;\n        this.initEvent(highlight);\n        this.initContentSection();\n        // To prevent overflowing contents in the viewer\n        if (this.isViewer) {\n            this.previewContent.style.overflowWrap = 'break-word';\n        }\n    }\n    MarkdownPreview.prototype.initContentSection = function () {\n        this.previewContent = createElementWith(\"<div class=\\\"\" + cls('contents') + \"\\\"></div>\");\n        if (!this.isViewer) {\n            this.el.appendChild(this.previewContent);\n        }\n    };\n    MarkdownPreview.prototype.toggleActive = function (active) {\n        toggleClass(this.el, 'active', active);\n    };\n    MarkdownPreview.prototype.initEvent = function (highlight) {\n        var _this = this;\n        this.eventEmitter.listen('updatePreview', this.update.bind(this));\n        if (this.isViewer) {\n            return;\n        }\n        if (highlight) {\n            this.eventEmitter.listen('changeToolbarState', function (_a) {\n                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;\n                _this.updateCursorNode(mdNode, cursorPos);\n            });\n            this.eventEmitter.listen('blur', function () {\n                _this.removeHighlight();\n            });\n        }\n        on_default()(this.el, 'scroll', function (event) {\n            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));\n        });\n        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });\n        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });\n    };\n    MarkdownPreview.prototype.removeHighlight = function () {\n        if (this.cursorNodeId) {\n            var currentEl = this.getElementByNodeId(this.cursorNodeId);\n            if (currentEl) {\n                removeClass_default()(currentEl, CLASS_HIGHLIGHT);\n            }\n        }\n    };\n    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {\n        if (cursorNode) {\n            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode(mdNode); });\n            if (cursorNode.type === 'tableRow') {\n                cursorNode = findTableCell(cursorNode, cursorPos[1]);\n            }\n            else if (cursorNode.type === 'tableBody') {\n                // empty line next to table\n                cursorNode = null;\n            }\n        }\n        var cursorNodeId = cursorNode ? cursorNode.id : null;\n        if (this.cursorNodeId === cursorNodeId) {\n            return;\n        }\n        var oldEL = this.getElementByNodeId(this.cursorNodeId);\n        var newEL = this.getElementByNodeId(cursorNodeId);\n        if (oldEL) {\n            removeClass_default()(oldEL, CLASS_HIGHLIGHT);\n        }\n        if (newEL) {\n            addClass_default()(newEL, CLASS_HIGHLIGHT);\n        }\n        this.cursorNodeId = cursorNodeId;\n    };\n    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {\n        return nodeId\n            ? this.previewContent.querySelector(\"[data-nodeid=\\\"\" + nodeId + \"\\\"]\")\n            : null;\n    };\n    MarkdownPreview.prototype.update = function (changed) {\n        var _this = this;\n        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });\n        this.eventEmitter.emit('afterPreviewRender', this);\n    };\n    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {\n        var _this = this;\n        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;\n        var contentEl = this.previewContent;\n        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));\n        if (!removedNodeRange) {\n            contentEl.insertAdjacentHTML('afterbegin', newHtml);\n        }\n        else {\n            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];\n            var startEl = this.getElementByNodeId(startNodeId);\n            var endEl = this.getElementByNodeId(endNodeId);\n            if (startEl) {\n                startEl.insertAdjacentHTML('beforebegin', newHtml);\n                var el = startEl;\n                while (el && el !== endEl) {\n                    var nextEl = el.nextElementSibling;\n                    removeNode(el);\n                    removeOffsetInfoByNode(el);\n                    el = nextEl;\n                }\n                if (el === null || el === void 0 ? void 0 : el.parentNode) {\n                    removeNode(el);\n                    removeOffsetInfoByNode(el);\n                }\n            }\n        }\n    };\n    MarkdownPreview.prototype.getRenderer = function () {\n        return this.renderer;\n    };\n    MarkdownPreview.prototype.destroy = function () {\n        off_default()(this.el, 'scroll');\n        this.el = null;\n    };\n    MarkdownPreview.prototype.getElement = function () {\n        return this.el;\n    };\n    MarkdownPreview.prototype.getHTML = function () {\n        return removeProseMirrorHackNodes(this.previewContent.innerHTML);\n    };\n    MarkdownPreview.prototype.setHTML = function (html) {\n        this.previewContent.innerHTML = html;\n    };\n    MarkdownPreview.prototype.setHeight = function (height) {\n        css_default()(this.el, { height: height + \"px\" });\n    };\n    MarkdownPreview.prototype.setMinHeight = function (minHeight) {\n        css_default()(this.el, { minHeight: minHeight + \"px\" });\n    };\n    return MarkdownPreview;\n}());\n/* harmony default export */ var mdPreview = (MarkdownPreview);\n\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-state\",\"commonjs2\":\"prosemirror-state\",\"amd\":\"prosemirror-state\"}\nvar external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_ = __nested_webpack_require_87464__(814);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-inputrules\",\"commonjs2\":\"prosemirror-inputrules\",\"amd\":\"prosemirror-inputrules\"}\nvar external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_ = __nested_webpack_require_87464__(479);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-view\",\"commonjs2\":\"prosemirror-view\",\"amd\":\"prosemirror-view\"}\nvar external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_ = __nested_webpack_require_87464__(311);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-keymap\",\"commonjs2\":\"prosemirror-keymap\",\"amd\":\"prosemirror-keymap\"}\nvar external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_ = __nested_webpack_require_87464__(481);\n// EXTERNAL MODULE: external {\"commonjs\":\"prosemirror-model\",\"commonjs2\":\"prosemirror-model\",\"amd\":\"prosemirror-model\"}\nvar external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_ = __nested_webpack_require_87464__(43);\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/array/inArray.js\nvar inArray = __nested_webpack_require_87464__(928);\nvar inArray_default = /*#__PURE__*/__nested_webpack_require_87464__.n(inArray);\n;// CONCATENATED MODULE: ./src/utils/map.ts\n\n/**\n * @class\n * @ignore\n * @classdesc ES6 Map\n */\nvar map_Map = /** @class */ (function () {\n    function Map() {\n        this.keys = [];\n        this.values = [];\n    }\n    Map.prototype.getKeyIndex = function (key) {\n        return inArray_default()(key, this.keys);\n    };\n    Map.prototype.get = function (key) {\n        return this.values[this.getKeyIndex(key)];\n    };\n    Map.prototype.set = function (key, value) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.values[keyIndex] = value;\n        }\n        else {\n            this.keys.push(key);\n            this.values.push(value);\n        }\n        return this;\n    };\n    Map.prototype.has = function (key) {\n        return this.getKeyIndex(key) > -1;\n    };\n    Map.prototype.delete = function (key) {\n        var keyIndex = this.getKeyIndex(key);\n        if (keyIndex > -1) {\n            this.keys.splice(keyIndex, 1);\n            this.values.splice(keyIndex, 1);\n            return true;\n        }\n        return false;\n    };\n    Map.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        if (thisArg === void 0) { thisArg = this; }\n        this.values.forEach(function (value, index) {\n            if (value && _this.keys[index]) {\n                callback.call(thisArg, value, _this.keys[index], _this);\n            }\n        });\n    };\n    Map.prototype.clear = function () {\n        this.keys = [];\n        this.values = [];\n    };\n    return Map;\n}());\n/* harmony default export */ var utils_map = (map_Map);\n\n;// CONCATENATED MODULE: ./src/i18n/i18n.ts\n/**\n * @fileoverview Implements i18n\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n */\n\n\nvar DEFAULT_CODE = 'en-US';\n/**\n * Class I18n\n * @ignore\n */\nvar I18n = /** @class */ (function () {\n    function I18n() {\n        this.code = DEFAULT_CODE;\n        this.langs = new utils_map();\n    }\n    I18n.prototype.setCode = function (code) {\n        this.code = code || DEFAULT_CODE;\n    };\n    /**\n     * Set language set\n     * @param {string|string[]} codes locale code\n     * @param {object} data language set\n     */\n    I18n.prototype.setLanguage = function (codes, data) {\n        var _this = this;\n        codes = [].concat(codes);\n        codes.forEach(function (code) {\n            if (!_this.langs.has(code)) {\n                _this.langs.set(code, data);\n            }\n            else {\n                var langData = _this.langs.get(code);\n                _this.langs.set(code, extend_default()(langData, data));\n            }\n        });\n    };\n    I18n.prototype.get = function (key, code) {\n        if (!code) {\n            code = this.code;\n        }\n        var langSet = this.langs.get(code);\n        if (!langSet) {\n            langSet = this.langs.get(DEFAULT_CODE);\n        }\n        var text = langSet[key];\n        if (!text) {\n            throw new Error(\"There is no text key \\\"\" + key + \"\\\" in \" + code);\n        }\n        return text;\n    };\n    return I18n;\n}());\n\n/* harmony default export */ var i18n = (new I18n());\n\n;// CONCATENATED MODULE: ./src/wysiwyg/helper/node.ts\n\n\nfunction findNodeBy(pos, condition) {\n    var depth = pos.depth;\n    while (depth) {\n        var node = pos.node(depth);\n        if (condition(node, depth)) {\n            return {\n                node: node,\n                depth: depth,\n                offset: depth > 0 ? pos.before(depth) : 0,\n            };\n        }\n        depth -= 1;\n    }\n    return null;\n}\nfunction node_isListNode(_a) {\n    var type = _a.type;\n    return type.name === 'bulletList' || type.name === 'orderedList';\n}\nfunction isInListNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';\n    });\n}\nfunction isInTableNode(pos) {\n    return !!findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';\n    });\n}\nfunction findListItem(pos) {\n    return findNodeBy(pos, function (_a) {\n        var type = _a.type;\n        return type.name === 'listItem';\n    });\n}\nfunction createDOMInfoParsedRawHTML(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            var rawHTML = dom.getAttribute('data-raw-html');\n            return __assign({}, (rawHTML && { rawHTML: rawHTML }));\n        },\n    };\n}\nfunction createCellAttrs(attrs) {\n    return Object.keys(attrs).reduce(function (acc, attrName) {\n        if (attrName !== 'rawHTML' && attrs[attrName]) {\n            attrName = attrName === 'className' ? 'class' : attrName;\n            acc[attrName] = attrs[attrName];\n        }\n        return acc;\n    }, {});\n}\nfunction createParsedCellDOM(tag) {\n    return {\n        tag: tag,\n        getAttrs: function (dom) {\n            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {\n                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;\n                var attrValue = dom.getAttribute(attrNameInDOM);\n                if (attrValue) {\n                    acc[attrName] = includes(['rawHTML', 'extended'], attrName)\n                        ? attrValue\n                        : Number(attrValue);\n                }\n                return acc;\n            }, {});\n        },\n    };\n}\nfunction getDefaultCustomAttrs() {\n    return {\n        htmlAttrs: { default: null },\n        classNames: { default: null },\n    };\n}\nfunction getCustomAttrs(attrs) {\n    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;\n    return __assign(__assign({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });\n}\n\n;// CONCATENATED MODULE: ./src/wysiwyg/helper/tableOffsetMap.ts\n\n\nvar cache = new Map();\n/* eslint-disable @typescript-eslint/no-unused-vars */\nvar TableOffsetMap = /** @class */ (function () {\n    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {\n        this.table = table;\n        this.tableRows = tableRows;\n        this.tableStartPos = tableStartPos;\n        this.rowInfo = rowInfo;\n    }\n    TableOffsetMap.create = function (cellPos) {\n        var table = findNodeBy(cellPos, function (_a) {\n            var type = _a.type;\n            return type.name === 'table';\n        });\n        if (table) {\n            var node = table.node, depth = table.depth, offset = table.offset;\n            var cached = cache.get(node);\n            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {\n                return cached;\n            }\n            var rows_1 = [];\n            var tablePos = cellPos.start(depth);\n            var thead = node.child(0);\n            var tbody = node.child(1);\n            var theadCellInfo = createOffsetMap(thead, tablePos);\n            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);\n            thead.forEach(function (row) { return rows_1.push(row); });\n            tbody.forEach(function (row) { return rows_1.push(row); });\n            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));\n            cache.set(node, map);\n            return map;\n        }\n        return null;\n    };\n    Object.defineProperty(TableOffsetMap.prototype, \"totalRowCount\", {\n        get: function () {\n            return this.rowInfo.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"totalColumnCount\", {\n        get: function () {\n            return this.rowInfo[0].length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableStartOffset\", {\n        get: function () {\n            return this.tableStartPos;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TableOffsetMap.prototype, \"tableEndOffset\", {\n        get: function () {\n            return this.tableStartPos + this.table.nodeSize - 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {\n        return this.rowInfo[rowIdx][colIdx];\n    };\n    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {\n        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {\n            var rowEnd = rowStart + this.tableRows[i].nodeSize;\n            if (i === rowIdx) {\n                var index = colIdx;\n                // Skip the cells from previous row(via rowspan)\n                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {\n                    index += 1;\n                }\n                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;\n            }\n            rowStart = rowEnd;\n        }\n    };\n    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {\n        var cellInfo = this.rowInfo[rowIdx][colIdx];\n        return {\n            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),\n            pos: cellInfo.offset,\n        };\n    };\n    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {\n        return false;\n    };\n    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {\n        return 0;\n    };\n    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {\n        return null;\n    };\n    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {\n        var offset = this.rowInfo[rowIdx][colIdx].offset;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;\n    };\n    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {\n        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;\n        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;\n    };\n    TableOffsetMap.prototype.getCellIndex = function (cellPos) {\n        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {\n            var rowInfo = this.rowInfo[rowIdx];\n            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {\n                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {\n                    return [rowIdx, colIdx];\n                }\n            }\n        }\n        return [0, 0];\n    };\n    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {\n        var _a, _b, _c;\n        if (endCellPos === void 0) { endCellPos = startCellPos; }\n        if (startCellPos.pos > endCellPos.pos) {\n            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];\n        }\n        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];\n        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];\n        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];\n        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];\n        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });\n    };\n    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {\n        return selectionInfo;\n    };\n    return TableOffsetMap;\n}());\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\nvar createOffsetMap = function (headOrBody, startOffset) {\n    var cellInfoMatrix = [];\n    headOrBody.forEach(function (row, rowOffset) {\n        // get row index based on table(not table head or table body)\n        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };\n        row.forEach(function (_a, cellOffset) {\n            var nodeSize = _a.nodeSize;\n            var colIdx = 0;\n            while (rowInfo[colIdx]) {\n                colIdx += 1;\n            }\n            rowInfo[colIdx] = {\n                // 2 is the sum of the front and back positions of the tag\n                offset: startOffset + rowOffset + cellOffset + 2,\n                nodeSize: nodeSize,\n            };\n            rowInfo.length += 1;\n        });\n        cellInfoMatrix.push(rowInfo);\n    });\n    return cellInfoMatrix;\n};\nfunction mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {\n    common_assign(TableOffsetMap.prototype, offsetMapMixin);\n    createOffsetMap = createOffsetMapMixin;\n    return TableOffsetMap;\n}\n\n;// CONCATENATED MODULE: ./src/helper/plugin.ts\n\n\n\n\n\n\n\n\n\n\nfunction execPlugin(pluginInfo) {\n    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;\n    var pmState = { Plugin: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin, PluginKey: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey, Selection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection, TextSelection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection };\n    var pmView = { Decoration: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration, DecorationSet: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet };\n    var pmModel = { Fragment: external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment };\n    var pmRules = { InputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.InputRule, inputRules: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.inputRules, undoInputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.undoInputRule };\n    var pmKeymap = { keymap: external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap };\n    var context = {\n        eventEmitter: eventEmitter,\n        usageStatistics: usageStatistics,\n        instance: instance,\n        pmState: pmState,\n        pmView: pmView,\n        pmModel: pmModel,\n        pmRules: pmRules,\n        pmKeymap: pmKeymap,\n        i18n: i18n,\n    };\n    if (isArray_default()(plugin)) {\n        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;\n        return pluginFn(context, options);\n    }\n    return plugin(context);\n}\nfunction getPluginInfo(pluginsInfo) {\n    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;\n    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);\n    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {\n        var pluginInfoResult = execPlugin({\n            plugin: plugin,\n            eventEmitter: eventEmitter,\n            usageStatistics: usageStatistics,\n            instance: instance,\n        });\n        if (!pluginInfoResult) {\n            throw new Error('The return value of the executed plugin is empty.');\n        }\n        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;\n        if (toHTMLRenderers) {\n            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);\n        }\n        if (toMarkdownRenderers) {\n            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);\n        }\n        if (markdownPlugins) {\n            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);\n        }\n        if (wysiwygPlugins) {\n            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);\n        }\n        if (wysiwygNodeViews) {\n            acc.wwNodeViews = tslib_es6_assign(tslib_es6_assign({}, acc.wwNodeViews), wysiwygNodeViews);\n        }\n        if (markdownCommands) {\n            acc.mdCommands = tslib_es6_assign(tslib_es6_assign({}, acc.mdCommands), markdownCommands);\n        }\n        if (wysiwygCommands) {\n            acc.wwCommands = tslib_es6_assign(tslib_es6_assign({}, acc.wwCommands), wysiwygCommands);\n        }\n        if (toolbarItems) {\n            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);\n        }\n        if (markdownParsers) {\n            acc.markdownParsers = tslib_es6_assign(tslib_es6_assign({}, acc.markdownParsers), markdownParsers);\n        }\n        return acc;\n    }, {\n        toHTMLRenderers: {},\n        toMarkdownRenderers: {},\n        mdPlugins: [],\n        wwPlugins: [],\n        wwNodeViews: {},\n        mdCommands: {},\n        wwCommands: {},\n        toolbarItems: [],\n        markdownParsers: {},\n    });\n}\n\n// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFalsy.js\nvar isFalsy = __nested_webpack_require_87464__(404);\nvar isFalsy_default = /*#__PURE__*/__nested_webpack_require_87464__.n(isFalsy);\n;// CONCATENATED MODULE: ./src/event/eventEmitter.ts\n\n\n\n\nvar eventTypeList = [\n    'afterPreviewRender',\n    'updatePreview',\n    'changeMode',\n    'needChangeMode',\n    'command',\n    'changePreviewStyle',\n    'changePreviewTabPreview',\n    'changePreviewTabWrite',\n    'scroll',\n    'contextmenu',\n    'show',\n    'hide',\n    'changeLanguage',\n    'changeToolbarState',\n    'toggleScrollSync',\n    'mixinTableOffsetMapPrototype',\n    'setFocusedNode',\n    'removePopupWidget',\n    'query',\n    // provide event for user\n    'openPopup',\n    'closePopup',\n    'addImageBlobHook',\n    'beforePreviewRender',\n    'beforeConvertWysiwygToMarkdown',\n    'load',\n    'loadUI',\n    'change',\n    'caretChange',\n    'destroy',\n    'focus',\n    'blur',\n    'keydown',\n    'keyup',\n];\n/**\n * Class EventEmitter\n * @ignore\n */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        var _this = this;\n        this.events = new utils_map();\n        this.eventTypes = eventTypeList.reduce(function (types, type) {\n            return tslib_es6_assign(tslib_es6_assign({}, types), { type: type });\n        }, {});\n        this.hold = false;\n        eventTypeList.forEach(function (eventType) {\n            _this.addEventType(eventType);\n        });\n    }\n    /**\n     * Listen event and bind event handler\n     * @param {string} type Event type string\n     * @param {function} handler Event handler\n     */\n    EventEmitter.prototype.listen = function (type, handler) {\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type) || [];\n        if (!this.hasEventType(typeInfo.type)) {\n            throw new Error(\"There is no event type \" + typeInfo.type);\n        }\n        if (typeInfo.namespace) {\n            handler.namespace = typeInfo.namespace;\n        }\n        eventHandlers.push(handler);\n        this.events.set(typeInfo.type, eventHandlers);\n    };\n    /**\n     * Emit event\n     * @param {string} eventName Event name to emit\n     * @returns {Array}\n     */\n    EventEmitter.prototype.emit = function (type) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var typeInfo = this.getTypeInfo(type);\n        var eventHandlers = this.events.get(typeInfo.type);\n        var results = [];\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, args);\n                if (!isUndefined_default()(result)) {\n                    results.push(result);\n                }\n            });\n        }\n        return results;\n    };\n    /**\n     * Emit given event and return result\n     * @param {string} eventName Event name to emit\n     * @param {any} source Source to change\n     * @returns {string}\n     */\n    EventEmitter.prototype.emitReduce = function (type, source) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var eventHandlers = this.events.get(type);\n        if (!this.hold && eventHandlers) {\n            eventHandlers.forEach(function (handler) {\n                var result = handler.apply(void 0, __spreadArray([source], args));\n                if (!isFalsy_default()(result)) {\n                    source = result;\n                }\n            });\n        }\n        return source;\n    };\n    /**\n     * Get event type and namespace\n     * @param {string} type Event type name\n     * @returns {{type: string, namespace: string}}\n     * @private\n     */\n    EventEmitter.prototype.getTypeInfo = function (type) {\n        var splited = type.split('.');\n        return {\n            type: splited[0],\n            namespace: splited[1],\n        };\n    };\n    /**\n     * Check whether event type exists or not\n     * @param {string} type Event type name\n     * @returns {boolean}\n     * @private\n     */\n    EventEmitter.prototype.hasEventType = function (type) {\n        return !isUndefined_default()(this.eventTypes[this.getTypeInfo(type).type]);\n    };\n    /**\n     * Add event type when given event not exists\n     * @param {string} type Event type name\n     */\n    EventEmitter.prototype.addEventType = function (type) {\n        if (this.hasEventType(type)) {\n            throw new Error(\"There is already have event type \" + type);\n        }\n        this.eventTypes[type] = type;\n    };\n    /**\n     * Remove event handler from given event type\n     * @param {string} eventType Event type name\n     * @param {function} [handler] - registered event handler\n     */\n    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {\n        var _this = this;\n        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;\n        if (type && handler) {\n            this.removeEventHandlerWithHandler(type, handler);\n        }\n        else if (type && !namespace) {\n            this.events.delete(type);\n        }\n        else if (!type && namespace) {\n            this.events.forEach(function (_, evtType) {\n                _this.removeEventHandlerWithTypeInfo(evtType, namespace);\n            });\n        }\n        else if (type && namespace) {\n            this.removeEventHandlerWithTypeInfo(type, namespace);\n        }\n    };\n    /**\n     * Remove event handler with event handler\n     * @param {string} type - event type name\n     * @param {function} handler - event handler\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {\n        var eventHandlers = this.events.get(type);\n        if (eventHandlers) {\n            var handlerIndex = eventHandlers.indexOf(handler);\n            if (eventHandlers.indexOf(handler) >= 0) {\n                eventHandlers.splice(handlerIndex, 1);\n            }\n        }\n    };\n    /**\n     * Remove event handler with event type information\n     * @param {string} type Event type name\n     * @param {string} namespace Event namespace\n     * @private\n     */\n    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {\n        var handlersToSurvive = [];\n        var eventHandlers = this.events.get(type);\n        if (!eventHandlers) {\n            return;\n        }\n        eventHandlers.map(function (handler) {\n            if (handler.namespace !== namespace) {\n                handlersToSurvive.push(handler);\n            }\n            return null;\n        });\n        this.events.set(type, handlersToSurvive);\n    };\n    EventEmitter.prototype.getEvents = function () {\n        return this.events;\n    };\n    EventEmitter.prototype.holdEventInvoke = function (fn) {\n        this.hold = true;\n        fn();\n        this.hold = false;\n    };\n    return EventEmitter;\n}());\n/* harmony default export */ var eventEmitter = (EventEmitter);\n\n;// CONCATENATED MODULE: ./src/viewer.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar TASK_ATTR_NAME = 'data-task';\nvar DISABLED_TASK_ATTR_NAME = 'data-task-disabled';\nvar TASK_CHECKED_CLASS_NAME = 'checked';\nfunction registerHTMLTagToWhitelist(convertorMap) {\n    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {\n        if (convertorMap[htmlType]) {\n            // register tag white list for preventing to remove the html in sanitizer\n            Object.keys(convertorMap[htmlType]).forEach(function (type) { return htmlSanitizer_registerTagWhitelistIfPossible(type); });\n        }\n    });\n}\n/**\n * Class ToastUIEditorViewer\n * @param {object} options Option object\n *     @param {HTMLElement} options.el - container element\n *     @param {string} [options.initialValue] Editor's initial value\n *     @param {Object} [options.events] - Events\n *         @param {function} [options.events.load] - It would be emitted when editor fully load\n *         @param {function} [options.events.change] - It would be emitted when content changed\n *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position\n *         @param {function} [options.events.focus] - It would be emitted when editor get focus\n *         @param {function} [options.events.blur] - It would be emitted when editor loose focus\n *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].\n *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec\n *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type\n *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node\n *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition\n *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer\n *     @param {boolean} [options.frontMatter=false] - whether use the front matter\n *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.\n */\nvar ToastUIEditorViewer = /** @class */ (function () {\n    function ToastUIEditorViewer(options) {\n        var _this = this;\n        this.options = extend_default()({\n            linkAttributes: null,\n            extendedAutolinks: false,\n            customHTMLRenderer: null,\n            referenceDefinition: false,\n            customHTMLSanitizer: null,\n            frontMatter: false,\n            usageStatistics: true,\n            theme: 'light',\n        }, options);\n        this.eventEmitter = new eventEmitter();\n        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);\n        var _a = getPluginInfo({\n            plugins: this.options.plugins,\n            eventEmitter: this.eventEmitter,\n            usageStatistics: this.options.usageStatistics,\n            instance: this,\n        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;\n        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;\n        var rendererOptions = {\n            linkAttributes: linkAttributes,\n            customHTMLRenderer: tslib_es6_assign(tslib_es6_assign({}, toHTMLRenderers), customHTMLRenderer),\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            frontMatter: frontMatter,\n            sanitizer: customHTMLSanitizer || sanitizeHTML,\n        };\n        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);\n        if (this.options.events) {\n            forEachOwnProperties_default()(this.options.events, function (fn, key) {\n                _this.on(key, fn);\n            });\n        }\n        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;\n        var existingHTML = el.innerHTML;\n        if (theme !== 'light') {\n            el.classList.add(cls(theme));\n        }\n        el.innerHTML = '';\n        this.toastMark = new ToastMark('', {\n            disallowedHtmlBlockTags: ['br', 'img'],\n            extendedAutolinks: extendedAutolinks,\n            referenceDefinition: referenceDefinition,\n            disallowDeepHeading: true,\n            frontMatter: frontMatter,\n            customParser: markdownParsers,\n        });\n        this.preview = new mdPreview(this.eventEmitter, tslib_es6_assign(tslib_es6_assign({}, rendererOptions), { isViewer: true }));\n        on_default()(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));\n        if (initialValue) {\n            this.setMarkdown(initialValue);\n        }\n        else if (existingHTML) {\n            this.preview.setHTML(existingHTML);\n        }\n        el.appendChild(this.preview.previewContent);\n        this.eventEmitter.emit('load', this);\n    }\n    /**\n     * Toggle task by detecting mousedown event.\n     * @param {MouseEvent} ev - event\n     * @private\n     */\n    ToastUIEditorViewer.prototype.toggleTask = function (ev) {\n        var element = ev.target;\n        var style = getComputedStyle(element, ':before');\n        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&\n            element.hasAttribute(TASK_ATTR_NAME) &&\n            isPositionInBox(style, ev.offsetX, ev.offsetY)) {\n            toggleClass(element, TASK_CHECKED_CLASS_NAME);\n            this.eventEmitter.emit('change', {\n                source: 'viewer',\n                date: ev,\n            });\n        }\n    };\n    /**\n     * Set content for preview\n     * @param {string} markdown Markdown text\n     */\n    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {\n        var lineTexts = this.toastMark.getLineTexts();\n        var length = lineTexts.length;\n        var lastLine = common_last(lineTexts);\n        var endSourcepos = [length, lastLine.length + 1];\n        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');\n        this.eventEmitter.emit('updatePreview', editResult);\n    };\n    /**\n     * Bind eventHandler to event type\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.on = function (type, handler) {\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Unbind eventHandler from event type\n     * @param {string} type Event type\n     */\n    ToastUIEditorViewer.prototype.off = function (type) {\n        this.eventEmitter.removeEventHandler(type);\n    };\n    /**\n     * Add hook to TUIEditor event\n     * @param {string} type Event type\n     * @param {function} handler Event handler\n     */\n    ToastUIEditorViewer.prototype.addHook = function (type, handler) {\n        this.eventEmitter.removeEventHandler(type);\n        this.eventEmitter.listen(type, handler);\n    };\n    /**\n     * Remove Viewer preview from document\n     */\n    ToastUIEditorViewer.prototype.destroy = function () {\n        off_default()(this.preview.el, 'mousedown', this.toggleTask.bind(this));\n        this.preview.destroy();\n        this.eventEmitter.emit('destroy');\n    };\n    /**\n     * Return true\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isViewer = function () {\n        return true;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isMarkdownMode = function () {\n        return false;\n    };\n    /**\n     * Return false\n     * @returns {boolean}\n     */\n    ToastUIEditorViewer.prototype.isWysiwygMode = function () {\n        return false;\n    };\n    return ToastUIEditorViewer;\n}());\n/* harmony default export */ var viewer = (ToastUIEditorViewer);\n\n;// CONCATENATED MODULE: ./src/indexViewer.ts\n\n\n/* harmony default export */ var indexViewer = (viewer);\n\n}();\n__nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLXZpZXdlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsMEZBQXdCLEdBQUcsbUJBQU8sQ0FBQyxrRkFBb0IsR0FBRyxtQkFBTyxDQUFDLGdGQUFtQixHQUFHLG1CQUFPLENBQUMsZ0ZBQW1CLEdBQUcsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDbkwsTUFBTSxFQUs4SjtBQUNwSyxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHLEtBQUk7QUFDUCxFQUFFLENBQUM7QUFDSCxDQUFDLHFCQUFxQjs7QUFFdEIscUNBQXFDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sb0JBQW9CLGVBQWUsT0FBTzs7QUFFMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLEVBQUUsaUJBQWlCLEVBQUUsTUFBTTtBQUN6RDtBQUNBLHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1R0FBdUcscUJBQXFCLG1CQUFtQjs7QUFFL0ksdUNBQXVDLDBCQUEwQiwwQ0FBMEMsZ0JBQWdCLE9BQU8sb0JBQW9CLGVBQWUsT0FBTzs7QUFFNUs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsVUFBVTtBQUN2QixjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RDtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQztBQUNEOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsY0FBYyxnQ0FBbUI7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsY0FBYyxnQ0FBbUI7QUFDakMsbUJBQW1CLGdDQUFtQjtBQUN0QywyQkFBMkIsZ0NBQW1COztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlO0FBQ2Y7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBLElBQUk7QUFDSixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsbUJBQW1CLGdDQUFtQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsZUFBZSxnQ0FBbUI7QUFDbEMsY0FBYyxnQ0FBbUI7O0FBRWpDLGdCQUFnQixnQ0FBbUI7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxlQUFlLGdDQUFtQjtBQUNsQyxjQUFjLGdDQUFtQjs7QUFFakMsZ0JBQWdCLGdDQUFtQjs7QUFFbkM7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLGNBQWMsZ0NBQW1CO0FBQ2pDLGtCQUFrQixnQ0FBbUI7O0FBRXJDO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxjQUFjLGdDQUFtQjtBQUNqQyxjQUFjLGdDQUFtQjtBQUNqQyxlQUFlLGdDQUFtQjtBQUNsQyxtQkFBbUIsZ0NBQW1COztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsZUFBZSxnQ0FBbUI7QUFDbEMsY0FBYyxnQ0FBbUI7O0FBRWpDO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLGlCQUFpQiwwQkFBMEIsYUFBYTtBQUNuRSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsa0JBQWtCLGdDQUFtQjs7QUFFckM7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSxrREFBa0QsZ0NBQW1COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUEsY0FBYyxnQ0FBbUI7QUFDakMsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQyxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLGNBQWMsZ0NBQW1CO0FBQ2pDLGNBQWMsZ0NBQW1COztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLG1CQUFtQixnQ0FBbUI7QUFDdEMsY0FBYyxnQ0FBbUI7QUFDakMsZUFBZSxnQ0FBbUI7QUFDbEMsbUJBQW1CLGdDQUFtQjs7QUFFdEM7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLDJCQUEyQixnQ0FBbUI7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxrQkFBa0IsZ0NBQW1CO0FBQ3JDLGdCQUFnQixnQ0FBbUI7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxrQkFBa0IsZ0NBQW1CO0FBQ3JDLGFBQWEsZ0NBQW1COztBQUVoQztBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGNBQWMsR0FBRztBQUNqQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0Esa0RBQWtELGdDQUFtQjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBLGVBQWUsZ0NBQW1COztBQUVsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCxnQ0FBbUI7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSxlQUFlLGdDQUFtQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixnQ0FBbUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBbUI7QUFDOUI7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3RELDBCQUEwQjtBQUMxQixZQUFZLGdDQUFtQixhQUFhLFdBQVc7QUFDdkQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLGdDQUFtQix3QkFBd0IsZ0NBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFtQiwyQkFBMkI7QUFDekQsV0FBVztBQUNYO0FBQ0E7QUFDQSxJQUFJLDBCQUFtQjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBbUIsR0FBRywwQkFBbUI7QUFDekMsMEJBQTBCO0FBQzFCLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQTZDLFVBQVUsc0RBQXNELGNBQWM7QUFDNUksMEJBQTBCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGtCQUFrQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSCxnQ0FBbUIscUJBQXFCLGdDQUFtQjtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0EsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxpQ0FBaUM7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUUsZ0NBQWdDLEtBQUssNkNBQTZDLEtBQUs7QUFDOUksMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDJDQUEyQztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxHQUFHLEdBQUcsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsYUFBYSxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEdBQUcsV0FBVyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQyx3Q0FBd0MsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHO0FBQzNFO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMseUJBQXlCLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksWUFBWTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FBV0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSw0Q0FBNEMsd0NBQXdDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNkRBQTZEO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0NBQW1CO0FBQ3BDLHNDQUFzQyxnQ0FBbUI7QUFDekQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELGtFQUFrRSxDQUFFO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxJQUFJLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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c0IsZ0JBQWdCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxDQUFDOzs7QUFHRDs7QUFFQSxDQUFDO0FBQ0QsMEJBQW1CLEdBQUcsMEJBQW1CO0FBQ3pDLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxocFxcT25lRHJpdmVcXERlc2t0b3BcXE5BUlJBVElWRSBORVhVU1xcYWktZ2VuZXJhdG9yXFxub2RlX21vZHVsZXNcXEB0b2FzdC11aVxcZWRpdG9yXFxkaXN0XFx0b2FzdHVpLWVkaXRvci12aWV3ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAdG9hc3QtdWkvZWRpdG9yXG4gKiBAdmVyc2lvbiAzLjIuMiB8IEZyaSBGZWIgMTcgMjAyM1xuICogQGF1dGhvciBOSE4gQ2xvdWQgRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLWtleW1hcFwiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLW1vZGVsXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3Itc3RhdGVcIiksIHJlcXVpcmUoXCJwcm9zZW1pcnJvci12aWV3XCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInByb3NlbWlycm9yLWlucHV0cnVsZXNcIiwgXCJwcm9zZW1pcnJvci1rZXltYXBcIiwgXCJwcm9zZW1pcnJvci1tb2RlbFwiLCBcInByb3NlbWlycm9yLXN0YXRlXCIsIFwicHJvc2VtaXJyb3Itdmlld1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ0b2FzdHVpXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLWtleW1hcFwiKSwgcmVxdWlyZShcInByb3NlbWlycm9yLW1vZGVsXCIpLCByZXF1aXJlKFwicHJvc2VtaXJyb3Itc3RhdGVcIiksIHJlcXVpcmUoXCJwcm9zZW1pcnJvci12aWV3XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJ0b2FzdHVpXCJdID0gcm9vdFtcInRvYXN0dWlcIl0gfHwge30sIHJvb3RbXCJ0b2FzdHVpXCJdW1wiRWRpdG9yXCJdID0gZmFjdG9yeShyb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSwgcm9vdFt1bmRlZmluZWRdLCByb290W3VuZGVmaW5lZF0sIHJvb3RbdW5kZWZpbmVkXSk7XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NzlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDgxX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzgxNF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zMTFfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDM2ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLyohIEBsaWNlbnNlIERPTVB1cmlmeSAyLjMuMyB8IChjKSBDdXJlNTMgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgbGljZW5zZSAyLjAgYW5kIE1vemlsbGEgUHVibGljIExpY2Vuc2UgMi4wIHwgZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvMi4zLjMvTElDRU5TRSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgMDtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5LFxuICAgICAgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsXG4gICAgICBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbixcbiAgICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsXG4gICAgICBzZWFsID0gT2JqZWN0LnNlYWwsXG4gICAgICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LFxuICAgICAgYXBwbHkgPSBfcmVmLmFwcGx5LFxuICAgICAgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7XG5cbiAgaWYgKCFhcHBseSkge1xuICAgIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZnVuLCB0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW4uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFmcmVlemUpIHtcbiAgICBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghc2VhbCkge1xuICAgIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdCkge1xuICAgIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChGdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShGdW5jLCBbbnVsbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkpKSgpO1xuICAgIH07XG4gIH1cblxuICB2YXIgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG4gIHZhciBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG4gIHZhciBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblxuICB2YXIgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xuICB2YXIgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xuICB2YXIgc3RyaW5nUmVwbGFjZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbiAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG4gIHZhciBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG4gIHZhciByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuXG4gIHZhciB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICAvKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZSAqL1xuICBmdW5jdGlvbiBhZGRUb1NldChzZXQsIGFycmF5KSB7XG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAvLyBNYWtlICdpbicgYW5kIHRydXRoeSBjaGVja3MgbGlrZSBCb29sZWFuKHNldC5jb25zdHJ1Y3RvcilcbiAgICAgIC8vIGluZGVwZW5kZW50IG9mIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gT2JqZWN0LnByb3RvdHlwZS5cbiAgICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxjRWxlbWVudCA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQpO1xuICAgICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHtcbiAgICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgLyogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3QgKi9cbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gICAgdmFyIG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IHZvaWQgMDtcbiAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgaWYgKGFwcGx5KGhhc093blByb3BlcnR5LCBvYmplY3QsIFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmplY3Q7XG4gIH1cblxuICAvKiBJRTEwIGRvZXNuJ3Qgc3VwcG9ydCBfX2xvb2t1cEdldHRlcl9fIHNvIGxldHMnXG4gICAqIHNpbXVsYXRlIGl0LiBJdCBhbHNvIGF1dG9tYXRpY2FsbHkgY2hlY2tzXG4gICAqIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uIG9yIGdldHRlciBhbmQgYmVoYXZlc1xuICAgKiBhY2NvcmRpbmdseS4gKi9cbiAgZnVuY3Rpb24gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcCkge1xuICAgIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgICBpZiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhbGxiYWNrVmFsdWUoZWxlbWVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdmYWxsYmFjayB2YWx1ZSBmb3InLCBlbGVtZW50KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxsYmFja1ZhbHVlO1xuICB9XG5cbiAgdmFyIGh0bWwgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5cbiAgLy8gU1ZHXG4gIHZhciBzdmcgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuXG4gIHZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuXG4gIC8vIExpc3Qgb2YgU1ZHIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FsbG93ZWQgYnkgZGVmYXVsdC5cbiAgLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4gIC8vIGNoZWNrcyBwcm9wZXJseSBpbiBjYXNlIG9uZSB3YW50cyB0byBhZGQgdGhlbSB0b1xuICAvLyBhbGxvdy1saXN0LlxuICB2YXIgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ2FuaW1hdGUnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGlzY2FyZCcsICdmZWRyb3BzaGFkb3cnLCAnZmVpbWFnZScsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJywgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbm9iamVjdCcsICdoYXRjaCcsICdoYXRjaHBhdGgnLCAnbWVzaCcsICdtZXNoZ3JhZGllbnQnLCAnbWVzaHBhdGNoJywgJ21lc2hyb3cnLCAnbWlzc2luZy1nbHlwaCcsICdzY3JpcHQnLCAnc2V0JywgJ3NvbGlkY29sb3InLCAndW5rbm93bicsICd1c2UnXSk7XG5cbiAgdmFyIG1hdGhNbCA9IGZyZWV6ZShbJ21hdGgnLCAnbWVuY2xvc2UnLCAnbWVycm9yJywgJ21mZW5jZWQnLCAnbWZyYWMnLCAnbWdseXBoJywgJ21pJywgJ21sYWJlbGVkdHInLCAnbW11bHRpc2NyaXB0cycsICdtbicsICdtbycsICdtb3ZlcicsICdtcGFkZGVkJywgJ21waGFudG9tJywgJ21yb290JywgJ21yb3cnLCAnbXMnLCAnbXNwYWNlJywgJ21zcXJ0JywgJ21zdHlsZScsICdtc3ViJywgJ21zdXAnLCAnbXN1YnN1cCcsICdtdGFibGUnLCAnbXRkJywgJ210ZXh0JywgJ210cicsICdtdW5kZXInLCAnbXVuZGVyb3ZlciddKTtcblxuICAvLyBTaW1pbGFybHkgdG8gU1ZHLCB3ZSB3YW50IHRvIGtub3cgYWxsIE1hdGhNTCBlbGVtZW50cyxcbiAgLy8gZXZlbiB0aG9zZSB0aGF0IHdlIGRpc2FsbG93IGJ5IGRlZmF1bHQuXG4gIHZhciBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFsnbWFjdGlvbicsICdtYWxpZ25ncm91cCcsICdtYWxpZ25tYXJrJywgJ21sb25nZGl2JywgJ21zY2FycmllcycsICdtc2NhcnJ5JywgJ21zZ3JvdXAnLCAnbXN0YWNrJywgJ21zbGluZScsICdtc3JvdycsICdzZW1hbnRpY3MnLCAnYW5ub3RhdGlvbicsICdhbm5vdGF0aW9uLXhtbCcsICdtcHJlc2NyaXB0cycsICdub25lJ10pO1xuXG4gIHZhciB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbiAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5cbiAgdmFyIHN2ZyQxID0gZnJlZXplKFsnYWNjZW50LWhlaWdodCcsICdhY2N1bXVsYXRlJywgJ2FkZGl0aXZlJywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdrJywgJ2sxJywgJ2syJywgJ2szJywgJ2s0JywgJ2tlcm5pbmcnLCAna2V5cG9pbnRzJywgJ2tleXNwbGluZXMnLCAna2V5dGltZXMnLCAnbGFuZycsICdsZW5ndGhhZGp1c3QnLCAnbGV0dGVyLXNwYWNpbmcnLCAna2VybmVsbWF0cml4JywgJ2tlcm5lbHVuaXRsZW5ndGgnLCAnbGlnaHRpbmctY29sb3InLCAnbG9jYWwnLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdtYXJrZXJoZWlnaHQnLCAnbWFya2VydW5pdHMnLCAnbWFya2Vyd2lkdGgnLCAnbWFza2NvbnRlbnR1bml0cycsICdtYXNrdW5pdHMnLCAnbWF4JywgJ21hc2snLCAnbWVkaWEnLCAnbWV0aG9kJywgJ21vZGUnLCAnbWluJywgJ25hbWUnLCAnbnVtb2N0YXZlcycsICdvZmZzZXQnLCAnb3BlcmF0b3InLCAnb3BhY2l0eScsICdvcmRlcicsICdvcmllbnQnLCAnb3JpZW50YXRpb24nLCAnb3JpZ2luJywgJ292ZXJmbG93JywgJ3BhaW50LW9yZGVyJywgJ3BhdGgnLCAncGF0aGxlbmd0aCcsICdwYXR0ZXJuY29udGVudHVuaXRzJywgJ3BhdHRlcm50cmFuc2Zvcm0nLCAncGF0dGVybnVuaXRzJywgJ3BvaW50cycsICdwcmVzZXJ2ZWFscGhhJywgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nLCAncHJpbWl0aXZldW5pdHMnLCAncicsICdyeCcsICdyeScsICdyYWRpdXMnLCAncmVmeCcsICdyZWZ5JywgJ3JlcGVhdGNvdW50JywgJ3JlcGVhdGR1cicsICdyZXN0YXJ0JywgJ3Jlc3VsdCcsICdyb3RhdGUnLCAnc2NhbGUnLCAnc2VlZCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3BlY3VsYXJjb25zdGFudCcsICdzcGVjdWxhcmV4cG9uZW50JywgJ3NwcmVhZG1ldGhvZCcsICdzdGFydG9mZnNldCcsICdzdGRkZXZpYXRpb24nLCAnc3RpdGNodGlsZXMnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlJywgJ3N0cm9rZS13aWR0aCcsICdzdHlsZScsICdzdXJmYWNlc2NhbGUnLCAnc3lzdGVtbGFuZ3VhZ2UnLCAndGFiaW5kZXgnLCAndGFyZ2V0eCcsICd0YXJnZXR5JywgJ3RyYW5zZm9ybScsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndGV4dGxlbmd0aCcsICd0eXBlJywgJ3UxJywgJ3UyJywgJ3VuaWNvZGUnLCAndmFsdWVzJywgJ3ZpZXdib3gnLCAndmlzaWJpbGl0eScsICd2ZXJzaW9uJywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dpZHRoJywgJ3dvcmQtc3BhY2luZycsICd3cmFwJywgJ3dyaXRpbmctbW9kZScsICd4Y2hhbm5lbHNlbGVjdG9yJywgJ3ljaGFubmVsc2VsZWN0b3InLCAneCcsICd4MScsICd4MicsICd4bWxucycsICd5JywgJ3kxJywgJ3kyJywgJ3onLCAnem9vbWFuZHBhbiddKTtcblxuICB2YXIgbWF0aE1sJDEgPSBmcmVlemUoWydhY2NlbnQnLCAnYWNjZW50dW5kZXInLCAnYWxpZ24nLCAnYmV2ZWxsZWQnLCAnY2xvc2UnLCAnY29sdW1uc2FsaWduJywgJ2NvbHVtbmxpbmVzJywgJ2NvbHVtbnNwYW4nLCAnZGVub21hbGlnbicsICdkZXB0aCcsICdkaXInLCAnZGlzcGxheScsICdkaXNwbGF5c3R5bGUnLCAnZW5jb2RpbmcnLCAnZmVuY2UnLCAnZnJhbWUnLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnbGFyZ2VvcCcsICdsZW5ndGgnLCAnbGluZXRoaWNrbmVzcycsICdsc3BhY2UnLCAnbHF1b3RlJywgJ21hdGhiYWNrZ3JvdW5kJywgJ21hdGhjb2xvcicsICdtYXRoc2l6ZScsICdtYXRodmFyaWFudCcsICdtYXhzaXplJywgJ21pbnNpemUnLCAnbW92YWJsZWxpbWl0cycsICdub3RhdGlvbicsICdudW1hbGlnbicsICdvcGVuJywgJ3Jvd2FsaWduJywgJ3Jvd2xpbmVzJywgJ3Jvd3NwYWNpbmcnLCAncm93c3BhbicsICdyc3BhY2UnLCAncnF1b3RlJywgJ3NjcmlwdGxldmVsJywgJ3NjcmlwdG1pbnNpemUnLCAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnc2VsZWN0aW9uJywgJ3NlcGFyYXRvcicsICdzZXBhcmF0b3JzJywgJ3N0cmV0Y2h5JywgJ3N1YnNjcmlwdHNoaWZ0JywgJ3N1cHNjcmlwdHNoaWZ0JywgJ3N5bW1ldHJpYycsICd2b2Zmc2V0JywgJ3dpZHRoJywgJ3htbG5zJ10pO1xuXG4gIHZhciB4bWwgPSBmcmVlemUoWyd4bGluazpocmVmJywgJ3htbDppZCcsICd4bGluazp0aXRsZScsICd4bWw6c3BhY2UnLCAneG1sbnM6eGxpbmsnXSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG4gIHZhciBNVVNUQUNIRV9FWFBSID0gc2VhbCgvXFx7XFx7W1xcc1xcU10qfFtcXHNcXFNdKlxcfVxcfS9nbSk7IC8vIFNwZWNpZnkgdGVtcGxhdGUgZGV0ZWN0aW9uIHJlZ2V4IGZvciBTQUZFX0ZPUl9URU1QTEFURVMgbW9kZVxuICB2YXIgRVJCX0VYUFIgPSBzZWFsKC88JVtcXHNcXFNdKnxbXFxzXFxTXSolPi9nbSk7XG4gIHZhciBEQVRBX0FUVFIgPSBzZWFsKC9eZGF0YS1bXFwtXFx3LlxcdTAwQjctXFx1RkZGRl0vKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICB2YXIgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1xcLVxcd10rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gIHZhciBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98Y2lkfHhtcHApOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2kgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICApO1xuICB2YXIgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XFx3K3NjcmlwdHxkYXRhKTovaSk7XG4gIHZhciBBVFRSX1dISVRFU1BBQ0UgPSBzZWFsKC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1RlxcdTMwMDBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICk7XG5cbiAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheSQxKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbiAgdmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICogRG9uJ3QgZXhwb3J0IHRoaXMgZnVuY3Rpb24gb3V0c2lkZSB0aGlzIG1vZHVsZSFcbiAgICogQHBhcmFtIHs/VHJ1c3RlZFR5cGVQb2xpY3lGYWN0b3J5fSB0cnVzdGVkVHlwZXMgVGhlIHBvbGljeSBmYWN0b3J5LlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgb2JqZWN0ICh0byBkZXRlcm1pbmUgcG9saWN5IG5hbWUgc3VmZml4KVxuICAgKiBAcmV0dXJuIHs/VHJ1c3RlZFR5cGVQb2xpY3l9IFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICAgKiBhcmUgbm90IHN1cHBvcnRlZCkuXG4gICAqL1xuICB2YXIgX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSA9IGZ1bmN0aW9uIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kodHJ1c3RlZFR5cGVzLCBkb2N1bWVudCkge1xuICAgIGlmICgodHlwZW9mIHRydXN0ZWRUeXBlcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodHJ1c3RlZFR5cGVzKSkgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyB0aGUgY2FsbGVycyB0byBjb250cm9sIHRoZSB1bmlxdWUgcG9saWN5IG5hbWVcbiAgICAvLyBieSBhZGRpbmcgYSBkYXRhLXR0LXBvbGljeS1zdWZmaXggdG8gdGhlIHNjcmlwdCBlbGVtZW50IHdpdGggdGhlIERPTVB1cmlmeS5cbiAgICAvLyBQb2xpY3kgY3JlYXRpb24gd2l0aCBkdXBsaWNhdGUgbmFtZXMgdGhyb3dzIGluIFRydXN0ZWQgVHlwZXMuXG4gICAgdmFyIHN1ZmZpeCA9IG51bGw7XG4gICAgdmFyIEFUVFJfTkFNRSA9ICdkYXRhLXR0LXBvbGljeS1zdWZmaXgnO1xuICAgIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpIHtcbiAgICAgIHN1ZmZpeCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSk7XG4gICAgfVxuXG4gICAgdmFyIHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgICBjcmVhdGVIVE1MOiBmdW5jdGlvbiBjcmVhdGVIVE1MKGh0bWwkJDEpIHtcbiAgICAgICAgICByZXR1cm4gaHRtbCQkMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gUG9saWN5IGNyZWF0aW9uIGZhaWxlZCAobW9zdCBsaWtlbHkgYW5vdGhlciBET01QdXJpZnkgc2NyaXB0IGhhc1xuICAgICAgLy8gYWxyZWFkeSBydW4pLiBTa2lwIGNyZWF0aW5nIHRoZSBwb2xpY3ksIGFzIHRoaXMgd2lsbCBvbmx5IGNhdXNlIGVycm9yc1xuICAgICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgICAgY29uc29sZS53YXJuKCdUcnVzdGVkVHlwZXMgcG9saWN5ICcgKyBwb2xpY3lOYW1lICsgJyBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVET01QdXJpZnkoKSB7XG4gICAgdmFyIHdpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZ2V0R2xvYmFsKCk7XG5cbiAgICB2YXIgRE9NUHVyaWZ5ID0gZnVuY3Rpb24gRE9NUHVyaWZ5KHJvb3QpIHtcbiAgICAgIHJldHVybiBjcmVhdGVET01QdXJpZnkocm9vdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFZlcnNpb24gbGFiZWwsIGV4cG9zZWQgZm9yIGVhc2llciBjaGVja3NcbiAgICAgKiBpZiBET01QdXJpZnkgaXMgdXAgdG8gZGF0ZSBvciBub3RcbiAgICAgKi9cbiAgICBET01QdXJpZnkudmVyc2lvbiA9ICcyLjMuMyc7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBlbGVtZW50cyB0aGF0IERPTVB1cmlmeSByZW1vdmVkIGR1cmluZyBzYW5pdGF0aW9uLlxuICAgICAqIEVtcHR5IGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZWQgPSBbXTtcblxuICAgIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSA5KSB7XG4gICAgICAvLyBOb3QgcnVubmluZyBpbiBhIGJyb3dzZXIsIHByb3ZpZGUgYSBmYWN0b3J5IGZ1bmN0aW9uXG4gICAgICAvLyBzbyB0aGF0IHlvdSBjYW4gcGFzcyB5b3VyIG93biBXaW5kb3dcbiAgICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICAgIH1cblxuICAgIHZhciBvcmlnaW5hbERvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG4gICAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICAgIHZhciBEb2N1bWVudEZyYWdtZW50ID0gd2luZG93LkRvY3VtZW50RnJhZ21lbnQsXG4gICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPSB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAgICAgICAgTm9kZSA9IHdpbmRvdy5Ob2RlLFxuICAgICAgICBFbGVtZW50ID0gd2luZG93LkVsZW1lbnQsXG4gICAgICAgIE5vZGVGaWx0ZXIgPSB3aW5kb3cuTm9kZUZpbHRlcixcbiAgICAgICAgX3dpbmRvdyROYW1lZE5vZGVNYXAgPSB3aW5kb3cuTmFtZWROb2RlTWFwLFxuICAgICAgICBOYW1lZE5vZGVNYXAgPSBfd2luZG93JE5hbWVkTm9kZU1hcCA9PT0gdW5kZWZpbmVkID8gd2luZG93Lk5hbWVkTm9kZU1hcCB8fCB3aW5kb3cuTW96TmFtZWRBdHRyTWFwIDogX3dpbmRvdyROYW1lZE5vZGVNYXAsXG4gICAgICAgIFRleHQgPSB3aW5kb3cuVGV4dCxcbiAgICAgICAgQ29tbWVudCA9IHdpbmRvdy5Db21tZW50LFxuICAgICAgICBET01QYXJzZXIgPSB3aW5kb3cuRE9NUGFyc2VyLFxuICAgICAgICB0cnVzdGVkVHlwZXMgPSB3aW5kb3cudHJ1c3RlZFR5cGVzO1xuXG5cbiAgICB2YXIgRWxlbWVudFByb3RvdHlwZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4gICAgdmFyIGNsb25lTm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2xvbmVOb2RlJyk7XG4gICAgdmFyIGdldE5leHRTaWJsaW5nID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICduZXh0U2libGluZycpO1xuICAgIHZhciBnZXRDaGlsZE5vZGVzID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjaGlsZE5vZGVzJyk7XG4gICAgdmFyIGdldFBhcmVudE5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ3BhcmVudE5vZGUnKTtcblxuICAgIC8vIEFzIHBlciBpc3N1ZSAjNDcsIHRoZSB3ZWItY29tcG9uZW50cyByZWdpc3RyeSBpcyBpbmhlcml0ZWQgYnkgYVxuICAgIC8vIG5ldyBkb2N1bWVudCBjcmVhdGVkIHZpYSBjcmVhdGVIVE1MRG9jdW1lbnQuIEFzIHBlciB0aGUgc3BlY1xuICAgIC8vIChodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjcmVhdGluZy1hbmQtcGFzc2luZy1yZWdpc3RyaWVzKVxuICAgIC8vIGEgbmV3IGVtcHR5IHJlZ2lzdHJ5IGlzIHVzZWQgd2hlbiBjcmVhdGluZyBhIHRlbXBsYXRlIGNvbnRlbnRzIG93bmVyXG4gICAgLy8gZG9jdW1lbnQsIHNvIHdlIHVzZSB0aGF0IGFzIG91ciBwYXJlbnQgZG9jdW1lbnQgdG8gZW5zdXJlIG5vdGhpbmdcbiAgICAvLyBpcyBpbmhlcml0ZWQuXG4gICAgaWYgKHR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgaWYgKHRlbXBsYXRlLmNvbnRlbnQgJiYgdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgb3JpZ2luYWxEb2N1bWVudCk7XG4gICAgdmFyIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpIDogJyc7XG5cbiAgICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQsXG4gICAgICAgIGltcGxlbWVudGF0aW9uID0gX2RvY3VtZW50LmltcGxlbWVudGF0aW9uLFxuICAgICAgICBjcmVhdGVOb2RlSXRlcmF0b3IgPSBfZG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG4gICAgICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuICAgIHZhciBpbXBvcnROb2RlID0gb3JpZ2luYWxEb2N1bWVudC5pbXBvcnROb2RlO1xuXG5cbiAgICB2YXIgZG9jdW1lbnRNb2RlID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50TW9kZSA9IGNsb25lKGRvY3VtZW50KS5kb2N1bWVudE1vZGUgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiB7fTtcbiAgICB9IGNhdGNoIChfKSB7fVxuXG4gICAgdmFyIGhvb2tzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2Ugd2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcnVubmluZyB0aGUgZnVsbCBET01QdXJpZnkuXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LmlzU3VwcG9ydGVkID0gdHlwZW9mIGdldFBhcmVudE5vZGUgPT09ICdmdW5jdGlvbicgJiYgaW1wbGVtZW50YXRpb24gJiYgdHlwZW9mIGltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRNb2RlICE9PSA5O1xuXG4gICAgdmFyIE1VU1RBQ0hFX0VYUFIkJDEgPSBNVVNUQUNIRV9FWFBSLFxuICAgICAgICBFUkJfRVhQUiQkMSA9IEVSQl9FWFBSLFxuICAgICAgICBEQVRBX0FUVFIkJDEgPSBEQVRBX0FUVFIsXG4gICAgICAgIEFSSUFfQVRUUiQkMSA9IEFSSUFfQVRUUixcbiAgICAgICAgSVNfU0NSSVBUX09SX0RBVEEkJDEgPSBJU19TQ1JJUFRfT1JfREFUQSxcbiAgICAgICAgQVRUUl9XSElURVNQQUNFJCQxID0gQVRUUl9XSElURVNQQUNFO1xuICAgIHZhciBJU19BTExPV0VEX1VSSSQkMSA9IElTX0FMTE9XRURfVVJJO1xuXG4gICAgLyoqXG4gICAgICogV2UgY29uc2lkZXIgdGhlIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGJlbG93IHRvIGJlIHNhZmUuIElkZWFsbHlcbiAgICAgKiBkb24ndCBhZGQgYW55IG5ldyBvbmVzIGJ1dCBmZWVsIGZyZWUgdG8gcmVtb3ZlIHVud2FudGVkIG9uZXMuXG4gICAgICovXG5cbiAgICAvKiBhbGxvd2VkIGVsZW1lbnQgbmFtZXMgKi9cblxuICAgIHZhciBBTExPV0VEX1RBR1MgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEoaHRtbCksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2ZyksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2Z0ZpbHRlcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShtYXRoTWwpLCBfdG9Db25zdW1hYmxlQXJyYXkkMSh0ZXh0KSkpO1xuXG4gICAgLyogQWxsb3dlZCBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgICB2YXIgQUxMT1dFRF9BVFRSID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9BTExPV0VEX0FUVFIgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKGh0bWwkMSksIF90b0NvbnN1bWFibGVBcnJheSQxKHN2ZyQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEobWF0aE1sJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMSh4bWwpKSk7XG5cbiAgICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiB0YWdzIChvdmVycmlkZXMgQUxMT1dFRF9UQUdTL0FERF9UQUdTKSAqL1xuICAgIHZhciBGT1JCSURfVEFHUyA9IG51bGw7XG5cbiAgICAvKiBFeHBsaWNpdGx5IGZvcmJpZGRlbiBhdHRyaWJ1dGVzIChvdmVycmlkZXMgQUxMT1dFRF9BVFRSL0FERF9BVFRSKSAqL1xuICAgIHZhciBGT1JCSURfQVRUUiA9IG51bGw7XG5cbiAgICAvKiBEZWNpZGUgaWYgQVJJQSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gICAgdmFyIEFMTE9XX0FSSUFfQVRUUiA9IHRydWU7XG5cbiAgICAvKiBEZWNpZGUgaWYgY3VzdG9tIGRhdGEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICAgIHZhciBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuXG4gICAgLyogRGVjaWRlIGlmIHVua25vd24gcHJvdG9jb2xzIGFyZSBva2F5ICovXG4gICAgdmFyIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gZmFsc2U7XG5cbiAgICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGNvbW1vbiB0ZW1wbGF0ZSBlbmdpbmVzLlxuICAgICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGRhdGEgYXR0cmlidXRlcywgbXVzdGFjaGVzIGFuZCBFUkJcbiAgICAgKi9cbiAgICB2YXIgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG5cbiAgICAvKiBEZWNpZGUgaWYgZG9jdW1lbnQgd2l0aCA8aHRtbD4uLi4gc2hvdWxkIGJlIHJldHVybmVkICovXG4gICAgdmFyIFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG5cbiAgICAvKiBUcmFjayB3aGV0aGVyIGNvbmZpZyBpcyBhbHJlYWR5IHNldCBvbiB0aGlzIGluc3RhbmNlIG9mIERPTVB1cmlmeS4gKi9cbiAgICB2YXIgU0VUX0NPTkZJRyA9IGZhbHNlO1xuXG4gICAgLyogRGVjaWRlIGlmIGFsbCBlbGVtZW50cyAoZS5nLiBzdHlsZSwgc2NyaXB0KSBtdXN0IGJlIGNoaWxkcmVuIG9mXG4gICAgICogZG9jdW1lbnQuYm9keS4gQnkgZGVmYXVsdCwgYnJvd3NlcnMgbWlnaHQgbW92ZSB0aGVtIHRvIGRvY3VtZW50LmhlYWQgKi9cbiAgICB2YXIgRk9SQ0VfQk9EWSA9IGZhbHNlO1xuXG4gICAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICAgKiBzdHJpbmcgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkuXG4gICAgICogSWYgYFdIT0xFX0RPQ1VNRU5UYCBpcyBlbmFibGVkIGEgYEhUTUxIdG1sRWxlbWVudGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkXG4gICAgICovXG4gICAgdmFyIFJFVFVSTl9ET00gPSBmYWxzZTtcblxuICAgIC8qIERlY2lkZSBpZiBhIERPTSBgRG9jdW1lbnRGcmFnbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgICAqIHN0cmluZyAgKG9yIGEgVHJ1c3RlZEhUTUwgb2JqZWN0IGlmIFRydXN0ZWQgVHlwZXMgYXJlIHN1cHBvcnRlZCkgKi9cbiAgICB2YXIgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGZhbHNlO1xuXG4gICAgLyogSWYgYFJFVFVSTl9ET01gIG9yIGBSRVRVUk5fRE9NX0ZSQUdNRU5UYCBpcyBlbmFibGVkLCBkZWNpZGUgaWYgdGhlIHJldHVybmVkIERPTVxuICAgICAqIGBOb2RlYCBpcyBpbXBvcnRlZCBpbnRvIHRoZSBjdXJyZW50IGBEb2N1bWVudGAuIElmIHRoaXMgZmxhZyBpcyBub3QgZW5hYmxlZCB0aGVcbiAgICAgKiBgTm9kZWAgd2lsbCBiZWxvbmcgKGl0cyBvd25lckRvY3VtZW50KSB0byBhIGZyZXNoIGBIVE1MRG9jdW1lbnRgLCBjcmVhdGVkIGJ5XG4gICAgICogRE9NUHVyaWZ5LlxuICAgICAqXG4gICAgICogVGhpcyBkZWZhdWx0cyB0byBgdHJ1ZWAgc3RhcnRpbmcgRE9NUHVyaWZ5IDIuMi4wLiBOb3RlIHRoYXQgc2V0dGluZyBpdCB0byBgZmFsc2VgXG4gICAgICogbWlnaHQgY2F1c2UgWFNTIGZyb20gYXR0YWNrcyBoaWRkZW4gaW4gY2xvc2VkIHNoYWRvd3Jvb3RzIGluIGNhc2UgdGhlIGJyb3dzZXJcbiAgICAgKiBzdXBwb3J0cyBEZWNsYXJhdGl2ZSBTaGFkb3c6IERPTSBodHRwczovL3dlYi5kZXYvZGVjbGFyYXRpdmUtc2hhZG93LWRvbS9cbiAgICAgKi9cbiAgICB2YXIgUkVUVVJOX0RPTV9JTVBPUlQgPSB0cnVlO1xuXG4gICAgLyogVHJ5IHRvIHJldHVybiBhIFRydXN0ZWQgVHlwZSBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZywgcmV0dXJuIGEgc3RyaW5nIGluXG4gICAgICogY2FzZSBUcnVzdGVkIFR5cGVzIGFyZSBub3Qgc3VwcG9ydGVkICAqL1xuICAgIHZhciBSRVRVUk5fVFJVU1RFRF9UWVBFID0gZmFsc2U7XG5cbiAgICAvKiBPdXRwdXQgc2hvdWxkIGJlIGZyZWUgZnJvbSBET00gY2xvYmJlcmluZyBhdHRhY2tzPyAqL1xuICAgIHZhciBTQU5JVElaRV9ET00gPSB0cnVlO1xuXG4gICAgLyogS2VlcCBlbGVtZW50IGNvbnRlbnQgd2hlbiByZW1vdmluZyBlbGVtZW50PyAqL1xuICAgIHZhciBLRUVQX0NPTlRFTlQgPSB0cnVlO1xuXG4gICAgLyogSWYgYSBgTm9kZWAgaXMgcGFzc2VkIHRvIHNhbml0aXplKCksIHRoZW4gcGVyZm9ybXMgc2FuaXRpemF0aW9uIGluLXBsYWNlIGluc3RlYWRcbiAgICAgKiBvZiBpbXBvcnRpbmcgaXQgaW50byBhIG5ldyBEb2N1bWVudCBhbmQgcmV0dXJuaW5nIGEgc2FuaXRpemVkIGNvcHkgKi9cbiAgICB2YXIgSU5fUExBQ0UgPSBmYWxzZTtcblxuICAgIC8qIEFsbG93IHVzYWdlIG9mIHByb2ZpbGVzIGxpa2UgaHRtbCwgc3ZnIGFuZCBtYXRoTWwgKi9cbiAgICB2YXIgVVNFX1BST0ZJTEVTID0ge307XG5cbiAgICAvKiBUYWdzIHRvIGlnbm9yZSBjb250ZW50IG9mIHdoZW4gS0VFUF9DT05URU5UIGlzIHRydWUgKi9cbiAgICB2YXIgRk9SQklEX0NPTlRFTlRTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9GT1JCSURfQ09OVEVOVFMgPSBhZGRUb1NldCh7fSwgWydhbm5vdGF0aW9uLXhtbCcsICdhdWRpbycsICdjb2xncm91cCcsICdkZXNjJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGVhZCcsICdpZnJhbWUnLCAnbWF0aCcsICdtaScsICdtbicsICdtbycsICdtcycsICdtdGV4dCcsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ3BsYWludGV4dCcsICdzY3JpcHQnLCAnc3R5bGUnLCAnc3ZnJywgJ3RlbXBsYXRlJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3ZpZGVvJywgJ3htcCddKTtcblxuICAgIC8qIFRhZ3MgdGhhdCBhcmUgc2FmZSBmb3IgZGF0YTogVVJJcyAqL1xuICAgIHZhciBEQVRBX1VSSV9UQUdTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9EQVRBX1VSSV9UQUdTID0gYWRkVG9TZXQoe30sIFsnYXVkaW8nLCAndmlkZW8nLCAnaW1nJywgJ3NvdXJjZScsICdpbWFnZScsICd0cmFjayddKTtcblxuICAgIC8qIEF0dHJpYnV0ZXMgc2FmZSBmb3IgdmFsdWVzIGxpa2UgXCJqYXZhc2NyaXB0OlwiICovXG4gICAgdmFyIFVSSV9TQUZFX0FUVFJJQlVURVMgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMgPSBhZGRUb1NldCh7fSwgWydhbHQnLCAnY2xhc3MnLCAnZm9yJywgJ2lkJywgJ2xhYmVsJywgJ25hbWUnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdyb2xlJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG5cbiAgICB2YXIgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgICB2YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuICAgIC8qIERvY3VtZW50IG5hbWVzcGFjZSAqL1xuICAgIHZhciBOQU1FU1BBQ0UgPSBIVE1MX05BTUVTUEFDRTtcbiAgICB2YXIgSVNfRU1QVFlfSU5QVVQgPSBmYWxzZTtcblxuICAgIC8qIFBhcnNpbmcgb2Ygc3RyaWN0IFhIVE1MIGRvY3VtZW50cyAqL1xuICAgIHZhciBQQVJTRVJfTUVESUFfVFlQRSA9IHZvaWQgMDtcbiAgICB2YXIgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyA9IFsnYXBwbGljYXRpb24veGh0bWwreG1sJywgJ3RleHQvaHRtbCddO1xuICAgIHZhciBERUZBVUxUX1BBUlNFUl9NRURJQV9UWVBFID0gJ3RleHQvaHRtbCc7XG4gICAgdmFyIHRyYW5zZm9ybUNhc2VGdW5jID0gdm9pZCAwO1xuXG4gICAgLyogS2VlcCBhIHJlZmVyZW5jZSB0byBjb25maWcgdG8gcGFzcyB0byBob29rcyAqL1xuICAgIHZhciBDT05GSUcgPSBudWxsO1xuXG4gICAgLyogSWRlYWxseSwgZG8gbm90IHRvdWNoIGFueXRoaW5nIGJlbG93IHRoaXMgbGluZSAqL1xuICAgIC8qIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18gKi9cblxuICAgIHZhciBmb3JtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcblxuICAgIC8qKlxuICAgICAqIF9wYXJzZUNvbmZpZ1xuICAgICAqXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjZmcgb3B0aW9uYWwgY29uZmlnIGxpdGVyYWxcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIHZhciBfcGFyc2VDb25maWcgPSBmdW5jdGlvbiBfcGFyc2VDb25maWcoY2ZnKSB7XG4gICAgICBpZiAoQ09ORklHICYmIENPTkZJRyA9PT0gY2ZnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gdGFtcGVyaW5nICovXG4gICAgICBpZiAoIWNmZyB8fCAodHlwZW9mIGNmZyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY2ZnKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNmZyA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSBwcm90b3R5cGUgcG9sbHV0aW9uICovXG4gICAgICBjZmcgPSBjbG9uZShjZmcpO1xuXG4gICAgICAvKiBTZXQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgICBBTExPV0VEX1RBR1MgPSAnQUxMT1dFRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkFMTE9XRURfVEFHUykgOiBERUZBVUxUX0FMTE9XRURfVEFHUztcbiAgICAgIEFMTE9XRURfQVRUUiA9ICdBTExPV0VEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSKSA6IERFRkFVTFRfQUxMT1dFRF9BVFRSO1xuICAgICAgVVJJX1NBRkVfQVRUUklCVVRFUyA9ICdBRERfVVJJX1NBRkVfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTKSwgY2ZnLkFERF9VUklfU0FGRV9BVFRSKSA6IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUztcbiAgICAgIERBVEFfVVJJX1RBR1MgPSAnQUREX0RBVEFfVVJJX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfREFUQV9VUklfVEFHUyksIGNmZy5BRERfREFUQV9VUklfVEFHUykgOiBERUZBVUxUX0RBVEFfVVJJX1RBR1M7XG4gICAgICBGT1JCSURfQ09OVEVOVFMgPSAnRk9SQklEX0NPTlRFTlRTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUykgOiBERUZBVUxUX0ZPUkJJRF9DT05URU5UUztcbiAgICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTKSA6IHt9O1xuICAgICAgRk9SQklEX0FUVFIgPSAnRk9SQklEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIpIDoge307XG4gICAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGNmZy5SRVRVUk5fRE9NX0ZSQUdNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBSRVRVUk5fRE9NX0lNUE9SVCA9IGNmZy5SRVRVUk5fRE9NX0lNUE9SVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBJU19BTExPV0VEX1VSSSQkMSA9IGNmZy5BTExPV0VEX1VSSV9SRUdFWFAgfHwgSVNfQUxMT1dFRF9VUkkkJDE7XG4gICAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuXG4gICAgICBQQVJTRVJfTUVESUFfVFlQRSA9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9wcmVmZXItaW5jbHVkZXNcbiAgICAgIFNVUFBPUlRFRF9QQVJTRVJfTUVESUFfVFlQRVMuaW5kZXhPZihjZmcuUEFSU0VSX01FRElBX1RZUEUpID09PSAtMSA/IFBBUlNFUl9NRURJQV9UWVBFID0gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IFBBUlNFUl9NRURJQV9UWVBFID0gY2ZnLlBBUlNFUl9NRURJQV9UWVBFO1xuXG4gICAgICAvLyBIVE1MIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgYXJlIG5vdCBjYXNlLXNlbnNpdGl2ZSwgY29udmVydGluZyB0byBsb3dlcmNhc2UuIEtlZXBpbmcgWEhUTUwgYXMgaXMuXG4gICAgICB0cmFuc2Zvcm1DYXNlRnVuYyA9IFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcbiAgICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBodG1sJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmcgPT09IHRydWUpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Zyk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmckMSk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogTWVyZ2UgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUoQUxMT1dFRF9UQUdTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZmcuQUREX1VSSV9TQUZFX0FUVFIpIHtcbiAgICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgaWYgKEZPUkJJRF9DT05URU5UUyA9PT0gREVGQVVMVF9GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgIH1cblxuICAgICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgICBpZiAoS0VFUF9DT05URU5UKSB7XG4gICAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsnaHRtbCcsICdoZWFkJywgJ2JvZHknXSk7XG4gICAgICB9XG5cbiAgICAgIC8qIEFkZCB0Ym9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSB0YWJsZXMgYXJlIHBlcm1pdHRlZCwgc2VlICMyODYsICMzNjUgKi9cbiAgICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgZnVydGhlciBtYW5pcHVsYXRpb24gb2YgY29uZmlndXJhdGlvbi5cbiAgICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICBmcmVlemUoY2ZnKTtcbiAgICAgIH1cblxuICAgICAgQ09ORklHID0gY2ZnO1xuICAgIH07XG5cbiAgICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnbWknLCAnbW8nLCAnbW4nLCAnbXMnLCAnbXRleHQnXSk7XG5cbiAgICB2YXIgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydmb3JlaWdub2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnLCAnYW5ub3RhdGlvbi14bWwnXSk7XG5cbiAgICAvKiBLZWVwIHRyYWNrIG9mIGFsbCBwb3NzaWJsZSBTVkcgYW5kIE1hdGhNTCB0YWdzXG4gICAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgICAqIGNvcnJlY3RseS4gKi9cbiAgICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2Zyk7XG4gICAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0Rpc2FsbG93ZWQpO1xuXG4gICAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwpO1xuICAgIGFkZFRvU2V0KEFMTF9NQVRITUxfVEFHUywgbWF0aE1sRGlzYWxsb3dlZCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCBhIERPTSBlbGVtZW50IHdob3NlIG5hbWVzcGFjZSBpcyBiZWluZyBjaGVja2VkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYVxuICAgICAqICBuYW1lc3BhY2UgdGhhdCBhIHNwZWMtY29tcGxpYW50IHBhcnNlciB3b3VsZCBuZXZlclxuICAgICAqICByZXR1cm4uIFJldHVybiB0cnVlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB2YXIgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZShlbGVtZW50KSB7XG4gICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICAgICAgLy8gSW4gSlNET00sIGlmIHdlJ3JlIGluc2lkZSBzaGFkb3cgRE9NLCB0aGVuIHBhcmVudE5vZGVcbiAgICAgIC8vIGNhbiBiZSBudWxsLiBXZSBqdXN0IHNpbXVsYXRlIHBhcmVudCBpbiB0aGlzIGNhc2UuXG4gICAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50LnRhZ05hbWUpIHtcbiAgICAgICAgcGFyZW50ID0ge1xuICAgICAgICAgIG5hbWVzcGFjZVVSSTogSFRNTF9OQU1FU1BBQ0UsXG4gICAgICAgICAgdGFnTmFtZTogJ3RlbXBsYXRlJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgICB2YXIgcGFyZW50VGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKHBhcmVudC50YWdOYW1lKTtcblxuICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBTVkdcbiAgICAgICAgLy8gaXMgdmlhIDxzdmc+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnc3ZnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBNYXRoTUwgdG8gU1ZHIGlzIHZpYVxuICAgICAgICAvLyBzdmcgaWYgcGFyZW50IGlzIGVpdGhlciA8YW5ub3RhdGlvbi14bWw+IG9yIE1hdGhNTFxuICAgICAgICAvLyB0ZXh0IGludGVncmF0aW9uIHBvaW50cy5cbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ3N2ZycgJiYgKHBhcmVudFRhZ05hbWUgPT09ICdhbm5vdGF0aW9uLXhtbCcgfHwgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBTVkdcbiAgICAgICAgLy8gc3BlYy4gQWxsIG90aGVycyBhcmUgZGlzYWxsb3dlZCBpbiBTVkcgbmFtZXNwYWNlLlxuICAgICAgICByZXR1cm4gQm9vbGVhbihBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIEhUTUwgbmFtZXNwYWNlIHRvIE1hdGhNTFxuICAgICAgICAvLyBpcyB2aWEgPG1hdGg+LiBJZiBpdCBoYXBwZW5zIHZpYSBhbnkgb3RoZXIgdGFnLCB0aGVuXG4gICAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIE1hdGhNTCBpcyB2aWFcbiAgICAgICAgLy8gPG1hdGg+IGFuZCBIVE1MIGludGVncmF0aW9uIHBvaW50c1xuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnbWF0aCcgJiYgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gTWF0aE1MXG4gICAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gTWF0aE1MIG5hbWVzcGFjZS5cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gU1ZHIHRvIEhUTUwgaXMgdmlhXG4gICAgICAgIC8vIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzLCBhbmQgZnJvbSBNYXRoTUwgdG8gSFRNTFxuICAgICAgICAvLyBpcyB2aWEgTWF0aE1MIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFICYmICFIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGFyZSBhbGxvd2VkIGluIGJvdGggU1ZHIGFuZCBIVE1MXG4gICAgICAgIC8vIG5hbWVzcGFjZS4gV2UgbmVlZCB0byBzcGVjaWZ5IHRoZW0gZXhwbGljaXRseVxuICAgICAgICAvLyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGVycm9ub3VzbHkgZGVsZXRlZCBmcm9tXG4gICAgICAgIC8vIEhUTUwgbmFtZXNwYWNlLlxuICAgICAgICB2YXIgY29tbW9uU3ZnQW5kSFRNTEVsZW1lbnRzID0gYWRkVG9TZXQoe30sIFsndGl0bGUnLCAnc3R5bGUnLCAnZm9udCcsICdhJywgJ3NjcmlwdCddKTtcblxuICAgICAgICAvLyBXZSBkaXNhbGxvdyB0YWdzIHRoYXQgYXJlIHNwZWNpZmljIGZvciBNYXRoTUxcbiAgICAgICAgLy8gb3IgU1ZHIGFuZCBzaG91bGQgbmV2ZXIgYXBwZWFyIGluIEhUTUwgbmFtZXNwYWNlXG4gICAgICAgIHJldHVybiAhQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdICYmIChjb21tb25TdmdBbmRIVE1MRWxlbWVudHNbdGFnTmFtZV0gfHwgIUFMTF9TVkdfVEFHU1t0YWdOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb2RlIHNob3VsZCBuZXZlciByZWFjaCB0aGlzIHBsYWNlICh0aGlzIG1lYW5zXG4gICAgICAvLyB0aGF0IHRoZSBlbGVtZW50IHNvbWVob3cgZ290IG5hbWVzcGFjZSB0aGF0IGlzIG5vdFxuICAgICAgLy8gSFRNTCwgU1ZHIG9yIE1hdGhNTCkuIFJldHVybiBmYWxzZSBqdXN0IGluIGNhc2UuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9mb3JjZVJlbW92ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gbm9kZSBhIERPTSBub2RlXG4gICAgICovXG4gICAgdmFyIF9mb3JjZVJlbW92ZSA9IGZ1bmN0aW9uIF9mb3JjZVJlbW92ZShub2RlKSB7XG4gICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHsgZWxlbWVudDogbm9kZSB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1yZW1vdmVcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUub3V0ZXJIVE1MID0gZW1wdHlIVE1MO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfcmVtb3ZlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgYW4gQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIGEgRE9NIG5vZGVcbiAgICAgKi9cbiAgICB2YXIgX3JlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgbm9kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgYXR0cmlidXRlOiBub2RlLmdldEF0dHJpYnV0ZU5vZGUobmFtZSksXG4gICAgICAgICAgZnJvbTogbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgICAgYXR0cmlidXRlOiBudWxsLFxuICAgICAgICAgIGZyb206IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICAvLyBXZSB2b2lkIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIHVucmVtb3ZhYmxlIFwiaXNcIlwiIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChuYW1lID09PSAnaXMnICYmICFBTExPV0VEX0FUVFJbbmFtZV0pIHtcbiAgICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfZm9yY2VSZW1vdmUobm9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2luaXREb2N1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJ0eSBhIHN0cmluZyBvZiBkaXJ0eSBtYXJrdXBcbiAgICAgKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICAgKi9cbiAgICB2YXIgX2luaXREb2N1bWVudCA9IGZ1bmN0aW9uIF9pbml0RG9jdW1lbnQoZGlydHkpIHtcbiAgICAgIC8qIENyZWF0ZSBhIEhUTUwgZG9jdW1lbnQgKi9cbiAgICAgIHZhciBkb2MgPSB2b2lkIDA7XG4gICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChGT1JDRV9CT0RZKSB7XG4gICAgICAgIGRpcnR5ID0gJzxyZW1vdmU+PC9yZW1vdmU+JyArIGRpcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSWYgRk9SQ0VfQk9EWSBpc24ndCB1c2VkLCBsZWFkaW5nIHdoaXRlc3BhY2UgbmVlZHMgdG8gYmUgcHJlc2VydmVkIG1hbnVhbGx5ICovXG4gICAgICAgIHZhciBtYXRjaGVzID0gc3RyaW5nTWF0Y2goZGlydHksIC9eW1xcclxcblxcdCBdKy8pO1xuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJykge1xuICAgICAgICAvLyBSb290IG9mIFhIVE1MIGRvYyBtdXN0IGNvbnRhaW4geG1sbnMgZGVjbGFyYXRpb24gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveGh0bWwxL25vcm1hdGl2ZS5odG1sI3N0cmljdClcbiAgICAgICAgZGlydHkgPSAnPGh0bWwgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI+PGhlYWQ+PC9oZWFkPjxib2R5PicgKyBkaXJ0eSArICc8L2JvZHk+PC9odG1sPic7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIC8qXG4gICAgICAgKiBVc2UgdGhlIERPTVBhcnNlciBBUEkgYnkgZGVmYXVsdCwgZmFsbGJhY2sgbGF0ZXIgaWYgbmVlZHMgYmVcbiAgICAgICAqIERPTVBhcnNlciBub3Qgd29yayBmb3Igc3ZnIHdoZW4gaGFzIG11bHRpcGxlIHJvb3QgZWxlbWVudC5cbiAgICAgICAqL1xuICAgICAgaWYgKE5BTUVTUEFDRSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGRpcnR5UGF5bG9hZCwgUEFSU0VSX01FRElBX1RZUEUpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuXG4gICAgICAvKiBVc2UgY3JlYXRlSFRNTERvY3VtZW50IGluIGNhc2UgRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGUgKi9cbiAgICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgIGRvYyA9IGltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KE5BTUVTUEFDRSwgJ3RlbXBsYXRlJywgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/ICcnIDogZGlydHlQYXlsb2FkO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgLy8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxlYWRpbmdXaGl0ZXNwYWNlKSwgYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvKiBXb3JrIG9uIHdob2xlIGRvY3VtZW50IG9yIGp1c3QgaXRzIGJvZHkgKi9cbiAgICAgIGlmIChOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5VGFnTmFtZS5jYWxsKGRvYywgV0hPTEVfRE9DVU1FTlQgPyAnaHRtbCcgOiAnYm9keScpWzBdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gV0hPTEVfRE9DVU1FTlQgPyBkb2MuZG9jdW1lbnRFbGVtZW50IDogYm9keTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2NyZWF0ZUl0ZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtEb2N1bWVudH0gcm9vdCBkb2N1bWVudC9mcmFnbWVudCB0byBjcmVhdGUgaXRlcmF0b3IgZm9yXG4gICAgICogQHJldHVybiB7SXRlcmF0b3J9IGl0ZXJhdG9yIGluc3RhbmNlXG4gICAgICovXG4gICAgdmFyIF9jcmVhdGVJdGVyYXRvciA9IGZ1bmN0aW9uIF9jcmVhdGVJdGVyYXRvcihyb290KSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfaXNDbG9iYmVyZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IGVsbSBlbGVtZW50IHRvIGNoZWNrIGZvciBjbG9iYmVyaW5nIGF0dGFja3NcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNsb2JiZXJlZCwgZmFsc2UgaWYgc2FmZVxuICAgICAqL1xuICAgIHZhciBfaXNDbG9iYmVyZWQgPSBmdW5jdGlvbiBfaXNDbG9iYmVyZWQoZWxtKSB7XG4gICAgICBpZiAoZWxtIGluc3RhbmNlb2YgVGV4dCB8fCBlbG0gaW5zdGFuY2VvZiBDb21tZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlbG0ubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0udGV4dENvbnRlbnQgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQ2hpbGQgIT09ICdmdW5jdGlvbicgfHwgIShlbG0uYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsbS5yZW1vdmVBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5zZXRBdHRyaWJ1dGUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsbS5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbG0uaW5zZXJ0QmVmb3JlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9pc05vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IG9iaiBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCdzIGEgRE9NIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlzIG9iamVjdCBpcyBhIERPTSBub2RlXG4gICAgICovXG4gICAgdmFyIF9pc05vZGUgPSBmdW5jdGlvbiBfaXNOb2RlKG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2YgTm9kZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoTm9kZSkpID09PSAnb2JqZWN0JyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiBvYmplY3QgJiYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9iamVjdCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2V4ZWN1dGVIb29rXG4gICAgICogRXhlY3V0ZSB1c2VyIGNvbmZpZ3VyYWJsZSBob29rc1xuICAgICAqXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBlbnRyeVBvaW50ICBOYW1lIG9mIHRoZSBob29rJ3MgZW50cnkgcG9pbnRcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBjdXJyZW50Tm9kZSBub2RlIHRvIHdvcmsgb24gd2l0aCB0aGUgaG9va1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBhZGRpdGlvbmFsIGhvb2sgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHZhciBfZXhlY3V0ZUhvb2sgPSBmdW5jdGlvbiBfZXhlY3V0ZUhvb2soZW50cnlQb2ludCwgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICAgIGlmICghaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcnJheUZvckVhY2goaG9va3NbZW50cnlQb2ludF0sIGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgIGhvb2suY2FsbChET01QdXJpZnksIGN1cnJlbnROb2RlLCBkYXRhLCBDT05GSUcpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZUVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgICAqIEBwcm90ZWN0IHRleHRDb250ZW50XG4gICAgICogQHByb3RlY3QgcmVtb3ZlQ2hpbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIHtOb2RlfSBjdXJyZW50Tm9kZSB0byBjaGVjayBmb3IgcGVybWlzc2lvbiB0byBleGlzdFxuICAgICAqIEByZXR1cm4gIHtCb29sZWFufSB0cnVlIGlmIG5vZGUgd2FzIGtpbGxlZCwgZmFsc2UgaWYgbGVmdCBhbGl2ZVxuICAgICAqL1xuICAgIHZhciBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgICAvKiBDaGVjayBpZiBlbGVtZW50IGlzIGNsb2JiZXJlZCBvciBjYW4gY2xvYmJlciAqL1xuICAgICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIGlmIHRhZ25hbWUgY29udGFpbnMgVW5pY29kZSAqL1xuICAgICAgaWYgKHN0cmluZ01hdGNoKGN1cnJlbnROb2RlLm5vZGVOYW1lLCAvW1xcdTAwODAtXFx1RkZGRl0vKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogTm93IGxldCdzIGNoZWNrIHRoZSBlbGVtZW50J3MgdHlwZSBhbmQgbmFtZSAqL1xuICAgICAgdmFyIHRhZ05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplRWxlbWVudCcsIGN1cnJlbnROb2RlLCB7XG4gICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgIGFsbG93ZWRUYWdzOiBBTExPV0VEX1RBR1NcbiAgICAgIH0pO1xuXG4gICAgICAvKiBEZXRlY3QgbVhTUyBhdHRlbXB0cyBhYnVzaW5nIG5hbWVzcGFjZSBjb25mdXNpb24gKi9cbiAgICAgIGlmICghX2lzTm9kZShjdXJyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZCkgJiYgKCFfaXNOb2RlKGN1cnJlbnROb2RlLmNvbnRlbnQpIHx8ICFfaXNOb2RlKGN1cnJlbnROb2RlLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQpKSAmJiByZWdFeHBUZXN0KC88Wy9cXHddL2csIGN1cnJlbnROb2RlLmlubmVySFRNTCkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIE1pdGlnYXRlIGEgcHJvYmxlbSB3aXRoIHRlbXBsYXRlcyBpbnNpZGUgc2VsZWN0ICovXG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ3NlbGVjdCcgJiYgcmVnRXhwVGVzdCgvPHRlbXBsYXRlL2ksIGN1cnJlbnROb2RlLmlubmVySFRNTCkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIFJlbW92ZSBlbGVtZW50IGlmIGFueXRoaW5nIGZvcmJpZHMgaXRzIHByZXNlbmNlICovXG4gICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAvKiBLZWVwIGNvbnRlbnQgZXhjZXB0IGZvciBiYWQtbGlzdGVkIGVsZW1lbnRzICovXG4gICAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgICBpZiAoY2hpbGROb2RlcyAmJiBwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgd2hldGhlciBlbGVtZW50IGhhcyBhIHZhbGlkIG5hbWVzcGFjZSAqL1xuICAgICAgaWYgKGN1cnJlbnROb2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiAhX2NoZWNrVmFsaWROYW1lc3BhY2UoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnKSAmJiByZWdFeHBUZXN0KC88XFwvbm8oc2NyaXB0fGVtYmVkKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBTYW5pdGl6ZSBlbGVtZW50IGNvbnRlbnQgdG8gYmUgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUyAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAvKiBHZXQgdGhlIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnQgKi9cbiAgICAgICAgY29udGVudCA9IGN1cnJlbnROb2RlLnRleHRDb250ZW50O1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBNVVNUQUNIRV9FWFBSJCQxLCAnICcpO1xuICAgICAgICBjb250ZW50ID0gc3RyaW5nUmVwbGFjZShjb250ZW50LCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7IGVsZW1lbnQ6IGN1cnJlbnROb2RlLmNsb25lTm9kZSgpIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfaXNWYWxpZEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBsY1RhZyBMb3dlcmNhc2UgdGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGNOYW1lIExvd2VyY2FzZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgdmFyIF9pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpIHtcbiAgICAgIC8qIE1ha2Ugc3VyZSBhdHRyaWJ1dGUgY2Fubm90IGNsb2JiZXIgKi9cbiAgICAgIGlmIChTQU5JVElaRV9ET00gJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykgJiYgKHZhbHVlIGluIGRvY3VtZW50IHx8IHZhbHVlIGluIGZvcm1FbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8qIEFsbG93IHZhbGlkIGRhdGEtKiBhdHRyaWJ1dGVzOiBBdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGFmdGVyIFwiLVwiXG4gICAgICAgICAgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2VtYmVkZGluZy1jdXN0b20tbm9uLXZpc2libGUtZGF0YS13aXRoLXRoZS1kYXRhLSotYXR0cmlidXRlcylcbiAgICAgICAgICBYTUwtY29tcGF0aWJsZSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN4bWwtY29tcGF0aWJsZSBhbmQgaHR0cDovL3d3dy53My5vcmcvVFIveG1sLyNkMGU4MDQpXG4gICAgICAgICAgV2UgZG9uJ3QgbmVlZCB0byBjaGVjayB0aGUgdmFsdWU7IGl0J3MgYWx3YXlzIFVSSSBzYWZlLiAqL1xuICAgICAgaWYgKEFMTE9XX0RBVEFfQVRUUiAmJiAhRk9SQklEX0FUVFJbbGNOYW1lXSAmJiByZWdFeHBUZXN0KERBVEFfQVRUUiQkMSwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIkJDEsIGxjTmFtZSkpIDsgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8qIENoZWNrIHZhbHVlIGlzIHNhZmUuIEZpcnN0LCBpcyBhdHRyIGluZXJ0PyBJZiBzbywgaXMgc2FmZSAqL1xuICAgICAgfSBlbHNlIGlmIChVUklfU0FGRV9BVFRSSUJVVEVTW2xjTmFtZV0pIDsgZWxzZSBpZiAocmVnRXhwVGVzdChJU19BTExPV0VEX1VSSSQkMSwgc3RyaW5nUmVwbGFjZSh2YWx1ZSwgQVRUUl9XSElURVNQQUNFJCQxLCAnJykpKSA7IGVsc2UgaWYgKChsY05hbWUgPT09ICdzcmMnIHx8IGxjTmFtZSA9PT0gJ3hsaW5rOmhyZWYnIHx8IGxjTmFtZSA9PT0gJ2hyZWYnKSAmJiBsY1RhZyAhPT0gJ3NjcmlwdCcgJiYgc3RyaW5nSW5kZXhPZih2YWx1ZSwgJ2RhdGE6JykgPT09IDAgJiYgREFUQV9VUklfVEFHU1tsY1RhZ10pIDsgZWxzZSBpZiAoQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMgJiYgIXJlZ0V4cFRlc3QoSVNfU0NSSVBUX09SX0RBVEEkJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSQkMSwgJycpKSkgOyBlbHNlIGlmICghdmFsdWUpIDsgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgICAqIEBwcm90ZWN0IHJlbW92ZUF0dHJpYnV0ZVxuICAgICAqIEBwcm90ZWN0IHNldEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gc2FuaXRpemVcbiAgICAgKi9cbiAgICB2YXIgX3Nhbml0aXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpIHtcbiAgICAgIHZhciBhdHRyID0gdm9pZCAwO1xuICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIGxjTmFtZSA9IHZvaWQgMDtcbiAgICAgIHZhciBsID0gdm9pZCAwO1xuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gY3VycmVudE5vZGUuYXR0cmlidXRlcztcblxuICAgICAgLyogQ2hlY2sgaWYgd2UgaGF2ZSBhdHRyaWJ1dGVzOyBpZiBub3Qgd2UgbWlnaHQgaGF2ZSBhIHRleHQgbm9kZSAqL1xuXG4gICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9va0V2ZW50ID0ge1xuICAgICAgICBhdHRyTmFtZTogJycsXG4gICAgICAgIGF0dHJWYWx1ZTogJycsXG4gICAgICAgIGtlZXBBdHRyOiB0cnVlLFxuICAgICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSXG4gICAgICB9O1xuICAgICAgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuXG4gICAgICAvKiBHbyBiYWNrd2FyZHMgb3ZlciBhbGwgYXR0cmlidXRlczsgc2FmZWx5IHJlbW92ZSBiYWQgb25lcyAqL1xuICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tsXTtcbiAgICAgICAgdmFyIF9hdHRyID0gYXR0cixcbiAgICAgICAgICAgIG5hbWUgPSBfYXR0ci5uYW1lLFxuICAgICAgICAgICAgbmFtZXNwYWNlVVJJID0gX2F0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIHZhbHVlID0gc3RyaW5nVHJpbShhdHRyLnZhbHVlKTtcbiAgICAgICAgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMobmFtZSk7XG5cbiAgICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICAgIGhvb2tFdmVudC5hdHRyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaG9va0V2ZW50LmtlZXBBdHRyID0gdHJ1ZTtcbiAgICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7IC8vIEFsbG93cyBkZXZlbG9wZXJzIHRvIHNlZSB0aGlzIGlzIGEgcHJvcGVydHkgdGhleSBjYW4gc2V0XG4gICAgICAgIF9leGVjdXRlSG9vaygndXBvblNhbml0aXplQXR0cmlidXRlJywgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICAgIHZhbHVlID0gaG9va0V2ZW50LmF0dHJWYWx1ZTtcbiAgICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVtb3ZlIGF0dHJpYnV0ZSAqL1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgaW4galF1ZXJ5IDMuMCAqL1xuICAgICAgICBpZiAocmVnRXhwVGVzdCgvXFwvPi9pLCB2YWx1ZSkpIHtcbiAgICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNhbml0aXplIGF0dHJpYnV0ZSBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICAgIHZhbHVlID0gc3RyaW5nUmVwbGFjZSh2YWx1ZSwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIEVSQl9FWFBSJCQxLCAnICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogSXMgYHZhbHVlYCB2YWxpZCBmb3IgdGhpcyBhdHRyaWJ1dGU/ICovXG4gICAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKGN1cnJlbnROb2RlLm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCFfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIEhhbmRsZSBpbnZhbGlkIGRhdGEtKiBhdHRyaWJ1dGUgc2V0IGJ5IHRyeS1jYXRjaGluZyBpdCAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChuYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVSSSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBzZXRBdHRyaWJ1dGUoKSBmb3IgYnJvd3Nlci11bnJlY29nbml6ZWQgbmFtZXNwYWNlcyBlLmcuIFwieC1zY2hlbWFcIi4gKi9cbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJyYXlQb3AoRE9NUHVyaWZ5LnJlbW92ZWQpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfc2FuaXRpemVTaGFkb3dET01cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IHRvIGl0ZXJhdGUgb3ZlciByZWN1cnNpdmVseVxuICAgICAqL1xuICAgIHZhciBfc2FuaXRpemVTaGFkb3dET00gPSBmdW5jdGlvbiBfc2FuaXRpemVTaGFkb3dET00oZnJhZ21lbnQpIHtcbiAgICAgIHZhciBzaGFkb3dOb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIHNoYWRvd0l0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKGZyYWdtZW50KTtcblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcblxuICAgICAgd2hpbGUgKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgICAgX2V4ZWN1dGVIb29rKCd1cG9uU2FuaXRpemVTaGFkb3dOb2RlJywgc2hhZG93Tm9kZSwgbnVsbCk7XG5cbiAgICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgICAgaWYgKF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBEZWVwIHNoYWRvdyBET00gZGV0ZWN0ZWQgKi9cbiAgICAgICAgaWYgKHNoYWRvd05vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpO1xuICAgICAgfVxuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2FmdGVyU2FuaXRpemVTaGFkb3dET00nLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhbml0aXplXG4gICAgICogUHVibGljIG1ldGhvZCBwcm92aWRpbmcgY29yZSBzYW5pdGF0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE5vZGV9IGRpcnR5IHN0cmluZyBvciBET00gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgRE9NUHVyaWZ5LnNhbml0aXplID0gZnVuY3Rpb24gKGRpcnR5LCBjZmcpIHtcbiAgICAgIHZhciBib2R5ID0gdm9pZCAwO1xuICAgICAgdmFyIGltcG9ydGVkTm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHZvaWQgMDtcbiAgICAgIHZhciBvbGROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIHJldHVybk5vZGUgPSB2b2lkIDA7XG4gICAgICAvKiBNYWtlIHN1cmUgd2UgaGF2ZSBhIHN0cmluZyB0byBzYW5pdGl6ZS5cbiAgICAgICAgRE8gTk9UIHJldHVybiBlYXJseSwgYXMgdGhpcyB3aWxsIHJldHVybiB0aGUgd3JvbmcgdHlwZSBpZlxuICAgICAgICB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGEgRE9NIG9iamVjdCByYXRoZXIgdGhhbiBhIHN0cmluZyAqL1xuICAgICAgSVNfRU1QVFlfSU5QVVQgPSAhZGlydHk7XG4gICAgICBpZiAoSVNfRU1QVFlfSU5QVVQpIHtcbiAgICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgICAgfVxuXG4gICAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG4gICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJyAmJiAhX2lzTm9kZShkaXJ0eSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgZGlydHkudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ3RvU3RyaW5nIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlydHkgPSBkaXJ0eS50b1N0cmluZygpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogQ2hlY2sgd2UgY2FuIHJ1bi4gT3RoZXJ3aXNlIGZhbGwgYmFjayBvciBpZ25vcmUgKi9cbiAgICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChfdHlwZW9mKHdpbmRvdy50b1N0YXRpY0hUTUwpID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygd2luZG93LnRvU3RhdGljSFRNTCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9pc05vZGUoZGlydHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnRvU3RhdGljSFRNTChkaXJ0eS5vdXRlckhUTUwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogQXNzaWduIGNvbmZpZyB2YXJzICovXG4gICAgICBpZiAoIVNFVF9DT05GSUcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgICB9XG5cbiAgICAgIC8qIENsZWFuIHVwIHJlbW92ZWQgZWxlbWVudHMgKi9cbiAgICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG5cbiAgICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cbiAgICAgIGlmICh0eXBlb2YgZGlydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIElOX1BMQUNFID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChJTl9QTEFDRSkgOyBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgLyogSWYgZGlydHkgaXMgYSBET00gZWxlbWVudCwgYXBwZW5kIHRvIGFuIGVtcHR5IGRvY3VtZW50IHRvIGF2b2lkXG4gICAgICAgICAgIGVsZW1lbnRzIGJlaW5nIHN0cmlwcGVkIGJ5IHRoZSBwYXJzZXIgKi9cbiAgICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoJzwhLS0tLT4nKTtcbiAgICAgICAgaW1wb3J0ZWROb2RlID0gYm9keS5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoZGlydHksIHRydWUpO1xuICAgICAgICBpZiAoaW1wb3J0ZWROb2RlLm5vZGVUeXBlID09PSAxICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgLyogTm9kZSBpcyBhbHJlYWR5IGEgYm9keSwgdXNlIGFzIGlzICovXG4gICAgICAgICAgYm9keSA9IGltcG9ydGVkTm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogRXhpdCBkaXJlY3RseSBpZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcblxuICAgICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gUkVUVVJOX0RPTSA/IG51bGwgOiBlbXB0eUhUTUw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cbiAgICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIC8qIEdldCBub2RlIGl0ZXJhdG9yICovXG4gICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcblxuICAgICAgLyogTm93IHN0YXJ0IGl0ZXJhdGluZyBvdmVyIHRoZSBjcmVhdGVkIGRvY3VtZW50ICovXG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAvKiBGaXggSUUncyBzdHJhbmdlIGJlaGF2aW9yIHdpdGggbWFuaXB1bGF0ZWQgdGV4dE5vZGVzICM4OSAqL1xuICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMgJiYgY3VycmVudE5vZGUgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTtcblxuICAgICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIG9sZE5vZGUgPSBudWxsO1xuXG4gICAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogUmV0dXJuIHNhbml0aXplZCBzdHJpbmcgb3IgRE9NICovXG4gICAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcblxuICAgICAgICAgIHdoaWxlIChib2R5LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1kb20tbm9kZS1hcHBlbmRcbiAgICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUkVUVVJOX0RPTV9JTVBPUlQpIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgQWRvcHROb2RlKCkgaXMgbm90IHVzZWQgYmVjYXVzZSBpbnRlcm5hbCBzdGF0ZSBpcyBub3QgcmVzZXRcbiAgICAgICAgICAgIChlLmcuIHRoZSBwYXN0IG5hbWVzIG1hcCBvZiBhIEhUTUxGb3JtRWxlbWVudCksIHRoaXMgaXMgc2FmZVxuICAgICAgICAgICAgaW4gdGhlb3J5IGJ1dCB3ZSB3b3VsZCByYXRoZXIgbm90IHJpc2sgYW5vdGhlciBhdHRhY2sgdmVjdG9yLlxuICAgICAgICAgICAgVGhlIHN0YXRlIHRoYXQgaXMgY2xvbmVkIGJ5IGltcG9ydE5vZGUoKSBpcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICAgIGJ5IHRoZSBzcGVjcy5cbiAgICAgICAgICAqL1xuICAgICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuXG4gICAgICAvKiBTYW5pdGl6ZSBmaW5hbCBzdHJpbmcgdGVtcGxhdGUtc2FmZSAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgICBzZXJpYWxpemVkSFRNTCA9IHN0cmluZ1JlcGxhY2Uoc2VyaWFsaXplZEhUTUwsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIHNldCB0aGUgY29uZmlndXJhdGlvbiBvbmNlXG4gICAgICogc2V0Q29uZmlnXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnNldENvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgU0VUX0NPTkZJRyA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICogY2xlYXJDb25maWdcbiAgICAgKlxuICAgICAqL1xuICAgIERPTVB1cmlmeS5jbGVhckNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIENPTkZJRyA9IG51bGw7XG4gICAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gY2hlY2sgaWYgYW4gYXR0cmlidXRlIHZhbHVlIGlzIHZhbGlkLlxuICAgICAqIFVzZXMgbGFzdCBzZXQgY29uZmlnLCBpZiBhbnkuIE90aGVyd2lzZSwgdXNlcyBjb25maWcgZGVmYXVsdHMuXG4gICAgICogaXNWYWxpZEF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gYXR0ciBBdHRyaWJ1dGUgbmFtZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC4gT3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLlxuICAgICAqL1xuICAgIERPTVB1cmlmeS5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0ciwgdmFsdWUpIHtcbiAgICAgIC8qIEluaXRpYWxpemUgc2hhcmVkIGNvbmZpZyB2YXJzIGlmIG5lY2Vzc2FyeS4gKi9cbiAgICAgIGlmICghQ09ORklHKSB7XG4gICAgICAgIF9wYXJzZUNvbmZpZyh7fSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsY1RhZyA9IHRyYW5zZm9ybUNhc2VGdW5jKHRhZyk7XG4gICAgICB2YXIgbGNOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoYXR0cik7XG4gICAgICByZXR1cm4gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRIb29rXG4gICAgICogUHVibGljIG1ldGhvZCB0byBhZGQgRE9NUHVyaWZ5IGhvb2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2sgdG8gYWRkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaG9va0Z1bmN0aW9uIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgKi9cbiAgICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICAgIGlmICh0eXBlb2YgaG9va0Z1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBob29rc1tlbnRyeVBvaW50XSB8fCBbXTtcbiAgICAgIGFycmF5UHVzaChob29rc1tlbnRyeVBvaW50XSwgaG9va0Z1bmN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlSG9va1xuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGEgRE9NUHVyaWZ5IGhvb2sgYXQgYSBnaXZlbiBlbnRyeVBvaW50XG4gICAgICogKHBvcHMgaXQgZnJvbSB0aGUgc3RhY2sgb2YgaG9va3MgaWYgbW9yZSBhcmUgcHJlc2VudClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byByZW1vdmVcbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgYXJyYXlQb3AoaG9va3NbZW50cnlQb2ludF0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVIb29rc1xuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gcmVtb3ZlIGFsbCBET01QdXJpZnkgaG9va3MgYXQgYSBnaXZlbiBlbnRyeVBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rcyB0byByZW1vdmVcbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlSG9va3MgPSBmdW5jdGlvbiAoZW50cnlQb2ludCkge1xuICAgICAgaWYgKGhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgIGhvb2tzW2VudHJ5UG9pbnRdID0gW107XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZUFsbEhvb2tzXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rc1xuICAgICAqXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaG9va3MgPSB7fTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgfVxuXG4gIHZhciBwdXJpZnkgPSBjcmVhdGVET01QdXJpZnkoKTtcblxuICByZXR1cm4gcHVyaWZ5O1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXJpZnkuanMubWFwXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheS5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIyKTtcblxuLyoqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZSBhcnJheVxuICogZnJvbSBzdGFydCBpbmRleChkZWZhdWx0IDApLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqIEl0IGNvbXBhcmVzIHNlYXJjaEVsZW1lbnQgdG8gZWxlbWVudHMgb2YgdGhlIEFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICogKHRoZSBzYW1lIG1ldGhvZCB1c2VkIGJ5IHRoZSA9PT0sIG9yIHRyaXBsZS1lcXVhbHMsIG9wZXJhdG9yKS5cbiAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGxvY2F0ZSBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBTdGFydCBpbmRleCBpbiBhcnJheSBmb3Igc2VhcmNoaW5nIChkZWZhdWx0IDApXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgRmlyc3QgaW5kZXggYXQgd2hpY2ggYSBnaXZlbiBlbGVtZW50LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudFxuICogQG1lbWJlcm9mIG1vZHVsZTphcnJheVxuICogQGV4YW1wbGVcbiAqIC8vIEVTNlxuICogaW1wb3J0IGluQXJyYXkgZnJvbSAndHVpLWNvZGUtc25pcHBldC9hcnJheS9pbkFycmF5JztcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGluQXJyYXkgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2FycmF5L2luQXJyYXknKTtcbiAqXG4gKiBjb25zdCBhcnIgPSBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91ciddO1xuICogY29uc3QgaWR4MSA9IGluQXJyYXkoJ29uZScsIGFyciwgMyk7IC8vIC0xXG4gKiBjb25zdCBpZHgyID0gaW5BcnJheSgnb25lJywgYXJyKTsgLy8gMFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNlYXJjaEVsZW1lbnQsIGFycmF5LCBzdGFydEluZGV4KSB7XG4gIHZhciBpO1xuICB2YXIgbGVuZ3RoO1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghaXNBcnJheShhcnJheSkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgc2VhcmNoRWxlbWVudCwgc3RhcnRJbmRleCk7XG4gIH1cblxuICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIGZvciAoaSA9IHN0YXJ0SW5kZXg7IHN0YXJ0SW5kZXggPj0gMCAmJiBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbkFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2OTA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyMik7XG52YXIgZm9yRWFjaEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OTMpO1xudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTYpO1xuXG4vKipcbiAqIEBtb2R1bGUgY29sbGVjdGlvblxuICovXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBwcm9wZXJ0eSBvZiBvYmplY3Qob3IgZWxlbWVudCBvZiBhcnJheSkgd2hpY2ggYWN0dWFsbHkgZXhpc3QuXG4gKiBJZiB0aGUgb2JqZWN0IGlzIEFycmF5LWxpa2Ugb2JqZWN0KGV4LWFyZ3VtZW50cyBvYmplY3QpLCBJdCBuZWVkcyB0byB0cmFuc2Zvcm0gdG8gQXJyYXkuKHNlZSAnZXgyJyBvZiBleGFtcGxlKS5cbiAqIElmIHRoZSBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGUgbG9vcCB3aWxsIGJlIHN0b3BwZWQuXG4gKiBDYWxsYmFjayBmdW5jdGlvbihpdGVyYXRlZSkgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAxKSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5KG9yIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudClcbiAqICAyKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkob3IgVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50KVxuICogIDMpIFRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaCBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaCc7IFxuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaCA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoJyk7IFxuICpcbiAqIGxldCBzdW0gPSAwO1xuICpcbiAqIGZvckVhY2goWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqXG4gKiAvLyBJbiBjYXNlIG9mIEFycmF5LWxpa2Ugb2JqZWN0XG4gKiBjb25zdCBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7IC8vIGNoYW5nZSB0byBhcnJheVxuICogZm9yRWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3JFYWNoQXJyYXkob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgb25jZSBmb3IgZWFjaCBlbGVtZW50IHByZXNlbnRcbiAqIGluIHRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgaW4gYXNjZW5kaW5nIG9yZGVyLlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudFxuICogIDIpIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudFxuICogIDMpIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgYmVpbmcgdHJhdmVyc2VkXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c3xOb2RlTGlzdH0gYXJyIFRoZSBhcnJheShvciBBcnJheS1saWtlIG9iamVjdCkgdGhhdCB3aWxsIGJlIHRyYXZlcnNlZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gQ29udGV4dCh0aGlzKSBvZiBjYWxsYmFjayBmdW5jdGlvblxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgZm9yRWFjaEFycmF5IGZyb20gJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi9mb3JFYWNoQXJyYXknO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaEFycmF5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC9jb2xsZWN0aW9uL2ZvckVhY2hBcnJheScpOyBcbiAqXG4gKiBsZXQgc3VtID0gMDtcbiAqXG4gKiBmb3JFYWNoQXJyYXkoWzEsMiwzXSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFyciwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgY29udGV4dCA9IGNvbnRleHQgfHwgbnVsbDtcblxuICBmb3IgKDsgaW5kZXggPCBsZW47IGluZGV4ICs9IDEpIHtcbiAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBhcnJbaW5kZXhdLCBpbmRleCwgYXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU2OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBFeGVjdXRlIHRoZSBwcm92aWRlZCBjYWxsYmFjayBvbmNlIGZvciBlYWNoIHByb3BlcnR5IG9mIG9iamVjdCB3aGljaCBhY3R1YWxseSBleGlzdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIG9uY2UgZm9yIGVhY2ggcHJvcGVydHkgb2Ygb2JqZWN0IHdoaWNoIGFjdHVhbGx5IGV4aXN0LlxuICogSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZSBsb29wIHdpbGwgYmUgc3RvcHBlZC5cbiAqIENhbGxiYWNrIGZ1bmN0aW9uKGl0ZXJhdGVlKSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogIDEpIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqICAyKSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAqICAzKSBUaGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSB0cmF2ZXJzZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlICBDYWxsYmFjayBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0KHRoaXMpIG9mIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBmb3JFYWNoT3duUHJvcGVydGllcyBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMnO1xuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgZm9yRWFjaE93blByb3BlcnRpZXMgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMnKTsgXG4gKlxuICogbGV0IHN1bSA9IDA7XG4gKlxuICogZm9yRWFjaE93blByb3BlcnRpZXMoe2E6MSxiOjIsYzozfSwgZnVuY3Rpb24odmFsdWUpe1xuICogICBzdW0gKz0gdmFsdWU7XG4gKiB9KTtcbiAqIGFsZXJ0KHN1bSk7IC8vIDZcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaE93blByb3BlcnRpZXMob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICB2YXIga2V5O1xuXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoT3duUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTkwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRyYW5zZm9ybSB0aGUgQXJyYXktbGlrZSBvYmplY3QgdG8gQXJyYXkuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGZvckVhY2hBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oODkzKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIEFycmF5LWxpa2Ugb2JqZWN0IHRvIEFycmF5LlxuICogSW4gbG93IElFIChiZWxvdyA4KSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwgaXMgbm90IHBlcmZlY3QuIFNvLCB0cnktY2F0Y2ggc3RhdGVtZW50IGlzIHVzZWQuXG4gKiBAcGFyYW0geyp9IGFycmF5TGlrZSBBcnJheS1saWtlIG9iamVjdFxuICogQHJldHVybnMge0FycmF5fSBBcnJheVxuICogQG1lbWJlcm9mIG1vZHVsZTpjb2xsZWN0aW9uXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2XG4gKiBpbXBvcnQgdG9BcnJheSBmcm9tICd0dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vdG9BcnJheSc7IFxuICogXG4gKiAvLyBDb21tb25KU1xuICogY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5Jyk7IFxuICpcbiAqIGNvbnN0IGFycmF5TGlrZSA9IHtcbiAqICAgMDogJ29uZScsXG4gKiAgIDE6ICd0d28nLFxuICogICAyOiAndGhyZWUnLFxuICogICAzOiAnZm91cicsXG4gKiAgIGxlbmd0aDogNFxuICogfTtcbiAqIGNvbnN0IHJlc3VsdCA9IHRvQXJyYXkoYXJyYXlMaWtlKTtcbiAqXG4gKiBhbGVydChyZXN1bHQgaW5zdGFuY2VvZiBBcnJheSk7IC8vIHRydWVcbiAqIGFsZXJ0KHJlc3VsdCk7IC8vIG9uZSx0d28sdGhyZWUsZm91clxuICovXG5mdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xuICB2YXIgYXJyO1xuICB0cnkge1xuICAgIGFyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhcnIgPSBbXTtcbiAgICBmb3JFYWNoQXJyYXkoYXJyYXlMaWtlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgYXJyLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NTU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEdldCBldmVudCBjb2xsZWN0aW9uIGZvciBzcGVjaWZpYyBIVE1MIGVsZW1lbnRcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgRVZFTlRfS0VZID0gJ19mZUV2ZW50S2V5JztcblxuLyoqXG4gKiBHZXQgZXZlbnQgY29sbGVjdGlvbiBmb3Igc3BlY2lmaWMgSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gSFRNTCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50IHR5cGVcbiAqIEByZXR1cm5zIHthcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhZmVFdmVudChlbGVtZW50LCB0eXBlKSB7XG4gIHZhciBldmVudHMgPSBlbGVtZW50W0VWRU5UX0tFWV07XG4gIHZhciBoYW5kbGVycztcblxuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IGVsZW1lbnRbRVZFTlRfS0VZXSA9IHt9O1xuICB9XG5cbiAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcnMpIHtcbiAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXJzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVFdmVudDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVuYmluZCBET00gZXZlbnRzXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTgpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5MCk7XG5cbnZhciBzYWZlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1NSk7XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0geyhzdHJpbmd8b2JqZWN0KX0gdHlwZXMgLSBTcGFjZSBzcGxpdHRlZCBldmVudHMgbmFtZXMgb3IgZXZlbnROYW1lOmhhbmRsZXIgb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbUV2ZW50XG4gKiBAZXhhbXBsZVxuICogLy8gRm9sbG93aW5nIHRoZSBleGFtcGxlIG9mIGRvbUV2ZW50I29uXG4gKiBcbiAqIC8vIFVuYmluZCBvbmUgZXZlbnQgZnJvbSBhbiBlbGVtZW50LlxuICogb2ZmKGRpdiwgJ2NsaWNrJywgdG9nZ2xlKTtcbiAqIFxuICogLy8gVW5iaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIGZyb20gbXVsdGlwbGUgZWxlbWVudHMgYXQgb25jZS5cbiAqIC8vIFVzZSBldmVudCBuYW1lcyBzcGxpdHRlZCBieSBhIHNwYWNlLlxuICogb2ZmKGVsZW1lbnQsICdtb3VzZWVudGVyIG1vdXNlbGVhdmUnLCBjaGFuZ2VDb2xvcik7XG4gKiBcbiAqIC8vIFVuYmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgZnJvbSBhbiBlbGVtZW50IGF0IG9uY2UuXG4gKiAvLyBVc2UgYW4gb2JqZWN0IHdoaWNoIG9mIGtleSBpcyBhbiBldmVudCBuYW1lIGFuZCB2YWx1ZSBpcyBhIGhhbmRsZXIgZnVuY3Rpb24uXG4gKiBvZmYoZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gVW5iaW5kIGV2ZW50cyB3aXRob3V0IGhhbmRsZXJzLlxuICogb2ZmKGRpdiwgJ2RyYWcnKTtcbiAqL1xuZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGlmIChpc1N0cmluZyh0eXBlcykpIHtcbiAgICBmb3JFYWNoKHR5cGVzLnNwbGl0KC9cXHMrL2cpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2godHlwZXMsIGZ1bmN0aW9uKGZ1bmMsIHR5cGUpIHtcbiAgICB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBmdW5jKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVW5iaW5kIERPTSBldmVudHNcbiAqIElmIGEgaGFuZGxlciBmdW5jdGlvbiBpcyBub3QgcGFzc2VkLCByZW1vdmUgYWxsIGV2ZW50cyBvZiB0aGF0IHR5cGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byB1bmJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBoYW5kbGVyIGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1bmJpbmRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQoZWxlbWVudCwgdHlwZSk7XG4gIHZhciBpbmRleDtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKDAsIGV2ZW50cy5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihpdGVtLCBpZHgpIHtcbiAgICAgIGlmIChoYW5kbGVyID09PSBpdGVtLmhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCB0eXBlLCBpdGVtLndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgaW5kZXggPSBpZHg7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBldmVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gQW4gZWxlbWVudCB0byByZW1vdmUgYW4gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoJ2RldGFjaEV2ZW50JyBpbiBlbGVtZW50KSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgdHlwZSwgaGFuZGxlcik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvZmY7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBCaW5kIERPTSBldmVudHNcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OCk7XG52YXIgZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkwKTtcblxudmFyIHNhZmVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNzU1KTtcblxuLyoqXG4gKiBCaW5kIERPTSBldmVudHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byBiaW5kIGV2ZW50c1xuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHR5cGVzIC0gU3BhY2Ugc3BsaXR0ZWQgZXZlbnRzIG5hbWVzIG9yIGV2ZW50TmFtZTpoYW5kbGVyIG9iamVjdFxuICogQHBhcmFtIHsoZnVuY3Rpb258b2JqZWN0KX0gaGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gb3IgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gY29udGV4dCAtIGNvbnRleHQgZm9yIGhhbmRsZXIgbWV0aG9kLlxuICogQG1lbWJlcm9mIG1vZHVsZTpkb21FdmVudFxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICogXG4gKiAvLyBCaW5kIG9uZSBldmVudCB0byBhbiBlbGVtZW50LlxuICogb24oZGl2LCAnY2xpY2snLCB0b2dnbGUpO1xuICogXG4gKiAvLyBCaW5kIG11bHRpcGxlIGV2ZW50cyB3aXRoIGEgc2FtZSBoYW5kbGVyIHRvIG11bHRpcGxlIGVsZW1lbnRzIGF0IG9uY2UuXG4gKiAvLyBVc2UgZXZlbnQgbmFtZXMgc3BsaXR0ZWQgYnkgYSBzcGFjZS5cbiAqIG9uKGRpdiwgJ21vdXNlZW50ZXIgbW91c2VsZWF2ZScsIGNoYW5nZUNvbG9yKTtcbiAqIFxuICogLy8gQmluZCBtdWx0aXBsZSBldmVudHMgd2l0aCBkaWZmZXJlbnQgaGFuZGxlcnMgdG8gYW4gZWxlbWVudCBhdCBvbmNlLlxuICogLy8gVXNlIGFuIG9iamVjdCB3aGljaCBvZiBrZXkgaXMgYW4gZXZlbnQgbmFtZSBhbmQgdmFsdWUgaXMgYSBoYW5kbGVyIGZ1bmN0aW9uLlxuICogb24oZGl2LCB7XG4gKiAgIGtleWRvd246IGhpZ2hsaWdodCxcbiAqICAga2V5dXA6IGRlaGlnaGxpZ2h0XG4gKiB9KTtcbiAqIFxuICogLy8gU2V0IGEgY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBjb25zdCBuYW1lID0gJ2dsb2JhbCc7XG4gKiBjb25zdCByZXBvc2l0b3J5ID0ge25hbWU6ICdDb2RlU25pcHBldCd9O1xuICogb24oZGl2LCAnZHJhZycsIGZ1bmN0aW9uKCkge1xuICogICBjb25zb2xlLmxvZyh0aGlzLm5hbWUpO1xuICogfSwgcmVwb3NpdG9yeSk7XG4gKiAvLyBSZXN1bHQgd2hlbiB5b3UgZHJhZyBhIGRpdjogXCJDb2RlU25pcHBldFwiXG4gKi9cbmZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gIGlmIChpc1N0cmluZyh0eXBlcykpIHtcbiAgICBmb3JFYWNoKHR5cGVzLnNwbGl0KC9cXHMrL2cpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmb3JFYWNoKHR5cGVzLCBmdW5jdGlvbihmdW5jLCB0eXBlKSB7XG4gICAgYmluZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGhhbmRsZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBCaW5kIERPTSBldmVudHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiBvciBjb250ZXh0IGZvciBoYW5kbGVyIG1ldGhvZFxuICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBjb250ZXh0IC0gY29udGV4dCBmb3IgaGFuZGxlciBtZXRob2QuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBiaW5kRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSAtIGV2ZW50IG9iamVjdFxuICAgICAqL1xuICBmdW5jdGlvbiBldmVudEhhbmRsZXIoZSkge1xuICAgIGhhbmRsZXIuY2FsbChjb250ZXh0IHx8IGVsZW1lbnQsIGUgfHwgd2luZG93LmV2ZW50KTtcbiAgfVxuXG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKCdhdHRhY2hFdmVudCcgaW4gZWxlbWVudCkge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGV2ZW50SGFuZGxlcik7XG4gIH1cbiAgbWVtb3JpemVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGV2ZW50SGFuZGxlcik7XG59XG5cbi8qKlxuICogTWVtb3JpemUgRE9NIGV2ZW50IGhhbmRsZXIgZm9yIHVuYmluZGluZy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGV2ZW50cyBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gaGFuZGxlciBmdW5jdGlvbiB0aGF0IHVzZXIgcGFzc2VkIGF0IG9uKCkgdXNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVkSGFuZGxlciAtIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3cmFwcGVkIGJ5IGRvbWV2ZW50IGZvciBpbXBsZW1lbnRpbmcgc29tZSBmZWF0dXJlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWVtb3JpemVIYW5kbGVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIHdyYXBwZWRIYW5kbGVyKSB7XG4gIHZhciBldmVudHMgPSBzYWZlRXZlbnQoZWxlbWVudCwgdHlwZSk7XG4gIHZhciBleGlzdEluRXZlbnRzID0gZmFsc2U7XG5cbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgZXhpc3RJbkV2ZW50cyA9IHRydWU7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgaWYgKCFleGlzdEluRXZlbnRzKSB7XG4gICAgZXZlbnRzLnB1c2goe1xuICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgIHdyYXBwZWRIYW5kbGVyOiB3cmFwcGVkSGFuZGxlclxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNldCBjbGFzc05hbWUgdmFsdWVcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIyKTtcbnZhciBpc1VuZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTI5KTtcblxuLyoqXG4gKiBTZXQgY2xhc3NOYW1lIHZhbHVlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBjc3NDbGFzcyAtIGNsYXNzIG5hbWVzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbGFzc05hbWUoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgY3NzQ2xhc3MgPSBpc0FycmF5KGNzc0NsYXNzKSA/IGNzc0NsYXNzLmpvaW4oJyAnKSA6IGNzc0NsYXNzO1xuXG4gIGNzc0NsYXNzID0gY3NzQ2xhc3MucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblxuICBpZiAoaXNVbmRlZmluZWQoZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCkpIHtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCA9IGNzc0NsYXNzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENsYXNzTmFtZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEFkZCBjc3MgY2xhc3MgdG8gZWxlbWVudFxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTApO1xudmFyIGluQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOCk7XG52YXIgZ2V0Q2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMik7XG52YXIgc2V0Q2xhc3NOYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbi8qKlxuICogZG9tVXRpbCBtb2R1bGVcbiAqIEBtb2R1bGUgZG9tVXRpbFxuICovXG5cbi8qKlxuICogQWRkIGNzcyBjbGFzcyB0byBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byBhZGRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG5ld0NsYXNzID0gW107XG4gIHZhciBvcmlnaW47XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2goY3NzQ2xhc3MsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzKGVsZW1lbnQpO1xuXG4gIGlmIChvcmlnaW4pIHtcbiAgICBjc3NDbGFzcyA9IFtdLmNvbmNhdChvcmlnaW4uc3BsaXQoL1xccysvKSwgY3NzQ2xhc3MpO1xuICB9XG5cbiAgZm9yRWFjaChjc3NDbGFzcywgZnVuY3Rpb24oY2xzKSB7XG4gICAgaWYgKGluQXJyYXkoY2xzLCBuZXdDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKGNscyk7XG4gICAgfVxuICB9KTtcblxuICBzZXRDbGFzc05hbWUoZWxlbWVudCwgbmV3Q2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZENsYXNzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NTgpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5MCk7XG5cbi8qKlxuICogU2V0dGluZyBlbGVtZW50IHN0eWxlXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIGVsZW1lbnQgdG8gc2V0dGluZyBzdHlsZVxuICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IGtleSAtIHN0eWxlIHByb3AgbmFtZSBvciB7cHJvcDogdmFsdWV9IHBhaXIgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSAtIHN0eWxlIHZhbHVlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gY3NzKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSkge1xuICAgIHN0eWxlW2tleV0gPSB2YWx1ZTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2goa2V5LCBmdW5jdGlvbih2LCBrKSB7XG4gICAgc3R5bGVba10gPSB2O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjc3M7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkwMjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBHZXQgSFRNTCBlbGVtZW50J3MgZGVzaWduIGNsYXNzZXMuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGlzVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjkpO1xuXG4vKipcbiAqIEdldCBIVE1MIGVsZW1lbnQncyBkZXNpZ24gY2xhc3Nlcy5cbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlbGVtZW50IGNzcyBjbGFzcyBuYW1lXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3MoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q2xhc3M7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcxNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaW5BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOTI4KTtcbnZhciBnZXRDbGFzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcblxuLyoqXG4gKiBDaGVjayBlbGVtZW50IGhhcyBzcGVjaWZpYyBjc3MgY2xhc3NcbiAqIEBwYXJhbSB7KEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpfSBlbGVtZW50IC0gdGFyZ2V0IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzcyAtIGNzcyBjbGFzc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmRvbVV0aWxcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgdmFyIG9yaWdpbjtcblxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpO1xuICB9XG5cbiAgb3JpZ2luID0gZ2V0Q2xhc3MoZWxlbWVudCkuc3BsaXQoL1xccysvKTtcblxuICByZXR1cm4gaW5BcnJheShjc3NDbGFzcywgb3JpZ2luKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0NsYXNzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgZWxlbWVudCBtYXRjaCBzZWxlY3RvclxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBpbkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjgpO1xudmFyIHRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MCk7XG5cbnZhciBlbFByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG52YXIgbWF0Y2hTZWxlY3RvciA9IGVsUHJvdG8ubWF0Y2hlcyB8fFxuICAgIGVsUHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWxQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudDtcblxuICAgICAgcmV0dXJuIGluQXJyYXkodGhpcywgdG9BcnJheShkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpKSA+IC0xO1xuICAgIH07XG5cbi8qKlxuICogQ2hlY2sgZWxlbWVudCBtYXRjaCBzZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciAtIHNlbGVjdG9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXMgc2VsZWN0b3IgbWF0Y2hlZCB0byBlbGVtZW50P1xuICogQG1lbWJlcm9mIG1vZHVsZTpkb21VdGlsXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIG1hdGNoU2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDYyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxudmFyIGZvckVhY2hBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oODkzKTtcbnZhciBpbkFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjgpO1xudmFyIGdldENsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDIpO1xudmFyIHNldENsYXNzTmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG4vKipcbiAqIFJlbW92ZSBjc3MgY2xhc3MgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTVkdFbGVtZW50KX0gZWxlbWVudCAtIHRhcmdldCBlbGVtZW50XG4gKiBAcGFyYW0gey4uLnN0cmluZ30gY3NzQ2xhc3MgLSBjc3MgY2xhc3NlcyB0byByZW1vdmVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6ZG9tVXRpbFxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50KSB7XG4gIHZhciBjc3NDbGFzcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcbiAgdmFyIG9yaWdpbiwgbmV3Q2xhc3M7XG5cbiAgaWYgKGNsYXNzTGlzdCkge1xuICAgIGZvckVhY2hBcnJheShjc3NDbGFzcywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9yaWdpbiA9IGdldENsYXNzKGVsZW1lbnQpLnNwbGl0KC9cXHMrLyk7XG4gIG5ld0NsYXNzID0gW107XG4gIGZvckVhY2hBcnJheShvcmlnaW4sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoaW5BcnJheShuYW1lLCBjc3NDbGFzcykgPCAwKSB7XG4gICAgICBuZXdDbGFzcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgc2V0Q2xhc3NOYW1lKGVsZW1lbnQsIG5ld0NsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmVDbGFzcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTY5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBFeHRlbmQgdGhlIHRhcmdldCBvYmplY3QgZnJvbSBvdGhlciBvYmplY3RzLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbi8qKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEV4dGVuZCB0aGUgdGFyZ2V0IG9iamVjdCBmcm9tIG90aGVyIG9iamVjdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gT2JqZWN0IHRoYXQgd2lsbCBiZSBleHRlbmRlZFxuICogQHBhcmFtIHsuLi5vYmplY3R9IG9iamVjdHMgLSBPYmplY3RzIGFzIHNvdXJjZXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IEV4dGVuZGVkIG9iamVjdFxuICogQG1lbWJlcm9mIG1vZHVsZTpvYmplY3RcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgb2JqZWN0cykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBoYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHNvdXJjZSwgcHJvcCwgaSwgbGVuO1xuXG4gIGZvciAoaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNTQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgUmVxdWVzdCBpbWFnZSBwaW5nLlxuICogQGF1dGhvciBOSE4gRkUgRGV2ZWxvcG1lbnQgTGFiIDxkbF9qYXZhc2NyaXB0QG5obi5jb20+XG4gKi9cblxuXG5cbnZhciBmb3JFYWNoT3duUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTU2KTtcblxuLyoqXG4gKiBAbW9kdWxlIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaW1hZ2UgcGluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgdXJsIGZvciBwaW5nIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFja2luZ0luZm8gaW5mb3MgZm9yIG1ha2UgcXVlcnkgc3RyaW5nXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnJlcXVlc3RcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpbWFnZVBpbmcgZnJvbSAndHVpLWNvZGUtc25pcHBldC9yZXF1ZXN0L2ltYWdlUGluZyc7XG4gKiBcbiAqIC8vIENvbW1vbkpTXG4gKiBjb25zdCBpbWFnZVBpbmcgPSByZXF1aXJlKCd0dWktY29kZS1zbmlwcGV0L3JlcXVlc3QvaW1hZ2VQaW5nJyk7XG4gKlxuICogaW1hZ2VQaW5nKCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0Jywge1xuICogICB2OiAxLFxuICogICB0OiAnZXZlbnQnLFxuICogICB0aWQ6ICd0cmFja2luZ2lkJyxcbiAqICAgY2lkOiAnY2lkJyxcbiAqICAgZHA6ICdkcCcsXG4gKiAgIGRoOiAnZGgnXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gaW1hZ2VQaW5nKHVybCwgdHJhY2tpbmdJbmZvKSB7XG4gIHZhciB0cmFja2luZ0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgdmFyIHF1ZXJ5U3RyaW5nID0gJyc7XG4gIGZvckVhY2hPd25Qcm9wZXJ0aWVzKHRyYWNraW5nSW5mbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHF1ZXJ5U3RyaW5nICs9ICcmJyArIGtleSArICc9JyArIHZhbHVlO1xuICB9KTtcbiAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XG5cbiAgdHJhY2tpbmdFbGVtZW50LnNyYyA9IHVybCArICc/JyArIHF1ZXJ5U3RyaW5nO1xuXG4gIHRyYWNraW5nRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRyYWNraW5nRWxlbWVudCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodHJhY2tpbmdFbGVtZW50KTtcblxuICByZXR1cm4gdHJhY2tpbmdFbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGltYWdlUGluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzkxOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOSk7XG52YXIgaW1hZ2VQaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTQpO1xuXG52YXIgbXM3ZGF5cyA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBkYXRlIGhhcyBwYXNzZWQgNyBkYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gZGF0ZSAtIG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0V4cGlyZWQoZGF0ZSkge1xuICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgcmV0dXJuIG5vdyAtIGRhdGUgPiBtczdkYXlzO1xufVxuXG4vKipcbiAqIFNlbmQgaG9zdG5hbWUgb24gRE9NQ29udGVudExvYWRlZC5cbiAqIFRvIHByZXZlbnQgaG9zdG5hbWUgc2V0IHR1aS51c2FnZVN0YXRpc3RpY3MgdG8gZmFsc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBwTmFtZSAtIGFwcGxpY2F0aW9uIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0cmFja2luZ0lkIC0gR0EgdHJhY2tpbmcgSURcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gc2VuZEhvc3RuYW1lKGFwcE5hbWUsIHRyYWNraW5nSWQpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9jb2xsZWN0JztcbiAgdmFyIGhvc3RuYW1lID0gbG9jYXRpb24uaG9zdG5hbWU7XG4gIHZhciBoaXRUeXBlID0gJ2V2ZW50JztcbiAgdmFyIGV2ZW50Q2F0ZWdvcnkgPSAndXNlJztcbiAgdmFyIGFwcGxpY2F0aW9uS2V5Rm9yU3RvcmFnZSA9ICdUT0FTVCBVSSAnICsgYXBwTmFtZSArICcgZm9yICcgKyBob3N0bmFtZSArICc6IFN0YXRpc3RpY3MnO1xuICB2YXIgZGF0ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhcHBsaWNhdGlvbktleUZvclN0b3JhZ2UpO1xuXG4gIC8vIHNraXAgaWYgdGhlIGZsYWcgaXMgZGVmaW5lZCBhbmQgaXMgc2V0IHRvIGZhbHNlIGV4cGxpY2l0bHlcbiAgaWYgKCFpc1VuZGVmaW5lZCh3aW5kb3cudHVpKSAmJiB3aW5kb3cudHVpLnVzYWdlU3RhdGlzdGljcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBza2lwIGlmIG5vdCBwYXNzIHNldmVuIGRheXMgb2xkXG4gIGlmIChkYXRlICYmICFpc0V4cGlyZWQoZGF0ZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwbGljYXRpb25LZXlGb3JTdG9yYWdlLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpbWFnZVBpbmcodXJsLCB7XG4gICAgICAgIHY6IDEsXG4gICAgICAgIHQ6IGhpdFR5cGUsXG4gICAgICAgIHRpZDogdHJhY2tpbmdJZCxcbiAgICAgICAgY2lkOiBob3N0bmFtZSxcbiAgICAgICAgZHA6IGhvc3RuYW1lLFxuICAgICAgICBkaDogYXBwTmFtZSxcbiAgICAgICAgZWw6IGFwcE5hbWUsXG4gICAgICAgIGVjOiBldmVudENhdGVnb3J5XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIDEwMDApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRIb3N0bmFtZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzIyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhbiBpbnN0YW5jZSBvZiBBcnJheSBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYW4gaW5zdGFuY2Ugb2YgQXJyYXksIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgYXJyYXkgaW5zdGFuY2U/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNVbmRlZmluZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOSk7XG52YXIgaXNOdWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzQpO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGV4aXN0aW5nIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBub3QgbnVsbCBhbmQgbm90IHVuZGVmaW5lZCwgcmV0dXJucyB0cnVlLlxuICogQHBhcmFtIHsqfSBwYXJhbSAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBleGlzdHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqIEBleGFtcGxlXG4gKiAvLyBFUzZcbiAqIGltcG9ydCBpc0V4aXN0eSBmcm9tICd0dWktY29kZS1zbmlwcGV0L3R5cGUvaXNFeGlzdHknKTtcbiAqIFxuICogLy8gQ29tbW9uSlNcbiAqIGNvbnN0IGlzRXhpc3R5ID0gcmVxdWlyZSgndHVpLWNvZGUtc25pcHBldC90eXBlL2lzRXhpc3R5Jyk7XG4gKlxuICogaXNFeGlzdHkoJycpOyAvL3RydWVcbiAqIGlzRXhpc3R5KDApOyAvL3RydWVcbiAqIGlzRXhpc3R5KFtdKTsgLy90cnVlXG4gKiBpc0V4aXN0eSh7fSk7IC8vdHJ1ZVxuICogaXNFeGlzdHkobnVsbCk7IC8vZmFsc2VcbiAqIGlzRXhpc3R5KHVuZGVmaW5lZCk7IC8vZmFsc2VcbiovXG5mdW5jdGlvbiBpc0V4aXN0eShwYXJhbSkge1xuICByZXR1cm4gIWlzVW5kZWZpbmVkKHBhcmFtKSAmJiAhaXNOdWxsKHBhcmFtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V4aXN0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDA0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGZhbHN5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNUcnV0aHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MCk7XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgZmFsc3kgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyBmYWxzeT9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6dHlwZVxuICovXG5mdW5jdGlvbiBpc0ZhbHN5KG9iaikge1xuICByZXR1cm4gIWlzVHJ1dGh5KG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGYWxzeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24gb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24sIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgZnVuY3Rpb24/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgbnVsbCBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBudWxsIG9yIG5vdC5cbiAqIElmIHRoZSBnaXZlbiB2YXJpYWJsZShhcmd1bWVudHNbMF0pIGlzIG51bGwsIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Kn0gb2JqIC0gVGFyZ2V0IGZvciBjaGVja2luZ1xuICogQHJldHVybnMge2Jvb2xlYW59IElzIG51bGw/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNOdWxsKG9iaikge1xuICByZXR1cm4gb2JqID09PSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTnVsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzU4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGZpbGVvdmVydmlldyBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBAYXV0aG9yIE5ITiBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqL1xuXG5cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIHN0cmluZyBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBzdHJpbmcsIHJldHVybiB0cnVlLlxuICogQHBhcmFtIHsqfSBvYmogLSBUYXJnZXQgZm9yIGNoZWNraW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gSXMgc3RyaW5nP1xuICogQG1lbWJlcm9mIG1vZHVsZTp0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgb2JqIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdHJ1dGh5IG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG52YXIgaXNFeGlzdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyB0cnV0aHkgb3Igbm90LlxuICogSWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIG5vdCBudWxsIG9yIG5vdCB1bmRlZmluZWQgb3Igbm90IGZhbHNlLCByZXR1cm5zIHRydWUuXG4gKiAoSXQgcmVnYXJkcyAwIGFzIHRydWUpXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB0cnV0aHk/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUcnV0aHkob2JqKSB7XG4gIHJldHVybiBpc0V4aXN0eShvYmopICYmIG9iaiAhPT0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUcnV0aHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyOTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkIG9yIG5vdC5cbiAqIEBhdXRob3IgTkhOIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCBvciBub3QuXG4gKiBJZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgdW5kZWZpbmVkLCByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IG9iaiAtIFRhcmdldCBmb3IgY2hlY2tpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufSBJcyB1bmRlZmluZWQ/XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnR5cGVcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDc5X187XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0ODE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180ODFfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIDQzOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzgxNF9fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzExOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzExX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuLyoqKioqKi8gXHRcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fSkoKTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbiFmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcImRlZmF1bHRcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGluZGV4Vmlld2VyOyB9XG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgdHNsaWJfZXM2X2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdHNsaWJfZXM2X2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiB0c2xpYl9lczZfYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbGlicy90b2FzdG1hcmsvZGlzdC9lc20vaW5kZXguanNcbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBlc21fZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZXNtX2V4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKVxuICAgICAgICAgICAgICAgIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBlc21fZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5mdW5jdGlvbiBlc21fZXh0ZW5kcyhkLCBiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgIGVzbV9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBlc21fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICAgIGVzbV9hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIGVzbV9hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBlc21fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgICAgIGlmICghYXIpXG4gICAgICAgICAgICAgICAgICAgIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbnZhciBlbmNvZGVDYWNoZSA9IHt9O1xuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gICAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICAgICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWNoZS5wdXNoKCclJyArICgnMCcgKyBpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG59XG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlJDEoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICAgIHZhciBpLCBsLCBjb2RlLCBuZXh0Q29kZSwgY2FjaGUsIHJlc3VsdCA9ICcnO1xuICAgIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gZW5jb2RlKHN0cmluZywga2VlcEVzY2FwZWQpXG4gICAgICAgIGtlZXBFc2NhcGVkID0gZXhjbHVkZTtcbiAgICAgICAgZXhjbHVkZSA9IGVuY29kZSQxLmRlZmF1bHRDaGFycztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAga2VlcEVzY2FwZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgICAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENvZGUgPj0gMHhEQzAwICYmIG5leHRDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmVuY29kZSQxLmRlZmF1bHRDaGFycyA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZSQxLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcbnZhciBlbmNvZGVfMSA9IGVuY29kZSQxO1xudmFyIGxpYiA9IHt9O1xudmFyIGRlY29kZSA9IHt9O1xudmFyIEFhY3V0ZSQxID0gXCLDgVwiO1xudmFyIGFhY3V0ZSQxID0gXCLDoVwiO1xudmFyIEFicmV2ZSA9IFwixIJcIjtcbnZhciBhYnJldmUgPSBcIsSDXCI7XG52YXIgYWMgPSBcIuKIvlwiO1xudmFyIGFjZCA9IFwi4oi/XCI7XG52YXIgYWNFID0gXCLiiL7Ms1wiO1xudmFyIEFjaXJjJDEgPSBcIsOCXCI7XG52YXIgYWNpcmMkMSA9IFwiw6JcIjtcbnZhciBhY3V0ZSQxID0gXCLCtFwiO1xudmFyIEFjeSA9IFwi0JBcIjtcbnZhciBhY3kgPSBcItCwXCI7XG52YXIgQUVsaWckMSA9IFwiw4ZcIjtcbnZhciBhZWxpZyQxID0gXCLDplwiO1xudmFyIGFmID0gXCLigaFcIjtcbnZhciBBZnIgPSBcIvCdlIRcIjtcbnZhciBhZnIgPSBcIvCdlJ5cIjtcbnZhciBBZ3JhdmUkMSA9IFwiw4BcIjtcbnZhciBhZ3JhdmUkMSA9IFwiw6BcIjtcbnZhciBhbGVmc3ltID0gXCLihLVcIjtcbnZhciBhbGVwaCA9IFwi4oS1XCI7XG52YXIgQWxwaGEgPSBcIs6RXCI7XG52YXIgYWxwaGEgPSBcIs6xXCI7XG52YXIgQW1hY3IgPSBcIsSAXCI7XG52YXIgYW1hY3IgPSBcIsSBXCI7XG52YXIgYW1hbGcgPSBcIuKov1wiO1xudmFyIGFtcCQyID0gXCImXCI7XG52YXIgQU1QJDEgPSBcIiZcIjtcbnZhciBhbmRhbmQgPSBcIuKplVwiO1xudmFyIEFuZCA9IFwi4qmTXCI7XG52YXIgYW5kID0gXCLiiKdcIjtcbnZhciBhbmRkID0gXCLiqZxcIjtcbnZhciBhbmRzbG9wZSA9IFwi4qmYXCI7XG52YXIgYW5kdiA9IFwi4qmaXCI7XG52YXIgYW5nID0gXCLiiKBcIjtcbnZhciBhbmdlID0gXCLipqRcIjtcbnZhciBhbmdsZSA9IFwi4oigXCI7XG52YXIgYW5nbXNkYWEgPSBcIuKmqFwiO1xudmFyIGFuZ21zZGFiID0gXCLipqlcIjtcbnZhciBhbmdtc2RhYyA9IFwi4qaqXCI7XG52YXIgYW5nbXNkYWQgPSBcIuKmq1wiO1xudmFyIGFuZ21zZGFlID0gXCLipqxcIjtcbnZhciBhbmdtc2RhZiA9IFwi4qatXCI7XG52YXIgYW5nbXNkYWcgPSBcIuKmrlwiO1xudmFyIGFuZ21zZGFoID0gXCLipq9cIjtcbnZhciBhbmdtc2QgPSBcIuKIoVwiO1xudmFyIGFuZ3J0ID0gXCLiiJ9cIjtcbnZhciBhbmdydHZiID0gXCLiir5cIjtcbnZhciBhbmdydHZiZCA9IFwi4qadXCI7XG52YXIgYW5nc3BoID0gXCLiiKJcIjtcbnZhciBhbmdzdCA9IFwiw4VcIjtcbnZhciBhbmd6YXJyID0gXCLijbxcIjtcbnZhciBBb2dvbiA9IFwixIRcIjtcbnZhciBhb2dvbiA9IFwixIVcIjtcbnZhciBBb3BmID0gXCLwnZS4XCI7XG52YXIgYW9wZiA9IFwi8J2VklwiO1xudmFyIGFwYWNpciA9IFwi4qmvXCI7XG52YXIgYXAgPSBcIuKJiFwiO1xudmFyIGFwRSA9IFwi4qmwXCI7XG52YXIgYXBlID0gXCLiiYpcIjtcbnZhciBhcGlkID0gXCLiiYtcIjtcbnZhciBhcG9zJDEgPSBcIidcIjtcbnZhciBBcHBseUZ1bmN0aW9uID0gXCLigaFcIjtcbnZhciBhcHByb3ggPSBcIuKJiFwiO1xudmFyIGFwcHJveGVxID0gXCLiiYpcIjtcbnZhciBBcmluZyQxID0gXCLDhVwiO1xudmFyIGFyaW5nJDEgPSBcIsOlXCI7XG52YXIgQXNjciA9IFwi8J2SnFwiO1xudmFyIGFzY3IgPSBcIvCdkrZcIjtcbnZhciBBc3NpZ24gPSBcIuKJlFwiO1xudmFyIGFzdCA9IFwiKlwiO1xudmFyIGFzeW1wID0gXCLiiYhcIjtcbnZhciBhc3ltcGVxID0gXCLiiY1cIjtcbnZhciBBdGlsZGUkMSA9IFwiw4NcIjtcbnZhciBhdGlsZGUkMSA9IFwiw6NcIjtcbnZhciBBdW1sJDEgPSBcIsOEXCI7XG52YXIgYXVtbCQxID0gXCLDpFwiO1xudmFyIGF3Y29uaW50ID0gXCLiiLNcIjtcbnZhciBhd2ludCA9IFwi4qiRXCI7XG52YXIgYmFja2NvbmcgPSBcIuKJjFwiO1xudmFyIGJhY2tlcHNpbG9uID0gXCLPtlwiO1xudmFyIGJhY2twcmltZSA9IFwi4oC1XCI7XG52YXIgYmFja3NpbSA9IFwi4oi9XCI7XG52YXIgYmFja3NpbWVxID0gXCLii41cIjtcbnZhciBCYWNrc2xhc2ggPSBcIuKIllwiO1xudmFyIEJhcnYgPSBcIuKrp1wiO1xudmFyIGJhcnZlZSA9IFwi4oq9XCI7XG52YXIgYmFyd2VkID0gXCLijIVcIjtcbnZhciBCYXJ3ZWQgPSBcIuKMhlwiO1xudmFyIGJhcndlZGdlID0gXCLijIVcIjtcbnZhciBiYnJrID0gXCLijrVcIjtcbnZhciBiYnJrdGJyayA9IFwi4o62XCI7XG52YXIgYmNvbmcgPSBcIuKJjFwiO1xudmFyIEJjeSA9IFwi0JFcIjtcbnZhciBiY3kgPSBcItCxXCI7XG52YXIgYmRxdW8gPSBcIuKAnlwiO1xudmFyIGJlY2F1cyA9IFwi4oi1XCI7XG52YXIgYmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgQmVjYXVzZSA9IFwi4oi1XCI7XG52YXIgYmVtcHR5diA9IFwi4qawXCI7XG52YXIgYmVwc2kgPSBcIs+2XCI7XG52YXIgYmVybm91ID0gXCLihKxcIjtcbnZhciBCZXJub3VsbGlzID0gXCLihKxcIjtcbnZhciBCZXRhID0gXCLOklwiO1xudmFyIGJldGEgPSBcIs6yXCI7XG52YXIgYmV0aCA9IFwi4oS2XCI7XG52YXIgYmV0d2VlbiA9IFwi4omsXCI7XG52YXIgQmZyID0gXCLwnZSFXCI7XG52YXIgYmZyID0gXCLwnZSfXCI7XG52YXIgYmlnY2FwID0gXCLii4JcIjtcbnZhciBiaWdjaXJjID0gXCLil69cIjtcbnZhciBiaWdjdXAgPSBcIuKLg1wiO1xudmFyIGJpZ29kb3QgPSBcIuKogFwiO1xudmFyIGJpZ29wbHVzID0gXCLiqIFcIjtcbnZhciBiaWdvdGltZXMgPSBcIuKoglwiO1xudmFyIGJpZ3NxY3VwID0gXCLiqIZcIjtcbnZhciBiaWdzdGFyID0gXCLimIVcIjtcbnZhciBiaWd0cmlhbmdsZWRvd24gPSBcIuKWvVwiO1xudmFyIGJpZ3RyaWFuZ2xldXAgPSBcIuKWs1wiO1xudmFyIGJpZ3VwbHVzID0gXCLiqIRcIjtcbnZhciBiaWd2ZWUgPSBcIuKLgVwiO1xudmFyIGJpZ3dlZGdlID0gXCLii4BcIjtcbnZhciBia2Fyb3cgPSBcIuKkjVwiO1xudmFyIGJsYWNrbG96ZW5nZSA9IFwi4qerXCI7XG52YXIgYmxhY2tzcXVhcmUgPSBcIuKWqlwiO1xudmFyIGJsYWNrdHJpYW5nbGUgPSBcIuKWtFwiO1xudmFyIGJsYWNrdHJpYW5nbGVkb3duID0gXCLilr5cIjtcbnZhciBibGFja3RyaWFuZ2xlbGVmdCA9IFwi4peCXCI7XG52YXIgYmxhY2t0cmlhbmdsZXJpZ2h0ID0gXCLilrhcIjtcbnZhciBibGFuayA9IFwi4pCjXCI7XG52YXIgYmxrMTIgPSBcIuKWklwiO1xudmFyIGJsazE0ID0gXCLilpFcIjtcbnZhciBibGszNCA9IFwi4paTXCI7XG52YXIgYmxvY2sgPSBcIuKWiFwiO1xudmFyIGJuZSA9IFwiPeKDpVwiO1xudmFyIGJuZXF1aXYgPSBcIuKJoeKDpVwiO1xudmFyIGJOb3QgPSBcIuKrrVwiO1xudmFyIGJub3QgPSBcIuKMkFwiO1xudmFyIEJvcGYgPSBcIvCdlLlcIjtcbnZhciBib3BmID0gXCLwnZWTXCI7XG52YXIgYm90ID0gXCLiiqVcIjtcbnZhciBib3R0b20gPSBcIuKKpVwiO1xudmFyIGJvd3RpZSA9IFwi4ouIXCI7XG52YXIgYm94Ym94ID0gXCLip4lcIjtcbnZhciBib3hkbCA9IFwi4pSQXCI7XG52YXIgYm94ZEwgPSBcIuKVlVwiO1xudmFyIGJveERsID0gXCLilZZcIjtcbnZhciBib3hETCA9IFwi4pWXXCI7XG52YXIgYm94ZHIgPSBcIuKUjFwiO1xudmFyIGJveGRSID0gXCLilZJcIjtcbnZhciBib3hEciA9IFwi4pWTXCI7XG52YXIgYm94RFIgPSBcIuKVlFwiO1xudmFyIGJveGggPSBcIuKUgFwiO1xudmFyIGJveEggPSBcIuKVkFwiO1xudmFyIGJveGhkID0gXCLilKxcIjtcbnZhciBib3hIZCA9IFwi4pWkXCI7XG52YXIgYm94aEQgPSBcIuKVpVwiO1xudmFyIGJveEhEID0gXCLilaZcIjtcbnZhciBib3hodSA9IFwi4pS0XCI7XG52YXIgYm94SHUgPSBcIuKVp1wiO1xudmFyIGJveGhVID0gXCLilahcIjtcbnZhciBib3hIVSA9IFwi4pWpXCI7XG52YXIgYm94bWludXMgPSBcIuKKn1wiO1xudmFyIGJveHBsdXMgPSBcIuKKnlwiO1xudmFyIGJveHRpbWVzID0gXCLiiqBcIjtcbnZhciBib3h1bCA9IFwi4pSYXCI7XG52YXIgYm94dUwgPSBcIuKVm1wiO1xudmFyIGJveFVsID0gXCLilZxcIjtcbnZhciBib3hVTCA9IFwi4pWdXCI7XG52YXIgYm94dXIgPSBcIuKUlFwiO1xudmFyIGJveHVSID0gXCLilZhcIjtcbnZhciBib3hVciA9IFwi4pWZXCI7XG52YXIgYm94VVIgPSBcIuKVmlwiO1xudmFyIGJveHYgPSBcIuKUglwiO1xudmFyIGJveFYgPSBcIuKVkVwiO1xudmFyIGJveHZoID0gXCLilLxcIjtcbnZhciBib3h2SCA9IFwi4pWqXCI7XG52YXIgYm94VmggPSBcIuKVq1wiO1xudmFyIGJveFZIID0gXCLilaxcIjtcbnZhciBib3h2bCA9IFwi4pSkXCI7XG52YXIgYm94dkwgPSBcIuKVoVwiO1xudmFyIGJveFZsID0gXCLilaJcIjtcbnZhciBib3hWTCA9IFwi4pWjXCI7XG52YXIgYm94dnIgPSBcIuKUnFwiO1xudmFyIGJveHZSID0gXCLilZ5cIjtcbnZhciBib3hWciA9IFwi4pWfXCI7XG52YXIgYm94VlIgPSBcIuKVoFwiO1xudmFyIGJwcmltZSA9IFwi4oC1XCI7XG52YXIgYnJldmUgPSBcIsuYXCI7XG52YXIgQnJldmUgPSBcIsuYXCI7XG52YXIgYnJ2YmFyJDEgPSBcIsKmXCI7XG52YXIgYnNjciA9IFwi8J2St1wiO1xudmFyIEJzY3IgPSBcIuKErFwiO1xudmFyIGJzZW1pID0gXCLigY9cIjtcbnZhciBic2ltID0gXCLiiL1cIjtcbnZhciBic2ltZSA9IFwi4ouNXCI7XG52YXIgYnNvbGIgPSBcIuKnhVwiO1xudmFyIGJzb2wgPSBcIlxcXFxcIjtcbnZhciBic29saHN1YiA9IFwi4p+IXCI7XG52YXIgYnVsbCA9IFwi4oCiXCI7XG52YXIgYnVsbGV0ID0gXCLigKJcIjtcbnZhciBidW1wID0gXCLiiY5cIjtcbnZhciBidW1wRSA9IFwi4qquXCI7XG52YXIgYnVtcGUgPSBcIuKJj1wiO1xudmFyIEJ1bXBlcSA9IFwi4omOXCI7XG52YXIgYnVtcGVxID0gXCLiiY9cIjtcbnZhciBDYWN1dGUgPSBcIsSGXCI7XG52YXIgY2FjdXRlID0gXCLEh1wiO1xudmFyIGNhcGFuZCA9IFwi4qmEXCI7XG52YXIgY2FwYnJjdXAgPSBcIuKpiVwiO1xudmFyIGNhcGNhcCA9IFwi4qmLXCI7XG52YXIgY2FwID0gXCLiiKlcIjtcbnZhciBDYXAgPSBcIuKLklwiO1xudmFyIGNhcGN1cCA9IFwi4qmHXCI7XG52YXIgY2FwZG90ID0gXCLiqYBcIjtcbnZhciBDYXBpdGFsRGlmZmVyZW50aWFsRCA9IFwi4oWFXCI7XG52YXIgY2FwcyA9IFwi4oip77iAXCI7XG52YXIgY2FyZXQgPSBcIuKBgVwiO1xudmFyIGNhcm9uID0gXCLLh1wiO1xudmFyIENheWxleXMgPSBcIuKErVwiO1xudmFyIGNjYXBzID0gXCLiqY1cIjtcbnZhciBDY2Fyb24gPSBcIsSMXCI7XG52YXIgY2Nhcm9uID0gXCLEjVwiO1xudmFyIENjZWRpbCQxID0gXCLDh1wiO1xudmFyIGNjZWRpbCQxID0gXCLDp1wiO1xudmFyIENjaXJjID0gXCLEiFwiO1xudmFyIGNjaXJjID0gXCLEiVwiO1xudmFyIENjb25pbnQgPSBcIuKIsFwiO1xudmFyIGNjdXBzID0gXCLiqYxcIjtcbnZhciBjY3Vwc3NtID0gXCLiqZBcIjtcbnZhciBDZG90ID0gXCLEilwiO1xudmFyIGNkb3QgPSBcIsSLXCI7XG52YXIgY2VkaWwkMSA9IFwiwrhcIjtcbnZhciBDZWRpbGxhID0gXCLCuFwiO1xudmFyIGNlbXB0eXYgPSBcIuKmslwiO1xudmFyIGNlbnQkMSA9IFwiwqJcIjtcbnZhciBjZW50ZXJkb3QgPSBcIsK3XCI7XG52YXIgQ2VudGVyRG90ID0gXCLCt1wiO1xudmFyIGNmciA9IFwi8J2UoFwiO1xudmFyIENmciA9IFwi4oStXCI7XG52YXIgQ0hjeSA9IFwi0KdcIjtcbnZhciBjaGN5ID0gXCLRh1wiO1xudmFyIGNoZWNrID0gXCLinJNcIjtcbnZhciBjaGVja21hcmsgPSBcIuKck1wiO1xudmFyIENoaSA9IFwizqdcIjtcbnZhciBjaGkgPSBcIs+HXCI7XG52YXIgY2lyYyA9IFwiy4ZcIjtcbnZhciBjaXJjZXEgPSBcIuKJl1wiO1xudmFyIGNpcmNsZWFycm93bGVmdCA9IFwi4oa6XCI7XG52YXIgY2lyY2xlYXJyb3dyaWdodCA9IFwi4oa7XCI7XG52YXIgY2lyY2xlZGFzdCA9IFwi4oqbXCI7XG52YXIgY2lyY2xlZGNpcmMgPSBcIuKKmlwiO1xudmFyIGNpcmNsZWRkYXNoID0gXCLiip1cIjtcbnZhciBDaXJjbGVEb3QgPSBcIuKKmVwiO1xudmFyIGNpcmNsZWRSID0gXCLCrlwiO1xudmFyIGNpcmNsZWRTID0gXCLik4hcIjtcbnZhciBDaXJjbGVNaW51cyA9IFwi4oqWXCI7XG52YXIgQ2lyY2xlUGx1cyA9IFwi4oqVXCI7XG52YXIgQ2lyY2xlVGltZXMgPSBcIuKKl1wiO1xudmFyIGNpciA9IFwi4peLXCI7XG52YXIgY2lyRSA9IFwi4qeDXCI7XG52YXIgY2lyZSA9IFwi4omXXCI7XG52YXIgY2lyZm5pbnQgPSBcIuKokFwiO1xudmFyIGNpcm1pZCA9IFwi4quvXCI7XG52YXIgY2lyc2NpciA9IFwi4qeCXCI7XG52YXIgQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLJcIjtcbnZhciBDbG9zZUN1cmx5RG91YmxlUXVvdGUgPSBcIuKAnVwiO1xudmFyIENsb3NlQ3VybHlRdW90ZSA9IFwi4oCZXCI7XG52YXIgY2x1YnMgPSBcIuKZo1wiO1xudmFyIGNsdWJzdWl0ID0gXCLimaNcIjtcbnZhciBjb2xvbiA9IFwiOlwiO1xudmFyIENvbG9uID0gXCLiiLdcIjtcbnZhciBDb2xvbmUgPSBcIuKptFwiO1xudmFyIGNvbG9uZSA9IFwi4omUXCI7XG52YXIgY29sb25lcSA9IFwi4omUXCI7XG52YXIgY29tbWEgPSBcIixcIjtcbnZhciBjb21tYXQgPSBcIkBcIjtcbnZhciBjb21wID0gXCLiiIFcIjtcbnZhciBjb21wZm4gPSBcIuKImFwiO1xudmFyIGNvbXBsZW1lbnQgPSBcIuKIgVwiO1xudmFyIGNvbXBsZXhlcyA9IFwi4oSCXCI7XG52YXIgY29uZyA9IFwi4omFXCI7XG52YXIgY29uZ2RvdCA9IFwi4qmtXCI7XG52YXIgQ29uZ3J1ZW50ID0gXCLiiaFcIjtcbnZhciBjb25pbnQgPSBcIuKIrlwiO1xudmFyIENvbmludCA9IFwi4oivXCI7XG52YXIgQ29udG91ckludGVncmFsID0gXCLiiK5cIjtcbnZhciBjb3BmID0gXCLwnZWUXCI7XG52YXIgQ29wZiA9IFwi4oSCXCI7XG52YXIgY29wcm9kID0gXCLiiJBcIjtcbnZhciBDb3Byb2R1Y3QgPSBcIuKIkFwiO1xudmFyIGNvcHkkMSA9IFwiwqlcIjtcbnZhciBDT1BZJDEgPSBcIsKpXCI7XG52YXIgY29weXNyID0gXCLihJdcIjtcbnZhciBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsID0gXCLiiLNcIjtcbnZhciBjcmFyciA9IFwi4oa1XCI7XG52YXIgY3Jvc3MgPSBcIuKcl1wiO1xudmFyIENyb3NzID0gXCLiqK9cIjtcbnZhciBDc2NyID0gXCLwnZKeXCI7XG52YXIgY3NjciA9IFwi8J2SuFwiO1xudmFyIGNzdWIgPSBcIuKrj1wiO1xudmFyIGNzdWJlID0gXCLiq5FcIjtcbnZhciBjc3VwID0gXCLiq5BcIjtcbnZhciBjc3VwZSA9IFwi4quSXCI7XG52YXIgY3Rkb3QgPSBcIuKLr1wiO1xudmFyIGN1ZGFycmwgPSBcIuKkuFwiO1xudmFyIGN1ZGFycnIgPSBcIuKktVwiO1xudmFyIGN1ZXByID0gXCLii55cIjtcbnZhciBjdWVzYyA9IFwi4oufXCI7XG52YXIgY3VsYXJyID0gXCLihrZcIjtcbnZhciBjdWxhcnJwID0gXCLipL1cIjtcbnZhciBjdXBicmNhcCA9IFwi4qmIXCI7XG52YXIgY3VwY2FwID0gXCLiqYZcIjtcbnZhciBDdXBDYXAgPSBcIuKJjVwiO1xudmFyIGN1cCA9IFwi4oiqXCI7XG52YXIgQ3VwID0gXCLii5NcIjtcbnZhciBjdXBjdXAgPSBcIuKpilwiO1xudmFyIGN1cGRvdCA9IFwi4oqNXCI7XG52YXIgY3Vwb3IgPSBcIuKphVwiO1xudmFyIGN1cHMgPSBcIuKIqu+4gFwiO1xudmFyIGN1cmFyciA9IFwi4oa3XCI7XG52YXIgY3VyYXJybSA9IFwi4qS8XCI7XG52YXIgY3VybHllcXByZWMgPSBcIuKLnlwiO1xudmFyIGN1cmx5ZXFzdWNjID0gXCLii59cIjtcbnZhciBjdXJseXZlZSA9IFwi4ouOXCI7XG52YXIgY3VybHl3ZWRnZSA9IFwi4ouPXCI7XG52YXIgY3VycmVuJDEgPSBcIsKkXCI7XG52YXIgY3VydmVhcnJvd2xlZnQgPSBcIuKGtlwiO1xudmFyIGN1cnZlYXJyb3dyaWdodCA9IFwi4oa3XCI7XG52YXIgY3V2ZWUgPSBcIuKLjlwiO1xudmFyIGN1d2VkID0gXCLii49cIjtcbnZhciBjd2NvbmludCA9IFwi4oiyXCI7XG52YXIgY3dpbnQgPSBcIuKIsVwiO1xudmFyIGN5bGN0eSA9IFwi4oytXCI7XG52YXIgZGFnZ2VyID0gXCLigKBcIjtcbnZhciBEYWdnZXIgPSBcIuKAoVwiO1xudmFyIGRhbGV0aCA9IFwi4oS4XCI7XG52YXIgZGFyciA9IFwi4oaTXCI7XG52YXIgRGFyciA9IFwi4oahXCI7XG52YXIgZEFyciA9IFwi4oeTXCI7XG52YXIgZGFzaCA9IFwi4oCQXCI7XG52YXIgRGFzaHYgPSBcIuKrpFwiO1xudmFyIGRhc2h2ID0gXCLiiqNcIjtcbnZhciBkYmthcm93ID0gXCLipI9cIjtcbnZhciBkYmxhYyA9IFwiy51cIjtcbnZhciBEY2Fyb24gPSBcIsSOXCI7XG52YXIgZGNhcm9uID0gXCLEj1wiO1xudmFyIERjeSA9IFwi0JRcIjtcbnZhciBkY3kgPSBcItC0XCI7XG52YXIgZGRhZ2dlciA9IFwi4oChXCI7XG52YXIgZGRhcnIgPSBcIuKHilwiO1xudmFyIEREID0gXCLihYVcIjtcbnZhciBkZCA9IFwi4oWGXCI7XG52YXIgRERvdHJhaGQgPSBcIuKkkVwiO1xudmFyIGRkb3RzZXEgPSBcIuKpt1wiO1xudmFyIGRlZyQxID0gXCLCsFwiO1xudmFyIERlbCA9IFwi4oiHXCI7XG52YXIgRGVsdGEgPSBcIs6UXCI7XG52YXIgZGVsdGEgPSBcIs60XCI7XG52YXIgZGVtcHR5diA9IFwi4qaxXCI7XG52YXIgZGZpc2h0ID0gXCLipb9cIjtcbnZhciBEZnIgPSBcIvCdlIdcIjtcbnZhciBkZnIgPSBcIvCdlKFcIjtcbnZhciBkSGFyID0gXCLipaVcIjtcbnZhciBkaGFybCA9IFwi4oeDXCI7XG52YXIgZGhhcnIgPSBcIuKHglwiO1xudmFyIERpYWNyaXRpY2FsQWN1dGUgPSBcIsK0XCI7XG52YXIgRGlhY3JpdGljYWxEb3QgPSBcIsuZXCI7XG52YXIgRGlhY3JpdGljYWxEb3VibGVBY3V0ZSA9IFwiy51cIjtcbnZhciBEaWFjcml0aWNhbEdyYXZlID0gXCJgXCI7XG52YXIgRGlhY3JpdGljYWxUaWxkZSA9IFwiy5xcIjtcbnZhciBkaWFtID0gXCLii4RcIjtcbnZhciBkaWFtb25kID0gXCLii4RcIjtcbnZhciBEaWFtb25kID0gXCLii4RcIjtcbnZhciBkaWFtb25kc3VpdCA9IFwi4pmmXCI7XG52YXIgZGlhbXMgPSBcIuKZplwiO1xudmFyIGRpZSA9IFwiwqhcIjtcbnZhciBEaWZmZXJlbnRpYWxEID0gXCLihYZcIjtcbnZhciBkaWdhbW1hID0gXCLPnVwiO1xudmFyIGRpc2luID0gXCLii7JcIjtcbnZhciBkaXYgPSBcIsO3XCI7XG52YXIgZGl2aWRlJDEgPSBcIsO3XCI7XG52YXIgZGl2aWRlb250aW1lcyA9IFwi4ouHXCI7XG52YXIgZGl2b254ID0gXCLii4dcIjtcbnZhciBESmN5ID0gXCLQglwiO1xudmFyIGRqY3kgPSBcItGSXCI7XG52YXIgZGxjb3JuID0gXCLijJ5cIjtcbnZhciBkbGNyb3AgPSBcIuKMjVwiO1xudmFyIGRvbGxhciA9IFwiJFwiO1xudmFyIERvcGYgPSBcIvCdlLtcIjtcbnZhciBkb3BmID0gXCLwnZWVXCI7XG52YXIgRG90ID0gXCLCqFwiO1xudmFyIGRvdCA9IFwiy5lcIjtcbnZhciBEb3REb3QgPSBcIuKDnFwiO1xudmFyIGRvdGVxID0gXCLiiZBcIjtcbnZhciBkb3RlcWRvdCA9IFwi4omRXCI7XG52YXIgRG90RXF1YWwgPSBcIuKJkFwiO1xudmFyIGRvdG1pbnVzID0gXCLiiLhcIjtcbnZhciBkb3RwbHVzID0gXCLiiJRcIjtcbnZhciBkb3RzcXVhcmUgPSBcIuKKoVwiO1xudmFyIGRvdWJsZWJhcndlZGdlID0gXCLijIZcIjtcbnZhciBEb3VibGVDb250b3VySW50ZWdyYWwgPSBcIuKIr1wiO1xudmFyIERvdWJsZURvdCA9IFwiwqhcIjtcbnZhciBEb3VibGVEb3duQXJyb3cgPSBcIuKHk1wiO1xudmFyIERvdWJsZUxlZnRBcnJvdyA9IFwi4oeQXCI7XG52YXIgRG91YmxlTGVmdFJpZ2h0QXJyb3cgPSBcIuKHlFwiO1xudmFyIERvdWJsZUxlZnRUZWUgPSBcIuKrpFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0QXJyb3cgPSBcIuKfuFwiO1xudmFyIERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyA9IFwi4p+6XCI7XG52YXIgRG91YmxlTG9uZ1JpZ2h0QXJyb3cgPSBcIuKfuVwiO1xudmFyIERvdWJsZVJpZ2h0QXJyb3cgPSBcIuKHklwiO1xudmFyIERvdWJsZVJpZ2h0VGVlID0gXCLiiqhcIjtcbnZhciBEb3VibGVVcEFycm93ID0gXCLih5FcIjtcbnZhciBEb3VibGVVcERvd25BcnJvdyA9IFwi4oeVXCI7XG52YXIgRG91YmxlVmVydGljYWxCYXIgPSBcIuKIpVwiO1xudmFyIERvd25BcnJvd0JhciA9IFwi4qSTXCI7XG52YXIgZG93bmFycm93ID0gXCLihpNcIjtcbnZhciBEb3duQXJyb3cgPSBcIuKGk1wiO1xudmFyIERvd25hcnJvdyA9IFwi4oeTXCI7XG52YXIgRG93bkFycm93VXBBcnJvdyA9IFwi4oe1XCI7XG52YXIgRG93bkJyZXZlID0gXCLMkVwiO1xudmFyIGRvd25kb3duYXJyb3dzID0gXCLih4pcIjtcbnZhciBkb3duaGFycG9vbmxlZnQgPSBcIuKHg1wiO1xudmFyIGRvd25oYXJwb29ucmlnaHQgPSBcIuKHglwiO1xudmFyIERvd25MZWZ0UmlnaHRWZWN0b3IgPSBcIuKlkFwiO1xudmFyIERvd25MZWZ0VGVlVmVjdG9yID0gXCLipZ5cIjtcbnZhciBEb3duTGVmdFZlY3RvckJhciA9IFwi4qWWXCI7XG52YXIgRG93bkxlZnRWZWN0b3IgPSBcIuKGvVwiO1xudmFyIERvd25SaWdodFRlZVZlY3RvciA9IFwi4qWfXCI7XG52YXIgRG93blJpZ2h0VmVjdG9yQmFyID0gXCLipZdcIjtcbnZhciBEb3duUmlnaHRWZWN0b3IgPSBcIuKHgVwiO1xudmFyIERvd25UZWVBcnJvdyA9IFwi4oanXCI7XG52YXIgRG93blRlZSA9IFwi4oqkXCI7XG52YXIgZHJia2Fyb3cgPSBcIuKkkFwiO1xudmFyIGRyY29ybiA9IFwi4oyfXCI7XG52YXIgZHJjcm9wID0gXCLijIxcIjtcbnZhciBEc2NyID0gXCLwnZKfXCI7XG52YXIgZHNjciA9IFwi8J2SuVwiO1xudmFyIERTY3kgPSBcItCFXCI7XG52YXIgZHNjeSA9IFwi0ZVcIjtcbnZhciBkc29sID0gXCLip7ZcIjtcbnZhciBEc3Ryb2sgPSBcIsSQXCI7XG52YXIgZHN0cm9rID0gXCLEkVwiO1xudmFyIGR0ZG90ID0gXCLii7FcIjtcbnZhciBkdHJpID0gXCLilr9cIjtcbnZhciBkdHJpZiA9IFwi4pa+XCI7XG52YXIgZHVhcnIgPSBcIuKHtVwiO1xudmFyIGR1aGFyID0gXCLipa9cIjtcbnZhciBkd2FuZ2xlID0gXCLipqZcIjtcbnZhciBEWmN5ID0gXCLQj1wiO1xudmFyIGR6Y3kgPSBcItGfXCI7XG52YXIgZHppZ3JhcnIgPSBcIuKfv1wiO1xudmFyIEVhY3V0ZSQxID0gXCLDiVwiO1xudmFyIGVhY3V0ZSQxID0gXCLDqVwiO1xudmFyIGVhc3RlciA9IFwi4qmuXCI7XG52YXIgRWNhcm9uID0gXCLEmlwiO1xudmFyIGVjYXJvbiA9IFwixJtcIjtcbnZhciBFY2lyYyQxID0gXCLDilwiO1xudmFyIGVjaXJjJDEgPSBcIsOqXCI7XG52YXIgZWNpciA9IFwi4omWXCI7XG52YXIgZWNvbG9uID0gXCLiiZVcIjtcbnZhciBFY3kgPSBcItCtXCI7XG52YXIgZWN5ID0gXCLRjVwiO1xudmFyIGVERG90ID0gXCLiqbdcIjtcbnZhciBFZG90ID0gXCLEllwiO1xudmFyIGVkb3QgPSBcIsSXXCI7XG52YXIgZURvdCA9IFwi4omRXCI7XG52YXIgZWUgPSBcIuKFh1wiO1xudmFyIGVmRG90ID0gXCLiiZJcIjtcbnZhciBFZnIgPSBcIvCdlIhcIjtcbnZhciBlZnIgPSBcIvCdlKJcIjtcbnZhciBlZyA9IFwi4qqaXCI7XG52YXIgRWdyYXZlJDEgPSBcIsOIXCI7XG52YXIgZWdyYXZlJDEgPSBcIsOoXCI7XG52YXIgZWdzID0gXCLiqpZcIjtcbnZhciBlZ3Nkb3QgPSBcIuKqmFwiO1xudmFyIGVsID0gXCLiqplcIjtcbnZhciBFbGVtZW50ID0gXCLiiIhcIjtcbnZhciBlbGludGVycyA9IFwi4o+nXCI7XG52YXIgZWxsID0gXCLihJNcIjtcbnZhciBlbHMgPSBcIuKqlVwiO1xudmFyIGVsc2RvdCA9IFwi4qqXXCI7XG52YXIgRW1hY3IgPSBcIsSSXCI7XG52YXIgZW1hY3IgPSBcIsSTXCI7XG52YXIgZW1wdHkgPSBcIuKIhVwiO1xudmFyIGVtcHR5c2V0ID0gXCLiiIVcIjtcbnZhciBFbXB0eVNtYWxsU3F1YXJlID0gXCLil7tcIjtcbnZhciBlbXB0eXYgPSBcIuKIhVwiO1xudmFyIEVtcHR5VmVyeVNtYWxsU3F1YXJlID0gXCLilqtcIjtcbnZhciBlbXNwMTMgPSBcIuKAhFwiO1xudmFyIGVtc3AxNCA9IFwi4oCFXCI7XG52YXIgZW1zcCA9IFwi4oCDXCI7XG52YXIgRU5HID0gXCLFilwiO1xudmFyIGVuZyA9IFwixYtcIjtcbnZhciBlbnNwID0gXCLigIJcIjtcbnZhciBFb2dvbiA9IFwixJhcIjtcbnZhciBlb2dvbiA9IFwixJlcIjtcbnZhciBFb3BmID0gXCLwnZS8XCI7XG52YXIgZW9wZiA9IFwi8J2VllwiO1xudmFyIGVwYXIgPSBcIuKLlVwiO1xudmFyIGVwYXJzbCA9IFwi4qejXCI7XG52YXIgZXBsdXMgPSBcIuKpsVwiO1xudmFyIGVwc2kgPSBcIs61XCI7XG52YXIgRXBzaWxvbiA9IFwizpVcIjtcbnZhciBlcHNpbG9uID0gXCLOtVwiO1xudmFyIGVwc2l2ID0gXCLPtVwiO1xudmFyIGVxY2lyYyA9IFwi4omWXCI7XG52YXIgZXFjb2xvbiA9IFwi4omVXCI7XG52YXIgZXFzaW0gPSBcIuKJglwiO1xudmFyIGVxc2xhbnRndHIgPSBcIuKqllwiO1xudmFyIGVxc2xhbnRsZXNzID0gXCLiqpVcIjtcbnZhciBFcXVhbCA9IFwi4qm1XCI7XG52YXIgZXF1YWxzID0gXCI9XCI7XG52YXIgRXF1YWxUaWxkZSA9IFwi4omCXCI7XG52YXIgZXF1ZXN0ID0gXCLiiZ9cIjtcbnZhciBFcXVpbGlicml1bSA9IFwi4oeMXCI7XG52YXIgZXF1aXYgPSBcIuKJoVwiO1xudmFyIGVxdWl2REQgPSBcIuKpuFwiO1xudmFyIGVxdnBhcnNsID0gXCLip6VcIjtcbnZhciBlcmFyciA9IFwi4qWxXCI7XG52YXIgZXJEb3QgPSBcIuKJk1wiO1xudmFyIGVzY3IgPSBcIuKEr1wiO1xudmFyIEVzY3IgPSBcIuKEsFwiO1xudmFyIGVzZG90ID0gXCLiiZBcIjtcbnZhciBFc2ltID0gXCLiqbNcIjtcbnZhciBlc2ltID0gXCLiiYJcIjtcbnZhciBFdGEgPSBcIs6XXCI7XG52YXIgZXRhID0gXCLOt1wiO1xudmFyIEVUSCQxID0gXCLDkFwiO1xudmFyIGV0aCQxID0gXCLDsFwiO1xudmFyIEV1bWwkMSA9IFwiw4tcIjtcbnZhciBldW1sJDEgPSBcIsOrXCI7XG52YXIgZXVybyA9IFwi4oKsXCI7XG52YXIgZXhjbCA9IFwiIVwiO1xudmFyIGV4aXN0ID0gXCLiiINcIjtcbnZhciBFeGlzdHMgPSBcIuKIg1wiO1xudmFyIGV4cGVjdGF0aW9uID0gXCLihLBcIjtcbnZhciBleHBvbmVudGlhbGUgPSBcIuKFh1wiO1xudmFyIEV4cG9uZW50aWFsRSA9IFwi4oWHXCI7XG52YXIgZmFsbGluZ2RvdHNlcSA9IFwi4omSXCI7XG52YXIgRmN5ID0gXCLQpFwiO1xudmFyIGZjeSA9IFwi0YRcIjtcbnZhciBmZW1hbGUgPSBcIuKZgFwiO1xudmFyIGZmaWxpZyA9IFwi76yDXCI7XG52YXIgZmZsaWcgPSBcIu+sgFwiO1xudmFyIGZmbGxpZyA9IFwi76yEXCI7XG52YXIgRmZyID0gXCLwnZSJXCI7XG52YXIgZmZyID0gXCLwnZSjXCI7XG52YXIgZmlsaWcgPSBcIu+sgVwiO1xudmFyIEZpbGxlZFNtYWxsU3F1YXJlID0gXCLil7xcIjtcbnZhciBGaWxsZWRWZXJ5U21hbGxTcXVhcmUgPSBcIuKWqlwiO1xudmFyIGZqbGlnID0gXCJmalwiO1xudmFyIGZsYXQgPSBcIuKZrVwiO1xudmFyIGZsbGlnID0gXCLvrIJcIjtcbnZhciBmbHRucyA9IFwi4paxXCI7XG52YXIgZm5vZiA9IFwixpJcIjtcbnZhciBGb3BmID0gXCLwnZS9XCI7XG52YXIgZm9wZiA9IFwi8J2Vl1wiO1xudmFyIGZvcmFsbCA9IFwi4oiAXCI7XG52YXIgRm9yQWxsID0gXCLiiIBcIjtcbnZhciBmb3JrID0gXCLii5RcIjtcbnZhciBmb3JrdiA9IFwi4quZXCI7XG52YXIgRm91cmllcnRyZiA9IFwi4oSxXCI7XG52YXIgZnBhcnRpbnQgPSBcIuKojVwiO1xudmFyIGZyYWMxMiQxID0gXCLCvVwiO1xudmFyIGZyYWMxMyA9IFwi4oWTXCI7XG52YXIgZnJhYzE0JDEgPSBcIsK8XCI7XG52YXIgZnJhYzE1ID0gXCLihZVcIjtcbnZhciBmcmFjMTYgPSBcIuKFmVwiO1xudmFyIGZyYWMxOCA9IFwi4oWbXCI7XG52YXIgZnJhYzIzID0gXCLihZRcIjtcbnZhciBmcmFjMjUgPSBcIuKFllwiO1xudmFyIGZyYWMzNCQxID0gXCLCvlwiO1xudmFyIGZyYWMzNSA9IFwi4oWXXCI7XG52YXIgZnJhYzM4ID0gXCLihZxcIjtcbnZhciBmcmFjNDUgPSBcIuKFmFwiO1xudmFyIGZyYWM1NiA9IFwi4oWaXCI7XG52YXIgZnJhYzU4ID0gXCLihZ1cIjtcbnZhciBmcmFjNzggPSBcIuKFnlwiO1xudmFyIGZyYXNsID0gXCLigYRcIjtcbnZhciBmcm93biA9IFwi4oyiXCI7XG52YXIgZnNjciA9IFwi8J2Su1wiO1xudmFyIEZzY3IgPSBcIuKEsVwiO1xudmFyIGdhY3V0ZSA9IFwix7VcIjtcbnZhciBHYW1tYSA9IFwizpNcIjtcbnZhciBnYW1tYSA9IFwizrNcIjtcbnZhciBHYW1tYWQgPSBcIs+cXCI7XG52YXIgZ2FtbWFkID0gXCLPnVwiO1xudmFyIGdhcCA9IFwi4qqGXCI7XG52YXIgR2JyZXZlID0gXCLEnlwiO1xudmFyIGdicmV2ZSA9IFwixJ9cIjtcbnZhciBHY2VkaWwgPSBcIsSiXCI7XG52YXIgR2NpcmMgPSBcIsScXCI7XG52YXIgZ2NpcmMgPSBcIsSdXCI7XG52YXIgR2N5ID0gXCLQk1wiO1xudmFyIGdjeSA9IFwi0LNcIjtcbnZhciBHZG90ID0gXCLEoFwiO1xudmFyIGdkb3QgPSBcIsShXCI7XG52YXIgZ2UgPSBcIuKJpVwiO1xudmFyIGdFID0gXCLiiadcIjtcbnZhciBnRWwgPSBcIuKqjFwiO1xudmFyIGdlbCA9IFwi4oubXCI7XG52YXIgZ2VxID0gXCLiiaVcIjtcbnZhciBnZXFxID0gXCLiiadcIjtcbnZhciBnZXFzbGFudCA9IFwi4qm+XCI7XG52YXIgZ2VzY2MgPSBcIuKqqVwiO1xudmFyIGdlcyA9IFwi4qm+XCI7XG52YXIgZ2VzZG90ID0gXCLiqoBcIjtcbnZhciBnZXNkb3RvID0gXCLiqoJcIjtcbnZhciBnZXNkb3RvbCA9IFwi4qqEXCI7XG52YXIgZ2VzbCA9IFwi4oub77iAXCI7XG52YXIgZ2VzbGVzID0gXCLiqpRcIjtcbnZhciBHZnIgPSBcIvCdlIpcIjtcbnZhciBnZnIgPSBcIvCdlKRcIjtcbnZhciBnZyA9IFwi4omrXCI7XG52YXIgR2cgPSBcIuKLmVwiO1xudmFyIGdnZyA9IFwi4ouZXCI7XG52YXIgZ2ltZWwgPSBcIuKEt1wiO1xudmFyIEdKY3kgPSBcItCDXCI7XG52YXIgZ2pjeSA9IFwi0ZNcIjtcbnZhciBnbGEgPSBcIuKqpVwiO1xudmFyIGdsID0gXCLiibdcIjtcbnZhciBnbEUgPSBcIuKqklwiO1xudmFyIGdsaiA9IFwi4qqkXCI7XG52YXIgZ25hcCA9IFwi4qqKXCI7XG52YXIgZ25hcHByb3ggPSBcIuKqilwiO1xudmFyIGduZSA9IFwi4qqIXCI7XG52YXIgZ25FID0gXCLiialcIjtcbnZhciBnbmVxID0gXCLiqohcIjtcbnZhciBnbmVxcSA9IFwi4ompXCI7XG52YXIgZ25zaW0gPSBcIuKLp1wiO1xudmFyIEdvcGYgPSBcIvCdlL5cIjtcbnZhciBnb3BmID0gXCLwnZWYXCI7XG52YXIgZ3JhdmUgPSBcImBcIjtcbnZhciBHcmVhdGVyRXF1YWwgPSBcIuKJpVwiO1xudmFyIEdyZWF0ZXJFcXVhbExlc3MgPSBcIuKLm1wiO1xudmFyIEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp1wiO1xudmFyIEdyZWF0ZXJHcmVhdGVyID0gXCLiqqJcIjtcbnZhciBHcmVhdGVyTGVzcyA9IFwi4om3XCI7XG52YXIgR3JlYXRlclNsYW50RXF1YWwgPSBcIuKpvlwiO1xudmFyIEdyZWF0ZXJUaWxkZSA9IFwi4omzXCI7XG52YXIgR3NjciA9IFwi8J2SolwiO1xudmFyIGdzY3IgPSBcIuKEilwiO1xudmFyIGdzaW0gPSBcIuKJs1wiO1xudmFyIGdzaW1lID0gXCLiqo5cIjtcbnZhciBnc2ltbCA9IFwi4qqQXCI7XG52YXIgZ3RjYyA9IFwi4qqnXCI7XG52YXIgZ3RjaXIgPSBcIuKpulwiO1xudmFyIGd0JDIgPSBcIj5cIjtcbnZhciBHVCQxID0gXCI+XCI7XG52YXIgR3QgPSBcIuKJq1wiO1xudmFyIGd0ZG90ID0gXCLii5dcIjtcbnZhciBndGxQYXIgPSBcIuKmlVwiO1xudmFyIGd0cXVlc3QgPSBcIuKpvFwiO1xudmFyIGd0cmFwcHJveCA9IFwi4qqGXCI7XG52YXIgZ3RyYXJyID0gXCLipbhcIjtcbnZhciBndHJkb3QgPSBcIuKLl1wiO1xudmFyIGd0cmVxbGVzcyA9IFwi4oubXCI7XG52YXIgZ3RyZXFxbGVzcyA9IFwi4qqMXCI7XG52YXIgZ3RybGVzcyA9IFwi4om3XCI7XG52YXIgZ3Ryc2ltID0gXCLiibNcIjtcbnZhciBndmVydG5lcXEgPSBcIuKJqe+4gFwiO1xudmFyIGd2bkUgPSBcIuKJqe+4gFwiO1xudmFyIEhhY2VrID0gXCLLh1wiO1xudmFyIGhhaXJzcCA9IFwi4oCKXCI7XG52YXIgaGFsZiA9IFwiwr1cIjtcbnZhciBoYW1pbHQgPSBcIuKEi1wiO1xudmFyIEhBUkRjeSA9IFwi0KpcIjtcbnZhciBoYXJkY3kgPSBcItGKXCI7XG52YXIgaGFycmNpciA9IFwi4qWIXCI7XG52YXIgaGFyciA9IFwi4oaUXCI7XG52YXIgaEFyciA9IFwi4oeUXCI7XG52YXIgaGFycncgPSBcIuKGrVwiO1xudmFyIEhhdCA9IFwiXlwiO1xudmFyIGhiYXIgPSBcIuKEj1wiO1xudmFyIEhjaXJjID0gXCLEpFwiO1xudmFyIGhjaXJjID0gXCLEpVwiO1xudmFyIGhlYXJ0cyA9IFwi4pmlXCI7XG52YXIgaGVhcnRzdWl0ID0gXCLimaVcIjtcbnZhciBoZWxsaXAgPSBcIuKAplwiO1xudmFyIGhlcmNvbiA9IFwi4oq5XCI7XG52YXIgaGZyID0gXCLwnZSlXCI7XG52YXIgSGZyID0gXCLihIxcIjtcbnZhciBIaWxiZXJ0U3BhY2UgPSBcIuKEi1wiO1xudmFyIGhrc2Vhcm93ID0gXCLipKVcIjtcbnZhciBoa3N3YXJvdyA9IFwi4qSmXCI7XG52YXIgaG9hcnIgPSBcIuKHv1wiO1xudmFyIGhvbXRodCA9IFwi4oi7XCI7XG52YXIgaG9va2xlZnRhcnJvdyA9IFwi4oapXCI7XG52YXIgaG9va3JpZ2h0YXJyb3cgPSBcIuKGqlwiO1xudmFyIGhvcGYgPSBcIvCdlZlcIjtcbnZhciBIb3BmID0gXCLihI1cIjtcbnZhciBob3JiYXIgPSBcIuKAlVwiO1xudmFyIEhvcml6b250YWxMaW5lID0gXCLilIBcIjtcbnZhciBoc2NyID0gXCLwnZK9XCI7XG52YXIgSHNjciA9IFwi4oSLXCI7XG52YXIgaHNsYXNoID0gXCLihI9cIjtcbnZhciBIc3Ryb2sgPSBcIsSmXCI7XG52YXIgaHN0cm9rID0gXCLEp1wiO1xudmFyIEh1bXBEb3duSHVtcCA9IFwi4omOXCI7XG52YXIgSHVtcEVxdWFsID0gXCLiiY9cIjtcbnZhciBoeWJ1bGwgPSBcIuKBg1wiO1xudmFyIGh5cGhlbiA9IFwi4oCQXCI7XG52YXIgSWFjdXRlJDEgPSBcIsONXCI7XG52YXIgaWFjdXRlJDEgPSBcIsOtXCI7XG52YXIgaWMgPSBcIuKBo1wiO1xudmFyIEljaXJjJDEgPSBcIsOOXCI7XG52YXIgaWNpcmMkMSA9IFwiw65cIjtcbnZhciBJY3kgPSBcItCYXCI7XG52YXIgaWN5ID0gXCLQuFwiO1xudmFyIElkb3QgPSBcIsSwXCI7XG52YXIgSUVjeSA9IFwi0JVcIjtcbnZhciBpZWN5ID0gXCLQtVwiO1xudmFyIGlleGNsJDEgPSBcIsKhXCI7XG52YXIgaWZmID0gXCLih5RcIjtcbnZhciBpZnIgPSBcIvCdlKZcIjtcbnZhciBJZnIgPSBcIuKEkVwiO1xudmFyIElncmF2ZSQxID0gXCLDjFwiO1xudmFyIGlncmF2ZSQxID0gXCLDrFwiO1xudmFyIGlpID0gXCLihYhcIjtcbnZhciBpaWlpbnQgPSBcIuKojFwiO1xudmFyIGlpaW50ID0gXCLiiK1cIjtcbnZhciBpaW5maW4gPSBcIuKnnFwiO1xudmFyIGlpb3RhID0gXCLihKlcIjtcbnZhciBJSmxpZyA9IFwixLJcIjtcbnZhciBpamxpZyA9IFwixLNcIjtcbnZhciBJbWFjciA9IFwixKpcIjtcbnZhciBpbWFjciA9IFwixKtcIjtcbnZhciBlc21faW1hZ2UgPSBcIuKEkVwiO1xudmFyIEltYWdpbmFyeUkgPSBcIuKFiFwiO1xudmFyIGltYWdsaW5lID0gXCLihJBcIjtcbnZhciBpbWFncGFydCA9IFwi4oSRXCI7XG52YXIgaW1hdGggPSBcIsSxXCI7XG52YXIgSW0gPSBcIuKEkVwiO1xudmFyIGltb2YgPSBcIuKKt1wiO1xudmFyIGltcGVkID0gXCLGtVwiO1xudmFyIEltcGxpZXMgPSBcIuKHklwiO1xudmFyIGluY2FyZSA9IFwi4oSFXCI7XG52YXIgaW5maW4gPSBcIuKInlwiO1xudmFyIGluZmludGllID0gXCLip51cIjtcbnZhciBpbm9kb3QgPSBcIsSxXCI7XG52YXIgaW50Y2FsID0gXCLiirpcIjtcbnZhciBlc21faW50ID0gXCLiiKtcIjtcbnZhciBJbnQgPSBcIuKIrFwiO1xudmFyIGludGVnZXJzID0gXCLihKRcIjtcbnZhciBJbnRlZ3JhbCA9IFwi4oirXCI7XG52YXIgaW50ZXJjYWwgPSBcIuKKulwiO1xudmFyIEludGVyc2VjdGlvbiA9IFwi4ouCXCI7XG52YXIgaW50bGFyaGsgPSBcIuKol1wiO1xudmFyIGludHByb2QgPSBcIuKovFwiO1xudmFyIEludmlzaWJsZUNvbW1hID0gXCLigaNcIjtcbnZhciBJbnZpc2libGVUaW1lcyA9IFwi4oGiXCI7XG52YXIgSU9jeSA9IFwi0IFcIjtcbnZhciBpb2N5ID0gXCLRkVwiO1xudmFyIElvZ29uID0gXCLErlwiO1xudmFyIGlvZ29uID0gXCLEr1wiO1xudmFyIElvcGYgPSBcIvCdlYBcIjtcbnZhciBpb3BmID0gXCLwnZWaXCI7XG52YXIgSW90YSA9IFwizplcIjtcbnZhciBpb3RhID0gXCLOuVwiO1xudmFyIGlwcm9kID0gXCLiqLxcIjtcbnZhciBpcXVlc3QkMSA9IFwiwr9cIjtcbnZhciBpc2NyID0gXCLwnZK+XCI7XG52YXIgSXNjciA9IFwi4oSQXCI7XG52YXIgaXNpbiA9IFwi4oiIXCI7XG52YXIgaXNpbmRvdCA9IFwi4ou1XCI7XG52YXIgaXNpbkUgPSBcIuKLuVwiO1xudmFyIGlzaW5zID0gXCLii7RcIjtcbnZhciBpc2luc3YgPSBcIuKLs1wiO1xudmFyIGlzaW52ID0gXCLiiIhcIjtcbnZhciBpdCA9IFwi4oGiXCI7XG52YXIgSXRpbGRlID0gXCLEqFwiO1xudmFyIGl0aWxkZSA9IFwixKlcIjtcbnZhciBJdWtjeSA9IFwi0IZcIjtcbnZhciBpdWtjeSA9IFwi0ZZcIjtcbnZhciBJdW1sJDEgPSBcIsOPXCI7XG52YXIgaXVtbCQxID0gXCLDr1wiO1xudmFyIEpjaXJjID0gXCLEtFwiO1xudmFyIGpjaXJjID0gXCLEtVwiO1xudmFyIEpjeSA9IFwi0JlcIjtcbnZhciBqY3kgPSBcItC5XCI7XG52YXIgSmZyID0gXCLwnZSNXCI7XG52YXIgamZyID0gXCLwnZSnXCI7XG52YXIgam1hdGggPSBcIsi3XCI7XG52YXIgSm9wZiA9IFwi8J2VgVwiO1xudmFyIGpvcGYgPSBcIvCdlZtcIjtcbnZhciBKc2NyID0gXCLwnZKlXCI7XG52YXIganNjciA9IFwi8J2Sv1wiO1xudmFyIEpzZXJjeSA9IFwi0IhcIjtcbnZhciBqc2VyY3kgPSBcItGYXCI7XG52YXIgSnVrY3kgPSBcItCEXCI7XG52YXIganVrY3kgPSBcItGUXCI7XG52YXIgS2FwcGEgPSBcIs6aXCI7XG52YXIga2FwcGEgPSBcIs66XCI7XG52YXIga2FwcGF2ID0gXCLPsFwiO1xudmFyIEtjZWRpbCA9IFwixLZcIjtcbnZhciBrY2VkaWwgPSBcIsS3XCI7XG52YXIgS2N5ID0gXCLQmlwiO1xudmFyIGtjeSA9IFwi0LpcIjtcbnZhciBLZnIgPSBcIvCdlI5cIjtcbnZhciBrZnIgPSBcIvCdlKhcIjtcbnZhciBrZ3JlZW4gPSBcIsS4XCI7XG52YXIgS0hjeSA9IFwi0KVcIjtcbnZhciBraGN5ID0gXCLRhVwiO1xudmFyIEtKY3kgPSBcItCMXCI7XG52YXIga2pjeSA9IFwi0ZxcIjtcbnZhciBLb3BmID0gXCLwnZWCXCI7XG52YXIga29wZiA9IFwi8J2VnFwiO1xudmFyIEtzY3IgPSBcIvCdkqZcIjtcbnZhciBrc2NyID0gXCLwnZOAXCI7XG52YXIgbEFhcnIgPSBcIuKHmlwiO1xudmFyIExhY3V0ZSA9IFwixLlcIjtcbnZhciBsYWN1dGUgPSBcIsS6XCI7XG52YXIgbGFlbXB0eXYgPSBcIuKmtFwiO1xudmFyIGxhZ3JhbiA9IFwi4oSSXCI7XG52YXIgTGFtYmRhID0gXCLOm1wiO1xudmFyIGxhbWJkYSA9IFwizrtcIjtcbnZhciBsYW5nID0gXCLin6hcIjtcbnZhciBMYW5nID0gXCLin6pcIjtcbnZhciBsYW5nZCA9IFwi4qaRXCI7XG52YXIgbGFuZ2xlID0gXCLin6hcIjtcbnZhciBsYXAgPSBcIuKqhVwiO1xudmFyIExhcGxhY2V0cmYgPSBcIuKEklwiO1xudmFyIGxhcXVvJDEgPSBcIsKrXCI7XG52YXIgbGFycmIgPSBcIuKHpFwiO1xudmFyIGxhcnJiZnMgPSBcIuKkn1wiO1xudmFyIGxhcnIgPSBcIuKGkFwiO1xudmFyIExhcnIgPSBcIuKGnlwiO1xudmFyIGxBcnIgPSBcIuKHkFwiO1xudmFyIGxhcnJmcyA9IFwi4qSdXCI7XG52YXIgbGFycmhrID0gXCLihqlcIjtcbnZhciBsYXJybHAgPSBcIuKGq1wiO1xudmFyIGxhcnJwbCA9IFwi4qS5XCI7XG52YXIgbGFycnNpbSA9IFwi4qWzXCI7XG52YXIgbGFycnRsID0gXCLihqJcIjtcbnZhciBsYXRhaWwgPSBcIuKkmVwiO1xudmFyIGxBdGFpbCA9IFwi4qSbXCI7XG52YXIgbGF0ID0gXCLiqqtcIjtcbnZhciBsYXRlID0gXCLiqq1cIjtcbnZhciBsYXRlcyA9IFwi4qqt77iAXCI7XG52YXIgbGJhcnIgPSBcIuKkjFwiO1xudmFyIGxCYXJyID0gXCLipI5cIjtcbnZhciBsYmJyayA9IFwi4p2yXCI7XG52YXIgbGJyYWNlID0gXCJ7XCI7XG52YXIgbGJyYWNrID0gXCJbXCI7XG52YXIgbGJya2UgPSBcIuKmi1wiO1xudmFyIGxicmtzbGQgPSBcIuKmj1wiO1xudmFyIGxicmtzbHUgPSBcIuKmjVwiO1xudmFyIExjYXJvbiA9IFwixL1cIjtcbnZhciBsY2Fyb24gPSBcIsS+XCI7XG52YXIgTGNlZGlsID0gXCLEu1wiO1xudmFyIGxjZWRpbCA9IFwixLxcIjtcbnZhciBsY2VpbCA9IFwi4oyIXCI7XG52YXIgbGN1YiA9IFwie1wiO1xudmFyIExjeSA9IFwi0JtcIjtcbnZhciBsY3kgPSBcItC7XCI7XG52YXIgbGRjYSA9IFwi4qS2XCI7XG52YXIgbGRxdW8gPSBcIuKAnFwiO1xudmFyIGxkcXVvciA9IFwi4oCeXCI7XG52YXIgbGRyZGhhciA9IFwi4qWnXCI7XG52YXIgbGRydXNoYXIgPSBcIuKli1wiO1xudmFyIGxkc2ggPSBcIuKGslwiO1xudmFyIGxlID0gXCLiiaRcIjtcbnZhciBsRSA9IFwi4ommXCI7XG52YXIgTGVmdEFuZ2xlQnJhY2tldCA9IFwi4p+oXCI7XG52YXIgTGVmdEFycm93QmFyID0gXCLih6RcIjtcbnZhciBsZWZ0YXJyb3cgPSBcIuKGkFwiO1xudmFyIExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgTGVmdGFycm93ID0gXCLih5BcIjtcbnZhciBMZWZ0QXJyb3dSaWdodEFycm93ID0gXCLih4ZcIjtcbnZhciBsZWZ0YXJyb3d0YWlsID0gXCLihqJcIjtcbnZhciBMZWZ0Q2VpbGluZyA9IFwi4oyIXCI7XG52YXIgTGVmdERvdWJsZUJyYWNrZXQgPSBcIuKfplwiO1xudmFyIExlZnREb3duVGVlVmVjdG9yID0gXCLipaFcIjtcbnZhciBMZWZ0RG93blZlY3RvckJhciA9IFwi4qWZXCI7XG52YXIgTGVmdERvd25WZWN0b3IgPSBcIuKHg1wiO1xudmFyIExlZnRGbG9vciA9IFwi4oyKXCI7XG52YXIgbGVmdGhhcnBvb25kb3duID0gXCLihr1cIjtcbnZhciBsZWZ0aGFycG9vbnVwID0gXCLihrxcIjtcbnZhciBsZWZ0bGVmdGFycm93cyA9IFwi4oeHXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3cgPSBcIuKGlFwiO1xudmFyIExlZnRSaWdodEFycm93ID0gXCLihpRcIjtcbnZhciBMZWZ0cmlnaHRhcnJvdyA9IFwi4oeUXCI7XG52YXIgbGVmdHJpZ2h0YXJyb3dzID0gXCLih4ZcIjtcbnZhciBsZWZ0cmlnaHRoYXJwb29ucyA9IFwi4oeLXCI7XG52YXIgbGVmdHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oatXCI7XG52YXIgTGVmdFJpZ2h0VmVjdG9yID0gXCLipY5cIjtcbnZhciBMZWZ0VGVlQXJyb3cgPSBcIuKGpFwiO1xudmFyIExlZnRUZWUgPSBcIuKKo1wiO1xudmFyIExlZnRUZWVWZWN0b3IgPSBcIuKlmlwiO1xudmFyIGxlZnR0aHJlZXRpbWVzID0gXCLii4tcIjtcbnZhciBMZWZ0VHJpYW5nbGVCYXIgPSBcIuKnj1wiO1xudmFyIExlZnRUcmlhbmdsZSA9IFwi4oqyXCI7XG52YXIgTGVmdFRyaWFuZ2xlRXF1YWwgPSBcIuKKtFwiO1xudmFyIExlZnRVcERvd25WZWN0b3IgPSBcIuKlkVwiO1xudmFyIExlZnRVcFRlZVZlY3RvciA9IFwi4qWgXCI7XG52YXIgTGVmdFVwVmVjdG9yQmFyID0gXCLipZhcIjtcbnZhciBMZWZ0VXBWZWN0b3IgPSBcIuKGv1wiO1xudmFyIExlZnRWZWN0b3JCYXIgPSBcIuKlklwiO1xudmFyIExlZnRWZWN0b3IgPSBcIuKGvFwiO1xudmFyIGxFZyA9IFwi4qqLXCI7XG52YXIgbGVnID0gXCLii5pcIjtcbnZhciBsZXEgPSBcIuKJpFwiO1xudmFyIGxlcXEgPSBcIuKJplwiO1xudmFyIGxlcXNsYW50ID0gXCLiqb1cIjtcbnZhciBsZXNjYyA9IFwi4qqoXCI7XG52YXIgbGVzID0gXCLiqb1cIjtcbnZhciBsZXNkb3QgPSBcIuKpv1wiO1xudmFyIGxlc2RvdG8gPSBcIuKqgVwiO1xudmFyIGxlc2RvdG9yID0gXCLiqoNcIjtcbnZhciBsZXNnID0gXCLii5rvuIBcIjtcbnZhciBsZXNnZXMgPSBcIuKqk1wiO1xudmFyIGxlc3NhcHByb3ggPSBcIuKqhVwiO1xudmFyIGxlc3Nkb3QgPSBcIuKLllwiO1xudmFyIGxlc3NlcWd0ciA9IFwi4ouaXCI7XG52YXIgbGVzc2VxcWd0ciA9IFwi4qqLXCI7XG52YXIgTGVzc0VxdWFsR3JlYXRlciA9IFwi4ouaXCI7XG52YXIgTGVzc0Z1bGxFcXVhbCA9IFwi4ommXCI7XG52YXIgTGVzc0dyZWF0ZXIgPSBcIuKJtlwiO1xudmFyIGxlc3NndHIgPSBcIuKJtlwiO1xudmFyIExlc3NMZXNzID0gXCLiqqFcIjtcbnZhciBsZXNzc2ltID0gXCLiibJcIjtcbnZhciBMZXNzU2xhbnRFcXVhbCA9IFwi4qm9XCI7XG52YXIgTGVzc1RpbGRlID0gXCLiibJcIjtcbnZhciBsZmlzaHQgPSBcIuKlvFwiO1xudmFyIGxmbG9vciA9IFwi4oyKXCI7XG52YXIgTGZyID0gXCLwnZSPXCI7XG52YXIgbGZyID0gXCLwnZSpXCI7XG52YXIgbGcgPSBcIuKJtlwiO1xudmFyIGxnRSA9IFwi4qqRXCI7XG52YXIgbEhhciA9IFwi4qWiXCI7XG52YXIgbGhhcmQgPSBcIuKGvVwiO1xudmFyIGxoYXJ1ID0gXCLihrxcIjtcbnZhciBsaGFydWwgPSBcIuKlqlwiO1xudmFyIGxoYmxrID0gXCLiloRcIjtcbnZhciBMSmN5ID0gXCLQiVwiO1xudmFyIGxqY3kgPSBcItGZXCI7XG52YXIgbGxhcnIgPSBcIuKHh1wiO1xudmFyIGxsID0gXCLiiapcIjtcbnZhciBMbCA9IFwi4ouYXCI7XG52YXIgbGxjb3JuZXIgPSBcIuKMnlwiO1xudmFyIExsZWZ0YXJyb3cgPSBcIuKHmlwiO1xudmFyIGxsaGFyZCA9IFwi4qWrXCI7XG52YXIgbGx0cmkgPSBcIuKXulwiO1xudmFyIExtaWRvdCA9IFwixL9cIjtcbnZhciBsbWlkb3QgPSBcIsWAXCI7XG52YXIgbG1vdXN0YWNoZSA9IFwi4o6wXCI7XG52YXIgbG1vdXN0ID0gXCLijrBcIjtcbnZhciBsbmFwID0gXCLiqolcIjtcbnZhciBsbmFwcHJveCA9IFwi4qqJXCI7XG52YXIgbG5lID0gXCLiqodcIjtcbnZhciBsbkUgPSBcIuKJqFwiO1xudmFyIGxuZXEgPSBcIuKqh1wiO1xudmFyIGxuZXFxID0gXCLiiahcIjtcbnZhciBsbnNpbSA9IFwi4oumXCI7XG52YXIgbG9hbmcgPSBcIuKfrFwiO1xudmFyIGxvYXJyID0gXCLih71cIjtcbnZhciBsb2JyayA9IFwi4p+mXCI7XG52YXIgbG9uZ2xlZnRhcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ0xlZnRBcnJvdyA9IFwi4p+1XCI7XG52YXIgTG9uZ2xlZnRhcnJvdyA9IFwi4p+4XCI7XG52YXIgbG9uZ2xlZnRyaWdodGFycm93ID0gXCLin7dcIjtcbnZhciBMb25nTGVmdFJpZ2h0QXJyb3cgPSBcIuKft1wiO1xudmFyIExvbmdsZWZ0cmlnaHRhcnJvdyA9IFwi4p+6XCI7XG52YXIgbG9uZ21hcHN0byA9IFwi4p+8XCI7XG52YXIgbG9uZ3JpZ2h0YXJyb3cgPSBcIuKftlwiO1xudmFyIExvbmdSaWdodEFycm93ID0gXCLin7ZcIjtcbnZhciBMb25ncmlnaHRhcnJvdyA9IFwi4p+5XCI7XG52YXIgbG9vcGFycm93bGVmdCA9IFwi4oarXCI7XG52YXIgbG9vcGFycm93cmlnaHQgPSBcIuKGrFwiO1xudmFyIGxvcGFyID0gXCLipoVcIjtcbnZhciBMb3BmID0gXCLwnZWDXCI7XG52YXIgbG9wZiA9IFwi8J2VnVwiO1xudmFyIGxvcGx1cyA9IFwi4qitXCI7XG52YXIgbG90aW1lcyA9IFwi4qi0XCI7XG52YXIgbG93YXN0ID0gXCLiiJdcIjtcbnZhciBsb3diYXIgPSBcIl9cIjtcbnZhciBMb3dlckxlZnRBcnJvdyA9IFwi4oaZXCI7XG52YXIgTG93ZXJSaWdodEFycm93ID0gXCLihphcIjtcbnZhciBsb3ogPSBcIuKXilwiO1xudmFyIGxvemVuZ2UgPSBcIuKXilwiO1xudmFyIGxvemYgPSBcIuKnq1wiO1xudmFyIGxwYXIgPSBcIihcIjtcbnZhciBscGFybHQgPSBcIuKmk1wiO1xudmFyIGxyYXJyID0gXCLih4ZcIjtcbnZhciBscmNvcm5lciA9IFwi4oyfXCI7XG52YXIgbHJoYXIgPSBcIuKHi1wiO1xudmFyIGxyaGFyZCA9IFwi4qWtXCI7XG52YXIgbHJtID0gXCLigI5cIjtcbnZhciBscnRyaSA9IFwi4oq/XCI7XG52YXIgbHNhcXVvID0gXCLigLlcIjtcbnZhciBsc2NyID0gXCLwnZOBXCI7XG52YXIgTHNjciA9IFwi4oSSXCI7XG52YXIgbHNoID0gXCLihrBcIjtcbnZhciBMc2ggPSBcIuKGsFwiO1xudmFyIGxzaW0gPSBcIuKJslwiO1xudmFyIGxzaW1lID0gXCLiqo1cIjtcbnZhciBsc2ltZyA9IFwi4qqPXCI7XG52YXIgbHNxYiA9IFwiW1wiO1xudmFyIGxzcXVvID0gXCLigJhcIjtcbnZhciBsc3F1b3IgPSBcIuKAmlwiO1xudmFyIExzdHJvayA9IFwixYFcIjtcbnZhciBsc3Ryb2sgPSBcIsWCXCI7XG52YXIgbHRjYyA9IFwi4qqmXCI7XG52YXIgbHRjaXIgPSBcIuKpuVwiO1xudmFyIGx0JDIgPSBcIjxcIjtcbnZhciBMVCQxID0gXCI8XCI7XG52YXIgTHQgPSBcIuKJqlwiO1xudmFyIGx0ZG90ID0gXCLii5ZcIjtcbnZhciBsdGhyZWUgPSBcIuKLi1wiO1xudmFyIGx0aW1lcyA9IFwi4ouJXCI7XG52YXIgbHRsYXJyID0gXCLipbZcIjtcbnZhciBsdHF1ZXN0ID0gXCLiqbtcIjtcbnZhciBsdHJpID0gXCLil4NcIjtcbnZhciBsdHJpZSA9IFwi4oq0XCI7XG52YXIgbHRyaWYgPSBcIuKXglwiO1xudmFyIGx0clBhciA9IFwi4qaWXCI7XG52YXIgbHVyZHNoYXIgPSBcIuKlilwiO1xudmFyIGx1cnVoYXIgPSBcIuKlplwiO1xudmFyIGx2ZXJ0bmVxcSA9IFwi4omo77iAXCI7XG52YXIgbHZuRSA9IFwi4omo77iAXCI7XG52YXIgbWFjciQxID0gXCLCr1wiO1xudmFyIG1hbGUgPSBcIuKZglwiO1xudmFyIG1hbHQgPSBcIuKcoFwiO1xudmFyIG1hbHRlc2UgPSBcIuKcoFwiO1xudmFyIG1hcCA9IFwi4oamXCI7XG52YXIgbWFwc3RvID0gXCLihqZcIjtcbnZhciBtYXBzdG9kb3duID0gXCLihqdcIjtcbnZhciBtYXBzdG9sZWZ0ID0gXCLihqRcIjtcbnZhciBtYXBzdG91cCA9IFwi4oalXCI7XG52YXIgbWFya2VyID0gXCLilq5cIjtcbnZhciBtY29tbWEgPSBcIuKoqVwiO1xudmFyIE1jeSA9IFwi0JxcIjtcbnZhciBtY3kgPSBcItC8XCI7XG52YXIgbWRhc2ggPSBcIuKAlFwiO1xudmFyIG1ERG90ID0gXCLiiLpcIjtcbnZhciBtZWFzdXJlZGFuZ2xlID0gXCLiiKFcIjtcbnZhciBNZWRpdW1TcGFjZSA9IFwi4oGfXCI7XG52YXIgTWVsbGludHJmID0gXCLihLNcIjtcbnZhciBNZnIgPSBcIvCdlJBcIjtcbnZhciBtZnIgPSBcIvCdlKpcIjtcbnZhciBtaG8gPSBcIuKEp1wiO1xudmFyIG1pY3JvJDEgPSBcIsK1XCI7XG52YXIgbWlkYXN0ID0gXCIqXCI7XG52YXIgbWlkY2lyID0gXCLiq7BcIjtcbnZhciBtaWQgPSBcIuKIo1wiO1xudmFyIG1pZGRvdCQxID0gXCLCt1wiO1xudmFyIG1pbnVzYiA9IFwi4oqfXCI7XG52YXIgbWludXMgPSBcIuKIklwiO1xudmFyIG1pbnVzZCA9IFwi4oi4XCI7XG52YXIgbWludXNkdSA9IFwi4qiqXCI7XG52YXIgTWludXNQbHVzID0gXCLiiJNcIjtcbnZhciBtbGNwID0gXCLiq5tcIjtcbnZhciBtbGRyID0gXCLigKZcIjtcbnZhciBtbnBsdXMgPSBcIuKIk1wiO1xudmFyIG1vZGVscyA9IFwi4oqnXCI7XG52YXIgTW9wZiA9IFwi8J2VhFwiO1xudmFyIG1vcGYgPSBcIvCdlZ5cIjtcbnZhciBtcCA9IFwi4oiTXCI7XG52YXIgbXNjciA9IFwi8J2TglwiO1xudmFyIE1zY3IgPSBcIuKEs1wiO1xudmFyIG1zdHBvcyA9IFwi4oi+XCI7XG52YXIgTXUgPSBcIs6cXCI7XG52YXIgbXUgPSBcIs68XCI7XG52YXIgbXVsdGltYXAgPSBcIuKKuFwiO1xudmFyIG11bWFwID0gXCLiirhcIjtcbnZhciBuYWJsYSA9IFwi4oiHXCI7XG52YXIgTmFjdXRlID0gXCLFg1wiO1xudmFyIG5hY3V0ZSA9IFwixYRcIjtcbnZhciBuYW5nID0gXCLiiKDig5JcIjtcbnZhciBuYXAgPSBcIuKJiVwiO1xudmFyIG5hcEUgPSBcIuKpsMy4XCI7XG52YXIgbmFwaWQgPSBcIuKJi8y4XCI7XG52YXIgbmFwb3MgPSBcIsWJXCI7XG52YXIgbmFwcHJveCA9IFwi4omJXCI7XG52YXIgbmF0dXJhbCA9IFwi4pmuXCI7XG52YXIgbmF0dXJhbHMgPSBcIuKElVwiO1xudmFyIG5hdHVyID0gXCLima5cIjtcbnZhciBuYnNwJDEgPSBcIsKgXCI7XG52YXIgbmJ1bXAgPSBcIuKJjsy4XCI7XG52YXIgbmJ1bXBlID0gXCLiiY/MuFwiO1xudmFyIG5jYXAgPSBcIuKpg1wiO1xudmFyIE5jYXJvbiA9IFwixYdcIjtcbnZhciBuY2Fyb24gPSBcIsWIXCI7XG52YXIgTmNlZGlsID0gXCLFhVwiO1xudmFyIG5jZWRpbCA9IFwixYZcIjtcbnZhciBuY29uZyA9IFwi4omHXCI7XG52YXIgbmNvbmdkb3QgPSBcIuKprcy4XCI7XG52YXIgbmN1cCA9IFwi4qmCXCI7XG52YXIgTmN5ID0gXCLQnVwiO1xudmFyIG5jeSA9IFwi0L1cIjtcbnZhciBuZGFzaCA9IFwi4oCTXCI7XG52YXIgbmVhcmhrID0gXCLipKRcIjtcbnZhciBuZWFyciA9IFwi4oaXXCI7XG52YXIgbmVBcnIgPSBcIuKHl1wiO1xudmFyIG5lYXJyb3cgPSBcIuKGl1wiO1xudmFyIG5lID0gXCLiiaBcIjtcbnZhciBuZWRvdCA9IFwi4omQzLhcIjtcbnZhciBOZWdhdGl2ZU1lZGl1bVNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVRoaWNrU3BhY2UgPSBcIuKAi1wiO1xudmFyIE5lZ2F0aXZlVGhpblNwYWNlID0gXCLigItcIjtcbnZhciBOZWdhdGl2ZVZlcnlUaGluU3BhY2UgPSBcIuKAi1wiO1xudmFyIG5lcXVpdiA9IFwi4omiXCI7XG52YXIgbmVzZWFyID0gXCLipKhcIjtcbnZhciBuZXNpbSA9IFwi4omCzLhcIjtcbnZhciBOZXN0ZWRHcmVhdGVyR3JlYXRlciA9IFwi4omrXCI7XG52YXIgTmVzdGVkTGVzc0xlc3MgPSBcIuKJqlwiO1xudmFyIE5ld0xpbmUgPSBcIlxcblwiO1xudmFyIG5leGlzdCA9IFwi4oiEXCI7XG52YXIgbmV4aXN0cyA9IFwi4oiEXCI7XG52YXIgTmZyID0gXCLwnZSRXCI7XG52YXIgbmZyID0gXCLwnZSrXCI7XG52YXIgbmdFID0gXCLiiafMuFwiO1xudmFyIG5nZSA9IFwi4omxXCI7XG52YXIgbmdlcSA9IFwi4omxXCI7XG52YXIgbmdlcXEgPSBcIuKJp8y4XCI7XG52YXIgbmdlcXNsYW50ID0gXCLiqb7MuFwiO1xudmFyIG5nZXMgPSBcIuKpvsy4XCI7XG52YXIgbkdnID0gXCLii5nMuFwiO1xudmFyIG5nc2ltID0gXCLiibVcIjtcbnZhciBuR3QgPSBcIuKJq+KDklwiO1xudmFyIG5ndCA9IFwi4omvXCI7XG52YXIgbmd0ciA9IFwi4omvXCI7XG52YXIgbkd0diA9IFwi4omrzLhcIjtcbnZhciBuaGFyciA9IFwi4oauXCI7XG52YXIgbmhBcnIgPSBcIuKHjlwiO1xudmFyIG5ocGFyID0gXCLiq7JcIjtcbnZhciBuaSA9IFwi4oiLXCI7XG52YXIgbmlzID0gXCLii7xcIjtcbnZhciBuaXNkID0gXCLii7pcIjtcbnZhciBuaXYgPSBcIuKIi1wiO1xudmFyIE5KY3kgPSBcItCKXCI7XG52YXIgbmpjeSA9IFwi0ZpcIjtcbnZhciBubGFyciA9IFwi4oaaXCI7XG52YXIgbmxBcnIgPSBcIuKHjVwiO1xudmFyIG5sZHIgPSBcIuKApVwiO1xudmFyIG5sRSA9IFwi4ommzLhcIjtcbnZhciBubGUgPSBcIuKJsFwiO1xudmFyIG5sZWZ0YXJyb3cgPSBcIuKGmlwiO1xudmFyIG5MZWZ0YXJyb3cgPSBcIuKHjVwiO1xudmFyIG5sZWZ0cmlnaHRhcnJvdyA9IFwi4oauXCI7XG52YXIgbkxlZnRyaWdodGFycm93ID0gXCLih45cIjtcbnZhciBubGVxID0gXCLiibBcIjtcbnZhciBubGVxcSA9IFwi4ommzLhcIjtcbnZhciBubGVxc2xhbnQgPSBcIuKpvcy4XCI7XG52YXIgbmxlcyA9IFwi4qm9zLhcIjtcbnZhciBubGVzcyA9IFwi4omuXCI7XG52YXIgbkxsID0gXCLii5jMuFwiO1xudmFyIG5sc2ltID0gXCLiibRcIjtcbnZhciBuTHQgPSBcIuKJquKDklwiO1xudmFyIG5sdCA9IFwi4omuXCI7XG52YXIgbmx0cmkgPSBcIuKLqlwiO1xudmFyIG5sdHJpZSA9IFwi4ousXCI7XG52YXIgbkx0diA9IFwi4omqzLhcIjtcbnZhciBubWlkID0gXCLiiKRcIjtcbnZhciBOb0JyZWFrID0gXCLigaBcIjtcbnZhciBOb25CcmVha2luZ1NwYWNlID0gXCLCoFwiO1xudmFyIG5vcGYgPSBcIvCdlZ9cIjtcbnZhciBOb3BmID0gXCLihJVcIjtcbnZhciBOb3QgPSBcIuKrrFwiO1xudmFyIG5vdCQxID0gXCLCrFwiO1xudmFyIE5vdENvbmdydWVudCA9IFwi4omiXCI7XG52YXIgTm90Q3VwQ2FwID0gXCLiia1cIjtcbnZhciBOb3REb3VibGVWZXJ0aWNhbEJhciA9IFwi4oimXCI7XG52YXIgTm90RWxlbWVudCA9IFwi4oiJXCI7XG52YXIgTm90RXF1YWwgPSBcIuKJoFwiO1xudmFyIE5vdEVxdWFsVGlsZGUgPSBcIuKJgsy4XCI7XG52YXIgTm90RXhpc3RzID0gXCLiiIRcIjtcbnZhciBOb3RHcmVhdGVyID0gXCLiia9cIjtcbnZhciBOb3RHcmVhdGVyRXF1YWwgPSBcIuKJsVwiO1xudmFyIE5vdEdyZWF0ZXJGdWxsRXF1YWwgPSBcIuKJp8y4XCI7XG52YXIgTm90R3JlYXRlckdyZWF0ZXIgPSBcIuKJq8y4XCI7XG52YXIgTm90R3JlYXRlckxlc3MgPSBcIuKJuVwiO1xudmFyIE5vdEdyZWF0ZXJTbGFudEVxdWFsID0gXCLiqb7MuFwiO1xudmFyIE5vdEdyZWF0ZXJUaWxkZSA9IFwi4om1XCI7XG52YXIgTm90SHVtcERvd25IdW1wID0gXCLiiY7MuFwiO1xudmFyIE5vdEh1bXBFcXVhbCA9IFwi4omPzLhcIjtcbnZhciBub3RpbiA9IFwi4oiJXCI7XG52YXIgbm90aW5kb3QgPSBcIuKLtcy4XCI7XG52YXIgbm90aW5FID0gXCLii7nMuFwiO1xudmFyIG5vdGludmEgPSBcIuKIiVwiO1xudmFyIG5vdGludmIgPSBcIuKLt1wiO1xudmFyIG5vdGludmMgPSBcIuKLtlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUJhciA9IFwi4qePzLhcIjtcbnZhciBOb3RMZWZ0VHJpYW5nbGUgPSBcIuKLqlwiO1xudmFyIE5vdExlZnRUcmlhbmdsZUVxdWFsID0gXCLii6xcIjtcbnZhciBOb3RMZXNzID0gXCLiia5cIjtcbnZhciBOb3RMZXNzRXF1YWwgPSBcIuKJsFwiO1xudmFyIE5vdExlc3NHcmVhdGVyID0gXCLiibhcIjtcbnZhciBOb3RMZXNzTGVzcyA9IFwi4omqzLhcIjtcbnZhciBOb3RMZXNzU2xhbnRFcXVhbCA9IFwi4qm9zLhcIjtcbnZhciBOb3RMZXNzVGlsZGUgPSBcIuKJtFwiO1xudmFyIE5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyID0gXCLiqqLMuFwiO1xudmFyIE5vdE5lc3RlZExlc3NMZXNzID0gXCLiqqHMuFwiO1xudmFyIG5vdG5pID0gXCLiiIxcIjtcbnZhciBub3RuaXZhID0gXCLiiIxcIjtcbnZhciBub3RuaXZiID0gXCLii75cIjtcbnZhciBub3RuaXZjID0gXCLii71cIjtcbnZhciBOb3RQcmVjZWRlcyA9IFwi4oqAXCI7XG52YXIgTm90UHJlY2VkZXNFcXVhbCA9IFwi4qqvzLhcIjtcbnZhciBOb3RQcmVjZWRlc1NsYW50RXF1YWwgPSBcIuKLoFwiO1xudmFyIE5vdFJldmVyc2VFbGVtZW50ID0gXCLiiIxcIjtcbnZhciBOb3RSaWdodFRyaWFuZ2xlQmFyID0gXCLip5DMuFwiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGUgPSBcIuKLq1wiO1xudmFyIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4outXCI7XG52YXIgTm90U3F1YXJlU3Vic2V0ID0gXCLiio/MuFwiO1xudmFyIE5vdFNxdWFyZVN1YnNldEVxdWFsID0gXCLii6JcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldCA9IFwi4oqQzLhcIjtcbnZhciBOb3RTcXVhcmVTdXBlcnNldEVxdWFsID0gXCLii6NcIjtcbnZhciBOb3RTdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIE5vdFN1YnNldEVxdWFsID0gXCLiiohcIjtcbnZhciBOb3RTdWNjZWVkcyA9IFwi4oqBXCI7XG52YXIgTm90U3VjY2VlZHNFcXVhbCA9IFwi4qqwzLhcIjtcbnZhciBOb3RTdWNjZWVkc1NsYW50RXF1YWwgPSBcIuKLoVwiO1xudmFyIE5vdFN1Y2NlZWRzVGlsZGUgPSBcIuKJv8y4XCI7XG52YXIgTm90U3VwZXJzZXQgPSBcIuKKg+KDklwiO1xudmFyIE5vdFN1cGVyc2V0RXF1YWwgPSBcIuKKiVwiO1xudmFyIE5vdFRpbGRlID0gXCLiiYFcIjtcbnZhciBOb3RUaWxkZUVxdWFsID0gXCLiiYRcIjtcbnZhciBOb3RUaWxkZUZ1bGxFcXVhbCA9IFwi4omHXCI7XG52YXIgTm90VGlsZGVUaWxkZSA9IFwi4omJXCI7XG52YXIgTm90VmVydGljYWxCYXIgPSBcIuKIpFwiO1xudmFyIG5wYXJhbGxlbCA9IFwi4oimXCI7XG52YXIgbnBhciA9IFwi4oimXCI7XG52YXIgbnBhcnNsID0gXCLiq73ig6VcIjtcbnZhciBucGFydCA9IFwi4oiCzLhcIjtcbnZhciBucG9saW50ID0gXCLiqJRcIjtcbnZhciBucHIgPSBcIuKKgFwiO1xudmFyIG5wcmN1ZSA9IFwi4ougXCI7XG52YXIgbnByZWMgPSBcIuKKgFwiO1xudmFyIG5wcmVjZXEgPSBcIuKqr8y4XCI7XG52YXIgbnByZSA9IFwi4qqvzLhcIjtcbnZhciBucmFycmMgPSBcIuKks8y4XCI7XG52YXIgbnJhcnIgPSBcIuKGm1wiO1xudmFyIG5yQXJyID0gXCLih49cIjtcbnZhciBucmFycncgPSBcIuKGncy4XCI7XG52YXIgbnJpZ2h0YXJyb3cgPSBcIuKGm1wiO1xudmFyIG5SaWdodGFycm93ID0gXCLih49cIjtcbnZhciBucnRyaSA9IFwi4ourXCI7XG52YXIgbnJ0cmllID0gXCLii61cIjtcbnZhciBuc2MgPSBcIuKKgVwiO1xudmFyIG5zY2N1ZSA9IFwi4ouhXCI7XG52YXIgbnNjZSA9IFwi4qqwzLhcIjtcbnZhciBOc2NyID0gXCLwnZKpXCI7XG52YXIgbnNjciA9IFwi8J2Tg1wiO1xudmFyIG5zaG9ydG1pZCA9IFwi4oikXCI7XG52YXIgbnNob3J0cGFyYWxsZWwgPSBcIuKIplwiO1xudmFyIG5zaW0gPSBcIuKJgVwiO1xudmFyIG5zaW1lID0gXCLiiYRcIjtcbnZhciBuc2ltZXEgPSBcIuKJhFwiO1xudmFyIG5zbWlkID0gXCLiiKRcIjtcbnZhciBuc3BhciA9IFwi4oimXCI7XG52YXIgbnNxc3ViZSA9IFwi4ouiXCI7XG52YXIgbnNxc3VwZSA9IFwi4oujXCI7XG52YXIgbnN1YiA9IFwi4oqEXCI7XG52YXIgbnN1YkUgPSBcIuKrhcy4XCI7XG52YXIgbnN1YmUgPSBcIuKKiFwiO1xudmFyIG5zdWJzZXQgPSBcIuKKguKDklwiO1xudmFyIG5zdWJzZXRlcSA9IFwi4oqIXCI7XG52YXIgbnN1YnNldGVxcSA9IFwi4quFzLhcIjtcbnZhciBuc3VjYyA9IFwi4oqBXCI7XG52YXIgbnN1Y2NlcSA9IFwi4qqwzLhcIjtcbnZhciBuc3VwID0gXCLiioVcIjtcbnZhciBuc3VwRSA9IFwi4quGzLhcIjtcbnZhciBuc3VwZSA9IFwi4oqJXCI7XG52YXIgbnN1cHNldCA9IFwi4oqD4oOSXCI7XG52YXIgbnN1cHNldGVxID0gXCLiiolcIjtcbnZhciBuc3Vwc2V0ZXFxID0gXCLiq4bMuFwiO1xudmFyIG50Z2wgPSBcIuKJuVwiO1xudmFyIE50aWxkZSQxID0gXCLDkVwiO1xudmFyIG50aWxkZSQxID0gXCLDsVwiO1xudmFyIG50bGcgPSBcIuKJuFwiO1xudmFyIG50cmlhbmdsZWxlZnQgPSBcIuKLqlwiO1xudmFyIG50cmlhbmdsZWxlZnRlcSA9IFwi4ousXCI7XG52YXIgbnRyaWFuZ2xlcmlnaHQgPSBcIuKLq1wiO1xudmFyIG50cmlhbmdsZXJpZ2h0ZXEgPSBcIuKLrVwiO1xudmFyIE51ID0gXCLOnVwiO1xudmFyIG51ID0gXCLOvVwiO1xudmFyIG51bSA9IFwiI1wiO1xudmFyIG51bWVybyA9IFwi4oSWXCI7XG52YXIgbnVtc3AgPSBcIuKAh1wiO1xudmFyIG52YXAgPSBcIuKJjeKDklwiO1xudmFyIG52ZGFzaCA9IFwi4oqsXCI7XG52YXIgbnZEYXNoID0gXCLiiq1cIjtcbnZhciBuVmRhc2ggPSBcIuKKrlwiO1xudmFyIG5WRGFzaCA9IFwi4oqvXCI7XG52YXIgbnZnZSA9IFwi4oml4oOSXCI7XG52YXIgbnZndCA9IFwiPuKDklwiO1xudmFyIG52SGFyciA9IFwi4qSEXCI7XG52YXIgbnZpbmZpbiA9IFwi4qeeXCI7XG52YXIgbnZsQXJyID0gXCLipIJcIjtcbnZhciBudmxlID0gXCLiiaTig5JcIjtcbnZhciBudmx0ID0gXCI84oOSXCI7XG52YXIgbnZsdHJpZSA9IFwi4oq04oOSXCI7XG52YXIgbnZyQXJyID0gXCLipINcIjtcbnZhciBudnJ0cmllID0gXCLiirXig5JcIjtcbnZhciBudnNpbSA9IFwi4oi84oOSXCI7XG52YXIgbndhcmhrID0gXCLipKNcIjtcbnZhciBud2FyciA9IFwi4oaWXCI7XG52YXIgbndBcnIgPSBcIuKHllwiO1xudmFyIG53YXJyb3cgPSBcIuKGllwiO1xudmFyIG53bmVhciA9IFwi4qSnXCI7XG52YXIgT2FjdXRlJDEgPSBcIsOTXCI7XG52YXIgb2FjdXRlJDEgPSBcIsOzXCI7XG52YXIgb2FzdCA9IFwi4oqbXCI7XG52YXIgT2NpcmMkMSA9IFwiw5RcIjtcbnZhciBvY2lyYyQxID0gXCLDtFwiO1xudmFyIG9jaXIgPSBcIuKKmlwiO1xudmFyIE9jeSA9IFwi0J5cIjtcbnZhciBvY3kgPSBcItC+XCI7XG52YXIgb2Rhc2ggPSBcIuKKnVwiO1xudmFyIE9kYmxhYyA9IFwixZBcIjtcbnZhciBvZGJsYWMgPSBcIsWRXCI7XG52YXIgb2RpdiA9IFwi4qi4XCI7XG52YXIgb2RvdCA9IFwi4oqZXCI7XG52YXIgb2Rzb2xkID0gXCLiprxcIjtcbnZhciBPRWxpZyA9IFwixZJcIjtcbnZhciBvZWxpZyA9IFwixZNcIjtcbnZhciBvZmNpciA9IFwi4qa/XCI7XG52YXIgT2ZyID0gXCLwnZSSXCI7XG52YXIgb2ZyID0gXCLwnZSsXCI7XG52YXIgb2dvbiA9IFwiy5tcIjtcbnZhciBPZ3JhdmUkMSA9IFwiw5JcIjtcbnZhciBvZ3JhdmUkMSA9IFwiw7JcIjtcbnZhciBvZ3QgPSBcIuKngVwiO1xudmFyIG9oYmFyID0gXCLiprVcIjtcbnZhciBvaG0gPSBcIs6pXCI7XG52YXIgb2ludCA9IFwi4oiuXCI7XG52YXIgb2xhcnIgPSBcIuKGulwiO1xudmFyIG9sY2lyID0gXCLipr5cIjtcbnZhciBvbGNyb3NzID0gXCLiprtcIjtcbnZhciBvbGluZSA9IFwi4oC+XCI7XG52YXIgb2x0ID0gXCLip4BcIjtcbnZhciBPbWFjciA9IFwixYxcIjtcbnZhciBvbWFjciA9IFwixY1cIjtcbnZhciBPbWVnYSA9IFwizqlcIjtcbnZhciBvbWVnYSA9IFwiz4lcIjtcbnZhciBPbWljcm9uID0gXCLOn1wiO1xudmFyIG9taWNyb24gPSBcIs6/XCI7XG52YXIgb21pZCA9IFwi4qa2XCI7XG52YXIgb21pbnVzID0gXCLiipZcIjtcbnZhciBPb3BmID0gXCLwnZWGXCI7XG52YXIgb29wZiA9IFwi8J2VoFwiO1xudmFyIG9wYXIgPSBcIuKmt1wiO1xudmFyIE9wZW5DdXJseURvdWJsZVF1b3RlID0gXCLigJxcIjtcbnZhciBPcGVuQ3VybHlRdW90ZSA9IFwi4oCYXCI7XG52YXIgb3BlcnAgPSBcIuKmuVwiO1xudmFyIG9wbHVzID0gXCLiipVcIjtcbnZhciBvcmFyciA9IFwi4oa7XCI7XG52YXIgT3IgPSBcIuKplFwiO1xudmFyIG9yID0gXCLiiKhcIjtcbnZhciBvcmQgPSBcIuKpnVwiO1xudmFyIG9yZGVyID0gXCLihLRcIjtcbnZhciBvcmRlcm9mID0gXCLihLRcIjtcbnZhciBvcmRmJDEgPSBcIsKqXCI7XG52YXIgb3JkbSQxID0gXCLCulwiO1xudmFyIG9yaWdvZiA9IFwi4oq2XCI7XG52YXIgb3JvciA9IFwi4qmWXCI7XG52YXIgb3JzbG9wZSA9IFwi4qmXXCI7XG52YXIgb3J2ID0gXCLiqZtcIjtcbnZhciBvUyA9IFwi4pOIXCI7XG52YXIgT3NjciA9IFwi8J2SqlwiO1xudmFyIG9zY3IgPSBcIuKEtFwiO1xudmFyIE9zbGFzaCQxID0gXCLDmFwiO1xudmFyIG9zbGFzaCQxID0gXCLDuFwiO1xudmFyIG9zb2wgPSBcIuKKmFwiO1xudmFyIE90aWxkZSQxID0gXCLDlVwiO1xudmFyIG90aWxkZSQxID0gXCLDtVwiO1xudmFyIG90aW1lc2FzID0gXCLiqLZcIjtcbnZhciBPdGltZXMgPSBcIuKot1wiO1xudmFyIG90aW1lcyA9IFwi4oqXXCI7XG52YXIgT3VtbCQxID0gXCLDllwiO1xudmFyIG91bWwkMSA9IFwiw7ZcIjtcbnZhciBvdmJhciA9IFwi4oy9XCI7XG52YXIgT3ZlckJhciA9IFwi4oC+XCI7XG52YXIgT3ZlckJyYWNlID0gXCLij55cIjtcbnZhciBPdmVyQnJhY2tldCA9IFwi4o60XCI7XG52YXIgT3ZlclBhcmVudGhlc2lzID0gXCLij5xcIjtcbnZhciBwYXJhJDEgPSBcIsK2XCI7XG52YXIgcGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIHBhciA9IFwi4oilXCI7XG52YXIgcGFyc2ltID0gXCLiq7NcIjtcbnZhciBwYXJzbCA9IFwi4qu9XCI7XG52YXIgcGFydCA9IFwi4oiCXCI7XG52YXIgUGFydGlhbEQgPSBcIuKIglwiO1xudmFyIFBjeSA9IFwi0J9cIjtcbnZhciBwY3kgPSBcItC/XCI7XG52YXIgcGVyY250ID0gXCIlXCI7XG52YXIgcGVyaW9kID0gXCIuXCI7XG52YXIgcGVybWlsID0gXCLigLBcIjtcbnZhciBwZXJwID0gXCLiiqVcIjtcbnZhciBwZXJ0ZW5rID0gXCLigLFcIjtcbnZhciBQZnIgPSBcIvCdlJNcIjtcbnZhciBwZnIgPSBcIvCdlK1cIjtcbnZhciBQaGkgPSBcIs6mXCI7XG52YXIgcGhpID0gXCLPhlwiO1xudmFyIHBoaXYgPSBcIs+VXCI7XG52YXIgcGhtbWF0ID0gXCLihLNcIjtcbnZhciBwaG9uZSA9IFwi4piOXCI7XG52YXIgUGkgPSBcIs6gXCI7XG52YXIgcGkgPSBcIs+AXCI7XG52YXIgcGl0Y2hmb3JrID0gXCLii5RcIjtcbnZhciBwaXYgPSBcIs+WXCI7XG52YXIgcGxhbmNrID0gXCLihI9cIjtcbnZhciBwbGFuY2toID0gXCLihI5cIjtcbnZhciBwbGFua3YgPSBcIuKEj1wiO1xudmFyIHBsdXNhY2lyID0gXCLiqKNcIjtcbnZhciBwbHVzYiA9IFwi4oqeXCI7XG52YXIgcGx1c2NpciA9IFwi4qiiXCI7XG52YXIgcGx1cyA9IFwiK1wiO1xudmFyIHBsdXNkbyA9IFwi4oiUXCI7XG52YXIgcGx1c2R1ID0gXCLiqKVcIjtcbnZhciBwbHVzZSA9IFwi4qmyXCI7XG52YXIgUGx1c01pbnVzID0gXCLCsVwiO1xudmFyIHBsdXNtbiQxID0gXCLCsVwiO1xudmFyIHBsdXNzaW0gPSBcIuKoplwiO1xudmFyIHBsdXN0d28gPSBcIuKop1wiO1xudmFyIHBtID0gXCLCsVwiO1xudmFyIFBvaW5jYXJlcGxhbmUgPSBcIuKEjFwiO1xudmFyIHBvaW50aW50ID0gXCLiqJVcIjtcbnZhciBwb3BmID0gXCLwnZWhXCI7XG52YXIgUG9wZiA9IFwi4oSZXCI7XG52YXIgcG91bmQkMSA9IFwiwqNcIjtcbnZhciBwcmFwID0gXCLiqrdcIjtcbnZhciBQciA9IFwi4qq7XCI7XG52YXIgcHIgPSBcIuKJulwiO1xudmFyIHByY3VlID0gXCLiibxcIjtcbnZhciBwcmVjYXBwcm94ID0gXCLiqrdcIjtcbnZhciBwcmVjID0gXCLiibpcIjtcbnZhciBwcmVjY3VybHllcSA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXMgPSBcIuKJulwiO1xudmFyIFByZWNlZGVzRXF1YWwgPSBcIuKqr1wiO1xudmFyIFByZWNlZGVzU2xhbnRFcXVhbCA9IFwi4om8XCI7XG52YXIgUHJlY2VkZXNUaWxkZSA9IFwi4om+XCI7XG52YXIgcHJlY2VxID0gXCLiqq9cIjtcbnZhciBwcmVjbmFwcHJveCA9IFwi4qq5XCI7XG52YXIgcHJlY25lcXEgPSBcIuKqtVwiO1xudmFyIHByZWNuc2ltID0gXCLii6hcIjtcbnZhciBwcmUgPSBcIuKqr1wiO1xudmFyIHByRSA9IFwi4qqzXCI7XG52YXIgcHJlY3NpbSA9IFwi4om+XCI7XG52YXIgcHJpbWUgPSBcIuKAslwiO1xudmFyIFByaW1lID0gXCLigLNcIjtcbnZhciBwcmltZXMgPSBcIuKEmVwiO1xudmFyIHBybmFwID0gXCLiqrlcIjtcbnZhciBwcm5FID0gXCLiqrVcIjtcbnZhciBwcm5zaW0gPSBcIuKLqFwiO1xudmFyIHByb2QgPSBcIuKIj1wiO1xudmFyIFByb2R1Y3QgPSBcIuKIj1wiO1xudmFyIHByb2ZhbGFyID0gXCLijK5cIjtcbnZhciBwcm9mbGluZSA9IFwi4oySXCI7XG52YXIgcHJvZnN1cmYgPSBcIuKMk1wiO1xudmFyIHByb3AgPSBcIuKInVwiO1xudmFyIFByb3BvcnRpb25hbCA9IFwi4oidXCI7XG52YXIgUHJvcG9ydGlvbiA9IFwi4oi3XCI7XG52YXIgcHJvcHRvID0gXCLiiJ1cIjtcbnZhciBwcnNpbSA9IFwi4om+XCI7XG52YXIgcHJ1cmVsID0gXCLiirBcIjtcbnZhciBQc2NyID0gXCLwnZKrXCI7XG52YXIgcHNjciA9IFwi8J2ThVwiO1xudmFyIFBzaSA9IFwizqhcIjtcbnZhciBwc2kgPSBcIs+IXCI7XG52YXIgcHVuY3NwID0gXCLigIhcIjtcbnZhciBRZnIgPSBcIvCdlJRcIjtcbnZhciBxZnIgPSBcIvCdlK5cIjtcbnZhciBxaW50ID0gXCLiqIxcIjtcbnZhciBxb3BmID0gXCLwnZWiXCI7XG52YXIgUW9wZiA9IFwi4oSaXCI7XG52YXIgcXByaW1lID0gXCLigZdcIjtcbnZhciBRc2NyID0gXCLwnZKsXCI7XG52YXIgcXNjciA9IFwi8J2ThlwiO1xudmFyIHF1YXRlcm5pb25zID0gXCLihI1cIjtcbnZhciBxdWF0aW50ID0gXCLiqJZcIjtcbnZhciBxdWVzdCA9IFwiP1wiO1xudmFyIHF1ZXN0ZXEgPSBcIuKJn1wiO1xudmFyIHF1b3QkMiA9IFwiXFxcIlwiO1xudmFyIFFVT1QkMSA9IFwiXFxcIlwiO1xudmFyIHJBYXJyID0gXCLih5tcIjtcbnZhciByYWNlID0gXCLiiL3MsVwiO1xudmFyIFJhY3V0ZSA9IFwixZRcIjtcbnZhciByYWN1dGUgPSBcIsWVXCI7XG52YXIgcmFkaWMgPSBcIuKImlwiO1xudmFyIHJhZW1wdHl2ID0gXCLiprNcIjtcbnZhciByYW5nID0gXCLin6lcIjtcbnZhciBSYW5nID0gXCLin6tcIjtcbnZhciByYW5nZCA9IFwi4qaSXCI7XG52YXIgcmFuZ2UgPSBcIuKmpVwiO1xudmFyIHJhbmdsZSA9IFwi4p+pXCI7XG52YXIgcmFxdW8kMSA9IFwiwrtcIjtcbnZhciByYXJyYXAgPSBcIuKltVwiO1xudmFyIHJhcnJiID0gXCLih6VcIjtcbnZhciByYXJyYmZzID0gXCLipKBcIjtcbnZhciByYXJyYyA9IFwi4qSzXCI7XG52YXIgcmFyciA9IFwi4oaSXCI7XG52YXIgUmFyciA9IFwi4oagXCI7XG52YXIgckFyciA9IFwi4oeSXCI7XG52YXIgcmFycmZzID0gXCLipJ5cIjtcbnZhciByYXJyaGsgPSBcIuKGqlwiO1xudmFyIHJhcnJscCA9IFwi4oasXCI7XG52YXIgcmFycnBsID0gXCLipYVcIjtcbnZhciByYXJyc2ltID0gXCLipbRcIjtcbnZhciBSYXJydGwgPSBcIuKkllwiO1xudmFyIHJhcnJ0bCA9IFwi4oajXCI7XG52YXIgcmFycncgPSBcIuKGnVwiO1xudmFyIHJhdGFpbCA9IFwi4qSaXCI7XG52YXIgckF0YWlsID0gXCLipJxcIjtcbnZhciByYXRpbyA9IFwi4oi2XCI7XG52YXIgcmF0aW9uYWxzID0gXCLihJpcIjtcbnZhciByYmFyciA9IFwi4qSNXCI7XG52YXIgckJhcnIgPSBcIuKkj1wiO1xudmFyIFJCYXJyID0gXCLipJBcIjtcbnZhciByYmJyayA9IFwi4p2zXCI7XG52YXIgcmJyYWNlID0gXCJ9XCI7XG52YXIgcmJyYWNrID0gXCJdXCI7XG52YXIgcmJya2UgPSBcIuKmjFwiO1xudmFyIHJicmtzbGQgPSBcIuKmjlwiO1xudmFyIHJicmtzbHUgPSBcIuKmkFwiO1xudmFyIFJjYXJvbiA9IFwixZhcIjtcbnZhciByY2Fyb24gPSBcIsWZXCI7XG52YXIgUmNlZGlsID0gXCLFllwiO1xudmFyIHJjZWRpbCA9IFwixZdcIjtcbnZhciByY2VpbCA9IFwi4oyJXCI7XG52YXIgcmN1YiA9IFwifVwiO1xudmFyIFJjeSA9IFwi0KBcIjtcbnZhciByY3kgPSBcItGAXCI7XG52YXIgcmRjYSA9IFwi4qS3XCI7XG52YXIgcmRsZGhhciA9IFwi4qWpXCI7XG52YXIgcmRxdW8gPSBcIuKAnVwiO1xudmFyIHJkcXVvciA9IFwi4oCdXCI7XG52YXIgcmRzaCA9IFwi4oazXCI7XG52YXIgcmVhbCA9IFwi4oScXCI7XG52YXIgcmVhbGluZSA9IFwi4oSbXCI7XG52YXIgcmVhbHBhcnQgPSBcIuKEnFwiO1xudmFyIHJlYWxzID0gXCLihJ1cIjtcbnZhciBSZSA9IFwi4oScXCI7XG52YXIgcmVjdCA9IFwi4patXCI7XG52YXIgcmVnJDEgPSBcIsKuXCI7XG52YXIgUkVHJDEgPSBcIsKuXCI7XG52YXIgUmV2ZXJzZUVsZW1lbnQgPSBcIuKIi1wiO1xudmFyIFJldmVyc2VFcXVpbGlicml1bSA9IFwi4oeLXCI7XG52YXIgUmV2ZXJzZVVwRXF1aWxpYnJpdW0gPSBcIuKlr1wiO1xudmFyIHJmaXNodCA9IFwi4qW9XCI7XG52YXIgcmZsb29yID0gXCLijItcIjtcbnZhciByZnIgPSBcIvCdlK9cIjtcbnZhciBSZnIgPSBcIuKEnFwiO1xudmFyIHJIYXIgPSBcIuKlpFwiO1xudmFyIHJoYXJkID0gXCLih4FcIjtcbnZhciByaGFydSA9IFwi4oeAXCI7XG52YXIgcmhhcnVsID0gXCLipaxcIjtcbnZhciBSaG8gPSBcIs6hXCI7XG52YXIgcmhvID0gXCLPgVwiO1xudmFyIHJob3YgPSBcIs+xXCI7XG52YXIgUmlnaHRBbmdsZUJyYWNrZXQgPSBcIuKfqVwiO1xudmFyIFJpZ2h0QXJyb3dCYXIgPSBcIuKHpVwiO1xudmFyIHJpZ2h0YXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0QXJyb3cgPSBcIuKGklwiO1xudmFyIFJpZ2h0YXJyb3cgPSBcIuKHklwiO1xudmFyIFJpZ2h0QXJyb3dMZWZ0QXJyb3cgPSBcIuKHhFwiO1xudmFyIHJpZ2h0YXJyb3d0YWlsID0gXCLihqNcIjtcbnZhciBSaWdodENlaWxpbmcgPSBcIuKMiVwiO1xudmFyIFJpZ2h0RG91YmxlQnJhY2tldCA9IFwi4p+nXCI7XG52YXIgUmlnaHREb3duVGVlVmVjdG9yID0gXCLipZ1cIjtcbnZhciBSaWdodERvd25WZWN0b3JCYXIgPSBcIuKllVwiO1xudmFyIFJpZ2h0RG93blZlY3RvciA9IFwi4oeCXCI7XG52YXIgUmlnaHRGbG9vciA9IFwi4oyLXCI7XG52YXIgcmlnaHRoYXJwb29uZG93biA9IFwi4oeBXCI7XG52YXIgcmlnaHRoYXJwb29udXAgPSBcIuKHgFwiO1xudmFyIHJpZ2h0bGVmdGFycm93cyA9IFwi4oeEXCI7XG52YXIgcmlnaHRsZWZ0aGFycG9vbnMgPSBcIuKHjFwiO1xudmFyIHJpZ2h0cmlnaHRhcnJvd3MgPSBcIuKHiVwiO1xudmFyIHJpZ2h0c3F1aWdhcnJvdyA9IFwi4oadXCI7XG52YXIgUmlnaHRUZWVBcnJvdyA9IFwi4oamXCI7XG52YXIgUmlnaHRUZWUgPSBcIuKKolwiO1xudmFyIFJpZ2h0VGVlVmVjdG9yID0gXCLipZtcIjtcbnZhciByaWdodHRocmVldGltZXMgPSBcIuKLjFwiO1xudmFyIFJpZ2h0VHJpYW5nbGVCYXIgPSBcIuKnkFwiO1xudmFyIFJpZ2h0VHJpYW5nbGUgPSBcIuKKs1wiO1xudmFyIFJpZ2h0VHJpYW5nbGVFcXVhbCA9IFwi4oq1XCI7XG52YXIgUmlnaHRVcERvd25WZWN0b3IgPSBcIuKlj1wiO1xudmFyIFJpZ2h0VXBUZWVWZWN0b3IgPSBcIuKlnFwiO1xudmFyIFJpZ2h0VXBWZWN0b3JCYXIgPSBcIuKllFwiO1xudmFyIFJpZ2h0VXBWZWN0b3IgPSBcIuKGvlwiO1xudmFyIFJpZ2h0VmVjdG9yQmFyID0gXCLipZNcIjtcbnZhciBSaWdodFZlY3RvciA9IFwi4oeAXCI7XG52YXIgcmluZyA9IFwiy5pcIjtcbnZhciByaXNpbmdkb3RzZXEgPSBcIuKJk1wiO1xudmFyIHJsYXJyID0gXCLih4RcIjtcbnZhciBybGhhciA9IFwi4oeMXCI7XG52YXIgcmxtID0gXCLigI9cIjtcbnZhciBybW91c3RhY2hlID0gXCLijrFcIjtcbnZhciBybW91c3QgPSBcIuKOsVwiO1xudmFyIHJubWlkID0gXCLiq65cIjtcbnZhciByb2FuZyA9IFwi4p+tXCI7XG52YXIgcm9hcnIgPSBcIuKHvlwiO1xudmFyIHJvYnJrID0gXCLin6dcIjtcbnZhciByb3BhciA9IFwi4qaGXCI7XG52YXIgcm9wZiA9IFwi8J2Vo1wiO1xudmFyIFJvcGYgPSBcIuKEnVwiO1xudmFyIHJvcGx1cyA9IFwi4qiuXCI7XG52YXIgcm90aW1lcyA9IFwi4qi1XCI7XG52YXIgUm91bmRJbXBsaWVzID0gXCLipbBcIjtcbnZhciBycGFyID0gXCIpXCI7XG52YXIgcnBhcmd0ID0gXCLippRcIjtcbnZhciBycHBvbGludCA9IFwi4qiSXCI7XG52YXIgcnJhcnIgPSBcIuKHiVwiO1xudmFyIFJyaWdodGFycm93ID0gXCLih5tcIjtcbnZhciByc2FxdW8gPSBcIuKAulwiO1xudmFyIHJzY3IgPSBcIvCdk4dcIjtcbnZhciBSc2NyID0gXCLihJtcIjtcbnZhciByc2ggPSBcIuKGsVwiO1xudmFyIFJzaCA9IFwi4oaxXCI7XG52YXIgcnNxYiA9IFwiXVwiO1xudmFyIHJzcXVvID0gXCLigJlcIjtcbnZhciByc3F1b3IgPSBcIuKAmVwiO1xudmFyIHJ0aHJlZSA9IFwi4ouMXCI7XG52YXIgcnRpbWVzID0gXCLii4pcIjtcbnZhciBydHJpID0gXCLilrlcIjtcbnZhciBydHJpZSA9IFwi4oq1XCI7XG52YXIgcnRyaWYgPSBcIuKWuFwiO1xudmFyIHJ0cmlsdHJpID0gXCLip45cIjtcbnZhciBSdWxlRGVsYXllZCA9IFwi4qe0XCI7XG52YXIgcnVsdWhhciA9IFwi4qWoXCI7XG52YXIgcnggPSBcIuKEnlwiO1xudmFyIFNhY3V0ZSA9IFwixZpcIjtcbnZhciBzYWN1dGUgPSBcIsWbXCI7XG52YXIgc2JxdW8gPSBcIuKAmlwiO1xudmFyIHNjYXAgPSBcIuKquFwiO1xudmFyIFNjYXJvbiA9IFwixaBcIjtcbnZhciBzY2Fyb24gPSBcIsWhXCI7XG52YXIgU2MgPSBcIuKqvFwiO1xudmFyIHNjID0gXCLiibtcIjtcbnZhciBzY2N1ZSA9IFwi4om9XCI7XG52YXIgc2NlID0gXCLiqrBcIjtcbnZhciBzY0UgPSBcIuKqtFwiO1xudmFyIFNjZWRpbCA9IFwixZ5cIjtcbnZhciBzY2VkaWwgPSBcIsWfXCI7XG52YXIgU2NpcmMgPSBcIsWcXCI7XG52YXIgc2NpcmMgPSBcIsWdXCI7XG52YXIgc2NuYXAgPSBcIuKqulwiO1xudmFyIHNjbkUgPSBcIuKqtlwiO1xudmFyIHNjbnNpbSA9IFwi4oupXCI7XG52YXIgc2Nwb2xpbnQgPSBcIuKok1wiO1xudmFyIHNjc2ltID0gXCLiib9cIjtcbnZhciBTY3kgPSBcItChXCI7XG52YXIgc2N5ID0gXCLRgVwiO1xudmFyIHNkb3RiID0gXCLiiqFcIjtcbnZhciBzZG90ID0gXCLii4VcIjtcbnZhciBzZG90ZSA9IFwi4qmmXCI7XG52YXIgc2VhcmhrID0gXCLipKVcIjtcbnZhciBzZWFyciA9IFwi4oaYXCI7XG52YXIgc2VBcnIgPSBcIuKHmFwiO1xudmFyIHNlYXJyb3cgPSBcIuKGmFwiO1xudmFyIHNlY3QkMSA9IFwiwqdcIjtcbnZhciBzZW1pID0gXCI7XCI7XG52YXIgc2Vzd2FyID0gXCLipKlcIjtcbnZhciBzZXRtaW51cyA9IFwi4oiWXCI7XG52YXIgc2V0bW4gPSBcIuKIllwiO1xudmFyIHNleHQgPSBcIuKctlwiO1xudmFyIFNmciA9IFwi8J2UllwiO1xudmFyIHNmciA9IFwi8J2UsFwiO1xudmFyIHNmcm93biA9IFwi4oyiXCI7XG52YXIgc2hhcnAgPSBcIuKZr1wiO1xudmFyIFNIQ0hjeSA9IFwi0KlcIjtcbnZhciBzaGNoY3kgPSBcItGJXCI7XG52YXIgU0hjeSA9IFwi0KhcIjtcbnZhciBzaGN5ID0gXCLRiFwiO1xudmFyIFNob3J0RG93bkFycm93ID0gXCLihpNcIjtcbnZhciBTaG9ydExlZnRBcnJvdyA9IFwi4oaQXCI7XG52YXIgc2hvcnRtaWQgPSBcIuKIo1wiO1xudmFyIHNob3J0cGFyYWxsZWwgPSBcIuKIpVwiO1xudmFyIFNob3J0UmlnaHRBcnJvdyA9IFwi4oaSXCI7XG52YXIgU2hvcnRVcEFycm93ID0gXCLihpFcIjtcbnZhciBzaHkkMSA9IFwiwq1cIjtcbnZhciBTaWdtYSA9IFwizqNcIjtcbnZhciBzaWdtYSA9IFwiz4NcIjtcbnZhciBzaWdtYWYgPSBcIs+CXCI7XG52YXIgc2lnbWF2ID0gXCLPglwiO1xudmFyIHNpbSA9IFwi4oi8XCI7XG52YXIgc2ltZG90ID0gXCLiqapcIjtcbnZhciBzaW1lID0gXCLiiYNcIjtcbnZhciBzaW1lcSA9IFwi4omDXCI7XG52YXIgc2ltZyA9IFwi4qqeXCI7XG52YXIgc2ltZ0UgPSBcIuKqoFwiO1xudmFyIHNpbWwgPSBcIuKqnVwiO1xudmFyIHNpbWxFID0gXCLiqp9cIjtcbnZhciBzaW1uZSA9IFwi4omGXCI7XG52YXIgc2ltcGx1cyA9IFwi4qikXCI7XG52YXIgc2ltcmFyciA9IFwi4qWyXCI7XG52YXIgc2xhcnIgPSBcIuKGkFwiO1xudmFyIFNtYWxsQ2lyY2xlID0gXCLiiJhcIjtcbnZhciBzbWFsbHNldG1pbnVzID0gXCLiiJZcIjtcbnZhciBzbWFzaHAgPSBcIuKos1wiO1xudmFyIHNtZXBhcnNsID0gXCLip6RcIjtcbnZhciBzbWlkID0gXCLiiKNcIjtcbnZhciBzbWlsZSA9IFwi4oyjXCI7XG52YXIgc210ID0gXCLiqqpcIjtcbnZhciBzbXRlID0gXCLiqqxcIjtcbnZhciBzbXRlcyA9IFwi4qqs77iAXCI7XG52YXIgU09GVGN5ID0gXCLQrFwiO1xudmFyIHNvZnRjeSA9IFwi0YxcIjtcbnZhciBzb2xiYXIgPSBcIuKMv1wiO1xudmFyIHNvbGIgPSBcIuKnhFwiO1xudmFyIHNvbCA9IFwiL1wiO1xudmFyIFNvcGYgPSBcIvCdlYpcIjtcbnZhciBzb3BmID0gXCLwnZWkXCI7XG52YXIgc3BhZGVzID0gXCLimaBcIjtcbnZhciBzcGFkZXN1aXQgPSBcIuKZoFwiO1xudmFyIHNwYXIgPSBcIuKIpVwiO1xudmFyIHNxY2FwID0gXCLiipNcIjtcbnZhciBzcWNhcHMgPSBcIuKKk++4gFwiO1xudmFyIHNxY3VwID0gXCLiipRcIjtcbnZhciBzcWN1cHMgPSBcIuKKlO+4gFwiO1xudmFyIFNxcnQgPSBcIuKImlwiO1xudmFyIHNxc3ViID0gXCLiio9cIjtcbnZhciBzcXN1YmUgPSBcIuKKkVwiO1xudmFyIHNxc3Vic2V0ID0gXCLiio9cIjtcbnZhciBzcXN1YnNldGVxID0gXCLiipFcIjtcbnZhciBzcXN1cCA9IFwi4oqQXCI7XG52YXIgc3FzdXBlID0gXCLiipJcIjtcbnZhciBzcXN1cHNldCA9IFwi4oqQXCI7XG52YXIgc3FzdXBzZXRlcSA9IFwi4oqSXCI7XG52YXIgc3F1YXJlID0gXCLilqFcIjtcbnZhciBTcXVhcmUgPSBcIuKWoVwiO1xudmFyIFNxdWFyZUludGVyc2VjdGlvbiA9IFwi4oqTXCI7XG52YXIgU3F1YXJlU3Vic2V0ID0gXCLiio9cIjtcbnZhciBTcXVhcmVTdWJzZXRFcXVhbCA9IFwi4oqRXCI7XG52YXIgU3F1YXJlU3VwZXJzZXQgPSBcIuKKkFwiO1xudmFyIFNxdWFyZVN1cGVyc2V0RXF1YWwgPSBcIuKKklwiO1xudmFyIFNxdWFyZVVuaW9uID0gXCLiipRcIjtcbnZhciBzcXVhcmYgPSBcIuKWqlwiO1xudmFyIHNxdSA9IFwi4pahXCI7XG52YXIgc3F1ZiA9IFwi4paqXCI7XG52YXIgc3JhcnIgPSBcIuKGklwiO1xudmFyIFNzY3IgPSBcIvCdkq5cIjtcbnZhciBzc2NyID0gXCLwnZOIXCI7XG52YXIgc3NldG1uID0gXCLiiJZcIjtcbnZhciBzc21pbGUgPSBcIuKMo1wiO1xudmFyIHNzdGFyZiA9IFwi4ouGXCI7XG52YXIgU3RhciA9IFwi4ouGXCI7XG52YXIgc3RhciA9IFwi4piGXCI7XG52YXIgc3RhcmYgPSBcIuKYhVwiO1xudmFyIHN0cmFpZ2h0ZXBzaWxvbiA9IFwiz7VcIjtcbnZhciBzdHJhaWdodHBoaSA9IFwiz5VcIjtcbnZhciBzdHJucyA9IFwiwq9cIjtcbnZhciBzdWIgPSBcIuKKglwiO1xudmFyIFN1YiA9IFwi4ouQXCI7XG52YXIgc3ViZG90ID0gXCLiqr1cIjtcbnZhciBzdWJFID0gXCLiq4VcIjtcbnZhciBzdWJlID0gXCLiioZcIjtcbnZhciBzdWJlZG90ID0gXCLiq4NcIjtcbnZhciBzdWJtdWx0ID0gXCLiq4FcIjtcbnZhciBzdWJuRSA9IFwi4quLXCI7XG52YXIgc3VibmUgPSBcIuKKilwiO1xudmFyIHN1YnBsdXMgPSBcIuKqv1wiO1xudmFyIHN1YnJhcnIgPSBcIuKluVwiO1xudmFyIHN1YnNldCA9IFwi4oqCXCI7XG52YXIgU3Vic2V0ID0gXCLii5BcIjtcbnZhciBzdWJzZXRlcSA9IFwi4oqGXCI7XG52YXIgc3Vic2V0ZXFxID0gXCLiq4VcIjtcbnZhciBTdWJzZXRFcXVhbCA9IFwi4oqGXCI7XG52YXIgc3Vic2V0bmVxID0gXCLiiopcIjtcbnZhciBzdWJzZXRuZXFxID0gXCLiq4tcIjtcbnZhciBzdWJzaW0gPSBcIuKrh1wiO1xudmFyIHN1YnN1YiA9IFwi4quVXCI7XG52YXIgc3Vic3VwID0gXCLiq5NcIjtcbnZhciBzdWNjYXBwcm94ID0gXCLiqrhcIjtcbnZhciBzdWNjID0gXCLiibtcIjtcbnZhciBzdWNjY3VybHllcSA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHMgPSBcIuKJu1wiO1xudmFyIFN1Y2NlZWRzRXF1YWwgPSBcIuKqsFwiO1xudmFyIFN1Y2NlZWRzU2xhbnRFcXVhbCA9IFwi4om9XCI7XG52YXIgU3VjY2VlZHNUaWxkZSA9IFwi4om/XCI7XG52YXIgc3VjY2VxID0gXCLiqrBcIjtcbnZhciBzdWNjbmFwcHJveCA9IFwi4qq6XCI7XG52YXIgc3VjY25lcXEgPSBcIuKqtlwiO1xudmFyIHN1Y2Nuc2ltID0gXCLii6lcIjtcbnZhciBzdWNjc2ltID0gXCLiib9cIjtcbnZhciBTdWNoVGhhdCA9IFwi4oiLXCI7XG52YXIgc3VtID0gXCLiiJFcIjtcbnZhciBTdW0gPSBcIuKIkVwiO1xudmFyIHN1bmcgPSBcIuKZqlwiO1xudmFyIHN1cDEkMSA9IFwiwrlcIjtcbnZhciBzdXAyJDEgPSBcIsKyXCI7XG52YXIgc3VwMyQxID0gXCLCs1wiO1xudmFyIHN1cCA9IFwi4oqDXCI7XG52YXIgU3VwID0gXCLii5FcIjtcbnZhciBzdXBkb3QgPSBcIuKqvlwiO1xudmFyIHN1cGRzdWIgPSBcIuKrmFwiO1xudmFyIHN1cEUgPSBcIuKrhlwiO1xudmFyIHN1cGUgPSBcIuKKh1wiO1xudmFyIHN1cGVkb3QgPSBcIuKrhFwiO1xudmFyIFN1cGVyc2V0ID0gXCLiioNcIjtcbnZhciBTdXBlcnNldEVxdWFsID0gXCLiiodcIjtcbnZhciBzdXBoc29sID0gXCLin4lcIjtcbnZhciBzdXBoc3ViID0gXCLiq5dcIjtcbnZhciBzdXBsYXJyID0gXCLipbtcIjtcbnZhciBzdXBtdWx0ID0gXCLiq4JcIjtcbnZhciBzdXBuRSA9IFwi4quMXCI7XG52YXIgc3VwbmUgPSBcIuKKi1wiO1xudmFyIHN1cHBsdXMgPSBcIuKrgFwiO1xudmFyIHN1cHNldCA9IFwi4oqDXCI7XG52YXIgU3Vwc2V0ID0gXCLii5FcIjtcbnZhciBzdXBzZXRlcSA9IFwi4oqHXCI7XG52YXIgc3Vwc2V0ZXFxID0gXCLiq4ZcIjtcbnZhciBzdXBzZXRuZXEgPSBcIuKKi1wiO1xudmFyIHN1cHNldG5lcXEgPSBcIuKrjFwiO1xudmFyIHN1cHNpbSA9IFwi4quIXCI7XG52YXIgc3Vwc3ViID0gXCLiq5RcIjtcbnZhciBzdXBzdXAgPSBcIuKrllwiO1xudmFyIHN3YXJoayA9IFwi4qSmXCI7XG52YXIgc3dhcnIgPSBcIuKGmVwiO1xudmFyIHN3QXJyID0gXCLih5lcIjtcbnZhciBzd2Fycm93ID0gXCLihplcIjtcbnZhciBzd253YXIgPSBcIuKkqlwiO1xudmFyIHN6bGlnJDEgPSBcIsOfXCI7XG52YXIgVGFiID0gXCJcXHRcIjtcbnZhciB0YXJnZXQgPSBcIuKMllwiO1xudmFyIFRhdSA9IFwizqRcIjtcbnZhciB0YXUgPSBcIs+EXCI7XG52YXIgdGJyayA9IFwi4o60XCI7XG52YXIgVGNhcm9uID0gXCLFpFwiO1xudmFyIHRjYXJvbiA9IFwixaVcIjtcbnZhciBUY2VkaWwgPSBcIsWiXCI7XG52YXIgdGNlZGlsID0gXCLFo1wiO1xudmFyIFRjeSA9IFwi0KJcIjtcbnZhciB0Y3kgPSBcItGCXCI7XG52YXIgdGRvdCA9IFwi4oObXCI7XG52YXIgdGVscmVjID0gXCLijJVcIjtcbnZhciBUZnIgPSBcIvCdlJdcIjtcbnZhciB0ZnIgPSBcIvCdlLFcIjtcbnZhciB0aGVyZTQgPSBcIuKItFwiO1xudmFyIHRoZXJlZm9yZSA9IFwi4oi0XCI7XG52YXIgVGhlcmVmb3JlID0gXCLiiLRcIjtcbnZhciBUaGV0YSA9IFwizphcIjtcbnZhciB0aGV0YSA9IFwizrhcIjtcbnZhciB0aGV0YXN5bSA9IFwiz5FcIjtcbnZhciB0aGV0YXYgPSBcIs+RXCI7XG52YXIgdGhpY2thcHByb3ggPSBcIuKJiFwiO1xudmFyIHRoaWNrc2ltID0gXCLiiLxcIjtcbnZhciBUaGlja1NwYWNlID0gXCLigZ/igIpcIjtcbnZhciBUaGluU3BhY2UgPSBcIuKAiVwiO1xudmFyIHRoaW5zcCA9IFwi4oCJXCI7XG52YXIgdGhrYXAgPSBcIuKJiFwiO1xudmFyIHRoa3NpbSA9IFwi4oi8XCI7XG52YXIgVEhPUk4kMSA9IFwiw55cIjtcbnZhciB0aG9ybiQxID0gXCLDvlwiO1xudmFyIHRpbGRlID0gXCLLnFwiO1xudmFyIFRpbGRlID0gXCLiiLxcIjtcbnZhciBUaWxkZUVxdWFsID0gXCLiiYNcIjtcbnZhciBUaWxkZUZ1bGxFcXVhbCA9IFwi4omFXCI7XG52YXIgVGlsZGVUaWxkZSA9IFwi4omIXCI7XG52YXIgdGltZXNiYXIgPSBcIuKosVwiO1xudmFyIHRpbWVzYiA9IFwi4oqgXCI7XG52YXIgdGltZXMkMSA9IFwiw5dcIjtcbnZhciB0aW1lc2QgPSBcIuKosFwiO1xudmFyIHRpbnQgPSBcIuKIrVwiO1xudmFyIHRvZWEgPSBcIuKkqFwiO1xudmFyIHRvcGJvdCA9IFwi4oy2XCI7XG52YXIgdG9wY2lyID0gXCLiq7FcIjtcbnZhciBlc21fdG9wID0gXCLiiqRcIjtcbnZhciBUb3BmID0gXCLwnZWLXCI7XG52YXIgdG9wZiA9IFwi8J2VpVwiO1xudmFyIHRvcGZvcmsgPSBcIuKrmlwiO1xudmFyIHRvc2EgPSBcIuKkqVwiO1xudmFyIHRwcmltZSA9IFwi4oC0XCI7XG52YXIgdHJhZGUgPSBcIuKEolwiO1xudmFyIFRSQURFID0gXCLihKJcIjtcbnZhciB0cmlhbmdsZSA9IFwi4pa1XCI7XG52YXIgdHJpYW5nbGVkb3duID0gXCLilr9cIjtcbnZhciB0cmlhbmdsZWxlZnQgPSBcIuKXg1wiO1xudmFyIHRyaWFuZ2xlbGVmdGVxID0gXCLiirRcIjtcbnZhciB0cmlhbmdsZXEgPSBcIuKJnFwiO1xudmFyIHRyaWFuZ2xlcmlnaHQgPSBcIuKWuVwiO1xudmFyIHRyaWFuZ2xlcmlnaHRlcSA9IFwi4oq1XCI7XG52YXIgdHJpZG90ID0gXCLil6xcIjtcbnZhciB0cmllID0gXCLiiZxcIjtcbnZhciB0cmltaW51cyA9IFwi4qi6XCI7XG52YXIgVHJpcGxlRG90ID0gXCLig5tcIjtcbnZhciB0cmlwbHVzID0gXCLiqLlcIjtcbnZhciB0cmlzYiA9IFwi4qeNXCI7XG52YXIgdHJpdGltZSA9IFwi4qi7XCI7XG52YXIgdHJwZXppdW0gPSBcIuKPolwiO1xudmFyIFRzY3IgPSBcIvCdkq9cIjtcbnZhciB0c2NyID0gXCLwnZOJXCI7XG52YXIgVFNjeSA9IFwi0KZcIjtcbnZhciB0c2N5ID0gXCLRhlwiO1xudmFyIFRTSGN5ID0gXCLQi1wiO1xudmFyIHRzaGN5ID0gXCLRm1wiO1xudmFyIFRzdHJvayA9IFwixaZcIjtcbnZhciB0c3Ryb2sgPSBcIsWnXCI7XG52YXIgdHdpeHQgPSBcIuKJrFwiO1xudmFyIHR3b2hlYWRsZWZ0YXJyb3cgPSBcIuKGnlwiO1xudmFyIHR3b2hlYWRyaWdodGFycm93ID0gXCLihqBcIjtcbnZhciBVYWN1dGUkMSA9IFwiw5pcIjtcbnZhciB1YWN1dGUkMSA9IFwiw7pcIjtcbnZhciB1YXJyID0gXCLihpFcIjtcbnZhciBVYXJyID0gXCLihp9cIjtcbnZhciB1QXJyID0gXCLih5FcIjtcbnZhciBVYXJyb2NpciA9IFwi4qWJXCI7XG52YXIgVWJyY3kgPSBcItCOXCI7XG52YXIgdWJyY3kgPSBcItGeXCI7XG52YXIgVWJyZXZlID0gXCLFrFwiO1xudmFyIHVicmV2ZSA9IFwixa1cIjtcbnZhciBVY2lyYyQxID0gXCLDm1wiO1xudmFyIHVjaXJjJDEgPSBcIsO7XCI7XG52YXIgVWN5ID0gXCLQo1wiO1xudmFyIHVjeSA9IFwi0YNcIjtcbnZhciB1ZGFyciA9IFwi4oeFXCI7XG52YXIgVWRibGFjID0gXCLFsFwiO1xudmFyIHVkYmxhYyA9IFwixbFcIjtcbnZhciB1ZGhhciA9IFwi4qWuXCI7XG52YXIgdWZpc2h0ID0gXCLipb5cIjtcbnZhciBVZnIgPSBcIvCdlJhcIjtcbnZhciB1ZnIgPSBcIvCdlLJcIjtcbnZhciBVZ3JhdmUkMSA9IFwiw5lcIjtcbnZhciB1Z3JhdmUkMSA9IFwiw7lcIjtcbnZhciB1SGFyID0gXCLipaNcIjtcbnZhciB1aGFybCA9IFwi4oa/XCI7XG52YXIgdWhhcnIgPSBcIuKGvlwiO1xudmFyIHVoYmxrID0gXCLiloBcIjtcbnZhciB1bGNvcm4gPSBcIuKMnFwiO1xudmFyIHVsY29ybmVyID0gXCLijJxcIjtcbnZhciB1bGNyb3AgPSBcIuKMj1wiO1xudmFyIHVsdHJpID0gXCLil7hcIjtcbnZhciBVbWFjciA9IFwixapcIjtcbnZhciB1bWFjciA9IFwixatcIjtcbnZhciB1bWwkMSA9IFwiwqhcIjtcbnZhciBVbmRlckJhciA9IFwiX1wiO1xudmFyIFVuZGVyQnJhY2UgPSBcIuKPn1wiO1xudmFyIFVuZGVyQnJhY2tldCA9IFwi4o61XCI7XG52YXIgVW5kZXJQYXJlbnRoZXNpcyA9IFwi4o+dXCI7XG52YXIgVW5pb24gPSBcIuKLg1wiO1xudmFyIFVuaW9uUGx1cyA9IFwi4oqOXCI7XG52YXIgVW9nb24gPSBcIsWyXCI7XG52YXIgdW9nb24gPSBcIsWzXCI7XG52YXIgVW9wZiA9IFwi8J2VjFwiO1xudmFyIHVvcGYgPSBcIvCdlaZcIjtcbnZhciBVcEFycm93QmFyID0gXCLipJJcIjtcbnZhciB1cGFycm93ID0gXCLihpFcIjtcbnZhciBVcEFycm93ID0gXCLihpFcIjtcbnZhciBVcGFycm93ID0gXCLih5FcIjtcbnZhciBVcEFycm93RG93bkFycm93ID0gXCLih4VcIjtcbnZhciB1cGRvd25hcnJvdyA9IFwi4oaVXCI7XG52YXIgVXBEb3duQXJyb3cgPSBcIuKGlVwiO1xudmFyIFVwZG93bmFycm93ID0gXCLih5VcIjtcbnZhciBVcEVxdWlsaWJyaXVtID0gXCLipa5cIjtcbnZhciB1cGhhcnBvb25sZWZ0ID0gXCLihr9cIjtcbnZhciB1cGhhcnBvb25yaWdodCA9IFwi4oa+XCI7XG52YXIgdXBsdXMgPSBcIuKKjlwiO1xudmFyIFVwcGVyTGVmdEFycm93ID0gXCLihpZcIjtcbnZhciBVcHBlclJpZ2h0QXJyb3cgPSBcIuKGl1wiO1xudmFyIHVwc2kgPSBcIs+FXCI7XG52YXIgVXBzaSA9IFwiz5JcIjtcbnZhciB1cHNpaCA9IFwiz5JcIjtcbnZhciBVcHNpbG9uID0gXCLOpVwiO1xudmFyIHVwc2lsb24gPSBcIs+FXCI7XG52YXIgVXBUZWVBcnJvdyA9IFwi4oalXCI7XG52YXIgVXBUZWUgPSBcIuKKpVwiO1xudmFyIHVwdXBhcnJvd3MgPSBcIuKHiFwiO1xudmFyIHVyY29ybiA9IFwi4oydXCI7XG52YXIgdXJjb3JuZXIgPSBcIuKMnVwiO1xudmFyIHVyY3JvcCA9IFwi4oyOXCI7XG52YXIgVXJpbmcgPSBcIsWuXCI7XG52YXIgdXJpbmcgPSBcIsWvXCI7XG52YXIgdXJ0cmkgPSBcIuKXuVwiO1xudmFyIFVzY3IgPSBcIvCdkrBcIjtcbnZhciB1c2NyID0gXCLwnZOKXCI7XG52YXIgdXRkb3QgPSBcIuKLsFwiO1xudmFyIFV0aWxkZSA9IFwixahcIjtcbnZhciB1dGlsZGUgPSBcIsWpXCI7XG52YXIgdXRyaSA9IFwi4pa1XCI7XG52YXIgdXRyaWYgPSBcIuKWtFwiO1xudmFyIHV1YXJyID0gXCLih4hcIjtcbnZhciBVdW1sJDEgPSBcIsOcXCI7XG52YXIgdXVtbCQxID0gXCLDvFwiO1xudmFyIHV3YW5nbGUgPSBcIuKmp1wiO1xudmFyIHZhbmdydCA9IFwi4qacXCI7XG52YXIgdmFyZXBzaWxvbiA9IFwiz7VcIjtcbnZhciB2YXJrYXBwYSA9IFwiz7BcIjtcbnZhciB2YXJub3RoaW5nID0gXCLiiIVcIjtcbnZhciB2YXJwaGkgPSBcIs+VXCI7XG52YXIgdmFycGkgPSBcIs+WXCI7XG52YXIgdmFycHJvcHRvID0gXCLiiJ1cIjtcbnZhciB2YXJyID0gXCLihpVcIjtcbnZhciB2QXJyID0gXCLih5VcIjtcbnZhciB2YXJyaG8gPSBcIs+xXCI7XG52YXIgdmFyc2lnbWEgPSBcIs+CXCI7XG52YXIgdmFyc3Vic2V0bmVxID0gXCLiiorvuIBcIjtcbnZhciB2YXJzdWJzZXRuZXFxID0gXCLiq4vvuIBcIjtcbnZhciB2YXJzdXBzZXRuZXEgPSBcIuKKi++4gFwiO1xudmFyIHZhcnN1cHNldG5lcXEgPSBcIuKrjO+4gFwiO1xudmFyIHZhcnRoZXRhID0gXCLPkVwiO1xudmFyIHZhcnRyaWFuZ2xlbGVmdCA9IFwi4oqyXCI7XG52YXIgdmFydHJpYW5nbGVyaWdodCA9IFwi4oqzXCI7XG52YXIgdkJhciA9IFwi4quoXCI7XG52YXIgVmJhciA9IFwi4qurXCI7XG52YXIgdkJhcnYgPSBcIuKrqVwiO1xudmFyIFZjeSA9IFwi0JJcIjtcbnZhciB2Y3kgPSBcItCyXCI7XG52YXIgdmRhc2ggPSBcIuKKolwiO1xudmFyIHZEYXNoID0gXCLiiqhcIjtcbnZhciBWZGFzaCA9IFwi4oqpXCI7XG52YXIgVkRhc2ggPSBcIuKKq1wiO1xudmFyIFZkYXNobCA9IFwi4qumXCI7XG52YXIgdmVlYmFyID0gXCLiirtcIjtcbnZhciB2ZWUgPSBcIuKIqFwiO1xudmFyIFZlZSA9IFwi4ouBXCI7XG52YXIgdmVlZXEgPSBcIuKJmlwiO1xudmFyIHZlbGxpcCA9IFwi4ouuXCI7XG52YXIgdmVyYmFyID0gXCJ8XCI7XG52YXIgVmVyYmFyID0gXCLigJZcIjtcbnZhciB2ZXJ0ID0gXCJ8XCI7XG52YXIgVmVydCA9IFwi4oCWXCI7XG52YXIgVmVydGljYWxCYXIgPSBcIuKIo1wiO1xudmFyIFZlcnRpY2FsTGluZSA9IFwifFwiO1xudmFyIFZlcnRpY2FsU2VwYXJhdG9yID0gXCLinZhcIjtcbnZhciBWZXJ0aWNhbFRpbGRlID0gXCLiiYBcIjtcbnZhciBWZXJ5VGhpblNwYWNlID0gXCLigIpcIjtcbnZhciBWZnIgPSBcIvCdlJlcIjtcbnZhciB2ZnIgPSBcIvCdlLNcIjtcbnZhciB2bHRyaSA9IFwi4oqyXCI7XG52YXIgdm5zdWIgPSBcIuKKguKDklwiO1xudmFyIHZuc3VwID0gXCLiioPig5JcIjtcbnZhciBWb3BmID0gXCLwnZWNXCI7XG52YXIgdm9wZiA9IFwi8J2Vp1wiO1xudmFyIHZwcm9wID0gXCLiiJ1cIjtcbnZhciB2cnRyaSA9IFwi4oqzXCI7XG52YXIgVnNjciA9IFwi8J2SsVwiO1xudmFyIHZzY3IgPSBcIvCdk4tcIjtcbnZhciB2c3VibkUgPSBcIuKri++4gFwiO1xudmFyIHZzdWJuZSA9IFwi4oqK77iAXCI7XG52YXIgdnN1cG5FID0gXCLiq4zvuIBcIjtcbnZhciB2c3VwbmUgPSBcIuKKi++4gFwiO1xudmFyIFZ2ZGFzaCA9IFwi4oqqXCI7XG52YXIgdnppZ3phZyA9IFwi4qaaXCI7XG52YXIgV2NpcmMgPSBcIsW0XCI7XG52YXIgd2NpcmMgPSBcIsW1XCI7XG52YXIgd2VkYmFyID0gXCLiqZ9cIjtcbnZhciB3ZWRnZSA9IFwi4oinXCI7XG52YXIgV2VkZ2UgPSBcIuKLgFwiO1xudmFyIHdlZGdlcSA9IFwi4omZXCI7XG52YXIgd2VpZXJwID0gXCLihJhcIjtcbnZhciBXZnIgPSBcIvCdlJpcIjtcbnZhciB3ZnIgPSBcIvCdlLRcIjtcbnZhciBXb3BmID0gXCLwnZWOXCI7XG52YXIgd29wZiA9IFwi8J2VqFwiO1xudmFyIHdwID0gXCLihJhcIjtcbnZhciB3ciA9IFwi4omAXCI7XG52YXIgd3JlYXRoID0gXCLiiYBcIjtcbnZhciBXc2NyID0gXCLwnZKyXCI7XG52YXIgd3NjciA9IFwi8J2TjFwiO1xudmFyIHhjYXAgPSBcIuKLglwiO1xudmFyIHhjaXJjID0gXCLil69cIjtcbnZhciB4Y3VwID0gXCLii4NcIjtcbnZhciB4ZHRyaSA9IFwi4pa9XCI7XG52YXIgWGZyID0gXCLwnZSbXCI7XG52YXIgeGZyID0gXCLwnZS1XCI7XG52YXIgeGhhcnIgPSBcIuKft1wiO1xudmFyIHhoQXJyID0gXCLin7pcIjtcbnZhciBYaSA9IFwizp5cIjtcbnZhciB4aSA9IFwizr5cIjtcbnZhciB4bGFyciA9IFwi4p+1XCI7XG52YXIgeGxBcnIgPSBcIuKfuFwiO1xudmFyIHhtYXAgPSBcIuKfvFwiO1xudmFyIHhuaXMgPSBcIuKLu1wiO1xudmFyIHhvZG90ID0gXCLiqIBcIjtcbnZhciBYb3BmID0gXCLwnZWPXCI7XG52YXIgeG9wZiA9IFwi8J2VqVwiO1xudmFyIHhvcGx1cyA9IFwi4qiBXCI7XG52YXIgeG90aW1lID0gXCLiqIJcIjtcbnZhciB4cmFyciA9IFwi4p+2XCI7XG52YXIgeHJBcnIgPSBcIuKfuVwiO1xudmFyIFhzY3IgPSBcIvCdkrNcIjtcbnZhciB4c2NyID0gXCLwnZONXCI7XG52YXIgeHNxY3VwID0gXCLiqIZcIjtcbnZhciB4dXBsdXMgPSBcIuKohFwiO1xudmFyIHh1dHJpID0gXCLilrNcIjtcbnZhciB4dmVlID0gXCLii4FcIjtcbnZhciB4d2VkZ2UgPSBcIuKLgFwiO1xudmFyIFlhY3V0ZSQxID0gXCLDnVwiO1xudmFyIHlhY3V0ZSQxID0gXCLDvVwiO1xudmFyIFlBY3kgPSBcItCvXCI7XG52YXIgeWFjeSA9IFwi0Y9cIjtcbnZhciBZY2lyYyA9IFwixbZcIjtcbnZhciB5Y2lyYyA9IFwixbdcIjtcbnZhciBZY3kgPSBcItCrXCI7XG52YXIgeWN5ID0gXCLRi1wiO1xudmFyIHllbiQxID0gXCLCpVwiO1xudmFyIFlmciA9IFwi8J2UnFwiO1xudmFyIHlmciA9IFwi8J2UtlwiO1xudmFyIFlJY3kgPSBcItCHXCI7XG52YXIgeWljeSA9IFwi0ZdcIjtcbnZhciBZb3BmID0gXCLwnZWQXCI7XG52YXIgeW9wZiA9IFwi8J2VqlwiO1xudmFyIFlzY3IgPSBcIvCdkrRcIjtcbnZhciB5c2NyID0gXCLwnZOOXCI7XG52YXIgWVVjeSA9IFwi0K5cIjtcbnZhciB5dWN5ID0gXCLRjlwiO1xudmFyIHl1bWwkMSA9IFwiw79cIjtcbnZhciBZdW1sID0gXCLFuFwiO1xudmFyIFphY3V0ZSA9IFwixblcIjtcbnZhciB6YWN1dGUgPSBcIsW6XCI7XG52YXIgWmNhcm9uID0gXCLFvVwiO1xudmFyIHpjYXJvbiA9IFwixb5cIjtcbnZhciBaY3kgPSBcItCXXCI7XG52YXIgemN5ID0gXCLQt1wiO1xudmFyIFpkb3QgPSBcIsW7XCI7XG52YXIgemRvdCA9IFwixbxcIjtcbnZhciB6ZWV0cmYgPSBcIuKEqFwiO1xudmFyIFplcm9XaWR0aFNwYWNlID0gXCLigItcIjtcbnZhciBaZXRhID0gXCLOllwiO1xudmFyIHpldGEgPSBcIs62XCI7XG52YXIgemZyID0gXCLwnZS3XCI7XG52YXIgWmZyID0gXCLihKhcIjtcbnZhciBaSGN5ID0gXCLQllwiO1xudmFyIHpoY3kgPSBcItC2XCI7XG52YXIgemlncmFyciA9IFwi4oedXCI7XG52YXIgem9wZiA9IFwi8J2Vq1wiO1xudmFyIFpvcGYgPSBcIuKEpFwiO1xudmFyIFpzY3IgPSBcIvCdkrVcIjtcbnZhciB6c2NyID0gXCLwnZOPXCI7XG52YXIgendqID0gXCLigI1cIjtcbnZhciB6d25qID0gXCLigIxcIjtcbnZhciByZXF1aXJlJCQxJDEgPSB7XG4gICAgQWFjdXRlOiBBYWN1dGUkMSxcbiAgICBhYWN1dGU6IGFhY3V0ZSQxLFxuICAgIEFicmV2ZTogQWJyZXZlLFxuICAgIGFicmV2ZTogYWJyZXZlLFxuICAgIGFjOiBhYyxcbiAgICBhY2Q6IGFjZCxcbiAgICBhY0U6IGFjRSxcbiAgICBBY2lyYzogQWNpcmMkMSxcbiAgICBhY2lyYzogYWNpcmMkMSxcbiAgICBhY3V0ZTogYWN1dGUkMSxcbiAgICBBY3k6IEFjeSxcbiAgICBhY3k6IGFjeSxcbiAgICBBRWxpZzogQUVsaWckMSxcbiAgICBhZWxpZzogYWVsaWckMSxcbiAgICBhZjogYWYsXG4gICAgQWZyOiBBZnIsXG4gICAgYWZyOiBhZnIsXG4gICAgQWdyYXZlOiBBZ3JhdmUkMSxcbiAgICBhZ3JhdmU6IGFncmF2ZSQxLFxuICAgIGFsZWZzeW06IGFsZWZzeW0sXG4gICAgYWxlcGg6IGFsZXBoLFxuICAgIEFscGhhOiBBbHBoYSxcbiAgICBhbHBoYTogYWxwaGEsXG4gICAgQW1hY3I6IEFtYWNyLFxuICAgIGFtYWNyOiBhbWFjcixcbiAgICBhbWFsZzogYW1hbGcsXG4gICAgYW1wOiBhbXAkMixcbiAgICBBTVA6IEFNUCQxLFxuICAgIGFuZGFuZDogYW5kYW5kLFxuICAgIEFuZDogQW5kLFxuICAgIGFuZDogYW5kLFxuICAgIGFuZGQ6IGFuZGQsXG4gICAgYW5kc2xvcGU6IGFuZHNsb3BlLFxuICAgIGFuZHY6IGFuZHYsXG4gICAgYW5nOiBhbmcsXG4gICAgYW5nZTogYW5nZSxcbiAgICBhbmdsZTogYW5nbGUsXG4gICAgYW5nbXNkYWE6IGFuZ21zZGFhLFxuICAgIGFuZ21zZGFiOiBhbmdtc2RhYixcbiAgICBhbmdtc2RhYzogYW5nbXNkYWMsXG4gICAgYW5nbXNkYWQ6IGFuZ21zZGFkLFxuICAgIGFuZ21zZGFlOiBhbmdtc2RhZSxcbiAgICBhbmdtc2RhZjogYW5nbXNkYWYsXG4gICAgYW5nbXNkYWc6IGFuZ21zZGFnLFxuICAgIGFuZ21zZGFoOiBhbmdtc2RhaCxcbiAgICBhbmdtc2Q6IGFuZ21zZCxcbiAgICBhbmdydDogYW5ncnQsXG4gICAgYW5ncnR2YjogYW5ncnR2YixcbiAgICBhbmdydHZiZDogYW5ncnR2YmQsXG4gICAgYW5nc3BoOiBhbmdzcGgsXG4gICAgYW5nc3Q6IGFuZ3N0LFxuICAgIGFuZ3phcnI6IGFuZ3phcnIsXG4gICAgQW9nb246IEFvZ29uLFxuICAgIGFvZ29uOiBhb2dvbixcbiAgICBBb3BmOiBBb3BmLFxuICAgIGFvcGY6IGFvcGYsXG4gICAgYXBhY2lyOiBhcGFjaXIsXG4gICAgYXA6IGFwLFxuICAgIGFwRTogYXBFLFxuICAgIGFwZTogYXBlLFxuICAgIGFwaWQ6IGFwaWQsXG4gICAgYXBvczogYXBvcyQxLFxuICAgIEFwcGx5RnVuY3Rpb246IEFwcGx5RnVuY3Rpb24sXG4gICAgYXBwcm94OiBhcHByb3gsXG4gICAgYXBwcm94ZXE6IGFwcHJveGVxLFxuICAgIEFyaW5nOiBBcmluZyQxLFxuICAgIGFyaW5nOiBhcmluZyQxLFxuICAgIEFzY3I6IEFzY3IsXG4gICAgYXNjcjogYXNjcixcbiAgICBBc3NpZ246IEFzc2lnbixcbiAgICBhc3Q6IGFzdCxcbiAgICBhc3ltcDogYXN5bXAsXG4gICAgYXN5bXBlcTogYXN5bXBlcSxcbiAgICBBdGlsZGU6IEF0aWxkZSQxLFxuICAgIGF0aWxkZTogYXRpbGRlJDEsXG4gICAgQXVtbDogQXVtbCQxLFxuICAgIGF1bWw6IGF1bWwkMSxcbiAgICBhd2NvbmludDogYXdjb25pbnQsXG4gICAgYXdpbnQ6IGF3aW50LFxuICAgIGJhY2tjb25nOiBiYWNrY29uZyxcbiAgICBiYWNrZXBzaWxvbjogYmFja2Vwc2lsb24sXG4gICAgYmFja3ByaW1lOiBiYWNrcHJpbWUsXG4gICAgYmFja3NpbTogYmFja3NpbSxcbiAgICBiYWNrc2ltZXE6IGJhY2tzaW1lcSxcbiAgICBCYWNrc2xhc2g6IEJhY2tzbGFzaCxcbiAgICBCYXJ2OiBCYXJ2LFxuICAgIGJhcnZlZTogYmFydmVlLFxuICAgIGJhcndlZDogYmFyd2VkLFxuICAgIEJhcndlZDogQmFyd2VkLFxuICAgIGJhcndlZGdlOiBiYXJ3ZWRnZSxcbiAgICBiYnJrOiBiYnJrLFxuICAgIGJicmt0YnJrOiBiYnJrdGJyayxcbiAgICBiY29uZzogYmNvbmcsXG4gICAgQmN5OiBCY3ksXG4gICAgYmN5OiBiY3ksXG4gICAgYmRxdW86IGJkcXVvLFxuICAgIGJlY2F1czogYmVjYXVzLFxuICAgIGJlY2F1c2U6IGJlY2F1c2UsXG4gICAgQmVjYXVzZTogQmVjYXVzZSxcbiAgICBiZW1wdHl2OiBiZW1wdHl2LFxuICAgIGJlcHNpOiBiZXBzaSxcbiAgICBiZXJub3U6IGJlcm5vdSxcbiAgICBCZXJub3VsbGlzOiBCZXJub3VsbGlzLFxuICAgIEJldGE6IEJldGEsXG4gICAgYmV0YTogYmV0YSxcbiAgICBiZXRoOiBiZXRoLFxuICAgIGJldHdlZW46IGJldHdlZW4sXG4gICAgQmZyOiBCZnIsXG4gICAgYmZyOiBiZnIsXG4gICAgYmlnY2FwOiBiaWdjYXAsXG4gICAgYmlnY2lyYzogYmlnY2lyYyxcbiAgICBiaWdjdXA6IGJpZ2N1cCxcbiAgICBiaWdvZG90OiBiaWdvZG90LFxuICAgIGJpZ29wbHVzOiBiaWdvcGx1cyxcbiAgICBiaWdvdGltZXM6IGJpZ290aW1lcyxcbiAgICBiaWdzcWN1cDogYmlnc3FjdXAsXG4gICAgYmlnc3RhcjogYmlnc3RhcixcbiAgICBiaWd0cmlhbmdsZWRvd246IGJpZ3RyaWFuZ2xlZG93bixcbiAgICBiaWd0cmlhbmdsZXVwOiBiaWd0cmlhbmdsZXVwLFxuICAgIGJpZ3VwbHVzOiBiaWd1cGx1cyxcbiAgICBiaWd2ZWU6IGJpZ3ZlZSxcbiAgICBiaWd3ZWRnZTogYmlnd2VkZ2UsXG4gICAgYmthcm93OiBia2Fyb3csXG4gICAgYmxhY2tsb3plbmdlOiBibGFja2xvemVuZ2UsXG4gICAgYmxhY2tzcXVhcmU6IGJsYWNrc3F1YXJlLFxuICAgIGJsYWNrdHJpYW5nbGU6IGJsYWNrdHJpYW5nbGUsXG4gICAgYmxhY2t0cmlhbmdsZWRvd246IGJsYWNrdHJpYW5nbGVkb3duLFxuICAgIGJsYWNrdHJpYW5nbGVsZWZ0OiBibGFja3RyaWFuZ2xlbGVmdCxcbiAgICBibGFja3RyaWFuZ2xlcmlnaHQ6IGJsYWNrdHJpYW5nbGVyaWdodCxcbiAgICBibGFuazogYmxhbmssXG4gICAgYmxrMTI6IGJsazEyLFxuICAgIGJsazE0OiBibGsxNCxcbiAgICBibGszNDogYmxrMzQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGJuZTogYm5lLFxuICAgIGJuZXF1aXY6IGJuZXF1aXYsXG4gICAgYk5vdDogYk5vdCxcbiAgICBibm90OiBibm90LFxuICAgIEJvcGY6IEJvcGYsXG4gICAgYm9wZjogYm9wZixcbiAgICBib3Q6IGJvdCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBib3d0aWU6IGJvd3RpZSxcbiAgICBib3hib3g6IGJveGJveCxcbiAgICBib3hkbDogYm94ZGwsXG4gICAgYm94ZEw6IGJveGRMLFxuICAgIGJveERsOiBib3hEbCxcbiAgICBib3hETDogYm94REwsXG4gICAgYm94ZHI6IGJveGRyLFxuICAgIGJveGRSOiBib3hkUixcbiAgICBib3hEcjogYm94RHIsXG4gICAgYm94RFI6IGJveERSLFxuICAgIGJveGg6IGJveGgsXG4gICAgYm94SDogYm94SCxcbiAgICBib3hoZDogYm94aGQsXG4gICAgYm94SGQ6IGJveEhkLFxuICAgIGJveGhEOiBib3hoRCxcbiAgICBib3hIRDogYm94SEQsXG4gICAgYm94aHU6IGJveGh1LFxuICAgIGJveEh1OiBib3hIdSxcbiAgICBib3hoVTogYm94aFUsXG4gICAgYm94SFU6IGJveEhVLFxuICAgIGJveG1pbnVzOiBib3htaW51cyxcbiAgICBib3hwbHVzOiBib3hwbHVzLFxuICAgIGJveHRpbWVzOiBib3h0aW1lcyxcbiAgICBib3h1bDogYm94dWwsXG4gICAgYm94dUw6IGJveHVMLFxuICAgIGJveFVsOiBib3hVbCxcbiAgICBib3hVTDogYm94VUwsXG4gICAgYm94dXI6IGJveHVyLFxuICAgIGJveHVSOiBib3h1UixcbiAgICBib3hVcjogYm94VXIsXG4gICAgYm94VVI6IGJveFVSLFxuICAgIGJveHY6IGJveHYsXG4gICAgYm94VjogYm94VixcbiAgICBib3h2aDogYm94dmgsXG4gICAgYm94dkg6IGJveHZILFxuICAgIGJveFZoOiBib3hWaCxcbiAgICBib3hWSDogYm94VkgsXG4gICAgYm94dmw6IGJveHZsLFxuICAgIGJveHZMOiBib3h2TCxcbiAgICBib3hWbDogYm94VmwsXG4gICAgYm94Vkw6IGJveFZMLFxuICAgIGJveHZyOiBib3h2cixcbiAgICBib3h2UjogYm94dlIsXG4gICAgYm94VnI6IGJveFZyLFxuICAgIGJveFZSOiBib3hWUixcbiAgICBicHJpbWU6IGJwcmltZSxcbiAgICBicmV2ZTogYnJldmUsXG4gICAgQnJldmU6IEJyZXZlLFxuICAgIGJydmJhcjogYnJ2YmFyJDEsXG4gICAgYnNjcjogYnNjcixcbiAgICBCc2NyOiBCc2NyLFxuICAgIGJzZW1pOiBic2VtaSxcbiAgICBic2ltOiBic2ltLFxuICAgIGJzaW1lOiBic2ltZSxcbiAgICBic29sYjogYnNvbGIsXG4gICAgYnNvbDogYnNvbCxcbiAgICBic29saHN1YjogYnNvbGhzdWIsXG4gICAgYnVsbDogYnVsbCxcbiAgICBidWxsZXQ6IGJ1bGxldCxcbiAgICBidW1wOiBidW1wLFxuICAgIGJ1bXBFOiBidW1wRSxcbiAgICBidW1wZTogYnVtcGUsXG4gICAgQnVtcGVxOiBCdW1wZXEsXG4gICAgYnVtcGVxOiBidW1wZXEsXG4gICAgQ2FjdXRlOiBDYWN1dGUsXG4gICAgY2FjdXRlOiBjYWN1dGUsXG4gICAgY2FwYW5kOiBjYXBhbmQsXG4gICAgY2FwYnJjdXA6IGNhcGJyY3VwLFxuICAgIGNhcGNhcDogY2FwY2FwLFxuICAgIGNhcDogY2FwLFxuICAgIENhcDogQ2FwLFxuICAgIGNhcGN1cDogY2FwY3VwLFxuICAgIGNhcGRvdDogY2FwZG90LFxuICAgIENhcGl0YWxEaWZmZXJlbnRpYWxEOiBDYXBpdGFsRGlmZmVyZW50aWFsRCxcbiAgICBjYXBzOiBjYXBzLFxuICAgIGNhcmV0OiBjYXJldCxcbiAgICBjYXJvbjogY2Fyb24sXG4gICAgQ2F5bGV5czogQ2F5bGV5cyxcbiAgICBjY2FwczogY2NhcHMsXG4gICAgQ2Nhcm9uOiBDY2Fyb24sXG4gICAgY2Nhcm9uOiBjY2Fyb24sXG4gICAgQ2NlZGlsOiBDY2VkaWwkMSxcbiAgICBjY2VkaWw6IGNjZWRpbCQxLFxuICAgIENjaXJjOiBDY2lyYyxcbiAgICBjY2lyYzogY2NpcmMsXG4gICAgQ2NvbmludDogQ2NvbmludCxcbiAgICBjY3VwczogY2N1cHMsXG4gICAgY2N1cHNzbTogY2N1cHNzbSxcbiAgICBDZG90OiBDZG90LFxuICAgIGNkb3Q6IGNkb3QsXG4gICAgY2VkaWw6IGNlZGlsJDEsXG4gICAgQ2VkaWxsYTogQ2VkaWxsYSxcbiAgICBjZW1wdHl2OiBjZW1wdHl2LFxuICAgIGNlbnQ6IGNlbnQkMSxcbiAgICBjZW50ZXJkb3Q6IGNlbnRlcmRvdCxcbiAgICBDZW50ZXJEb3Q6IENlbnRlckRvdCxcbiAgICBjZnI6IGNmcixcbiAgICBDZnI6IENmcixcbiAgICBDSGN5OiBDSGN5LFxuICAgIGNoY3k6IGNoY3ksXG4gICAgY2hlY2s6IGNoZWNrLFxuICAgIGNoZWNrbWFyazogY2hlY2ttYXJrLFxuICAgIENoaTogQ2hpLFxuICAgIGNoaTogY2hpLFxuICAgIGNpcmM6IGNpcmMsXG4gICAgY2lyY2VxOiBjaXJjZXEsXG4gICAgY2lyY2xlYXJyb3dsZWZ0OiBjaXJjbGVhcnJvd2xlZnQsXG4gICAgY2lyY2xlYXJyb3dyaWdodDogY2lyY2xlYXJyb3dyaWdodCxcbiAgICBjaXJjbGVkYXN0OiBjaXJjbGVkYXN0LFxuICAgIGNpcmNsZWRjaXJjOiBjaXJjbGVkY2lyYyxcbiAgICBjaXJjbGVkZGFzaDogY2lyY2xlZGRhc2gsXG4gICAgQ2lyY2xlRG90OiBDaXJjbGVEb3QsXG4gICAgY2lyY2xlZFI6IGNpcmNsZWRSLFxuICAgIGNpcmNsZWRTOiBjaXJjbGVkUyxcbiAgICBDaXJjbGVNaW51czogQ2lyY2xlTWludXMsXG4gICAgQ2lyY2xlUGx1czogQ2lyY2xlUGx1cyxcbiAgICBDaXJjbGVUaW1lczogQ2lyY2xlVGltZXMsXG4gICAgY2lyOiBjaXIsXG4gICAgY2lyRTogY2lyRSxcbiAgICBjaXJlOiBjaXJlLFxuICAgIGNpcmZuaW50OiBjaXJmbmludCxcbiAgICBjaXJtaWQ6IGNpcm1pZCxcbiAgICBjaXJzY2lyOiBjaXJzY2lyLFxuICAgIENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogQ2xvY2t3aXNlQ29udG91ckludGVncmFsLFxuICAgIENsb3NlQ3VybHlEb3VibGVRdW90ZTogQ2xvc2VDdXJseURvdWJsZVF1b3RlLFxuICAgIENsb3NlQ3VybHlRdW90ZTogQ2xvc2VDdXJseVF1b3RlLFxuICAgIGNsdWJzOiBjbHVicyxcbiAgICBjbHVic3VpdDogY2x1YnN1aXQsXG4gICAgY29sb246IGNvbG9uLFxuICAgIENvbG9uOiBDb2xvbixcbiAgICBDb2xvbmU6IENvbG9uZSxcbiAgICBjb2xvbmU6IGNvbG9uZSxcbiAgICBjb2xvbmVxOiBjb2xvbmVxLFxuICAgIGNvbW1hOiBjb21tYSxcbiAgICBjb21tYXQ6IGNvbW1hdCxcbiAgICBjb21wOiBjb21wLFxuICAgIGNvbXBmbjogY29tcGZuLFxuICAgIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsXG4gICAgY29tcGxleGVzOiBjb21wbGV4ZXMsXG4gICAgY29uZzogY29uZyxcbiAgICBjb25nZG90OiBjb25nZG90LFxuICAgIENvbmdydWVudDogQ29uZ3J1ZW50LFxuICAgIGNvbmludDogY29uaW50LFxuICAgIENvbmludDogQ29uaW50LFxuICAgIENvbnRvdXJJbnRlZ3JhbDogQ29udG91ckludGVncmFsLFxuICAgIGNvcGY6IGNvcGYsXG4gICAgQ29wZjogQ29wZixcbiAgICBjb3Byb2Q6IGNvcHJvZCxcbiAgICBDb3Byb2R1Y3Q6IENvcHJvZHVjdCxcbiAgICBjb3B5OiBjb3B5JDEsXG4gICAgQ09QWTogQ09QWSQxLFxuICAgIGNvcHlzcjogY29weXNyLFxuICAgIENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6IENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwsXG4gICAgY3JhcnI6IGNyYXJyLFxuICAgIGNyb3NzOiBjcm9zcyxcbiAgICBDcm9zczogQ3Jvc3MsXG4gICAgQ3NjcjogQ3NjcixcbiAgICBjc2NyOiBjc2NyLFxuICAgIGNzdWI6IGNzdWIsXG4gICAgY3N1YmU6IGNzdWJlLFxuICAgIGNzdXA6IGNzdXAsXG4gICAgY3N1cGU6IGNzdXBlLFxuICAgIGN0ZG90OiBjdGRvdCxcbiAgICBjdWRhcnJsOiBjdWRhcnJsLFxuICAgIGN1ZGFycnI6IGN1ZGFycnIsXG4gICAgY3VlcHI6IGN1ZXByLFxuICAgIGN1ZXNjOiBjdWVzYyxcbiAgICBjdWxhcnI6IGN1bGFycixcbiAgICBjdWxhcnJwOiBjdWxhcnJwLFxuICAgIGN1cGJyY2FwOiBjdXBicmNhcCxcbiAgICBjdXBjYXA6IGN1cGNhcCxcbiAgICBDdXBDYXA6IEN1cENhcCxcbiAgICBjdXA6IGN1cCxcbiAgICBDdXA6IEN1cCxcbiAgICBjdXBjdXA6IGN1cGN1cCxcbiAgICBjdXBkb3Q6IGN1cGRvdCxcbiAgICBjdXBvcjogY3Vwb3IsXG4gICAgY3VwczogY3VwcyxcbiAgICBjdXJhcnI6IGN1cmFycixcbiAgICBjdXJhcnJtOiBjdXJhcnJtLFxuICAgIGN1cmx5ZXFwcmVjOiBjdXJseWVxcHJlYyxcbiAgICBjdXJseWVxc3VjYzogY3VybHllcXN1Y2MsXG4gICAgY3VybHl2ZWU6IGN1cmx5dmVlLFxuICAgIGN1cmx5d2VkZ2U6IGN1cmx5d2VkZ2UsXG4gICAgY3VycmVuOiBjdXJyZW4kMSxcbiAgICBjdXJ2ZWFycm93bGVmdDogY3VydmVhcnJvd2xlZnQsXG4gICAgY3VydmVhcnJvd3JpZ2h0OiBjdXJ2ZWFycm93cmlnaHQsXG4gICAgY3V2ZWU6IGN1dmVlLFxuICAgIGN1d2VkOiBjdXdlZCxcbiAgICBjd2NvbmludDogY3djb25pbnQsXG4gICAgY3dpbnQ6IGN3aW50LFxuICAgIGN5bGN0eTogY3lsY3R5LFxuICAgIGRhZ2dlcjogZGFnZ2VyLFxuICAgIERhZ2dlcjogRGFnZ2VyLFxuICAgIGRhbGV0aDogZGFsZXRoLFxuICAgIGRhcnI6IGRhcnIsXG4gICAgRGFycjogRGFycixcbiAgICBkQXJyOiBkQXJyLFxuICAgIGRhc2g6IGRhc2gsXG4gICAgRGFzaHY6IERhc2h2LFxuICAgIGRhc2h2OiBkYXNodixcbiAgICBkYmthcm93OiBkYmthcm93LFxuICAgIGRibGFjOiBkYmxhYyxcbiAgICBEY2Fyb246IERjYXJvbixcbiAgICBkY2Fyb246IGRjYXJvbixcbiAgICBEY3k6IERjeSxcbiAgICBkY3k6IGRjeSxcbiAgICBkZGFnZ2VyOiBkZGFnZ2VyLFxuICAgIGRkYXJyOiBkZGFycixcbiAgICBERDogREQsXG4gICAgZGQ6IGRkLFxuICAgIEREb3RyYWhkOiBERG90cmFoZCxcbiAgICBkZG90c2VxOiBkZG90c2VxLFxuICAgIGRlZzogZGVnJDEsXG4gICAgRGVsOiBEZWwsXG4gICAgRGVsdGE6IERlbHRhLFxuICAgIGRlbHRhOiBkZWx0YSxcbiAgICBkZW1wdHl2OiBkZW1wdHl2LFxuICAgIGRmaXNodDogZGZpc2h0LFxuICAgIERmcjogRGZyLFxuICAgIGRmcjogZGZyLFxuICAgIGRIYXI6IGRIYXIsXG4gICAgZGhhcmw6IGRoYXJsLFxuICAgIGRoYXJyOiBkaGFycixcbiAgICBEaWFjcml0aWNhbEFjdXRlOiBEaWFjcml0aWNhbEFjdXRlLFxuICAgIERpYWNyaXRpY2FsRG90OiBEaWFjcml0aWNhbERvdCxcbiAgICBEaWFjcml0aWNhbERvdWJsZUFjdXRlOiBEaWFjcml0aWNhbERvdWJsZUFjdXRlLFxuICAgIERpYWNyaXRpY2FsR3JhdmU6IERpYWNyaXRpY2FsR3JhdmUsXG4gICAgRGlhY3JpdGljYWxUaWxkZTogRGlhY3JpdGljYWxUaWxkZSxcbiAgICBkaWFtOiBkaWFtLFxuICAgIGRpYW1vbmQ6IGRpYW1vbmQsXG4gICAgRGlhbW9uZDogRGlhbW9uZCxcbiAgICBkaWFtb25kc3VpdDogZGlhbW9uZHN1aXQsXG4gICAgZGlhbXM6IGRpYW1zLFxuICAgIGRpZTogZGllLFxuICAgIERpZmZlcmVudGlhbEQ6IERpZmZlcmVudGlhbEQsXG4gICAgZGlnYW1tYTogZGlnYW1tYSxcbiAgICBkaXNpbjogZGlzaW4sXG4gICAgZGl2OiBkaXYsXG4gICAgZGl2aWRlOiBkaXZpZGUkMSxcbiAgICBkaXZpZGVvbnRpbWVzOiBkaXZpZGVvbnRpbWVzLFxuICAgIGRpdm9ueDogZGl2b254LFxuICAgIERKY3k6IERKY3ksXG4gICAgZGpjeTogZGpjeSxcbiAgICBkbGNvcm46IGRsY29ybixcbiAgICBkbGNyb3A6IGRsY3JvcCxcbiAgICBkb2xsYXI6IGRvbGxhcixcbiAgICBEb3BmOiBEb3BmLFxuICAgIGRvcGY6IGRvcGYsXG4gICAgRG90OiBEb3QsXG4gICAgZG90OiBkb3QsXG4gICAgRG90RG90OiBEb3REb3QsXG4gICAgZG90ZXE6IGRvdGVxLFxuICAgIGRvdGVxZG90OiBkb3RlcWRvdCxcbiAgICBEb3RFcXVhbDogRG90RXF1YWwsXG4gICAgZG90bWludXM6IGRvdG1pbnVzLFxuICAgIGRvdHBsdXM6IGRvdHBsdXMsXG4gICAgZG90c3F1YXJlOiBkb3RzcXVhcmUsXG4gICAgZG91YmxlYmFyd2VkZ2U6IGRvdWJsZWJhcndlZGdlLFxuICAgIERvdWJsZUNvbnRvdXJJbnRlZ3JhbDogRG91YmxlQ29udG91ckludGVncmFsLFxuICAgIERvdWJsZURvdDogRG91YmxlRG90LFxuICAgIERvdWJsZURvd25BcnJvdzogRG91YmxlRG93bkFycm93LFxuICAgIERvdWJsZUxlZnRBcnJvdzogRG91YmxlTGVmdEFycm93LFxuICAgIERvdWJsZUxlZnRSaWdodEFycm93OiBEb3VibGVMZWZ0UmlnaHRBcnJvdyxcbiAgICBEb3VibGVMZWZ0VGVlOiBEb3VibGVMZWZ0VGVlLFxuICAgIERvdWJsZUxvbmdMZWZ0QXJyb3c6IERvdWJsZUxvbmdMZWZ0QXJyb3csXG4gICAgRG91YmxlTG9uZ0xlZnRSaWdodEFycm93OiBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3csXG4gICAgRG91YmxlTG9uZ1JpZ2h0QXJyb3c6IERvdWJsZUxvbmdSaWdodEFycm93LFxuICAgIERvdWJsZVJpZ2h0QXJyb3c6IERvdWJsZVJpZ2h0QXJyb3csXG4gICAgRG91YmxlUmlnaHRUZWU6IERvdWJsZVJpZ2h0VGVlLFxuICAgIERvdWJsZVVwQXJyb3c6IERvdWJsZVVwQXJyb3csXG4gICAgRG91YmxlVXBEb3duQXJyb3c6IERvdWJsZVVwRG93bkFycm93LFxuICAgIERvdWJsZVZlcnRpY2FsQmFyOiBEb3VibGVWZXJ0aWNhbEJhcixcbiAgICBEb3duQXJyb3dCYXI6IERvd25BcnJvd0JhcixcbiAgICBkb3duYXJyb3c6IGRvd25hcnJvdyxcbiAgICBEb3duQXJyb3c6IERvd25BcnJvdyxcbiAgICBEb3duYXJyb3c6IERvd25hcnJvdyxcbiAgICBEb3duQXJyb3dVcEFycm93OiBEb3duQXJyb3dVcEFycm93LFxuICAgIERvd25CcmV2ZTogRG93bkJyZXZlLFxuICAgIGRvd25kb3duYXJyb3dzOiBkb3duZG93bmFycm93cyxcbiAgICBkb3duaGFycG9vbmxlZnQ6IGRvd25oYXJwb29ubGVmdCxcbiAgICBkb3duaGFycG9vbnJpZ2h0OiBkb3duaGFycG9vbnJpZ2h0LFxuICAgIERvd25MZWZ0UmlnaHRWZWN0b3I6IERvd25MZWZ0UmlnaHRWZWN0b3IsXG4gICAgRG93bkxlZnRUZWVWZWN0b3I6IERvd25MZWZ0VGVlVmVjdG9yLFxuICAgIERvd25MZWZ0VmVjdG9yQmFyOiBEb3duTGVmdFZlY3RvckJhcixcbiAgICBEb3duTGVmdFZlY3RvcjogRG93bkxlZnRWZWN0b3IsXG4gICAgRG93blJpZ2h0VGVlVmVjdG9yOiBEb3duUmlnaHRUZWVWZWN0b3IsXG4gICAgRG93blJpZ2h0VmVjdG9yQmFyOiBEb3duUmlnaHRWZWN0b3JCYXIsXG4gICAgRG93blJpZ2h0VmVjdG9yOiBEb3duUmlnaHRWZWN0b3IsXG4gICAgRG93blRlZUFycm93OiBEb3duVGVlQXJyb3csXG4gICAgRG93blRlZTogRG93blRlZSxcbiAgICBkcmJrYXJvdzogZHJia2Fyb3csXG4gICAgZHJjb3JuOiBkcmNvcm4sXG4gICAgZHJjcm9wOiBkcmNyb3AsXG4gICAgRHNjcjogRHNjcixcbiAgICBkc2NyOiBkc2NyLFxuICAgIERTY3k6IERTY3ksXG4gICAgZHNjeTogZHNjeSxcbiAgICBkc29sOiBkc29sLFxuICAgIERzdHJvazogRHN0cm9rLFxuICAgIGRzdHJvazogZHN0cm9rLFxuICAgIGR0ZG90OiBkdGRvdCxcbiAgICBkdHJpOiBkdHJpLFxuICAgIGR0cmlmOiBkdHJpZixcbiAgICBkdWFycjogZHVhcnIsXG4gICAgZHVoYXI6IGR1aGFyLFxuICAgIGR3YW5nbGU6IGR3YW5nbGUsXG4gICAgRFpjeTogRFpjeSxcbiAgICBkemN5OiBkemN5LFxuICAgIGR6aWdyYXJyOiBkemlncmFycixcbiAgICBFYWN1dGU6IEVhY3V0ZSQxLFxuICAgIGVhY3V0ZTogZWFjdXRlJDEsXG4gICAgZWFzdGVyOiBlYXN0ZXIsXG4gICAgRWNhcm9uOiBFY2Fyb24sXG4gICAgZWNhcm9uOiBlY2Fyb24sXG4gICAgRWNpcmM6IEVjaXJjJDEsXG4gICAgZWNpcmM6IGVjaXJjJDEsXG4gICAgZWNpcjogZWNpcixcbiAgICBlY29sb246IGVjb2xvbixcbiAgICBFY3k6IEVjeSxcbiAgICBlY3k6IGVjeSxcbiAgICBlRERvdDogZUREb3QsXG4gICAgRWRvdDogRWRvdCxcbiAgICBlZG90OiBlZG90LFxuICAgIGVEb3Q6IGVEb3QsXG4gICAgZWU6IGVlLFxuICAgIGVmRG90OiBlZkRvdCxcbiAgICBFZnI6IEVmcixcbiAgICBlZnI6IGVmcixcbiAgICBlZzogZWcsXG4gICAgRWdyYXZlOiBFZ3JhdmUkMSxcbiAgICBlZ3JhdmU6IGVncmF2ZSQxLFxuICAgIGVnczogZWdzLFxuICAgIGVnc2RvdDogZWdzZG90LFxuICAgIGVsOiBlbCxcbiAgICBFbGVtZW50OiBFbGVtZW50LFxuICAgIGVsaW50ZXJzOiBlbGludGVycyxcbiAgICBlbGw6IGVsbCxcbiAgICBlbHM6IGVscyxcbiAgICBlbHNkb3Q6IGVsc2RvdCxcbiAgICBFbWFjcjogRW1hY3IsXG4gICAgZW1hY3I6IGVtYWNyLFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICBlbXB0eXNldDogZW1wdHlzZXQsXG4gICAgRW1wdHlTbWFsbFNxdWFyZTogRW1wdHlTbWFsbFNxdWFyZSxcbiAgICBlbXB0eXY6IGVtcHR5dixcbiAgICBFbXB0eVZlcnlTbWFsbFNxdWFyZTogRW1wdHlWZXJ5U21hbGxTcXVhcmUsXG4gICAgZW1zcDEzOiBlbXNwMTMsXG4gICAgZW1zcDE0OiBlbXNwMTQsXG4gICAgZW1zcDogZW1zcCxcbiAgICBFTkc6IEVORyxcbiAgICBlbmc6IGVuZyxcbiAgICBlbnNwOiBlbnNwLFxuICAgIEVvZ29uOiBFb2dvbixcbiAgICBlb2dvbjogZW9nb24sXG4gICAgRW9wZjogRW9wZixcbiAgICBlb3BmOiBlb3BmLFxuICAgIGVwYXI6IGVwYXIsXG4gICAgZXBhcnNsOiBlcGFyc2wsXG4gICAgZXBsdXM6IGVwbHVzLFxuICAgIGVwc2k6IGVwc2ksXG4gICAgRXBzaWxvbjogRXBzaWxvbixcbiAgICBlcHNpbG9uOiBlcHNpbG9uLFxuICAgIGVwc2l2OiBlcHNpdixcbiAgICBlcWNpcmM6IGVxY2lyYyxcbiAgICBlcWNvbG9uOiBlcWNvbG9uLFxuICAgIGVxc2ltOiBlcXNpbSxcbiAgICBlcXNsYW50Z3RyOiBlcXNsYW50Z3RyLFxuICAgIGVxc2xhbnRsZXNzOiBlcXNsYW50bGVzcyxcbiAgICBFcXVhbDogRXF1YWwsXG4gICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgRXF1YWxUaWxkZTogRXF1YWxUaWxkZSxcbiAgICBlcXVlc3Q6IGVxdWVzdCxcbiAgICBFcXVpbGlicml1bTogRXF1aWxpYnJpdW0sXG4gICAgZXF1aXY6IGVxdWl2LFxuICAgIGVxdWl2REQ6IGVxdWl2REQsXG4gICAgZXF2cGFyc2w6IGVxdnBhcnNsLFxuICAgIGVyYXJyOiBlcmFycixcbiAgICBlckRvdDogZXJEb3QsXG4gICAgZXNjcjogZXNjcixcbiAgICBFc2NyOiBFc2NyLFxuICAgIGVzZG90OiBlc2RvdCxcbiAgICBFc2ltOiBFc2ltLFxuICAgIGVzaW06IGVzaW0sXG4gICAgRXRhOiBFdGEsXG4gICAgZXRhOiBldGEsXG4gICAgRVRIOiBFVEgkMSxcbiAgICBldGg6IGV0aCQxLFxuICAgIEV1bWw6IEV1bWwkMSxcbiAgICBldW1sOiBldW1sJDEsXG4gICAgZXVybzogZXVybyxcbiAgICBleGNsOiBleGNsLFxuICAgIGV4aXN0OiBleGlzdCxcbiAgICBFeGlzdHM6IEV4aXN0cyxcbiAgICBleHBlY3RhdGlvbjogZXhwZWN0YXRpb24sXG4gICAgZXhwb25lbnRpYWxlOiBleHBvbmVudGlhbGUsXG4gICAgRXhwb25lbnRpYWxFOiBFeHBvbmVudGlhbEUsXG4gICAgZmFsbGluZ2RvdHNlcTogZmFsbGluZ2RvdHNlcSxcbiAgICBGY3k6IEZjeSxcbiAgICBmY3k6IGZjeSxcbiAgICBmZW1hbGU6IGZlbWFsZSxcbiAgICBmZmlsaWc6IGZmaWxpZyxcbiAgICBmZmxpZzogZmZsaWcsXG4gICAgZmZsbGlnOiBmZmxsaWcsXG4gICAgRmZyOiBGZnIsXG4gICAgZmZyOiBmZnIsXG4gICAgZmlsaWc6IGZpbGlnLFxuICAgIEZpbGxlZFNtYWxsU3F1YXJlOiBGaWxsZWRTbWFsbFNxdWFyZSxcbiAgICBGaWxsZWRWZXJ5U21hbGxTcXVhcmU6IEZpbGxlZFZlcnlTbWFsbFNxdWFyZSxcbiAgICBmamxpZzogZmpsaWcsXG4gICAgZmxhdDogZmxhdCxcbiAgICBmbGxpZzogZmxsaWcsXG4gICAgZmx0bnM6IGZsdG5zLFxuICAgIGZub2Y6IGZub2YsXG4gICAgRm9wZjogRm9wZixcbiAgICBmb3BmOiBmb3BmLFxuICAgIGZvcmFsbDogZm9yYWxsLFxuICAgIEZvckFsbDogRm9yQWxsLFxuICAgIGZvcms6IGZvcmssXG4gICAgZm9ya3Y6IGZvcmt2LFxuICAgIEZvdXJpZXJ0cmY6IEZvdXJpZXJ0cmYsXG4gICAgZnBhcnRpbnQ6IGZwYXJ0aW50LFxuICAgIGZyYWMxMjogZnJhYzEyJDEsXG4gICAgZnJhYzEzOiBmcmFjMTMsXG4gICAgZnJhYzE0OiBmcmFjMTQkMSxcbiAgICBmcmFjMTU6IGZyYWMxNSxcbiAgICBmcmFjMTY6IGZyYWMxNixcbiAgICBmcmFjMTg6IGZyYWMxOCxcbiAgICBmcmFjMjM6IGZyYWMyMyxcbiAgICBmcmFjMjU6IGZyYWMyNSxcbiAgICBmcmFjMzQ6IGZyYWMzNCQxLFxuICAgIGZyYWMzNTogZnJhYzM1LFxuICAgIGZyYWMzODogZnJhYzM4LFxuICAgIGZyYWM0NTogZnJhYzQ1LFxuICAgIGZyYWM1NjogZnJhYzU2LFxuICAgIGZyYWM1ODogZnJhYzU4LFxuICAgIGZyYWM3ODogZnJhYzc4LFxuICAgIGZyYXNsOiBmcmFzbCxcbiAgICBmcm93bjogZnJvd24sXG4gICAgZnNjcjogZnNjcixcbiAgICBGc2NyOiBGc2NyLFxuICAgIGdhY3V0ZTogZ2FjdXRlLFxuICAgIEdhbW1hOiBHYW1tYSxcbiAgICBnYW1tYTogZ2FtbWEsXG4gICAgR2FtbWFkOiBHYW1tYWQsXG4gICAgZ2FtbWFkOiBnYW1tYWQsXG4gICAgZ2FwOiBnYXAsXG4gICAgR2JyZXZlOiBHYnJldmUsXG4gICAgZ2JyZXZlOiBnYnJldmUsXG4gICAgR2NlZGlsOiBHY2VkaWwsXG4gICAgR2NpcmM6IEdjaXJjLFxuICAgIGdjaXJjOiBnY2lyYyxcbiAgICBHY3k6IEdjeSxcbiAgICBnY3k6IGdjeSxcbiAgICBHZG90OiBHZG90LFxuICAgIGdkb3Q6IGdkb3QsXG4gICAgZ2U6IGdlLFxuICAgIGdFOiBnRSxcbiAgICBnRWw6IGdFbCxcbiAgICBnZWw6IGdlbCxcbiAgICBnZXE6IGdlcSxcbiAgICBnZXFxOiBnZXFxLFxuICAgIGdlcXNsYW50OiBnZXFzbGFudCxcbiAgICBnZXNjYzogZ2VzY2MsXG4gICAgZ2VzOiBnZXMsXG4gICAgZ2VzZG90OiBnZXNkb3QsXG4gICAgZ2VzZG90bzogZ2VzZG90byxcbiAgICBnZXNkb3RvbDogZ2VzZG90b2wsXG4gICAgZ2VzbDogZ2VzbCxcbiAgICBnZXNsZXM6IGdlc2xlcyxcbiAgICBHZnI6IEdmcixcbiAgICBnZnI6IGdmcixcbiAgICBnZzogZ2csXG4gICAgR2c6IEdnLFxuICAgIGdnZzogZ2dnLFxuICAgIGdpbWVsOiBnaW1lbCxcbiAgICBHSmN5OiBHSmN5LFxuICAgIGdqY3k6IGdqY3ksXG4gICAgZ2xhOiBnbGEsXG4gICAgZ2w6IGdsLFxuICAgIGdsRTogZ2xFLFxuICAgIGdsajogZ2xqLFxuICAgIGduYXA6IGduYXAsXG4gICAgZ25hcHByb3g6IGduYXBwcm94LFxuICAgIGduZTogZ25lLFxuICAgIGduRTogZ25FLFxuICAgIGduZXE6IGduZXEsXG4gICAgZ25lcXE6IGduZXFxLFxuICAgIGduc2ltOiBnbnNpbSxcbiAgICBHb3BmOiBHb3BmLFxuICAgIGdvcGY6IGdvcGYsXG4gICAgZ3JhdmU6IGdyYXZlLFxuICAgIEdyZWF0ZXJFcXVhbDogR3JlYXRlckVxdWFsLFxuICAgIEdyZWF0ZXJFcXVhbExlc3M6IEdyZWF0ZXJFcXVhbExlc3MsXG4gICAgR3JlYXRlckZ1bGxFcXVhbDogR3JlYXRlckZ1bGxFcXVhbCxcbiAgICBHcmVhdGVyR3JlYXRlcjogR3JlYXRlckdyZWF0ZXIsXG4gICAgR3JlYXRlckxlc3M6IEdyZWF0ZXJMZXNzLFxuICAgIEdyZWF0ZXJTbGFudEVxdWFsOiBHcmVhdGVyU2xhbnRFcXVhbCxcbiAgICBHcmVhdGVyVGlsZGU6IEdyZWF0ZXJUaWxkZSxcbiAgICBHc2NyOiBHc2NyLFxuICAgIGdzY3I6IGdzY3IsXG4gICAgZ3NpbTogZ3NpbSxcbiAgICBnc2ltZTogZ3NpbWUsXG4gICAgZ3NpbWw6IGdzaW1sLFxuICAgIGd0Y2M6IGd0Y2MsXG4gICAgZ3RjaXI6IGd0Y2lyLFxuICAgIGd0OiBndCQyLFxuICAgIEdUOiBHVCQxLFxuICAgIEd0OiBHdCxcbiAgICBndGRvdDogZ3Rkb3QsXG4gICAgZ3RsUGFyOiBndGxQYXIsXG4gICAgZ3RxdWVzdDogZ3RxdWVzdCxcbiAgICBndHJhcHByb3g6IGd0cmFwcHJveCxcbiAgICBndHJhcnI6IGd0cmFycixcbiAgICBndHJkb3Q6IGd0cmRvdCxcbiAgICBndHJlcWxlc3M6IGd0cmVxbGVzcyxcbiAgICBndHJlcXFsZXNzOiBndHJlcXFsZXNzLFxuICAgIGd0cmxlc3M6IGd0cmxlc3MsXG4gICAgZ3Ryc2ltOiBndHJzaW0sXG4gICAgZ3ZlcnRuZXFxOiBndmVydG5lcXEsXG4gICAgZ3ZuRTogZ3ZuRSxcbiAgICBIYWNlazogSGFjZWssXG4gICAgaGFpcnNwOiBoYWlyc3AsXG4gICAgaGFsZjogaGFsZixcbiAgICBoYW1pbHQ6IGhhbWlsdCxcbiAgICBIQVJEY3k6IEhBUkRjeSxcbiAgICBoYXJkY3k6IGhhcmRjeSxcbiAgICBoYXJyY2lyOiBoYXJyY2lyLFxuICAgIGhhcnI6IGhhcnIsXG4gICAgaEFycjogaEFycixcbiAgICBoYXJydzogaGFycncsXG4gICAgSGF0OiBIYXQsXG4gICAgaGJhcjogaGJhcixcbiAgICBIY2lyYzogSGNpcmMsXG4gICAgaGNpcmM6IGhjaXJjLFxuICAgIGhlYXJ0czogaGVhcnRzLFxuICAgIGhlYXJ0c3VpdDogaGVhcnRzdWl0LFxuICAgIGhlbGxpcDogaGVsbGlwLFxuICAgIGhlcmNvbjogaGVyY29uLFxuICAgIGhmcjogaGZyLFxuICAgIEhmcjogSGZyLFxuICAgIEhpbGJlcnRTcGFjZTogSGlsYmVydFNwYWNlLFxuICAgIGhrc2Vhcm93OiBoa3NlYXJvdyxcbiAgICBoa3N3YXJvdzogaGtzd2Fyb3csXG4gICAgaG9hcnI6IGhvYXJyLFxuICAgIGhvbXRodDogaG9tdGh0LFxuICAgIGhvb2tsZWZ0YXJyb3c6IGhvb2tsZWZ0YXJyb3csXG4gICAgaG9va3JpZ2h0YXJyb3c6IGhvb2tyaWdodGFycm93LFxuICAgIGhvcGY6IGhvcGYsXG4gICAgSG9wZjogSG9wZixcbiAgICBob3JiYXI6IGhvcmJhcixcbiAgICBIb3Jpem9udGFsTGluZTogSG9yaXpvbnRhbExpbmUsXG4gICAgaHNjcjogaHNjcixcbiAgICBIc2NyOiBIc2NyLFxuICAgIGhzbGFzaDogaHNsYXNoLFxuICAgIEhzdHJvazogSHN0cm9rLFxuICAgIGhzdHJvazogaHN0cm9rLFxuICAgIEh1bXBEb3duSHVtcDogSHVtcERvd25IdW1wLFxuICAgIEh1bXBFcXVhbDogSHVtcEVxdWFsLFxuICAgIGh5YnVsbDogaHlidWxsLFxuICAgIGh5cGhlbjogaHlwaGVuLFxuICAgIElhY3V0ZTogSWFjdXRlJDEsXG4gICAgaWFjdXRlOiBpYWN1dGUkMSxcbiAgICBpYzogaWMsXG4gICAgSWNpcmM6IEljaXJjJDEsXG4gICAgaWNpcmM6IGljaXJjJDEsXG4gICAgSWN5OiBJY3ksXG4gICAgaWN5OiBpY3ksXG4gICAgSWRvdDogSWRvdCxcbiAgICBJRWN5OiBJRWN5LFxuICAgIGllY3k6IGllY3ksXG4gICAgaWV4Y2w6IGlleGNsJDEsXG4gICAgaWZmOiBpZmYsXG4gICAgaWZyOiBpZnIsXG4gICAgSWZyOiBJZnIsXG4gICAgSWdyYXZlOiBJZ3JhdmUkMSxcbiAgICBpZ3JhdmU6IGlncmF2ZSQxLFxuICAgIGlpOiBpaSxcbiAgICBpaWlpbnQ6IGlpaWludCxcbiAgICBpaWludDogaWlpbnQsXG4gICAgaWluZmluOiBpaW5maW4sXG4gICAgaWlvdGE6IGlpb3RhLFxuICAgIElKbGlnOiBJSmxpZyxcbiAgICBpamxpZzogaWpsaWcsXG4gICAgSW1hY3I6IEltYWNyLFxuICAgIGltYWNyOiBpbWFjcixcbiAgICBpbWFnZTogZXNtX2ltYWdlLFxuICAgIEltYWdpbmFyeUk6IEltYWdpbmFyeUksXG4gICAgaW1hZ2xpbmU6IGltYWdsaW5lLFxuICAgIGltYWdwYXJ0OiBpbWFncGFydCxcbiAgICBpbWF0aDogaW1hdGgsXG4gICAgSW06IEltLFxuICAgIGltb2Y6IGltb2YsXG4gICAgaW1wZWQ6IGltcGVkLFxuICAgIEltcGxpZXM6IEltcGxpZXMsXG4gICAgaW5jYXJlOiBpbmNhcmUsXG4gICAgXCJpblwiOiBcIuKIiFwiLFxuICAgIGluZmluOiBpbmZpbixcbiAgICBpbmZpbnRpZTogaW5maW50aWUsXG4gICAgaW5vZG90OiBpbm9kb3QsXG4gICAgaW50Y2FsOiBpbnRjYWwsXG4gICAgaW50OiBlc21faW50LFxuICAgIEludDogSW50LFxuICAgIGludGVnZXJzOiBpbnRlZ2VycyxcbiAgICBJbnRlZ3JhbDogSW50ZWdyYWwsXG4gICAgaW50ZXJjYWw6IGludGVyY2FsLFxuICAgIEludGVyc2VjdGlvbjogSW50ZXJzZWN0aW9uLFxuICAgIGludGxhcmhrOiBpbnRsYXJoayxcbiAgICBpbnRwcm9kOiBpbnRwcm9kLFxuICAgIEludmlzaWJsZUNvbW1hOiBJbnZpc2libGVDb21tYSxcbiAgICBJbnZpc2libGVUaW1lczogSW52aXNpYmxlVGltZXMsXG4gICAgSU9jeTogSU9jeSxcbiAgICBpb2N5OiBpb2N5LFxuICAgIElvZ29uOiBJb2dvbixcbiAgICBpb2dvbjogaW9nb24sXG4gICAgSW9wZjogSW9wZixcbiAgICBpb3BmOiBpb3BmLFxuICAgIElvdGE6IElvdGEsXG4gICAgaW90YTogaW90YSxcbiAgICBpcHJvZDogaXByb2QsXG4gICAgaXF1ZXN0OiBpcXVlc3QkMSxcbiAgICBpc2NyOiBpc2NyLFxuICAgIElzY3I6IElzY3IsXG4gICAgaXNpbjogaXNpbixcbiAgICBpc2luZG90OiBpc2luZG90LFxuICAgIGlzaW5FOiBpc2luRSxcbiAgICBpc2luczogaXNpbnMsXG4gICAgaXNpbnN2OiBpc2luc3YsXG4gICAgaXNpbnY6IGlzaW52LFxuICAgIGl0OiBpdCxcbiAgICBJdGlsZGU6IEl0aWxkZSxcbiAgICBpdGlsZGU6IGl0aWxkZSxcbiAgICBJdWtjeTogSXVrY3ksXG4gICAgaXVrY3k6IGl1a2N5LFxuICAgIEl1bWw6IEl1bWwkMSxcbiAgICBpdW1sOiBpdW1sJDEsXG4gICAgSmNpcmM6IEpjaXJjLFxuICAgIGpjaXJjOiBqY2lyYyxcbiAgICBKY3k6IEpjeSxcbiAgICBqY3k6IGpjeSxcbiAgICBKZnI6IEpmcixcbiAgICBqZnI6IGpmcixcbiAgICBqbWF0aDogam1hdGgsXG4gICAgSm9wZjogSm9wZixcbiAgICBqb3BmOiBqb3BmLFxuICAgIEpzY3I6IEpzY3IsXG4gICAganNjcjoganNjcixcbiAgICBKc2VyY3k6IEpzZXJjeSxcbiAgICBqc2VyY3k6IGpzZXJjeSxcbiAgICBKdWtjeTogSnVrY3ksXG4gICAganVrY3k6IGp1a2N5LFxuICAgIEthcHBhOiBLYXBwYSxcbiAgICBrYXBwYToga2FwcGEsXG4gICAga2FwcGF2OiBrYXBwYXYsXG4gICAgS2NlZGlsOiBLY2VkaWwsXG4gICAga2NlZGlsOiBrY2VkaWwsXG4gICAgS2N5OiBLY3ksXG4gICAga2N5OiBrY3ksXG4gICAgS2ZyOiBLZnIsXG4gICAga2ZyOiBrZnIsXG4gICAga2dyZWVuOiBrZ3JlZW4sXG4gICAgS0hjeTogS0hjeSxcbiAgICBraGN5OiBraGN5LFxuICAgIEtKY3k6IEtKY3ksXG4gICAga2pjeToga2pjeSxcbiAgICBLb3BmOiBLb3BmLFxuICAgIGtvcGY6IGtvcGYsXG4gICAgS3NjcjogS3NjcixcbiAgICBrc2NyOiBrc2NyLFxuICAgIGxBYXJyOiBsQWFycixcbiAgICBMYWN1dGU6IExhY3V0ZSxcbiAgICBsYWN1dGU6IGxhY3V0ZSxcbiAgICBsYWVtcHR5djogbGFlbXB0eXYsXG4gICAgbGFncmFuOiBsYWdyYW4sXG4gICAgTGFtYmRhOiBMYW1iZGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgbGFuZzogbGFuZyxcbiAgICBMYW5nOiBMYW5nLFxuICAgIGxhbmdkOiBsYW5nZCxcbiAgICBsYW5nbGU6IGxhbmdsZSxcbiAgICBsYXA6IGxhcCxcbiAgICBMYXBsYWNldHJmOiBMYXBsYWNldHJmLFxuICAgIGxhcXVvOiBsYXF1byQxLFxuICAgIGxhcnJiOiBsYXJyYixcbiAgICBsYXJyYmZzOiBsYXJyYmZzLFxuICAgIGxhcnI6IGxhcnIsXG4gICAgTGFycjogTGFycixcbiAgICBsQXJyOiBsQXJyLFxuICAgIGxhcnJmczogbGFycmZzLFxuICAgIGxhcnJoazogbGFycmhrLFxuICAgIGxhcnJscDogbGFycmxwLFxuICAgIGxhcnJwbDogbGFycnBsLFxuICAgIGxhcnJzaW06IGxhcnJzaW0sXG4gICAgbGFycnRsOiBsYXJydGwsXG4gICAgbGF0YWlsOiBsYXRhaWwsXG4gICAgbEF0YWlsOiBsQXRhaWwsXG4gICAgbGF0OiBsYXQsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBsYXRlczogbGF0ZXMsXG4gICAgbGJhcnI6IGxiYXJyLFxuICAgIGxCYXJyOiBsQmFycixcbiAgICBsYmJyazogbGJicmssXG4gICAgbGJyYWNlOiBsYnJhY2UsXG4gICAgbGJyYWNrOiBsYnJhY2ssXG4gICAgbGJya2U6IGxicmtlLFxuICAgIGxicmtzbGQ6IGxicmtzbGQsXG4gICAgbGJya3NsdTogbGJya3NsdSxcbiAgICBMY2Fyb246IExjYXJvbixcbiAgICBsY2Fyb246IGxjYXJvbixcbiAgICBMY2VkaWw6IExjZWRpbCxcbiAgICBsY2VkaWw6IGxjZWRpbCxcbiAgICBsY2VpbDogbGNlaWwsXG4gICAgbGN1YjogbGN1YixcbiAgICBMY3k6IExjeSxcbiAgICBsY3k6IGxjeSxcbiAgICBsZGNhOiBsZGNhLFxuICAgIGxkcXVvOiBsZHF1byxcbiAgICBsZHF1b3I6IGxkcXVvcixcbiAgICBsZHJkaGFyOiBsZHJkaGFyLFxuICAgIGxkcnVzaGFyOiBsZHJ1c2hhcixcbiAgICBsZHNoOiBsZHNoLFxuICAgIGxlOiBsZSxcbiAgICBsRTogbEUsXG4gICAgTGVmdEFuZ2xlQnJhY2tldDogTGVmdEFuZ2xlQnJhY2tldCxcbiAgICBMZWZ0QXJyb3dCYXI6IExlZnRBcnJvd0JhcixcbiAgICBsZWZ0YXJyb3c6IGxlZnRhcnJvdyxcbiAgICBMZWZ0QXJyb3c6IExlZnRBcnJvdyxcbiAgICBMZWZ0YXJyb3c6IExlZnRhcnJvdyxcbiAgICBMZWZ0QXJyb3dSaWdodEFycm93OiBMZWZ0QXJyb3dSaWdodEFycm93LFxuICAgIGxlZnRhcnJvd3RhaWw6IGxlZnRhcnJvd3RhaWwsXG4gICAgTGVmdENlaWxpbmc6IExlZnRDZWlsaW5nLFxuICAgIExlZnREb3VibGVCcmFja2V0OiBMZWZ0RG91YmxlQnJhY2tldCxcbiAgICBMZWZ0RG93blRlZVZlY3RvcjogTGVmdERvd25UZWVWZWN0b3IsXG4gICAgTGVmdERvd25WZWN0b3JCYXI6IExlZnREb3duVmVjdG9yQmFyLFxuICAgIExlZnREb3duVmVjdG9yOiBMZWZ0RG93blZlY3RvcixcbiAgICBMZWZ0Rmxvb3I6IExlZnRGbG9vcixcbiAgICBsZWZ0aGFycG9vbmRvd246IGxlZnRoYXJwb29uZG93bixcbiAgICBsZWZ0aGFycG9vbnVwOiBsZWZ0aGFycG9vbnVwLFxuICAgIGxlZnRsZWZ0YXJyb3dzOiBsZWZ0bGVmdGFycm93cyxcbiAgICBsZWZ0cmlnaHRhcnJvdzogbGVmdHJpZ2h0YXJyb3csXG4gICAgTGVmdFJpZ2h0QXJyb3c6IExlZnRSaWdodEFycm93LFxuICAgIExlZnRyaWdodGFycm93OiBMZWZ0cmlnaHRhcnJvdyxcbiAgICBsZWZ0cmlnaHRhcnJvd3M6IGxlZnRyaWdodGFycm93cyxcbiAgICBsZWZ0cmlnaHRoYXJwb29uczogbGVmdHJpZ2h0aGFycG9vbnMsXG4gICAgbGVmdHJpZ2h0c3F1aWdhcnJvdzogbGVmdHJpZ2h0c3F1aWdhcnJvdyxcbiAgICBMZWZ0UmlnaHRWZWN0b3I6IExlZnRSaWdodFZlY3RvcixcbiAgICBMZWZ0VGVlQXJyb3c6IExlZnRUZWVBcnJvdyxcbiAgICBMZWZ0VGVlOiBMZWZ0VGVlLFxuICAgIExlZnRUZWVWZWN0b3I6IExlZnRUZWVWZWN0b3IsXG4gICAgbGVmdHRocmVldGltZXM6IGxlZnR0aHJlZXRpbWVzLFxuICAgIExlZnRUcmlhbmdsZUJhcjogTGVmdFRyaWFuZ2xlQmFyLFxuICAgIExlZnRUcmlhbmdsZTogTGVmdFRyaWFuZ2xlLFxuICAgIExlZnRUcmlhbmdsZUVxdWFsOiBMZWZ0VHJpYW5nbGVFcXVhbCxcbiAgICBMZWZ0VXBEb3duVmVjdG9yOiBMZWZ0VXBEb3duVmVjdG9yLFxuICAgIExlZnRVcFRlZVZlY3RvcjogTGVmdFVwVGVlVmVjdG9yLFxuICAgIExlZnRVcFZlY3RvckJhcjogTGVmdFVwVmVjdG9yQmFyLFxuICAgIExlZnRVcFZlY3RvcjogTGVmdFVwVmVjdG9yLFxuICAgIExlZnRWZWN0b3JCYXI6IExlZnRWZWN0b3JCYXIsXG4gICAgTGVmdFZlY3RvcjogTGVmdFZlY3RvcixcbiAgICBsRWc6IGxFZyxcbiAgICBsZWc6IGxlZyxcbiAgICBsZXE6IGxlcSxcbiAgICBsZXFxOiBsZXFxLFxuICAgIGxlcXNsYW50OiBsZXFzbGFudCxcbiAgICBsZXNjYzogbGVzY2MsXG4gICAgbGVzOiBsZXMsXG4gICAgbGVzZG90OiBsZXNkb3QsXG4gICAgbGVzZG90bzogbGVzZG90byxcbiAgICBsZXNkb3RvcjogbGVzZG90b3IsXG4gICAgbGVzZzogbGVzZyxcbiAgICBsZXNnZXM6IGxlc2dlcyxcbiAgICBsZXNzYXBwcm94OiBsZXNzYXBwcm94LFxuICAgIGxlc3Nkb3Q6IGxlc3Nkb3QsXG4gICAgbGVzc2VxZ3RyOiBsZXNzZXFndHIsXG4gICAgbGVzc2VxcWd0cjogbGVzc2VxcWd0cixcbiAgICBMZXNzRXF1YWxHcmVhdGVyOiBMZXNzRXF1YWxHcmVhdGVyLFxuICAgIExlc3NGdWxsRXF1YWw6IExlc3NGdWxsRXF1YWwsXG4gICAgTGVzc0dyZWF0ZXI6IExlc3NHcmVhdGVyLFxuICAgIGxlc3NndHI6IGxlc3NndHIsXG4gICAgTGVzc0xlc3M6IExlc3NMZXNzLFxuICAgIGxlc3NzaW06IGxlc3NzaW0sXG4gICAgTGVzc1NsYW50RXF1YWw6IExlc3NTbGFudEVxdWFsLFxuICAgIExlc3NUaWxkZTogTGVzc1RpbGRlLFxuICAgIGxmaXNodDogbGZpc2h0LFxuICAgIGxmbG9vcjogbGZsb29yLFxuICAgIExmcjogTGZyLFxuICAgIGxmcjogbGZyLFxuICAgIGxnOiBsZyxcbiAgICBsZ0U6IGxnRSxcbiAgICBsSGFyOiBsSGFyLFxuICAgIGxoYXJkOiBsaGFyZCxcbiAgICBsaGFydTogbGhhcnUsXG4gICAgbGhhcnVsOiBsaGFydWwsXG4gICAgbGhibGs6IGxoYmxrLFxuICAgIExKY3k6IExKY3ksXG4gICAgbGpjeTogbGpjeSxcbiAgICBsbGFycjogbGxhcnIsXG4gICAgbGw6IGxsLFxuICAgIExsOiBMbCxcbiAgICBsbGNvcm5lcjogbGxjb3JuZXIsXG4gICAgTGxlZnRhcnJvdzogTGxlZnRhcnJvdyxcbiAgICBsbGhhcmQ6IGxsaGFyZCxcbiAgICBsbHRyaTogbGx0cmksXG4gICAgTG1pZG90OiBMbWlkb3QsXG4gICAgbG1pZG90OiBsbWlkb3QsXG4gICAgbG1vdXN0YWNoZTogbG1vdXN0YWNoZSxcbiAgICBsbW91c3Q6IGxtb3VzdCxcbiAgICBsbmFwOiBsbmFwLFxuICAgIGxuYXBwcm94OiBsbmFwcHJveCxcbiAgICBsbmU6IGxuZSxcbiAgICBsbkU6IGxuRSxcbiAgICBsbmVxOiBsbmVxLFxuICAgIGxuZXFxOiBsbmVxcSxcbiAgICBsbnNpbTogbG5zaW0sXG4gICAgbG9hbmc6IGxvYW5nLFxuICAgIGxvYXJyOiBsb2FycixcbiAgICBsb2JyazogbG9icmssXG4gICAgbG9uZ2xlZnRhcnJvdzogbG9uZ2xlZnRhcnJvdyxcbiAgICBMb25nTGVmdEFycm93OiBMb25nTGVmdEFycm93LFxuICAgIExvbmdsZWZ0YXJyb3c6IExvbmdsZWZ0YXJyb3csXG4gICAgbG9uZ2xlZnRyaWdodGFycm93OiBsb25nbGVmdHJpZ2h0YXJyb3csXG4gICAgTG9uZ0xlZnRSaWdodEFycm93OiBMb25nTGVmdFJpZ2h0QXJyb3csXG4gICAgTG9uZ2xlZnRyaWdodGFycm93OiBMb25nbGVmdHJpZ2h0YXJyb3csXG4gICAgbG9uZ21hcHN0bzogbG9uZ21hcHN0byxcbiAgICBsb25ncmlnaHRhcnJvdzogbG9uZ3JpZ2h0YXJyb3csXG4gICAgTG9uZ1JpZ2h0QXJyb3c6IExvbmdSaWdodEFycm93LFxuICAgIExvbmdyaWdodGFycm93OiBMb25ncmlnaHRhcnJvdyxcbiAgICBsb29wYXJyb3dsZWZ0OiBsb29wYXJyb3dsZWZ0LFxuICAgIGxvb3BhcnJvd3JpZ2h0OiBsb29wYXJyb3dyaWdodCxcbiAgICBsb3BhcjogbG9wYXIsXG4gICAgTG9wZjogTG9wZixcbiAgICBsb3BmOiBsb3BmLFxuICAgIGxvcGx1czogbG9wbHVzLFxuICAgIGxvdGltZXM6IGxvdGltZXMsXG4gICAgbG93YXN0OiBsb3dhc3QsXG4gICAgbG93YmFyOiBsb3diYXIsXG4gICAgTG93ZXJMZWZ0QXJyb3c6IExvd2VyTGVmdEFycm93LFxuICAgIExvd2VyUmlnaHRBcnJvdzogTG93ZXJSaWdodEFycm93LFxuICAgIGxvejogbG96LFxuICAgIGxvemVuZ2U6IGxvemVuZ2UsXG4gICAgbG96ZjogbG96ZixcbiAgICBscGFyOiBscGFyLFxuICAgIGxwYXJsdDogbHBhcmx0LFxuICAgIGxyYXJyOiBscmFycixcbiAgICBscmNvcm5lcjogbHJjb3JuZXIsXG4gICAgbHJoYXI6IGxyaGFyLFxuICAgIGxyaGFyZDogbHJoYXJkLFxuICAgIGxybTogbHJtLFxuICAgIGxydHJpOiBscnRyaSxcbiAgICBsc2FxdW86IGxzYXF1byxcbiAgICBsc2NyOiBsc2NyLFxuICAgIExzY3I6IExzY3IsXG4gICAgbHNoOiBsc2gsXG4gICAgTHNoOiBMc2gsXG4gICAgbHNpbTogbHNpbSxcbiAgICBsc2ltZTogbHNpbWUsXG4gICAgbHNpbWc6IGxzaW1nLFxuICAgIGxzcWI6IGxzcWIsXG4gICAgbHNxdW86IGxzcXVvLFxuICAgIGxzcXVvcjogbHNxdW9yLFxuICAgIExzdHJvazogTHN0cm9rLFxuICAgIGxzdHJvazogbHN0cm9rLFxuICAgIGx0Y2M6IGx0Y2MsXG4gICAgbHRjaXI6IGx0Y2lyLFxuICAgIGx0OiBsdCQyLFxuICAgIExUOiBMVCQxLFxuICAgIEx0OiBMdCxcbiAgICBsdGRvdDogbHRkb3QsXG4gICAgbHRocmVlOiBsdGhyZWUsXG4gICAgbHRpbWVzOiBsdGltZXMsXG4gICAgbHRsYXJyOiBsdGxhcnIsXG4gICAgbHRxdWVzdDogbHRxdWVzdCxcbiAgICBsdHJpOiBsdHJpLFxuICAgIGx0cmllOiBsdHJpZSxcbiAgICBsdHJpZjogbHRyaWYsXG4gICAgbHRyUGFyOiBsdHJQYXIsXG4gICAgbHVyZHNoYXI6IGx1cmRzaGFyLFxuICAgIGx1cnVoYXI6IGx1cnVoYXIsXG4gICAgbHZlcnRuZXFxOiBsdmVydG5lcXEsXG4gICAgbHZuRTogbHZuRSxcbiAgICBtYWNyOiBtYWNyJDEsXG4gICAgbWFsZTogbWFsZSxcbiAgICBtYWx0OiBtYWx0LFxuICAgIG1hbHRlc2U6IG1hbHRlc2UsXG4gICAgXCJNYXBcIjogXCLipIVcIixcbiAgICBtYXA6IG1hcCxcbiAgICBtYXBzdG86IG1hcHN0byxcbiAgICBtYXBzdG9kb3duOiBtYXBzdG9kb3duLFxuICAgIG1hcHN0b2xlZnQ6IG1hcHN0b2xlZnQsXG4gICAgbWFwc3RvdXA6IG1hcHN0b3VwLFxuICAgIG1hcmtlcjogbWFya2VyLFxuICAgIG1jb21tYTogbWNvbW1hLFxuICAgIE1jeTogTWN5LFxuICAgIG1jeTogbWN5LFxuICAgIG1kYXNoOiBtZGFzaCxcbiAgICBtRERvdDogbUREb3QsXG4gICAgbWVhc3VyZWRhbmdsZTogbWVhc3VyZWRhbmdsZSxcbiAgICBNZWRpdW1TcGFjZTogTWVkaXVtU3BhY2UsXG4gICAgTWVsbGludHJmOiBNZWxsaW50cmYsXG4gICAgTWZyOiBNZnIsXG4gICAgbWZyOiBtZnIsXG4gICAgbWhvOiBtaG8sXG4gICAgbWljcm86IG1pY3JvJDEsXG4gICAgbWlkYXN0OiBtaWRhc3QsXG4gICAgbWlkY2lyOiBtaWRjaXIsXG4gICAgbWlkOiBtaWQsXG4gICAgbWlkZG90OiBtaWRkb3QkMSxcbiAgICBtaW51c2I6IG1pbnVzYixcbiAgICBtaW51czogbWludXMsXG4gICAgbWludXNkOiBtaW51c2QsXG4gICAgbWludXNkdTogbWludXNkdSxcbiAgICBNaW51c1BsdXM6IE1pbnVzUGx1cyxcbiAgICBtbGNwOiBtbGNwLFxuICAgIG1sZHI6IG1sZHIsXG4gICAgbW5wbHVzOiBtbnBsdXMsXG4gICAgbW9kZWxzOiBtb2RlbHMsXG4gICAgTW9wZjogTW9wZixcbiAgICBtb3BmOiBtb3BmLFxuICAgIG1wOiBtcCxcbiAgICBtc2NyOiBtc2NyLFxuICAgIE1zY3I6IE1zY3IsXG4gICAgbXN0cG9zOiBtc3Rwb3MsXG4gICAgTXU6IE11LFxuICAgIG11OiBtdSxcbiAgICBtdWx0aW1hcDogbXVsdGltYXAsXG4gICAgbXVtYXA6IG11bWFwLFxuICAgIG5hYmxhOiBuYWJsYSxcbiAgICBOYWN1dGU6IE5hY3V0ZSxcbiAgICBuYWN1dGU6IG5hY3V0ZSxcbiAgICBuYW5nOiBuYW5nLFxuICAgIG5hcDogbmFwLFxuICAgIG5hcEU6IG5hcEUsXG4gICAgbmFwaWQ6IG5hcGlkLFxuICAgIG5hcG9zOiBuYXBvcyxcbiAgICBuYXBwcm94OiBuYXBwcm94LFxuICAgIG5hdHVyYWw6IG5hdHVyYWwsXG4gICAgbmF0dXJhbHM6IG5hdHVyYWxzLFxuICAgIG5hdHVyOiBuYXR1cixcbiAgICBuYnNwOiBuYnNwJDEsXG4gICAgbmJ1bXA6IG5idW1wLFxuICAgIG5idW1wZTogbmJ1bXBlLFxuICAgIG5jYXA6IG5jYXAsXG4gICAgTmNhcm9uOiBOY2Fyb24sXG4gICAgbmNhcm9uOiBuY2Fyb24sXG4gICAgTmNlZGlsOiBOY2VkaWwsXG4gICAgbmNlZGlsOiBuY2VkaWwsXG4gICAgbmNvbmc6IG5jb25nLFxuICAgIG5jb25nZG90OiBuY29uZ2RvdCxcbiAgICBuY3VwOiBuY3VwLFxuICAgIE5jeTogTmN5LFxuICAgIG5jeTogbmN5LFxuICAgIG5kYXNoOiBuZGFzaCxcbiAgICBuZWFyaGs6IG5lYXJoayxcbiAgICBuZWFycjogbmVhcnIsXG4gICAgbmVBcnI6IG5lQXJyLFxuICAgIG5lYXJyb3c6IG5lYXJyb3csXG4gICAgbmU6IG5lLFxuICAgIG5lZG90OiBuZWRvdCxcbiAgICBOZWdhdGl2ZU1lZGl1bVNwYWNlOiBOZWdhdGl2ZU1lZGl1bVNwYWNlLFxuICAgIE5lZ2F0aXZlVGhpY2tTcGFjZTogTmVnYXRpdmVUaGlja1NwYWNlLFxuICAgIE5lZ2F0aXZlVGhpblNwYWNlOiBOZWdhdGl2ZVRoaW5TcGFjZSxcbiAgICBOZWdhdGl2ZVZlcnlUaGluU3BhY2U6IE5lZ2F0aXZlVmVyeVRoaW5TcGFjZSxcbiAgICBuZXF1aXY6IG5lcXVpdixcbiAgICBuZXNlYXI6IG5lc2VhcixcbiAgICBuZXNpbTogbmVzaW0sXG4gICAgTmVzdGVkR3JlYXRlckdyZWF0ZXI6IE5lc3RlZEdyZWF0ZXJHcmVhdGVyLFxuICAgIE5lc3RlZExlc3NMZXNzOiBOZXN0ZWRMZXNzTGVzcyxcbiAgICBOZXdMaW5lOiBOZXdMaW5lLFxuICAgIG5leGlzdDogbmV4aXN0LFxuICAgIG5leGlzdHM6IG5leGlzdHMsXG4gICAgTmZyOiBOZnIsXG4gICAgbmZyOiBuZnIsXG4gICAgbmdFOiBuZ0UsXG4gICAgbmdlOiBuZ2UsXG4gICAgbmdlcTogbmdlcSxcbiAgICBuZ2VxcTogbmdlcXEsXG4gICAgbmdlcXNsYW50OiBuZ2Vxc2xhbnQsXG4gICAgbmdlczogbmdlcyxcbiAgICBuR2c6IG5HZyxcbiAgICBuZ3NpbTogbmdzaW0sXG4gICAgbkd0OiBuR3QsXG4gICAgbmd0OiBuZ3QsXG4gICAgbmd0cjogbmd0cixcbiAgICBuR3R2OiBuR3R2LFxuICAgIG5oYXJyOiBuaGFycixcbiAgICBuaEFycjogbmhBcnIsXG4gICAgbmhwYXI6IG5ocGFyLFxuICAgIG5pOiBuaSxcbiAgICBuaXM6IG5pcyxcbiAgICBuaXNkOiBuaXNkLFxuICAgIG5pdjogbml2LFxuICAgIE5KY3k6IE5KY3ksXG4gICAgbmpjeTogbmpjeSxcbiAgICBubGFycjogbmxhcnIsXG4gICAgbmxBcnI6IG5sQXJyLFxuICAgIG5sZHI6IG5sZHIsXG4gICAgbmxFOiBubEUsXG4gICAgbmxlOiBubGUsXG4gICAgbmxlZnRhcnJvdzogbmxlZnRhcnJvdyxcbiAgICBuTGVmdGFycm93OiBuTGVmdGFycm93LFxuICAgIG5sZWZ0cmlnaHRhcnJvdzogbmxlZnRyaWdodGFycm93LFxuICAgIG5MZWZ0cmlnaHRhcnJvdzogbkxlZnRyaWdodGFycm93LFxuICAgIG5sZXE6IG5sZXEsXG4gICAgbmxlcXE6IG5sZXFxLFxuICAgIG5sZXFzbGFudDogbmxlcXNsYW50LFxuICAgIG5sZXM6IG5sZXMsXG4gICAgbmxlc3M6IG5sZXNzLFxuICAgIG5MbDogbkxsLFxuICAgIG5sc2ltOiBubHNpbSxcbiAgICBuTHQ6IG5MdCxcbiAgICBubHQ6IG5sdCxcbiAgICBubHRyaTogbmx0cmksXG4gICAgbmx0cmllOiBubHRyaWUsXG4gICAgbkx0djogbkx0dixcbiAgICBubWlkOiBubWlkLFxuICAgIE5vQnJlYWs6IE5vQnJlYWssXG4gICAgTm9uQnJlYWtpbmdTcGFjZTogTm9uQnJlYWtpbmdTcGFjZSxcbiAgICBub3BmOiBub3BmLFxuICAgIE5vcGY6IE5vcGYsXG4gICAgTm90OiBOb3QsXG4gICAgbm90OiBub3QkMSxcbiAgICBOb3RDb25ncnVlbnQ6IE5vdENvbmdydWVudCxcbiAgICBOb3RDdXBDYXA6IE5vdEN1cENhcCxcbiAgICBOb3REb3VibGVWZXJ0aWNhbEJhcjogTm90RG91YmxlVmVydGljYWxCYXIsXG4gICAgTm90RWxlbWVudDogTm90RWxlbWVudCxcbiAgICBOb3RFcXVhbDogTm90RXF1YWwsXG4gICAgTm90RXF1YWxUaWxkZTogTm90RXF1YWxUaWxkZSxcbiAgICBOb3RFeGlzdHM6IE5vdEV4aXN0cyxcbiAgICBOb3RHcmVhdGVyOiBOb3RHcmVhdGVyLFxuICAgIE5vdEdyZWF0ZXJFcXVhbDogTm90R3JlYXRlckVxdWFsLFxuICAgIE5vdEdyZWF0ZXJGdWxsRXF1YWw6IE5vdEdyZWF0ZXJGdWxsRXF1YWwsXG4gICAgTm90R3JlYXRlckdyZWF0ZXI6IE5vdEdyZWF0ZXJHcmVhdGVyLFxuICAgIE5vdEdyZWF0ZXJMZXNzOiBOb3RHcmVhdGVyTGVzcyxcbiAgICBOb3RHcmVhdGVyU2xhbnRFcXVhbDogTm90R3JlYXRlclNsYW50RXF1YWwsXG4gICAgTm90R3JlYXRlclRpbGRlOiBOb3RHcmVhdGVyVGlsZGUsXG4gICAgTm90SHVtcERvd25IdW1wOiBOb3RIdW1wRG93bkh1bXAsXG4gICAgTm90SHVtcEVxdWFsOiBOb3RIdW1wRXF1YWwsXG4gICAgbm90aW46IG5vdGluLFxuICAgIG5vdGluZG90OiBub3RpbmRvdCxcbiAgICBub3RpbkU6IG5vdGluRSxcbiAgICBub3RpbnZhOiBub3RpbnZhLFxuICAgIG5vdGludmI6IG5vdGludmIsXG4gICAgbm90aW52Yzogbm90aW52YyxcbiAgICBOb3RMZWZ0VHJpYW5nbGVCYXI6IE5vdExlZnRUcmlhbmdsZUJhcixcbiAgICBOb3RMZWZ0VHJpYW5nbGU6IE5vdExlZnRUcmlhbmdsZSxcbiAgICBOb3RMZWZ0VHJpYW5nbGVFcXVhbDogTm90TGVmdFRyaWFuZ2xlRXF1YWwsXG4gICAgTm90TGVzczogTm90TGVzcyxcbiAgICBOb3RMZXNzRXF1YWw6IE5vdExlc3NFcXVhbCxcbiAgICBOb3RMZXNzR3JlYXRlcjogTm90TGVzc0dyZWF0ZXIsXG4gICAgTm90TGVzc0xlc3M6IE5vdExlc3NMZXNzLFxuICAgIE5vdExlc3NTbGFudEVxdWFsOiBOb3RMZXNzU2xhbnRFcXVhbCxcbiAgICBOb3RMZXNzVGlsZGU6IE5vdExlc3NUaWxkZSxcbiAgICBOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjogTm90TmVzdGVkR3JlYXRlckdyZWF0ZXIsXG4gICAgTm90TmVzdGVkTGVzc0xlc3M6IE5vdE5lc3RlZExlc3NMZXNzLFxuICAgIG5vdG5pOiBub3RuaSxcbiAgICBub3RuaXZhOiBub3RuaXZhLFxuICAgIG5vdG5pdmI6IG5vdG5pdmIsXG4gICAgbm90bml2Yzogbm90bml2YyxcbiAgICBOb3RQcmVjZWRlczogTm90UHJlY2VkZXMsXG4gICAgTm90UHJlY2VkZXNFcXVhbDogTm90UHJlY2VkZXNFcXVhbCxcbiAgICBOb3RQcmVjZWRlc1NsYW50RXF1YWw6IE5vdFByZWNlZGVzU2xhbnRFcXVhbCxcbiAgICBOb3RSZXZlcnNlRWxlbWVudDogTm90UmV2ZXJzZUVsZW1lbnQsXG4gICAgTm90UmlnaHRUcmlhbmdsZUJhcjogTm90UmlnaHRUcmlhbmdsZUJhcixcbiAgICBOb3RSaWdodFRyaWFuZ2xlOiBOb3RSaWdodFRyaWFuZ2xlLFxuICAgIE5vdFJpZ2h0VHJpYW5nbGVFcXVhbDogTm90UmlnaHRUcmlhbmdsZUVxdWFsLFxuICAgIE5vdFNxdWFyZVN1YnNldDogTm90U3F1YXJlU3Vic2V0LFxuICAgIE5vdFNxdWFyZVN1YnNldEVxdWFsOiBOb3RTcXVhcmVTdWJzZXRFcXVhbCxcbiAgICBOb3RTcXVhcmVTdXBlcnNldDogTm90U3F1YXJlU3VwZXJzZXQsXG4gICAgTm90U3F1YXJlU3VwZXJzZXRFcXVhbDogTm90U3F1YXJlU3VwZXJzZXRFcXVhbCxcbiAgICBOb3RTdWJzZXQ6IE5vdFN1YnNldCxcbiAgICBOb3RTdWJzZXRFcXVhbDogTm90U3Vic2V0RXF1YWwsXG4gICAgTm90U3VjY2VlZHM6IE5vdFN1Y2NlZWRzLFxuICAgIE5vdFN1Y2NlZWRzRXF1YWw6IE5vdFN1Y2NlZWRzRXF1YWwsXG4gICAgTm90U3VjY2VlZHNTbGFudEVxdWFsOiBOb3RTdWNjZWVkc1NsYW50RXF1YWwsXG4gICAgTm90U3VjY2VlZHNUaWxkZTogTm90U3VjY2VlZHNUaWxkZSxcbiAgICBOb3RTdXBlcnNldDogTm90U3VwZXJzZXQsXG4gICAgTm90U3VwZXJzZXRFcXVhbDogTm90U3VwZXJzZXRFcXVhbCxcbiAgICBOb3RUaWxkZTogTm90VGlsZGUsXG4gICAgTm90VGlsZGVFcXVhbDogTm90VGlsZGVFcXVhbCxcbiAgICBOb3RUaWxkZUZ1bGxFcXVhbDogTm90VGlsZGVGdWxsRXF1YWwsXG4gICAgTm90VGlsZGVUaWxkZTogTm90VGlsZGVUaWxkZSxcbiAgICBOb3RWZXJ0aWNhbEJhcjogTm90VmVydGljYWxCYXIsXG4gICAgbnBhcmFsbGVsOiBucGFyYWxsZWwsXG4gICAgbnBhcjogbnBhcixcbiAgICBucGFyc2w6IG5wYXJzbCxcbiAgICBucGFydDogbnBhcnQsXG4gICAgbnBvbGludDogbnBvbGludCxcbiAgICBucHI6IG5wcixcbiAgICBucHJjdWU6IG5wcmN1ZSxcbiAgICBucHJlYzogbnByZWMsXG4gICAgbnByZWNlcTogbnByZWNlcSxcbiAgICBucHJlOiBucHJlLFxuICAgIG5yYXJyYzogbnJhcnJjLFxuICAgIG5yYXJyOiBucmFycixcbiAgICBuckFycjogbnJBcnIsXG4gICAgbnJhcnJ3OiBucmFycncsXG4gICAgbnJpZ2h0YXJyb3c6IG5yaWdodGFycm93LFxuICAgIG5SaWdodGFycm93OiBuUmlnaHRhcnJvdyxcbiAgICBucnRyaTogbnJ0cmksXG4gICAgbnJ0cmllOiBucnRyaWUsXG4gICAgbnNjOiBuc2MsXG4gICAgbnNjY3VlOiBuc2NjdWUsXG4gICAgbnNjZTogbnNjZSxcbiAgICBOc2NyOiBOc2NyLFxuICAgIG5zY3I6IG5zY3IsXG4gICAgbnNob3J0bWlkOiBuc2hvcnRtaWQsXG4gICAgbnNob3J0cGFyYWxsZWw6IG5zaG9ydHBhcmFsbGVsLFxuICAgIG5zaW06IG5zaW0sXG4gICAgbnNpbWU6IG5zaW1lLFxuICAgIG5zaW1lcTogbnNpbWVxLFxuICAgIG5zbWlkOiBuc21pZCxcbiAgICBuc3BhcjogbnNwYXIsXG4gICAgbnNxc3ViZTogbnNxc3ViZSxcbiAgICBuc3FzdXBlOiBuc3FzdXBlLFxuICAgIG5zdWI6IG5zdWIsXG4gICAgbnN1YkU6IG5zdWJFLFxuICAgIG5zdWJlOiBuc3ViZSxcbiAgICBuc3Vic2V0OiBuc3Vic2V0LFxuICAgIG5zdWJzZXRlcTogbnN1YnNldGVxLFxuICAgIG5zdWJzZXRlcXE6IG5zdWJzZXRlcXEsXG4gICAgbnN1Y2M6IG5zdWNjLFxuICAgIG5zdWNjZXE6IG5zdWNjZXEsXG4gICAgbnN1cDogbnN1cCxcbiAgICBuc3VwRTogbnN1cEUsXG4gICAgbnN1cGU6IG5zdXBlLFxuICAgIG5zdXBzZXQ6IG5zdXBzZXQsXG4gICAgbnN1cHNldGVxOiBuc3Vwc2V0ZXEsXG4gICAgbnN1cHNldGVxcTogbnN1cHNldGVxcSxcbiAgICBudGdsOiBudGdsLFxuICAgIE50aWxkZTogTnRpbGRlJDEsXG4gICAgbnRpbGRlOiBudGlsZGUkMSxcbiAgICBudGxnOiBudGxnLFxuICAgIG50cmlhbmdsZWxlZnQ6IG50cmlhbmdsZWxlZnQsXG4gICAgbnRyaWFuZ2xlbGVmdGVxOiBudHJpYW5nbGVsZWZ0ZXEsXG4gICAgbnRyaWFuZ2xlcmlnaHQ6IG50cmlhbmdsZXJpZ2h0LFxuICAgIG50cmlhbmdsZXJpZ2h0ZXE6IG50cmlhbmdsZXJpZ2h0ZXEsXG4gICAgTnU6IE51LFxuICAgIG51OiBudSxcbiAgICBudW06IG51bSxcbiAgICBudW1lcm86IG51bWVybyxcbiAgICBudW1zcDogbnVtc3AsXG4gICAgbnZhcDogbnZhcCxcbiAgICBudmRhc2g6IG52ZGFzaCxcbiAgICBudkRhc2g6IG52RGFzaCxcbiAgICBuVmRhc2g6IG5WZGFzaCxcbiAgICBuVkRhc2g6IG5WRGFzaCxcbiAgICBudmdlOiBudmdlLFxuICAgIG52Z3Q6IG52Z3QsXG4gICAgbnZIYXJyOiBudkhhcnIsXG4gICAgbnZpbmZpbjogbnZpbmZpbixcbiAgICBudmxBcnI6IG52bEFycixcbiAgICBudmxlOiBudmxlLFxuICAgIG52bHQ6IG52bHQsXG4gICAgbnZsdHJpZTogbnZsdHJpZSxcbiAgICBudnJBcnI6IG52ckFycixcbiAgICBudnJ0cmllOiBudnJ0cmllLFxuICAgIG52c2ltOiBudnNpbSxcbiAgICBud2FyaGs6IG53YXJoayxcbiAgICBud2FycjogbndhcnIsXG4gICAgbndBcnI6IG53QXJyLFxuICAgIG53YXJyb3c6IG53YXJyb3csXG4gICAgbnduZWFyOiBud25lYXIsXG4gICAgT2FjdXRlOiBPYWN1dGUkMSxcbiAgICBvYWN1dGU6IG9hY3V0ZSQxLFxuICAgIG9hc3Q6IG9hc3QsXG4gICAgT2NpcmM6IE9jaXJjJDEsXG4gICAgb2NpcmM6IG9jaXJjJDEsXG4gICAgb2Npcjogb2NpcixcbiAgICBPY3k6IE9jeSxcbiAgICBvY3k6IG9jeSxcbiAgICBvZGFzaDogb2Rhc2gsXG4gICAgT2RibGFjOiBPZGJsYWMsXG4gICAgb2RibGFjOiBvZGJsYWMsXG4gICAgb2Rpdjogb2RpdixcbiAgICBvZG90OiBvZG90LFxuICAgIG9kc29sZDogb2Rzb2xkLFxuICAgIE9FbGlnOiBPRWxpZyxcbiAgICBvZWxpZzogb2VsaWcsXG4gICAgb2ZjaXI6IG9mY2lyLFxuICAgIE9mcjogT2ZyLFxuICAgIG9mcjogb2ZyLFxuICAgIG9nb246IG9nb24sXG4gICAgT2dyYXZlOiBPZ3JhdmUkMSxcbiAgICBvZ3JhdmU6IG9ncmF2ZSQxLFxuICAgIG9ndDogb2d0LFxuICAgIG9oYmFyOiBvaGJhcixcbiAgICBvaG06IG9obSxcbiAgICBvaW50OiBvaW50LFxuICAgIG9sYXJyOiBvbGFycixcbiAgICBvbGNpcjogb2xjaXIsXG4gICAgb2xjcm9zczogb2xjcm9zcyxcbiAgICBvbGluZTogb2xpbmUsXG4gICAgb2x0OiBvbHQsXG4gICAgT21hY3I6IE9tYWNyLFxuICAgIG9tYWNyOiBvbWFjcixcbiAgICBPbWVnYTogT21lZ2EsXG4gICAgb21lZ2E6IG9tZWdhLFxuICAgIE9taWNyb246IE9taWNyb24sXG4gICAgb21pY3Jvbjogb21pY3JvbixcbiAgICBvbWlkOiBvbWlkLFxuICAgIG9taW51czogb21pbnVzLFxuICAgIE9vcGY6IE9vcGYsXG4gICAgb29wZjogb29wZixcbiAgICBvcGFyOiBvcGFyLFxuICAgIE9wZW5DdXJseURvdWJsZVF1b3RlOiBPcGVuQ3VybHlEb3VibGVRdW90ZSxcbiAgICBPcGVuQ3VybHlRdW90ZTogT3BlbkN1cmx5UXVvdGUsXG4gICAgb3BlcnA6IG9wZXJwLFxuICAgIG9wbHVzOiBvcGx1cyxcbiAgICBvcmFycjogb3JhcnIsXG4gICAgT3I6IE9yLFxuICAgIG9yOiBvcixcbiAgICBvcmQ6IG9yZCxcbiAgICBvcmRlcjogb3JkZXIsXG4gICAgb3JkZXJvZjogb3JkZXJvZixcbiAgICBvcmRmOiBvcmRmJDEsXG4gICAgb3JkbTogb3JkbSQxLFxuICAgIG9yaWdvZjogb3JpZ29mLFxuICAgIG9yb3I6IG9yb3IsXG4gICAgb3JzbG9wZTogb3JzbG9wZSxcbiAgICBvcnY6IG9ydixcbiAgICBvUzogb1MsXG4gICAgT3NjcjogT3NjcixcbiAgICBvc2NyOiBvc2NyLFxuICAgIE9zbGFzaDogT3NsYXNoJDEsXG4gICAgb3NsYXNoOiBvc2xhc2gkMSxcbiAgICBvc29sOiBvc29sLFxuICAgIE90aWxkZTogT3RpbGRlJDEsXG4gICAgb3RpbGRlOiBvdGlsZGUkMSxcbiAgICBvdGltZXNhczogb3RpbWVzYXMsXG4gICAgT3RpbWVzOiBPdGltZXMsXG4gICAgb3RpbWVzOiBvdGltZXMsXG4gICAgT3VtbDogT3VtbCQxLFxuICAgIG91bWw6IG91bWwkMSxcbiAgICBvdmJhcjogb3ZiYXIsXG4gICAgT3ZlckJhcjogT3ZlckJhcixcbiAgICBPdmVyQnJhY2U6IE92ZXJCcmFjZSxcbiAgICBPdmVyQnJhY2tldDogT3ZlckJyYWNrZXQsXG4gICAgT3ZlclBhcmVudGhlc2lzOiBPdmVyUGFyZW50aGVzaXMsXG4gICAgcGFyYTogcGFyYSQxLFxuICAgIHBhcmFsbGVsOiBwYXJhbGxlbCxcbiAgICBwYXI6IHBhcixcbiAgICBwYXJzaW06IHBhcnNpbSxcbiAgICBwYXJzbDogcGFyc2wsXG4gICAgcGFydDogcGFydCxcbiAgICBQYXJ0aWFsRDogUGFydGlhbEQsXG4gICAgUGN5OiBQY3ksXG4gICAgcGN5OiBwY3ksXG4gICAgcGVyY250OiBwZXJjbnQsXG4gICAgcGVyaW9kOiBwZXJpb2QsXG4gICAgcGVybWlsOiBwZXJtaWwsXG4gICAgcGVycDogcGVycCxcbiAgICBwZXJ0ZW5rOiBwZXJ0ZW5rLFxuICAgIFBmcjogUGZyLFxuICAgIHBmcjogcGZyLFxuICAgIFBoaTogUGhpLFxuICAgIHBoaTogcGhpLFxuICAgIHBoaXY6IHBoaXYsXG4gICAgcGhtbWF0OiBwaG1tYXQsXG4gICAgcGhvbmU6IHBob25lLFxuICAgIFBpOiBQaSxcbiAgICBwaTogcGksXG4gICAgcGl0Y2hmb3JrOiBwaXRjaGZvcmssXG4gICAgcGl2OiBwaXYsXG4gICAgcGxhbmNrOiBwbGFuY2ssXG4gICAgcGxhbmNraDogcGxhbmNraCxcbiAgICBwbGFua3Y6IHBsYW5rdixcbiAgICBwbHVzYWNpcjogcGx1c2FjaXIsXG4gICAgcGx1c2I6IHBsdXNiLFxuICAgIHBsdXNjaXI6IHBsdXNjaXIsXG4gICAgcGx1czogcGx1cyxcbiAgICBwbHVzZG86IHBsdXNkbyxcbiAgICBwbHVzZHU6IHBsdXNkdSxcbiAgICBwbHVzZTogcGx1c2UsXG4gICAgUGx1c01pbnVzOiBQbHVzTWludXMsXG4gICAgcGx1c21uOiBwbHVzbW4kMSxcbiAgICBwbHVzc2ltOiBwbHVzc2ltLFxuICAgIHBsdXN0d286IHBsdXN0d28sXG4gICAgcG06IHBtLFxuICAgIFBvaW5jYXJlcGxhbmU6IFBvaW5jYXJlcGxhbmUsXG4gICAgcG9pbnRpbnQ6IHBvaW50aW50LFxuICAgIHBvcGY6IHBvcGYsXG4gICAgUG9wZjogUG9wZixcbiAgICBwb3VuZDogcG91bmQkMSxcbiAgICBwcmFwOiBwcmFwLFxuICAgIFByOiBQcixcbiAgICBwcjogcHIsXG4gICAgcHJjdWU6IHByY3VlLFxuICAgIHByZWNhcHByb3g6IHByZWNhcHByb3gsXG4gICAgcHJlYzogcHJlYyxcbiAgICBwcmVjY3VybHllcTogcHJlY2N1cmx5ZXEsXG4gICAgUHJlY2VkZXM6IFByZWNlZGVzLFxuICAgIFByZWNlZGVzRXF1YWw6IFByZWNlZGVzRXF1YWwsXG4gICAgUHJlY2VkZXNTbGFudEVxdWFsOiBQcmVjZWRlc1NsYW50RXF1YWwsXG4gICAgUHJlY2VkZXNUaWxkZTogUHJlY2VkZXNUaWxkZSxcbiAgICBwcmVjZXE6IHByZWNlcSxcbiAgICBwcmVjbmFwcHJveDogcHJlY25hcHByb3gsXG4gICAgcHJlY25lcXE6IHByZWNuZXFxLFxuICAgIHByZWNuc2ltOiBwcmVjbnNpbSxcbiAgICBwcmU6IHByZSxcbiAgICBwckU6IHByRSxcbiAgICBwcmVjc2ltOiBwcmVjc2ltLFxuICAgIHByaW1lOiBwcmltZSxcbiAgICBQcmltZTogUHJpbWUsXG4gICAgcHJpbWVzOiBwcmltZXMsXG4gICAgcHJuYXA6IHBybmFwLFxuICAgIHBybkU6IHBybkUsXG4gICAgcHJuc2ltOiBwcm5zaW0sXG4gICAgcHJvZDogcHJvZCxcbiAgICBQcm9kdWN0OiBQcm9kdWN0LFxuICAgIHByb2ZhbGFyOiBwcm9mYWxhcixcbiAgICBwcm9mbGluZTogcHJvZmxpbmUsXG4gICAgcHJvZnN1cmY6IHByb2ZzdXJmLFxuICAgIHByb3A6IHByb3AsXG4gICAgUHJvcG9ydGlvbmFsOiBQcm9wb3J0aW9uYWwsXG4gICAgUHJvcG9ydGlvbjogUHJvcG9ydGlvbixcbiAgICBwcm9wdG86IHByb3B0byxcbiAgICBwcnNpbTogcHJzaW0sXG4gICAgcHJ1cmVsOiBwcnVyZWwsXG4gICAgUHNjcjogUHNjcixcbiAgICBwc2NyOiBwc2NyLFxuICAgIFBzaTogUHNpLFxuICAgIHBzaTogcHNpLFxuICAgIHB1bmNzcDogcHVuY3NwLFxuICAgIFFmcjogUWZyLFxuICAgIHFmcjogcWZyLFxuICAgIHFpbnQ6IHFpbnQsXG4gICAgcW9wZjogcW9wZixcbiAgICBRb3BmOiBRb3BmLFxuICAgIHFwcmltZTogcXByaW1lLFxuICAgIFFzY3I6IFFzY3IsXG4gICAgcXNjcjogcXNjcixcbiAgICBxdWF0ZXJuaW9uczogcXVhdGVybmlvbnMsXG4gICAgcXVhdGludDogcXVhdGludCxcbiAgICBxdWVzdDogcXVlc3QsXG4gICAgcXVlc3RlcTogcXVlc3RlcSxcbiAgICBxdW90OiBxdW90JDIsXG4gICAgUVVPVDogUVVPVCQxLFxuICAgIHJBYXJyOiByQWFycixcbiAgICByYWNlOiByYWNlLFxuICAgIFJhY3V0ZTogUmFjdXRlLFxuICAgIHJhY3V0ZTogcmFjdXRlLFxuICAgIHJhZGljOiByYWRpYyxcbiAgICByYWVtcHR5djogcmFlbXB0eXYsXG4gICAgcmFuZzogcmFuZyxcbiAgICBSYW5nOiBSYW5nLFxuICAgIHJhbmdkOiByYW5nZCxcbiAgICByYW5nZTogcmFuZ2UsXG4gICAgcmFuZ2xlOiByYW5nbGUsXG4gICAgcmFxdW86IHJhcXVvJDEsXG4gICAgcmFycmFwOiByYXJyYXAsXG4gICAgcmFycmI6IHJhcnJiLFxuICAgIHJhcnJiZnM6IHJhcnJiZnMsXG4gICAgcmFycmM6IHJhcnJjLFxuICAgIHJhcnI6IHJhcnIsXG4gICAgUmFycjogUmFycixcbiAgICByQXJyOiByQXJyLFxuICAgIHJhcnJmczogcmFycmZzLFxuICAgIHJhcnJoazogcmFycmhrLFxuICAgIHJhcnJscDogcmFycmxwLFxuICAgIHJhcnJwbDogcmFycnBsLFxuICAgIHJhcnJzaW06IHJhcnJzaW0sXG4gICAgUmFycnRsOiBSYXJydGwsXG4gICAgcmFycnRsOiByYXJydGwsXG4gICAgcmFycnc6IHJhcnJ3LFxuICAgIHJhdGFpbDogcmF0YWlsLFxuICAgIHJBdGFpbDogckF0YWlsLFxuICAgIHJhdGlvOiByYXRpbyxcbiAgICByYXRpb25hbHM6IHJhdGlvbmFscyxcbiAgICByYmFycjogcmJhcnIsXG4gICAgckJhcnI6IHJCYXJyLFxuICAgIFJCYXJyOiBSQmFycixcbiAgICByYmJyazogcmJicmssXG4gICAgcmJyYWNlOiByYnJhY2UsXG4gICAgcmJyYWNrOiByYnJhY2ssXG4gICAgcmJya2U6IHJicmtlLFxuICAgIHJicmtzbGQ6IHJicmtzbGQsXG4gICAgcmJya3NsdTogcmJya3NsdSxcbiAgICBSY2Fyb246IFJjYXJvbixcbiAgICByY2Fyb246IHJjYXJvbixcbiAgICBSY2VkaWw6IFJjZWRpbCxcbiAgICByY2VkaWw6IHJjZWRpbCxcbiAgICByY2VpbDogcmNlaWwsXG4gICAgcmN1YjogcmN1YixcbiAgICBSY3k6IFJjeSxcbiAgICByY3k6IHJjeSxcbiAgICByZGNhOiByZGNhLFxuICAgIHJkbGRoYXI6IHJkbGRoYXIsXG4gICAgcmRxdW86IHJkcXVvLFxuICAgIHJkcXVvcjogcmRxdW9yLFxuICAgIHJkc2g6IHJkc2gsXG4gICAgcmVhbDogcmVhbCxcbiAgICByZWFsaW5lOiByZWFsaW5lLFxuICAgIHJlYWxwYXJ0OiByZWFscGFydCxcbiAgICByZWFsczogcmVhbHMsXG4gICAgUmU6IFJlLFxuICAgIHJlY3Q6IHJlY3QsXG4gICAgcmVnOiByZWckMSxcbiAgICBSRUc6IFJFRyQxLFxuICAgIFJldmVyc2VFbGVtZW50OiBSZXZlcnNlRWxlbWVudCxcbiAgICBSZXZlcnNlRXF1aWxpYnJpdW06IFJldmVyc2VFcXVpbGlicml1bSxcbiAgICBSZXZlcnNlVXBFcXVpbGlicml1bTogUmV2ZXJzZVVwRXF1aWxpYnJpdW0sXG4gICAgcmZpc2h0OiByZmlzaHQsXG4gICAgcmZsb29yOiByZmxvb3IsXG4gICAgcmZyOiByZnIsXG4gICAgUmZyOiBSZnIsXG4gICAgckhhcjogckhhcixcbiAgICByaGFyZDogcmhhcmQsXG4gICAgcmhhcnU6IHJoYXJ1LFxuICAgIHJoYXJ1bDogcmhhcnVsLFxuICAgIFJobzogUmhvLFxuICAgIHJobzogcmhvLFxuICAgIHJob3Y6IHJob3YsXG4gICAgUmlnaHRBbmdsZUJyYWNrZXQ6IFJpZ2h0QW5nbGVCcmFja2V0LFxuICAgIFJpZ2h0QXJyb3dCYXI6IFJpZ2h0QXJyb3dCYXIsXG4gICAgcmlnaHRhcnJvdzogcmlnaHRhcnJvdyxcbiAgICBSaWdodEFycm93OiBSaWdodEFycm93LFxuICAgIFJpZ2h0YXJyb3c6IFJpZ2h0YXJyb3csXG4gICAgUmlnaHRBcnJvd0xlZnRBcnJvdzogUmlnaHRBcnJvd0xlZnRBcnJvdyxcbiAgICByaWdodGFycm93dGFpbDogcmlnaHRhcnJvd3RhaWwsXG4gICAgUmlnaHRDZWlsaW5nOiBSaWdodENlaWxpbmcsXG4gICAgUmlnaHREb3VibGVCcmFja2V0OiBSaWdodERvdWJsZUJyYWNrZXQsXG4gICAgUmlnaHREb3duVGVlVmVjdG9yOiBSaWdodERvd25UZWVWZWN0b3IsXG4gICAgUmlnaHREb3duVmVjdG9yQmFyOiBSaWdodERvd25WZWN0b3JCYXIsXG4gICAgUmlnaHREb3duVmVjdG9yOiBSaWdodERvd25WZWN0b3IsXG4gICAgUmlnaHRGbG9vcjogUmlnaHRGbG9vcixcbiAgICByaWdodGhhcnBvb25kb3duOiByaWdodGhhcnBvb25kb3duLFxuICAgIHJpZ2h0aGFycG9vbnVwOiByaWdodGhhcnBvb251cCxcbiAgICByaWdodGxlZnRhcnJvd3M6IHJpZ2h0bGVmdGFycm93cyxcbiAgICByaWdodGxlZnRoYXJwb29uczogcmlnaHRsZWZ0aGFycG9vbnMsXG4gICAgcmlnaHRyaWdodGFycm93czogcmlnaHRyaWdodGFycm93cyxcbiAgICByaWdodHNxdWlnYXJyb3c6IHJpZ2h0c3F1aWdhcnJvdyxcbiAgICBSaWdodFRlZUFycm93OiBSaWdodFRlZUFycm93LFxuICAgIFJpZ2h0VGVlOiBSaWdodFRlZSxcbiAgICBSaWdodFRlZVZlY3RvcjogUmlnaHRUZWVWZWN0b3IsXG4gICAgcmlnaHR0aHJlZXRpbWVzOiByaWdodHRocmVldGltZXMsXG4gICAgUmlnaHRUcmlhbmdsZUJhcjogUmlnaHRUcmlhbmdsZUJhcixcbiAgICBSaWdodFRyaWFuZ2xlOiBSaWdodFRyaWFuZ2xlLFxuICAgIFJpZ2h0VHJpYW5nbGVFcXVhbDogUmlnaHRUcmlhbmdsZUVxdWFsLFxuICAgIFJpZ2h0VXBEb3duVmVjdG9yOiBSaWdodFVwRG93blZlY3RvcixcbiAgICBSaWdodFVwVGVlVmVjdG9yOiBSaWdodFVwVGVlVmVjdG9yLFxuICAgIFJpZ2h0VXBWZWN0b3JCYXI6IFJpZ2h0VXBWZWN0b3JCYXIsXG4gICAgUmlnaHRVcFZlY3RvcjogUmlnaHRVcFZlY3RvcixcbiAgICBSaWdodFZlY3RvckJhcjogUmlnaHRWZWN0b3JCYXIsXG4gICAgUmlnaHRWZWN0b3I6IFJpZ2h0VmVjdG9yLFxuICAgIHJpbmc6IHJpbmcsXG4gICAgcmlzaW5nZG90c2VxOiByaXNpbmdkb3RzZXEsXG4gICAgcmxhcnI6IHJsYXJyLFxuICAgIHJsaGFyOiBybGhhcixcbiAgICBybG06IHJsbSxcbiAgICBybW91c3RhY2hlOiBybW91c3RhY2hlLFxuICAgIHJtb3VzdDogcm1vdXN0LFxuICAgIHJubWlkOiBybm1pZCxcbiAgICByb2FuZzogcm9hbmcsXG4gICAgcm9hcnI6IHJvYXJyLFxuICAgIHJvYnJrOiByb2JyayxcbiAgICByb3Bhcjogcm9wYXIsXG4gICAgcm9wZjogcm9wZixcbiAgICBSb3BmOiBSb3BmLFxuICAgIHJvcGx1czogcm9wbHVzLFxuICAgIHJvdGltZXM6IHJvdGltZXMsXG4gICAgUm91bmRJbXBsaWVzOiBSb3VuZEltcGxpZXMsXG4gICAgcnBhcjogcnBhcixcbiAgICBycGFyZ3Q6IHJwYXJndCxcbiAgICBycHBvbGludDogcnBwb2xpbnQsXG4gICAgcnJhcnI6IHJyYXJyLFxuICAgIFJyaWdodGFycm93OiBScmlnaHRhcnJvdyxcbiAgICByc2FxdW86IHJzYXF1byxcbiAgICByc2NyOiByc2NyLFxuICAgIFJzY3I6IFJzY3IsXG4gICAgcnNoOiByc2gsXG4gICAgUnNoOiBSc2gsXG4gICAgcnNxYjogcnNxYixcbiAgICByc3F1bzogcnNxdW8sXG4gICAgcnNxdW9yOiByc3F1b3IsXG4gICAgcnRocmVlOiBydGhyZWUsXG4gICAgcnRpbWVzOiBydGltZXMsXG4gICAgcnRyaTogcnRyaSxcbiAgICBydHJpZTogcnRyaWUsXG4gICAgcnRyaWY6IHJ0cmlmLFxuICAgIHJ0cmlsdHJpOiBydHJpbHRyaSxcbiAgICBSdWxlRGVsYXllZDogUnVsZURlbGF5ZWQsXG4gICAgcnVsdWhhcjogcnVsdWhhcixcbiAgICByeDogcngsXG4gICAgU2FjdXRlOiBTYWN1dGUsXG4gICAgc2FjdXRlOiBzYWN1dGUsXG4gICAgc2JxdW86IHNicXVvLFxuICAgIHNjYXA6IHNjYXAsXG4gICAgU2Nhcm9uOiBTY2Fyb24sXG4gICAgc2Nhcm9uOiBzY2Fyb24sXG4gICAgU2M6IFNjLFxuICAgIHNjOiBzYyxcbiAgICBzY2N1ZTogc2NjdWUsXG4gICAgc2NlOiBzY2UsXG4gICAgc2NFOiBzY0UsXG4gICAgU2NlZGlsOiBTY2VkaWwsXG4gICAgc2NlZGlsOiBzY2VkaWwsXG4gICAgU2NpcmM6IFNjaXJjLFxuICAgIHNjaXJjOiBzY2lyYyxcbiAgICBzY25hcDogc2NuYXAsXG4gICAgc2NuRTogc2NuRSxcbiAgICBzY25zaW06IHNjbnNpbSxcbiAgICBzY3BvbGludDogc2Nwb2xpbnQsXG4gICAgc2NzaW06IHNjc2ltLFxuICAgIFNjeTogU2N5LFxuICAgIHNjeTogc2N5LFxuICAgIHNkb3RiOiBzZG90YixcbiAgICBzZG90OiBzZG90LFxuICAgIHNkb3RlOiBzZG90ZSxcbiAgICBzZWFyaGs6IHNlYXJoayxcbiAgICBzZWFycjogc2VhcnIsXG4gICAgc2VBcnI6IHNlQXJyLFxuICAgIHNlYXJyb3c6IHNlYXJyb3csXG4gICAgc2VjdDogc2VjdCQxLFxuICAgIHNlbWk6IHNlbWksXG4gICAgc2Vzd2FyOiBzZXN3YXIsXG4gICAgc2V0bWludXM6IHNldG1pbnVzLFxuICAgIHNldG1uOiBzZXRtbixcbiAgICBzZXh0OiBzZXh0LFxuICAgIFNmcjogU2ZyLFxuICAgIHNmcjogc2ZyLFxuICAgIHNmcm93bjogc2Zyb3duLFxuICAgIHNoYXJwOiBzaGFycCxcbiAgICBTSENIY3k6IFNIQ0hjeSxcbiAgICBzaGNoY3k6IHNoY2hjeSxcbiAgICBTSGN5OiBTSGN5LFxuICAgIHNoY3k6IHNoY3ksXG4gICAgU2hvcnREb3duQXJyb3c6IFNob3J0RG93bkFycm93LFxuICAgIFNob3J0TGVmdEFycm93OiBTaG9ydExlZnRBcnJvdyxcbiAgICBzaG9ydG1pZDogc2hvcnRtaWQsXG4gICAgc2hvcnRwYXJhbGxlbDogc2hvcnRwYXJhbGxlbCxcbiAgICBTaG9ydFJpZ2h0QXJyb3c6IFNob3J0UmlnaHRBcnJvdyxcbiAgICBTaG9ydFVwQXJyb3c6IFNob3J0VXBBcnJvdyxcbiAgICBzaHk6IHNoeSQxLFxuICAgIFNpZ21hOiBTaWdtYSxcbiAgICBzaWdtYTogc2lnbWEsXG4gICAgc2lnbWFmOiBzaWdtYWYsXG4gICAgc2lnbWF2OiBzaWdtYXYsXG4gICAgc2ltOiBzaW0sXG4gICAgc2ltZG90OiBzaW1kb3QsXG4gICAgc2ltZTogc2ltZSxcbiAgICBzaW1lcTogc2ltZXEsXG4gICAgc2ltZzogc2ltZyxcbiAgICBzaW1nRTogc2ltZ0UsXG4gICAgc2ltbDogc2ltbCxcbiAgICBzaW1sRTogc2ltbEUsXG4gICAgc2ltbmU6IHNpbW5lLFxuICAgIHNpbXBsdXM6IHNpbXBsdXMsXG4gICAgc2ltcmFycjogc2ltcmFycixcbiAgICBzbGFycjogc2xhcnIsXG4gICAgU21hbGxDaXJjbGU6IFNtYWxsQ2lyY2xlLFxuICAgIHNtYWxsc2V0bWludXM6IHNtYWxsc2V0bWludXMsXG4gICAgc21hc2hwOiBzbWFzaHAsXG4gICAgc21lcGFyc2w6IHNtZXBhcnNsLFxuICAgIHNtaWQ6IHNtaWQsXG4gICAgc21pbGU6IHNtaWxlLFxuICAgIHNtdDogc210LFxuICAgIHNtdGU6IHNtdGUsXG4gICAgc210ZXM6IHNtdGVzLFxuICAgIFNPRlRjeTogU09GVGN5LFxuICAgIHNvZnRjeTogc29mdGN5LFxuICAgIHNvbGJhcjogc29sYmFyLFxuICAgIHNvbGI6IHNvbGIsXG4gICAgc29sOiBzb2wsXG4gICAgU29wZjogU29wZixcbiAgICBzb3BmOiBzb3BmLFxuICAgIHNwYWRlczogc3BhZGVzLFxuICAgIHNwYWRlc3VpdDogc3BhZGVzdWl0LFxuICAgIHNwYXI6IHNwYXIsXG4gICAgc3FjYXA6IHNxY2FwLFxuICAgIHNxY2Fwczogc3FjYXBzLFxuICAgIHNxY3VwOiBzcWN1cCxcbiAgICBzcWN1cHM6IHNxY3VwcyxcbiAgICBTcXJ0OiBTcXJ0LFxuICAgIHNxc3ViOiBzcXN1YixcbiAgICBzcXN1YmU6IHNxc3ViZSxcbiAgICBzcXN1YnNldDogc3FzdWJzZXQsXG4gICAgc3FzdWJzZXRlcTogc3FzdWJzZXRlcSxcbiAgICBzcXN1cDogc3FzdXAsXG4gICAgc3FzdXBlOiBzcXN1cGUsXG4gICAgc3FzdXBzZXQ6IHNxc3Vwc2V0LFxuICAgIHNxc3Vwc2V0ZXE6IHNxc3Vwc2V0ZXEsXG4gICAgc3F1YXJlOiBzcXVhcmUsXG4gICAgU3F1YXJlOiBTcXVhcmUsXG4gICAgU3F1YXJlSW50ZXJzZWN0aW9uOiBTcXVhcmVJbnRlcnNlY3Rpb24sXG4gICAgU3F1YXJlU3Vic2V0OiBTcXVhcmVTdWJzZXQsXG4gICAgU3F1YXJlU3Vic2V0RXF1YWw6IFNxdWFyZVN1YnNldEVxdWFsLFxuICAgIFNxdWFyZVN1cGVyc2V0OiBTcXVhcmVTdXBlcnNldCxcbiAgICBTcXVhcmVTdXBlcnNldEVxdWFsOiBTcXVhcmVTdXBlcnNldEVxdWFsLFxuICAgIFNxdWFyZVVuaW9uOiBTcXVhcmVVbmlvbixcbiAgICBzcXVhcmY6IHNxdWFyZixcbiAgICBzcXU6IHNxdSxcbiAgICBzcXVmOiBzcXVmLFxuICAgIHNyYXJyOiBzcmFycixcbiAgICBTc2NyOiBTc2NyLFxuICAgIHNzY3I6IHNzY3IsXG4gICAgc3NldG1uOiBzc2V0bW4sXG4gICAgc3NtaWxlOiBzc21pbGUsXG4gICAgc3N0YXJmOiBzc3RhcmYsXG4gICAgU3RhcjogU3RhcixcbiAgICBzdGFyOiBzdGFyLFxuICAgIHN0YXJmOiBzdGFyZixcbiAgICBzdHJhaWdodGVwc2lsb246IHN0cmFpZ2h0ZXBzaWxvbixcbiAgICBzdHJhaWdodHBoaTogc3RyYWlnaHRwaGksXG4gICAgc3RybnM6IHN0cm5zLFxuICAgIHN1Yjogc3ViLFxuICAgIFN1YjogU3ViLFxuICAgIHN1YmRvdDogc3ViZG90LFxuICAgIHN1YkU6IHN1YkUsXG4gICAgc3ViZTogc3ViZSxcbiAgICBzdWJlZG90OiBzdWJlZG90LFxuICAgIHN1Ym11bHQ6IHN1Ym11bHQsXG4gICAgc3VibkU6IHN1Ym5FLFxuICAgIHN1Ym5lOiBzdWJuZSxcbiAgICBzdWJwbHVzOiBzdWJwbHVzLFxuICAgIHN1YnJhcnI6IHN1YnJhcnIsXG4gICAgc3Vic2V0OiBzdWJzZXQsXG4gICAgU3Vic2V0OiBTdWJzZXQsXG4gICAgc3Vic2V0ZXE6IHN1YnNldGVxLFxuICAgIHN1YnNldGVxcTogc3Vic2V0ZXFxLFxuICAgIFN1YnNldEVxdWFsOiBTdWJzZXRFcXVhbCxcbiAgICBzdWJzZXRuZXE6IHN1YnNldG5lcSxcbiAgICBzdWJzZXRuZXFxOiBzdWJzZXRuZXFxLFxuICAgIHN1YnNpbTogc3Vic2ltLFxuICAgIHN1YnN1Yjogc3Vic3ViLFxuICAgIHN1YnN1cDogc3Vic3VwLFxuICAgIHN1Y2NhcHByb3g6IHN1Y2NhcHByb3gsXG4gICAgc3VjYzogc3VjYyxcbiAgICBzdWNjY3VybHllcTogc3VjY2N1cmx5ZXEsXG4gICAgU3VjY2VlZHM6IFN1Y2NlZWRzLFxuICAgIFN1Y2NlZWRzRXF1YWw6IFN1Y2NlZWRzRXF1YWwsXG4gICAgU3VjY2VlZHNTbGFudEVxdWFsOiBTdWNjZWVkc1NsYW50RXF1YWwsXG4gICAgU3VjY2VlZHNUaWxkZTogU3VjY2VlZHNUaWxkZSxcbiAgICBzdWNjZXE6IHN1Y2NlcSxcbiAgICBzdWNjbmFwcHJveDogc3VjY25hcHByb3gsXG4gICAgc3VjY25lcXE6IHN1Y2NuZXFxLFxuICAgIHN1Y2Nuc2ltOiBzdWNjbnNpbSxcbiAgICBzdWNjc2ltOiBzdWNjc2ltLFxuICAgIFN1Y2hUaGF0OiBTdWNoVGhhdCxcbiAgICBzdW06IHN1bSxcbiAgICBTdW06IFN1bSxcbiAgICBzdW5nOiBzdW5nLFxuICAgIHN1cDE6IHN1cDEkMSxcbiAgICBzdXAyOiBzdXAyJDEsXG4gICAgc3VwMzogc3VwMyQxLFxuICAgIHN1cDogc3VwLFxuICAgIFN1cDogU3VwLFxuICAgIHN1cGRvdDogc3VwZG90LFxuICAgIHN1cGRzdWI6IHN1cGRzdWIsXG4gICAgc3VwRTogc3VwRSxcbiAgICBzdXBlOiBzdXBlLFxuICAgIHN1cGVkb3Q6IHN1cGVkb3QsXG4gICAgU3VwZXJzZXQ6IFN1cGVyc2V0LFxuICAgIFN1cGVyc2V0RXF1YWw6IFN1cGVyc2V0RXF1YWwsXG4gICAgc3VwaHNvbDogc3VwaHNvbCxcbiAgICBzdXBoc3ViOiBzdXBoc3ViLFxuICAgIHN1cGxhcnI6IHN1cGxhcnIsXG4gICAgc3VwbXVsdDogc3VwbXVsdCxcbiAgICBzdXBuRTogc3VwbkUsXG4gICAgc3VwbmU6IHN1cG5lLFxuICAgIHN1cHBsdXM6IHN1cHBsdXMsXG4gICAgc3Vwc2V0OiBzdXBzZXQsXG4gICAgU3Vwc2V0OiBTdXBzZXQsXG4gICAgc3Vwc2V0ZXE6IHN1cHNldGVxLFxuICAgIHN1cHNldGVxcTogc3Vwc2V0ZXFxLFxuICAgIHN1cHNldG5lcTogc3Vwc2V0bmVxLFxuICAgIHN1cHNldG5lcXE6IHN1cHNldG5lcXEsXG4gICAgc3Vwc2ltOiBzdXBzaW0sXG4gICAgc3Vwc3ViOiBzdXBzdWIsXG4gICAgc3Vwc3VwOiBzdXBzdXAsXG4gICAgc3dhcmhrOiBzd2FyaGssXG4gICAgc3dhcnI6IHN3YXJyLFxuICAgIHN3QXJyOiBzd0FycixcbiAgICBzd2Fycm93OiBzd2Fycm93LFxuICAgIHN3bndhcjogc3dud2FyLFxuICAgIHN6bGlnOiBzemxpZyQxLFxuICAgIFRhYjogVGFiLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIFRhdTogVGF1LFxuICAgIHRhdTogdGF1LFxuICAgIHRicms6IHRicmssXG4gICAgVGNhcm9uOiBUY2Fyb24sXG4gICAgdGNhcm9uOiB0Y2Fyb24sXG4gICAgVGNlZGlsOiBUY2VkaWwsXG4gICAgdGNlZGlsOiB0Y2VkaWwsXG4gICAgVGN5OiBUY3ksXG4gICAgdGN5OiB0Y3ksXG4gICAgdGRvdDogdGRvdCxcbiAgICB0ZWxyZWM6IHRlbHJlYyxcbiAgICBUZnI6IFRmcixcbiAgICB0ZnI6IHRmcixcbiAgICB0aGVyZTQ6IHRoZXJlNCxcbiAgICB0aGVyZWZvcmU6IHRoZXJlZm9yZSxcbiAgICBUaGVyZWZvcmU6IFRoZXJlZm9yZSxcbiAgICBUaGV0YTogVGhldGEsXG4gICAgdGhldGE6IHRoZXRhLFxuICAgIHRoZXRhc3ltOiB0aGV0YXN5bSxcbiAgICB0aGV0YXY6IHRoZXRhdixcbiAgICB0aGlja2FwcHJveDogdGhpY2thcHByb3gsXG4gICAgdGhpY2tzaW06IHRoaWNrc2ltLFxuICAgIFRoaWNrU3BhY2U6IFRoaWNrU3BhY2UsXG4gICAgVGhpblNwYWNlOiBUaGluU3BhY2UsXG4gICAgdGhpbnNwOiB0aGluc3AsXG4gICAgdGhrYXA6IHRoa2FwLFxuICAgIHRoa3NpbTogdGhrc2ltLFxuICAgIFRIT1JOOiBUSE9STiQxLFxuICAgIHRob3JuOiB0aG9ybiQxLFxuICAgIHRpbGRlOiB0aWxkZSxcbiAgICBUaWxkZTogVGlsZGUsXG4gICAgVGlsZGVFcXVhbDogVGlsZGVFcXVhbCxcbiAgICBUaWxkZUZ1bGxFcXVhbDogVGlsZGVGdWxsRXF1YWwsXG4gICAgVGlsZGVUaWxkZTogVGlsZGVUaWxkZSxcbiAgICB0aW1lc2JhcjogdGltZXNiYXIsXG4gICAgdGltZXNiOiB0aW1lc2IsXG4gICAgdGltZXM6IHRpbWVzJDEsXG4gICAgdGltZXNkOiB0aW1lc2QsXG4gICAgdGludDogdGludCxcbiAgICB0b2VhOiB0b2VhLFxuICAgIHRvcGJvdDogdG9wYm90LFxuICAgIHRvcGNpcjogdG9wY2lyLFxuICAgIHRvcDogZXNtX3RvcCxcbiAgICBUb3BmOiBUb3BmLFxuICAgIHRvcGY6IHRvcGYsXG4gICAgdG9wZm9yazogdG9wZm9yayxcbiAgICB0b3NhOiB0b3NhLFxuICAgIHRwcmltZTogdHByaW1lLFxuICAgIHRyYWRlOiB0cmFkZSxcbiAgICBUUkFERTogVFJBREUsXG4gICAgdHJpYW5nbGU6IHRyaWFuZ2xlLFxuICAgIHRyaWFuZ2xlZG93bjogdHJpYW5nbGVkb3duLFxuICAgIHRyaWFuZ2xlbGVmdDogdHJpYW5nbGVsZWZ0LFxuICAgIHRyaWFuZ2xlbGVmdGVxOiB0cmlhbmdsZWxlZnRlcSxcbiAgICB0cmlhbmdsZXE6IHRyaWFuZ2xlcSxcbiAgICB0cmlhbmdsZXJpZ2h0OiB0cmlhbmdsZXJpZ2h0LFxuICAgIHRyaWFuZ2xlcmlnaHRlcTogdHJpYW5nbGVyaWdodGVxLFxuICAgIHRyaWRvdDogdHJpZG90LFxuICAgIHRyaWU6IHRyaWUsXG4gICAgdHJpbWludXM6IHRyaW1pbnVzLFxuICAgIFRyaXBsZURvdDogVHJpcGxlRG90LFxuICAgIHRyaXBsdXM6IHRyaXBsdXMsXG4gICAgdHJpc2I6IHRyaXNiLFxuICAgIHRyaXRpbWU6IHRyaXRpbWUsXG4gICAgdHJwZXppdW06IHRycGV6aXVtLFxuICAgIFRzY3I6IFRzY3IsXG4gICAgdHNjcjogdHNjcixcbiAgICBUU2N5OiBUU2N5LFxuICAgIHRzY3k6IHRzY3ksXG4gICAgVFNIY3k6IFRTSGN5LFxuICAgIHRzaGN5OiB0c2hjeSxcbiAgICBUc3Ryb2s6IFRzdHJvayxcbiAgICB0c3Ryb2s6IHRzdHJvayxcbiAgICB0d2l4dDogdHdpeHQsXG4gICAgdHdvaGVhZGxlZnRhcnJvdzogdHdvaGVhZGxlZnRhcnJvdyxcbiAgICB0d29oZWFkcmlnaHRhcnJvdzogdHdvaGVhZHJpZ2h0YXJyb3csXG4gICAgVWFjdXRlOiBVYWN1dGUkMSxcbiAgICB1YWN1dGU6IHVhY3V0ZSQxLFxuICAgIHVhcnI6IHVhcnIsXG4gICAgVWFycjogVWFycixcbiAgICB1QXJyOiB1QXJyLFxuICAgIFVhcnJvY2lyOiBVYXJyb2NpcixcbiAgICBVYnJjeTogVWJyY3ksXG4gICAgdWJyY3k6IHVicmN5LFxuICAgIFVicmV2ZTogVWJyZXZlLFxuICAgIHVicmV2ZTogdWJyZXZlLFxuICAgIFVjaXJjOiBVY2lyYyQxLFxuICAgIHVjaXJjOiB1Y2lyYyQxLFxuICAgIFVjeTogVWN5LFxuICAgIHVjeTogdWN5LFxuICAgIHVkYXJyOiB1ZGFycixcbiAgICBVZGJsYWM6IFVkYmxhYyxcbiAgICB1ZGJsYWM6IHVkYmxhYyxcbiAgICB1ZGhhcjogdWRoYXIsXG4gICAgdWZpc2h0OiB1ZmlzaHQsXG4gICAgVWZyOiBVZnIsXG4gICAgdWZyOiB1ZnIsXG4gICAgVWdyYXZlOiBVZ3JhdmUkMSxcbiAgICB1Z3JhdmU6IHVncmF2ZSQxLFxuICAgIHVIYXI6IHVIYXIsXG4gICAgdWhhcmw6IHVoYXJsLFxuICAgIHVoYXJyOiB1aGFycixcbiAgICB1aGJsazogdWhibGssXG4gICAgdWxjb3JuOiB1bGNvcm4sXG4gICAgdWxjb3JuZXI6IHVsY29ybmVyLFxuICAgIHVsY3JvcDogdWxjcm9wLFxuICAgIHVsdHJpOiB1bHRyaSxcbiAgICBVbWFjcjogVW1hY3IsXG4gICAgdW1hY3I6IHVtYWNyLFxuICAgIHVtbDogdW1sJDEsXG4gICAgVW5kZXJCYXI6IFVuZGVyQmFyLFxuICAgIFVuZGVyQnJhY2U6IFVuZGVyQnJhY2UsXG4gICAgVW5kZXJCcmFja2V0OiBVbmRlckJyYWNrZXQsXG4gICAgVW5kZXJQYXJlbnRoZXNpczogVW5kZXJQYXJlbnRoZXNpcyxcbiAgICBVbmlvbjogVW5pb24sXG4gICAgVW5pb25QbHVzOiBVbmlvblBsdXMsXG4gICAgVW9nb246IFVvZ29uLFxuICAgIHVvZ29uOiB1b2dvbixcbiAgICBVb3BmOiBVb3BmLFxuICAgIHVvcGY6IHVvcGYsXG4gICAgVXBBcnJvd0JhcjogVXBBcnJvd0JhcixcbiAgICB1cGFycm93OiB1cGFycm93LFxuICAgIFVwQXJyb3c6IFVwQXJyb3csXG4gICAgVXBhcnJvdzogVXBhcnJvdyxcbiAgICBVcEFycm93RG93bkFycm93OiBVcEFycm93RG93bkFycm93LFxuICAgIHVwZG93bmFycm93OiB1cGRvd25hcnJvdyxcbiAgICBVcERvd25BcnJvdzogVXBEb3duQXJyb3csXG4gICAgVXBkb3duYXJyb3c6IFVwZG93bmFycm93LFxuICAgIFVwRXF1aWxpYnJpdW06IFVwRXF1aWxpYnJpdW0sXG4gICAgdXBoYXJwb29ubGVmdDogdXBoYXJwb29ubGVmdCxcbiAgICB1cGhhcnBvb25yaWdodDogdXBoYXJwb29ucmlnaHQsXG4gICAgdXBsdXM6IHVwbHVzLFxuICAgIFVwcGVyTGVmdEFycm93OiBVcHBlckxlZnRBcnJvdyxcbiAgICBVcHBlclJpZ2h0QXJyb3c6IFVwcGVyUmlnaHRBcnJvdyxcbiAgICB1cHNpOiB1cHNpLFxuICAgIFVwc2k6IFVwc2ksXG4gICAgdXBzaWg6IHVwc2loLFxuICAgIFVwc2lsb246IFVwc2lsb24sXG4gICAgdXBzaWxvbjogdXBzaWxvbixcbiAgICBVcFRlZUFycm93OiBVcFRlZUFycm93LFxuICAgIFVwVGVlOiBVcFRlZSxcbiAgICB1cHVwYXJyb3dzOiB1cHVwYXJyb3dzLFxuICAgIHVyY29ybjogdXJjb3JuLFxuICAgIHVyY29ybmVyOiB1cmNvcm5lcixcbiAgICB1cmNyb3A6IHVyY3JvcCxcbiAgICBVcmluZzogVXJpbmcsXG4gICAgdXJpbmc6IHVyaW5nLFxuICAgIHVydHJpOiB1cnRyaSxcbiAgICBVc2NyOiBVc2NyLFxuICAgIHVzY3I6IHVzY3IsXG4gICAgdXRkb3Q6IHV0ZG90LFxuICAgIFV0aWxkZTogVXRpbGRlLFxuICAgIHV0aWxkZTogdXRpbGRlLFxuICAgIHV0cmk6IHV0cmksXG4gICAgdXRyaWY6IHV0cmlmLFxuICAgIHV1YXJyOiB1dWFycixcbiAgICBVdW1sOiBVdW1sJDEsXG4gICAgdXVtbDogdXVtbCQxLFxuICAgIHV3YW5nbGU6IHV3YW5nbGUsXG4gICAgdmFuZ3J0OiB2YW5ncnQsXG4gICAgdmFyZXBzaWxvbjogdmFyZXBzaWxvbixcbiAgICB2YXJrYXBwYTogdmFya2FwcGEsXG4gICAgdmFybm90aGluZzogdmFybm90aGluZyxcbiAgICB2YXJwaGk6IHZhcnBoaSxcbiAgICB2YXJwaTogdmFycGksXG4gICAgdmFycHJvcHRvOiB2YXJwcm9wdG8sXG4gICAgdmFycjogdmFycixcbiAgICB2QXJyOiB2QXJyLFxuICAgIHZhcnJobzogdmFycmhvLFxuICAgIHZhcnNpZ21hOiB2YXJzaWdtYSxcbiAgICB2YXJzdWJzZXRuZXE6IHZhcnN1YnNldG5lcSxcbiAgICB2YXJzdWJzZXRuZXFxOiB2YXJzdWJzZXRuZXFxLFxuICAgIHZhcnN1cHNldG5lcTogdmFyc3Vwc2V0bmVxLFxuICAgIHZhcnN1cHNldG5lcXE6IHZhcnN1cHNldG5lcXEsXG4gICAgdmFydGhldGE6IHZhcnRoZXRhLFxuICAgIHZhcnRyaWFuZ2xlbGVmdDogdmFydHJpYW5nbGVsZWZ0LFxuICAgIHZhcnRyaWFuZ2xlcmlnaHQ6IHZhcnRyaWFuZ2xlcmlnaHQsXG4gICAgdkJhcjogdkJhcixcbiAgICBWYmFyOiBWYmFyLFxuICAgIHZCYXJ2OiB2QmFydixcbiAgICBWY3k6IFZjeSxcbiAgICB2Y3k6IHZjeSxcbiAgICB2ZGFzaDogdmRhc2gsXG4gICAgdkRhc2g6IHZEYXNoLFxuICAgIFZkYXNoOiBWZGFzaCxcbiAgICBWRGFzaDogVkRhc2gsXG4gICAgVmRhc2hsOiBWZGFzaGwsXG4gICAgdmVlYmFyOiB2ZWViYXIsXG4gICAgdmVlOiB2ZWUsXG4gICAgVmVlOiBWZWUsXG4gICAgdmVlZXE6IHZlZWVxLFxuICAgIHZlbGxpcDogdmVsbGlwLFxuICAgIHZlcmJhcjogdmVyYmFyLFxuICAgIFZlcmJhcjogVmVyYmFyLFxuICAgIHZlcnQ6IHZlcnQsXG4gICAgVmVydDogVmVydCxcbiAgICBWZXJ0aWNhbEJhcjogVmVydGljYWxCYXIsXG4gICAgVmVydGljYWxMaW5lOiBWZXJ0aWNhbExpbmUsXG4gICAgVmVydGljYWxTZXBhcmF0b3I6IFZlcnRpY2FsU2VwYXJhdG9yLFxuICAgIFZlcnRpY2FsVGlsZGU6IFZlcnRpY2FsVGlsZGUsXG4gICAgVmVyeVRoaW5TcGFjZTogVmVyeVRoaW5TcGFjZSxcbiAgICBWZnI6IFZmcixcbiAgICB2ZnI6IHZmcixcbiAgICB2bHRyaTogdmx0cmksXG4gICAgdm5zdWI6IHZuc3ViLFxuICAgIHZuc3VwOiB2bnN1cCxcbiAgICBWb3BmOiBWb3BmLFxuICAgIHZvcGY6IHZvcGYsXG4gICAgdnByb3A6IHZwcm9wLFxuICAgIHZydHJpOiB2cnRyaSxcbiAgICBWc2NyOiBWc2NyLFxuICAgIHZzY3I6IHZzY3IsXG4gICAgdnN1Ym5FOiB2c3VibkUsXG4gICAgdnN1Ym5lOiB2c3VibmUsXG4gICAgdnN1cG5FOiB2c3VwbkUsXG4gICAgdnN1cG5lOiB2c3VwbmUsXG4gICAgVnZkYXNoOiBWdmRhc2gsXG4gICAgdnppZ3phZzogdnppZ3phZyxcbiAgICBXY2lyYzogV2NpcmMsXG4gICAgd2NpcmM6IHdjaXJjLFxuICAgIHdlZGJhcjogd2VkYmFyLFxuICAgIHdlZGdlOiB3ZWRnZSxcbiAgICBXZWRnZTogV2VkZ2UsXG4gICAgd2VkZ2VxOiB3ZWRnZXEsXG4gICAgd2VpZXJwOiB3ZWllcnAsXG4gICAgV2ZyOiBXZnIsXG4gICAgd2ZyOiB3ZnIsXG4gICAgV29wZjogV29wZixcbiAgICB3b3BmOiB3b3BmLFxuICAgIHdwOiB3cCxcbiAgICB3cjogd3IsXG4gICAgd3JlYXRoOiB3cmVhdGgsXG4gICAgV3NjcjogV3NjcixcbiAgICB3c2NyOiB3c2NyLFxuICAgIHhjYXA6IHhjYXAsXG4gICAgeGNpcmM6IHhjaXJjLFxuICAgIHhjdXA6IHhjdXAsXG4gICAgeGR0cmk6IHhkdHJpLFxuICAgIFhmcjogWGZyLFxuICAgIHhmcjogeGZyLFxuICAgIHhoYXJyOiB4aGFycixcbiAgICB4aEFycjogeGhBcnIsXG4gICAgWGk6IFhpLFxuICAgIHhpOiB4aSxcbiAgICB4bGFycjogeGxhcnIsXG4gICAgeGxBcnI6IHhsQXJyLFxuICAgIHhtYXA6IHhtYXAsXG4gICAgeG5pczogeG5pcyxcbiAgICB4b2RvdDogeG9kb3QsXG4gICAgWG9wZjogWG9wZixcbiAgICB4b3BmOiB4b3BmLFxuICAgIHhvcGx1czogeG9wbHVzLFxuICAgIHhvdGltZTogeG90aW1lLFxuICAgIHhyYXJyOiB4cmFycixcbiAgICB4ckFycjogeHJBcnIsXG4gICAgWHNjcjogWHNjcixcbiAgICB4c2NyOiB4c2NyLFxuICAgIHhzcWN1cDogeHNxY3VwLFxuICAgIHh1cGx1czogeHVwbHVzLFxuICAgIHh1dHJpOiB4dXRyaSxcbiAgICB4dmVlOiB4dmVlLFxuICAgIHh3ZWRnZTogeHdlZGdlLFxuICAgIFlhY3V0ZTogWWFjdXRlJDEsXG4gICAgeWFjdXRlOiB5YWN1dGUkMSxcbiAgICBZQWN5OiBZQWN5LFxuICAgIHlhY3k6IHlhY3ksXG4gICAgWWNpcmM6IFljaXJjLFxuICAgIHljaXJjOiB5Y2lyYyxcbiAgICBZY3k6IFljeSxcbiAgICB5Y3k6IHljeSxcbiAgICB5ZW46IHllbiQxLFxuICAgIFlmcjogWWZyLFxuICAgIHlmcjogeWZyLFxuICAgIFlJY3k6IFlJY3ksXG4gICAgeWljeTogeWljeSxcbiAgICBZb3BmOiBZb3BmLFxuICAgIHlvcGY6IHlvcGYsXG4gICAgWXNjcjogWXNjcixcbiAgICB5c2NyOiB5c2NyLFxuICAgIFlVY3k6IFlVY3ksXG4gICAgeXVjeTogeXVjeSxcbiAgICB5dW1sOiB5dW1sJDEsXG4gICAgWXVtbDogWXVtbCxcbiAgICBaYWN1dGU6IFphY3V0ZSxcbiAgICB6YWN1dGU6IHphY3V0ZSxcbiAgICBaY2Fyb246IFpjYXJvbixcbiAgICB6Y2Fyb246IHpjYXJvbixcbiAgICBaY3k6IFpjeSxcbiAgICB6Y3k6IHpjeSxcbiAgICBaZG90OiBaZG90LFxuICAgIHpkb3Q6IHpkb3QsXG4gICAgemVldHJmOiB6ZWV0cmYsXG4gICAgWmVyb1dpZHRoU3BhY2U6IFplcm9XaWR0aFNwYWNlLFxuICAgIFpldGE6IFpldGEsXG4gICAgemV0YTogemV0YSxcbiAgICB6ZnI6IHpmcixcbiAgICBaZnI6IFpmcixcbiAgICBaSGN5OiBaSGN5LFxuICAgIHpoY3k6IHpoY3ksXG4gICAgemlncmFycjogemlncmFycixcbiAgICB6b3BmOiB6b3BmLFxuICAgIFpvcGY6IFpvcGYsXG4gICAgWnNjcjogWnNjcixcbiAgICB6c2NyOiB6c2NyLFxuICAgIHp3ajogendqLFxuICAgIHp3bmo6IHp3bmpcbn07XG52YXIgQWFjdXRlID0gXCLDgVwiO1xudmFyIGFhY3V0ZSA9IFwiw6FcIjtcbnZhciBBY2lyYyA9IFwiw4JcIjtcbnZhciBhY2lyYyA9IFwiw6JcIjtcbnZhciBhY3V0ZSA9IFwiwrRcIjtcbnZhciBBRWxpZyA9IFwiw4ZcIjtcbnZhciBhZWxpZyA9IFwiw6ZcIjtcbnZhciBBZ3JhdmUgPSBcIsOAXCI7XG52YXIgYWdyYXZlID0gXCLDoFwiO1xudmFyIGFtcCQxID0gXCImXCI7XG52YXIgQU1QID0gXCImXCI7XG52YXIgQXJpbmcgPSBcIsOFXCI7XG52YXIgYXJpbmcgPSBcIsOlXCI7XG52YXIgQXRpbGRlID0gXCLDg1wiO1xudmFyIGF0aWxkZSA9IFwiw6NcIjtcbnZhciBBdW1sID0gXCLDhFwiO1xudmFyIGF1bWwgPSBcIsOkXCI7XG52YXIgYnJ2YmFyID0gXCLCplwiO1xudmFyIENjZWRpbCA9IFwiw4dcIjtcbnZhciBjY2VkaWwgPSBcIsOnXCI7XG52YXIgY2VkaWwgPSBcIsK4XCI7XG52YXIgY2VudCA9IFwiwqJcIjtcbnZhciBjb3B5ID0gXCLCqVwiO1xudmFyIENPUFkgPSBcIsKpXCI7XG52YXIgY3VycmVuID0gXCLCpFwiO1xudmFyIGRlZyA9IFwiwrBcIjtcbnZhciBkaXZpZGUgPSBcIsO3XCI7XG52YXIgRWFjdXRlID0gXCLDiVwiO1xudmFyIGVhY3V0ZSA9IFwiw6lcIjtcbnZhciBFY2lyYyA9IFwiw4pcIjtcbnZhciBlY2lyYyA9IFwiw6pcIjtcbnZhciBFZ3JhdmUgPSBcIsOIXCI7XG52YXIgZWdyYXZlID0gXCLDqFwiO1xudmFyIEVUSCA9IFwiw5BcIjtcbnZhciBldGggPSBcIsOwXCI7XG52YXIgRXVtbCA9IFwiw4tcIjtcbnZhciBldW1sID0gXCLDq1wiO1xudmFyIGZyYWMxMiA9IFwiwr1cIjtcbnZhciBmcmFjMTQgPSBcIsK8XCI7XG52YXIgZnJhYzM0ID0gXCLCvlwiO1xudmFyIGd0JDEgPSBcIj5cIjtcbnZhciBHVCA9IFwiPlwiO1xudmFyIElhY3V0ZSA9IFwiw41cIjtcbnZhciBpYWN1dGUgPSBcIsOtXCI7XG52YXIgSWNpcmMgPSBcIsOOXCI7XG52YXIgaWNpcmMgPSBcIsOuXCI7XG52YXIgaWV4Y2wgPSBcIsKhXCI7XG52YXIgSWdyYXZlID0gXCLDjFwiO1xudmFyIGlncmF2ZSA9IFwiw6xcIjtcbnZhciBpcXVlc3QgPSBcIsK/XCI7XG52YXIgSXVtbCA9IFwiw49cIjtcbnZhciBpdW1sID0gXCLDr1wiO1xudmFyIGxhcXVvID0gXCLCq1wiO1xudmFyIGx0JDEgPSBcIjxcIjtcbnZhciBMVCA9IFwiPFwiO1xudmFyIG1hY3IgPSBcIsKvXCI7XG52YXIgbWljcm8gPSBcIsK1XCI7XG52YXIgbWlkZG90ID0gXCLCt1wiO1xudmFyIG5ic3AgPSBcIsKgXCI7XG52YXIgbm90ID0gXCLCrFwiO1xudmFyIE50aWxkZSA9IFwiw5FcIjtcbnZhciBudGlsZGUgPSBcIsOxXCI7XG52YXIgT2FjdXRlID0gXCLDk1wiO1xudmFyIG9hY3V0ZSA9IFwiw7NcIjtcbnZhciBPY2lyYyA9IFwiw5RcIjtcbnZhciBvY2lyYyA9IFwiw7RcIjtcbnZhciBPZ3JhdmUgPSBcIsOSXCI7XG52YXIgb2dyYXZlID0gXCLDslwiO1xudmFyIG9yZGYgPSBcIsKqXCI7XG52YXIgb3JkbSA9IFwiwrpcIjtcbnZhciBPc2xhc2ggPSBcIsOYXCI7XG52YXIgb3NsYXNoID0gXCLDuFwiO1xudmFyIE90aWxkZSA9IFwiw5VcIjtcbnZhciBvdGlsZGUgPSBcIsO1XCI7XG52YXIgT3VtbCA9IFwiw5ZcIjtcbnZhciBvdW1sID0gXCLDtlwiO1xudmFyIHBhcmEgPSBcIsK2XCI7XG52YXIgcGx1c21uID0gXCLCsVwiO1xudmFyIHBvdW5kID0gXCLCo1wiO1xudmFyIHF1b3QkMSA9IFwiXFxcIlwiO1xudmFyIFFVT1QgPSBcIlxcXCJcIjtcbnZhciByYXF1byA9IFwiwrtcIjtcbnZhciByZWcgPSBcIsKuXCI7XG52YXIgUkVHID0gXCLCrlwiO1xudmFyIHNlY3QgPSBcIsKnXCI7XG52YXIgc2h5ID0gXCLCrVwiO1xudmFyIHN1cDEgPSBcIsK5XCI7XG52YXIgc3VwMiA9IFwiwrJcIjtcbnZhciBzdXAzID0gXCLCs1wiO1xudmFyIHN6bGlnID0gXCLDn1wiO1xudmFyIFRIT1JOID0gXCLDnlwiO1xudmFyIHRob3JuID0gXCLDvlwiO1xudmFyIHRpbWVzID0gXCLDl1wiO1xudmFyIFVhY3V0ZSA9IFwiw5pcIjtcbnZhciB1YWN1dGUgPSBcIsO6XCI7XG52YXIgVWNpcmMgPSBcIsObXCI7XG52YXIgdWNpcmMgPSBcIsO7XCI7XG52YXIgVWdyYXZlID0gXCLDmVwiO1xudmFyIHVncmF2ZSA9IFwiw7lcIjtcbnZhciB1bWwgPSBcIsKoXCI7XG52YXIgVXVtbCA9IFwiw5xcIjtcbnZhciB1dW1sID0gXCLDvFwiO1xudmFyIFlhY3V0ZSA9IFwiw51cIjtcbnZhciB5YWN1dGUgPSBcIsO9XCI7XG52YXIgeWVuID0gXCLCpVwiO1xudmFyIHl1bWwgPSBcIsO/XCI7XG52YXIgcmVxdWlyZSQkMSA9IHtcbiAgICBBYWN1dGU6IEFhY3V0ZSxcbiAgICBhYWN1dGU6IGFhY3V0ZSxcbiAgICBBY2lyYzogQWNpcmMsXG4gICAgYWNpcmM6IGFjaXJjLFxuICAgIGFjdXRlOiBhY3V0ZSxcbiAgICBBRWxpZzogQUVsaWcsXG4gICAgYWVsaWc6IGFlbGlnLFxuICAgIEFncmF2ZTogQWdyYXZlLFxuICAgIGFncmF2ZTogYWdyYXZlLFxuICAgIGFtcDogYW1wJDEsXG4gICAgQU1QOiBBTVAsXG4gICAgQXJpbmc6IEFyaW5nLFxuICAgIGFyaW5nOiBhcmluZyxcbiAgICBBdGlsZGU6IEF0aWxkZSxcbiAgICBhdGlsZGU6IGF0aWxkZSxcbiAgICBBdW1sOiBBdW1sLFxuICAgIGF1bWw6IGF1bWwsXG4gICAgYnJ2YmFyOiBicnZiYXIsXG4gICAgQ2NlZGlsOiBDY2VkaWwsXG4gICAgY2NlZGlsOiBjY2VkaWwsXG4gICAgY2VkaWw6IGNlZGlsLFxuICAgIGNlbnQ6IGNlbnQsXG4gICAgY29weTogY29weSxcbiAgICBDT1BZOiBDT1BZLFxuICAgIGN1cnJlbjogY3VycmVuLFxuICAgIGRlZzogZGVnLFxuICAgIGRpdmlkZTogZGl2aWRlLFxuICAgIEVhY3V0ZTogRWFjdXRlLFxuICAgIGVhY3V0ZTogZWFjdXRlLFxuICAgIEVjaXJjOiBFY2lyYyxcbiAgICBlY2lyYzogZWNpcmMsXG4gICAgRWdyYXZlOiBFZ3JhdmUsXG4gICAgZWdyYXZlOiBlZ3JhdmUsXG4gICAgRVRIOiBFVEgsXG4gICAgZXRoOiBldGgsXG4gICAgRXVtbDogRXVtbCxcbiAgICBldW1sOiBldW1sLFxuICAgIGZyYWMxMjogZnJhYzEyLFxuICAgIGZyYWMxNDogZnJhYzE0LFxuICAgIGZyYWMzNDogZnJhYzM0LFxuICAgIGd0OiBndCQxLFxuICAgIEdUOiBHVCxcbiAgICBJYWN1dGU6IElhY3V0ZSxcbiAgICBpYWN1dGU6IGlhY3V0ZSxcbiAgICBJY2lyYzogSWNpcmMsXG4gICAgaWNpcmM6IGljaXJjLFxuICAgIGlleGNsOiBpZXhjbCxcbiAgICBJZ3JhdmU6IElncmF2ZSxcbiAgICBpZ3JhdmU6IGlncmF2ZSxcbiAgICBpcXVlc3Q6IGlxdWVzdCxcbiAgICBJdW1sOiBJdW1sLFxuICAgIGl1bWw6IGl1bWwsXG4gICAgbGFxdW86IGxhcXVvLFxuICAgIGx0OiBsdCQxLFxuICAgIExUOiBMVCxcbiAgICBtYWNyOiBtYWNyLFxuICAgIG1pY3JvOiBtaWNybyxcbiAgICBtaWRkb3Q6IG1pZGRvdCxcbiAgICBuYnNwOiBuYnNwLFxuICAgIG5vdDogbm90LFxuICAgIE50aWxkZTogTnRpbGRlLFxuICAgIG50aWxkZTogbnRpbGRlLFxuICAgIE9hY3V0ZTogT2FjdXRlLFxuICAgIG9hY3V0ZTogb2FjdXRlLFxuICAgIE9jaXJjOiBPY2lyYyxcbiAgICBvY2lyYzogb2NpcmMsXG4gICAgT2dyYXZlOiBPZ3JhdmUsXG4gICAgb2dyYXZlOiBvZ3JhdmUsXG4gICAgb3JkZjogb3JkZixcbiAgICBvcmRtOiBvcmRtLFxuICAgIE9zbGFzaDogT3NsYXNoLFxuICAgIG9zbGFzaDogb3NsYXNoLFxuICAgIE90aWxkZTogT3RpbGRlLFxuICAgIG90aWxkZTogb3RpbGRlLFxuICAgIE91bWw6IE91bWwsXG4gICAgb3VtbDogb3VtbCxcbiAgICBwYXJhOiBwYXJhLFxuICAgIHBsdXNtbjogcGx1c21uLFxuICAgIHBvdW5kOiBwb3VuZCxcbiAgICBxdW90OiBxdW90JDEsXG4gICAgUVVPVDogUVVPVCxcbiAgICByYXF1bzogcmFxdW8sXG4gICAgcmVnOiByZWcsXG4gICAgUkVHOiBSRUcsXG4gICAgc2VjdDogc2VjdCxcbiAgICBzaHk6IHNoeSxcbiAgICBzdXAxOiBzdXAxLFxuICAgIHN1cDI6IHN1cDIsXG4gICAgc3VwMzogc3VwMyxcbiAgICBzemxpZzogc3psaWcsXG4gICAgVEhPUk46IFRIT1JOLFxuICAgIHRob3JuOiB0aG9ybixcbiAgICB0aW1lczogdGltZXMsXG4gICAgVWFjdXRlOiBVYWN1dGUsXG4gICAgdWFjdXRlOiB1YWN1dGUsXG4gICAgVWNpcmM6IFVjaXJjLFxuICAgIHVjaXJjOiB1Y2lyYyxcbiAgICBVZ3JhdmU6IFVncmF2ZSxcbiAgICB1Z3JhdmU6IHVncmF2ZSxcbiAgICB1bWw6IHVtbCxcbiAgICBVdW1sOiBVdW1sLFxuICAgIHV1bWw6IHV1bWwsXG4gICAgWWFjdXRlOiBZYWN1dGUsXG4gICAgeWFjdXRlOiB5YWN1dGUsXG4gICAgeWVuOiB5ZW4sXG4gICAgeXVtbDogeXVtbFxufTtcbnZhciBhbXAgPSBcIiZcIjtcbnZhciBhcG9zID0gXCInXCI7XG52YXIgZ3QgPSBcIj5cIjtcbnZhciBsdCA9IFwiPFwiO1xudmFyIHF1b3QgPSBcIlxcXCJcIjtcbnZhciByZXF1aXJlJCQwJDEgPSB7XG4gICAgYW1wOiBhbXAsXG4gICAgYXBvczogYXBvcyxcbiAgICBndDogZ3QsXG4gICAgbHQ6IGx0LFxuICAgIHF1b3Q6IHF1b3Rcbn07XG52YXIgZGVjb2RlX2NvZGVwb2ludCA9IHt9O1xudmFyIHJlcXVpcmUkJDAgPSB7XG4gICAgXCIwXCI6IDY1NTMzLFxuICAgIFwiMTI4XCI6IDgzNjQsXG4gICAgXCIxMzBcIjogODIxOCxcbiAgICBcIjEzMVwiOiA0MDIsXG4gICAgXCIxMzJcIjogODIyMixcbiAgICBcIjEzM1wiOiA4MjMwLFxuICAgIFwiMTM0XCI6IDgyMjQsXG4gICAgXCIxMzVcIjogODIyNSxcbiAgICBcIjEzNlwiOiA3MTAsXG4gICAgXCIxMzdcIjogODI0MCxcbiAgICBcIjEzOFwiOiAzNTIsXG4gICAgXCIxMzlcIjogODI0OSxcbiAgICBcIjE0MFwiOiAzMzgsXG4gICAgXCIxNDJcIjogMzgxLFxuICAgIFwiMTQ1XCI6IDgyMTYsXG4gICAgXCIxNDZcIjogODIxNyxcbiAgICBcIjE0N1wiOiA4MjIwLFxuICAgIFwiMTQ4XCI6IDgyMjEsXG4gICAgXCIxNDlcIjogODIyNixcbiAgICBcIjE1MFwiOiA4MjExLFxuICAgIFwiMTUxXCI6IDgyMTIsXG4gICAgXCIxNTJcIjogNzMyLFxuICAgIFwiMTUzXCI6IDg0ODIsXG4gICAgXCIxNTRcIjogMzUzLFxuICAgIFwiMTU1XCI6IDgyNTAsXG4gICAgXCIxNTZcIjogMzM5LFxuICAgIFwiMTU4XCI6IDM4MixcbiAgICBcIjE1OVwiOiAzNzZcbn07XG52YXIgX19pbXBvcnREZWZhdWx0JDIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZV9jb2RlcG9pbnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRlY29kZV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMihyZXF1aXJlJCQwKTtcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9oZS9ibG9iL21hc3Rlci9zcmMvaGUuanMjTDk0LUwxMTlcbnZhciBmcm9tQ29kZVBvaW50JDIgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcuZnJvbUNvZGVQb2ludCB8fFxuICAgIGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweGZmZmYpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4+IDEwKSAmIDB4M2ZmKSB8IDB4ZDgwMCk7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSAweGRjMDAgfCAoY29kZVBvaW50ICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcbiAgICBpZiAoKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGZmZikgfHwgY29kZVBvaW50ID4gMHgxMGZmZmYpIHtcbiAgICAgICAgcmV0dXJuIFwiXFx1RkZGRFwiO1xuICAgIH1cbiAgICBpZiAoY29kZVBvaW50IGluIGRlY29kZV9qc29uXzEuZGVmYXVsdCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBkZWNvZGVfanNvbl8xLmRlZmF1bHRbY29kZVBvaW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21Db2RlUG9pbnQkMihjb2RlUG9pbnQpO1xufVxuZGVjb2RlX2NvZGVwb2ludC5kZWZhdWx0ID0gZGVjb2RlQ29kZVBvaW50O1xudmFyIF9faW1wb3J0RGVmYXVsdCQxID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWNvZGUsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZGVjb2RlLmRlY29kZUhUTUwgPSBkZWNvZGUuZGVjb2RlSFRNTFN0cmljdCA9IGRlY29kZS5kZWNvZGVYTUwgPSB2b2lkIDA7XG52YXIgZW50aXRpZXNfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxJDEpO1xudmFyIGxlZ2FjeV9qc29uXzEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQxKTtcbnZhciB4bWxfanNvbl8xJDEgPSBfX2ltcG9ydERlZmF1bHQkMShyZXF1aXJlJCQwJDEpO1xudmFyIGRlY29kZV9jb2RlcG9pbnRfMSA9IF9faW1wb3J0RGVmYXVsdCQxKGRlY29kZV9jb2RlcG9pbnQpO1xudmFyIHN0cmljdEVudGl0eVJlID0gLyYoPzpbYS16QS1aMC05XSt8I1t4WF1bXFxkYS1mQS1GXSt8I1xcZCspOy9nO1xuZGVjb2RlLmRlY29kZVhNTCA9IGdldFN0cmljdERlY29kZXIoeG1sX2pzb25fMSQxLmRlZmF1bHQpO1xuZGVjb2RlLmRlY29kZUhUTUxTdHJpY3QgPSBnZXRTdHJpY3REZWNvZGVyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuZnVuY3Rpb24gZ2V0U3RyaWN0RGVjb2RlcihtYXApIHtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKG1hcCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2Uoc3RyaWN0RW50aXR5UmUsIHJlcGxhY2UpOyB9O1xufVxudmFyIHNvcnRlciA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYSA8IGIgPyAxIDogLTEpOyB9O1xuZGVjb2RlLmRlY29kZUhUTUwgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZWdhY3kgPSBPYmplY3Qua2V5cyhsZWdhY3lfanNvbl8xLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpLnNvcnQoc29ydGVyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsZWdhY3lbal0gPT09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGtleXNbaV0gKz0gXCI7P1wiO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5c1tpXSArPSBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiJig/OlwiICsga2V5cy5qb2luKFwifFwiKSArIFwifCNbeFhdW1xcXFxkYS1mQS1GXSs7P3wjXFxcXGQrOz8pXCIsIFwiZ1wiKTtcbiAgICB2YXIgcmVwbGFjZSA9IGdldFJlcGxhY2VyKGVudGl0aWVzX2pzb25fMSQxLmRlZmF1bHQpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKHN0cikge1xuICAgICAgICBpZiAoc3RyLnN1YnN0cigtMSkgIT09IFwiO1wiKVxuICAgICAgICAgICAgc3RyICs9IFwiO1wiO1xuICAgICAgICByZXR1cm4gcmVwbGFjZShzdHIpO1xuICAgIH1cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGNyZWF0aW5nIGEgbWVyZ2VkIG1hcFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKHJlLCByZXBsYWNlcik7IH07XG59KSgpO1xuZnVuY3Rpb24gZ2V0UmVwbGFjZXIobWFwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2Uoc3RyKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KDEpID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIHNlY29uZENoYXIgPSBzdHIuY2hhckF0KDIpO1xuICAgICAgICAgICAgaWYgKHNlY29uZENoYXIgPT09IFwiWFwiIHx8IHNlY29uZENoYXIgPT09IFwieFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZV9jb2RlcG9pbnRfMS5kZWZhdWx0KHBhcnNlSW50KHN0ci5zdWJzdHIoMyksIDE2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlX2NvZGVwb2ludF8xLmRlZmF1bHQocGFyc2VJbnQoc3RyLnN1YnN0cigyKSwgMTApKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgcmV0dXJuIG1hcFtzdHIuc2xpY2UoMSwgLTEpXSB8fCBzdHI7XG4gICAgfTtcbn1cbnZhciBlbmNvZGUgPSB7fTtcbnZhciBlc21faW1wb3J0RGVmYXVsdCA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW5jb2RlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmVuY29kZS5lc2NhcGVVVEY4ID0gZW5jb2RlLmVzY2FwZSA9IGVuY29kZS5lbmNvZGVOb25Bc2NpaUhUTUwgPSBlbmNvZGUuZW5jb2RlSFRNTCA9IGVuY29kZS5lbmNvZGVYTUwgPSB2b2lkIDA7XG52YXIgeG1sX2pzb25fMSA9IGVzbV9pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDAkMSk7XG52YXIgaW52ZXJzZVhNTCA9IGdldEludmVyc2VPYmooeG1sX2pzb25fMS5kZWZhdWx0KTtcbnZhciB4bWxSZXBsYWNlciA9IGdldEludmVyc2VSZXBsYWNlcihpbnZlcnNlWE1MKTtcbi8qKlxuICogRW5jb2RlcyBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzIHdlbGwgYXMgY2hhcmFjdGVycyBub3QgdmFsaWQgaW4gWE1MXG4gKiBkb2N1bWVudHMgdXNpbmcgWE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlWE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VYTUwpO1xudmFyIGVudGl0aWVzX2pzb25fMSA9IGVzbV9pbXBvcnREZWZhdWx0KHJlcXVpcmUkJDEkMSk7XG52YXIgaW52ZXJzZUhUTUwgPSBnZXRJbnZlcnNlT2JqKGVudGl0aWVzX2pzb25fMS5kZWZhdWx0KTtcbnZhciBodG1sUmVwbGFjZXIgPSBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZUhUTUwpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBlbnRpdGllcyBhbmQgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0LlxuICpcbiAqIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyB0aGF0IGFyZSB2YWxpZCBBU0NJSSBjaGFyYWN0ZXJzIGluIEhUTUwgZG9jdW1lbnRzLlxuICogRm9yIGV4YW1wbGUgYCNgIHdpbGwgYmUgZW5jb2RlZCBhcyBgJm51bTtgLiBUbyBnZXQgYSBtb3JlIGNvbXBhY3Qgb3V0cHV0LFxuICogY29uc2lkZXIgdXNpbmcgdGhlIGBlbmNvZGVOb25Bc2NpaUhUTUxgIGZ1bmN0aW9uLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlSFRNTCA9IGdldEludmVyc2UoaW52ZXJzZUhUTUwsIGh0bWxSZXBsYWNlcik7XG4vKipcbiAqIEVuY29kZXMgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBhcyB3ZWxsIGFzIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIEhUTUxcbiAqIGRvY3VtZW50cyB1c2luZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqIElmIGEgY2hhcmFjdGVyIGhhcyBubyBlcXVpdmFsZW50IGVudGl0eSwgYVxuICogbnVtZXJpYyBoZXhhZGVjaW1hbCByZWZlcmVuY2UgKGVnLiBgJiN4ZmM7YCkgd2lsbCBiZSB1c2VkLlxuICovXG5lbmNvZGUuZW5jb2RlTm9uQXNjaWlIVE1MID0gZ2V0QVNDSUlFbmNvZGVyKGludmVyc2VIVE1MKTtcbmZ1bmN0aW9uIGdldEludmVyc2VPYmoob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChpbnZlcnNlLCBuYW1lKSB7XG4gICAgICAgIGludmVyc2Vbb2JqW25hbWVdXSA9IFwiJlwiICsgbmFtZSArIFwiO1wiO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlUmVwbGFjZXIoaW52ZXJzZSkge1xuICAgIHZhciBzaW5nbGUgPSBbXTtcbiAgICB2YXIgbXVsdGlwbGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMoaW52ZXJzZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICBpZiAoay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2YWx1ZSB0byBzaW5nbGUgYXJyYXlcbiAgICAgICAgICAgIHNpbmdsZS5wdXNoKFwiXFxcXFwiICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdmFsdWUgdG8gbXVsdGlwbGUgYXJyYXlcbiAgICAgICAgICAgIG11bHRpcGxlLnB1c2goayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIHJhbmdlcyB0byBzaW5nbGUgY2hhcmFjdGVycy5cbiAgICBzaW5nbGUuc29ydCgpO1xuICAgIGZvciAodmFyIHN0YXJ0ID0gMDsgc3RhcnQgPCBzaW5nbGUubGVuZ3RoIC0gMTsgc3RhcnQrKykge1xuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgYSBydW4gb2YgY2hhcmFjdGVyc1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICAgIHdoaWxlIChlbmQgPCBzaW5nbGUubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgc2luZ2xlW2VuZF0uY2hhckNvZGVBdCgxKSArIDEgPT09IHNpbmdsZVtlbmQgKyAxXS5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgICAgICBlbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSAxICsgZW5kIC0gc3RhcnQ7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmVwbGFjZSBhdCBsZWFzdCB0aHJlZSBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChjb3VudCA8IDMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc2luZ2xlLnNwbGljZShzdGFydCwgY291bnQsIHNpbmdsZVtzdGFydF0gKyBcIi1cIiArIHNpbmdsZVtlbmRdKTtcbiAgICB9XG4gICAgbXVsdGlwbGUudW5zaGlmdChcIltcIiArIHNpbmdsZS5qb2luKFwiXCIpICsgXCJdXCIpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG11bHRpcGxlLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59XG4vLyAvW15cXDAtXFx4N0ZdL2d1XG52YXIgcmVOb25BU0NJSSA9IC8oPzpbXFx4ODAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZztcbnZhciBnZXRDb2RlUG9pbnQgPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0ICE9IG51bGxcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5jb2RlUG9pbnRBdCgwKTsgfVxuICAgIDogLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiAoYy5jaGFyQ29kZUF0KDApIC0gMHhkODAwKSAqIDB4NDAwICtcbiAgICAgICAgICAgICAgICBjLmNoYXJDb2RlQXQoMSkgLVxuICAgICAgICAgICAgICAgIDB4ZGMwMCArXG4gICAgICAgICAgICAgICAgMHgxMDAwMDtcbiAgICAgICAgfTtcbmZ1bmN0aW9uIHNpbmdsZUNoYXJSZXBsYWNlcihjKSB7XG4gICAgcmV0dXJuIFwiJiN4XCIgKyAoYy5sZW5ndGggPiAxID8gZ2V0Q29kZVBvaW50KGMpIDogYy5jaGFyQ29kZUF0KDApKVxuICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpICsgXCI7XCI7XG59XG5mdW5jdGlvbiBnZXRJbnZlcnNlKGludmVyc2UsIHJlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICAucmVwbGFjZShyZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGludmVyc2VbbmFtZV07IH0pXG4gICAgICAgICAgICAucmVwbGFjZShyZU5vbkFTQ0lJLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xuICAgIH07XG59XG52YXIgcmVFc2NhcGVDaGFycyA9IG5ldyBSZWdFeHAoeG1sUmVwbGFjZXIuc291cmNlICsgXCJ8XCIgKyByZU5vbkFTQ0lJLnNvdXJjZSwgXCJnXCIpO1xuLyoqXG4gKiBFbmNvZGVzIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycywgYXMgd2VsbCBhcyBjaGFyYWN0ZXJzIG5vdCB2YWxpZCBpbiBYTUxcbiAqIGRvY3VtZW50cyB1c2luZyBudW1lcmljIGhleGFkZWNpbWFsIHJlZmVyZW5jZSAoZWcuIGAmI3hmYztgKS5cbiAqXG4gKiBIYXZlIGEgbG9vayBhdCBgZXNjYXBlVVRGOGAgaWYgeW91IHdhbnQgYSBtb3JlIGNvbmNpc2Ugb3V0cHV0IGF0IHRoZSBleHBlbnNlXG4gKiBvZiByZWR1Y2VkIHRyYW5zcG9ydGFiaWxpdHkuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNtX2VzY2FwZShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBzaW5nbGVDaGFyUmVwbGFjZXIpO1xufVxuZW5jb2RlLmVzY2FwZSA9IGVzbV9lc2NhcGU7XG4vKipcbiAqIEVuY29kZXMgYWxsIGNoYXJhY3RlcnMgbm90IHZhbGlkIGluIFhNTCBkb2N1bWVudHMgdXNpbmcgbnVtZXJpYyBoZXhhZGVjaW1hbFxuICogcmVmZXJlbmNlIChlZy4gYCYjeGZjO2ApLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgb3V0cHV0IHdpbGwgYmUgY2hhcmFjdGVyLXNldCBkZXBlbmRlbnQuXG4gKlxuICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGVzY2FwZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVVRGOChkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSh4bWxSZXBsYWNlciwgc2luZ2xlQ2hhclJlcGxhY2VyKTtcbn1cbmVuY29kZS5lc2NhcGVVVEY4ID0gZXNjYXBlVVRGODtcbmZ1bmN0aW9uIGdldEFTQ0lJRW5jb2RlcihvYmopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucmVwbGFjZShyZUVzY2FwZUNoYXJzLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gb2JqW2NdIHx8IHNpbmdsZUNoYXJSZXBsYWNlcihjKTsgfSk7XG4gICAgfTtcbn1cbihmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBleHBvcnRzLmRlY29kZVhNTFN0cmljdCA9IGV4cG9ydHMuZGVjb2RlSFRNTDVTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUw0U3RyaWN0ID0gZXhwb3J0cy5kZWNvZGVIVE1MNSA9IGV4cG9ydHMuZGVjb2RlSFRNTDQgPSBleHBvcnRzLmRlY29kZUhUTUxTdHJpY3QgPSBleHBvcnRzLmRlY29kZUhUTUwgPSBleHBvcnRzLmRlY29kZVhNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTDUgPSBleHBvcnRzLmVuY29kZUhUTUw0ID0gZXhwb3J0cy5lc2NhcGVVVEY4ID0gZXhwb3J0cy5lc2NhcGUgPSBleHBvcnRzLmVuY29kZU5vbkFzY2lpSFRNTCA9IGV4cG9ydHMuZW5jb2RlSFRNTCA9IGV4cG9ydHMuZW5jb2RlWE1MID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmRlY29kZVN0cmljdCA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuICAgIHZhciBkZWNvZGVfMSA9IGRlY29kZTtcbiAgICB2YXIgZW5jb2RlXzEgPSBlbmNvZGU7XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIHN0cmluZyB3aXRoIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgU3RyaW5nIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gbGV2ZWwgT3B0aW9uYWwgbGV2ZWwgdG8gZGVjb2RlIGF0LiAwID0gWE1MLCAxID0gSFRNTC4gRGVmYXVsdCBpcyAwLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlWE1MYCBvciBgZGVjb2RlSFRNTGAgZGlyZWN0bHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlJDEoZGF0YSwgbGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuICghbGV2ZWwgfHwgbGV2ZWwgPD0gMCA/IGRlY29kZV8xLmRlY29kZVhNTCA6IGRlY29kZV8xLmRlY29kZUhUTUwpKGRhdGEpO1xuICAgIH1cbiAgICBleHBvcnRzLmRlY29kZSA9IGRlY29kZSQxO1xuICAgIC8qKlxuICAgICAqIERlY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy4gRG9lcyBub3QgYWxsb3cgbWlzc2luZyB0cmFpbGluZyBzZW1pY29sb25zIGZvciBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGRlY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZUhUTUxTdHJpY3RgIG9yIGBkZWNvZGVYTUxgIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY29kZVN0cmljdChkYXRhLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZGVjb2RlXzEuZGVjb2RlWE1MIDogZGVjb2RlXzEuZGVjb2RlSFRNTFN0cmljdCkoZGF0YSk7XG4gICAgfVxuICAgIGV4cG9ydHMuZGVjb2RlU3RyaWN0ID0gZGVjb2RlU3RyaWN0O1xuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzdHJpbmcgd2l0aCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIFN0cmluZyB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIGxldmVsIE9wdGlvbmFsIGxldmVsIHRvIGVuY29kZSBhdC4gMCA9IFhNTCwgMSA9IEhUTUwuIERlZmF1bHQgaXMgMC5cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGVuY29kZUhUTUxgLCBgZW5jb2RlWE1MYCBvciBgZW5jb2RlTm9uQXNjaWlIVE1MYCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmNvZGUkMShkYXRhLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gKCFsZXZlbCB8fCBsZXZlbCA8PSAwID8gZW5jb2RlXzEuZW5jb2RlWE1MIDogZW5jb2RlXzEuZW5jb2RlSFRNTCkoZGF0YSk7XG4gICAgfVxuICAgIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlJDE7XG4gICAgdmFyIGVuY29kZV8yID0gZW5jb2RlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZVhNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlWE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUhUTUxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZV8yLmVuY29kZUhUTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlTm9uQXNjaWlIVE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lbmNvZGVOb25Bc2NpaUhUTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVfMi5lc2NhcGU7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlVVRGOFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZXNjYXBlVVRGODsgfSB9KTtcbiAgICAvLyBMZWdhY3kgYWxpYXNlcyAoZGVwcmVjYXRlZClcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVIVE1MNVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlXzIuZW5jb2RlSFRNTDsgfSB9KTtcbiAgICB2YXIgZGVjb2RlXzIgPSBkZWNvZGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlWE1MXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVYTUw7IH0gfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlSFRNTFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlSFRNTDsgfSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVIVE1MU3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuICAgIC8vIExlZ2FjeSBhbGlhc2VzIChkZXByZWNhdGVkKVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MOyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw0U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUhUTUw1U3RyaWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGVfMi5kZWNvZGVIVE1MU3RyaWN0OyB9IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVhNTFN0cmljdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlXzIuZGVjb2RlWE1MOyB9IH0pO1xufShsaWIpKTtcbnZhciBFTlRJVFkgPSAnJig/OiN4W2EtZjAtOV17MSw2fXwjWzAtOV17MSw3fXxbYS16XVthLXowLTldezEsMzF9KTsnO1xudmFyIENfQkFDS1NMQVNIJDEgPSA5MjtcbnZhciByZUJhY2tzbGFzaE9yQW1wID0gL1tcXFxcJl0vO1xudmFyIEVTQ0FQQUJMRSA9ICdbIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW1xcXFxcXFxcXFxcXF1eX2B7fH1+LV0nO1xudmFyIHJlRW50aXR5T3JFc2NhcGVkQ2hhciA9IG5ldyBSZWdFeHAoXCJcXFxcXFxcXFwiICsgRVNDQVBBQkxFICsgXCJ8XCIgKyBFTlRJVFksICdnaScpO1xudmFyIFhNTFNQRUNJQUwgPSAnWyY8PlwiXSc7XG52YXIgcmVYbWxTcGVjaWFsID0gbmV3IFJlZ0V4cChYTUxTUEVDSUFMLCAnZycpO1xudmFyIHVuZXNjYXBlQ2hhciA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdCgwKSA9PT0gQ19CQUNLU0xBU0gkMSkge1xuICAgICAgICByZXR1cm4gcy5jaGFyQXQoMSk7XG4gICAgfVxuICAgIHJldHVybiBsaWIuZGVjb2RlSFRNTChzKTtcbn07XG4vLyBSZXBsYWNlIGVudGl0aWVzIGFuZCBiYWNrc2xhc2ggZXNjYXBlcyB3aXRoIGxpdGVyYWwgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHVuZXNjYXBlU3RyaW5nKHMpIHtcbiAgICBpZiAocmVCYWNrc2xhc2hPckFtcC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UocmVFbnRpdHlPckVzY2FwZWRDaGFyLCB1bmVzY2FwZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSSSh1cmkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZW5jb2RlXzEodXJpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VVbnNhZmVDaGFyKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZVhtbChzKSB7XG4gICAgaWYgKHJlWG1sU3BlY2lhbC50ZXN0KHMpKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UocmVYbWxTcGVjaWFsLCByZXBsYWNlVW5zYWZlQ2hhcik7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgY291bnQpIHtcbiAgICB2YXIgYXJyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBhcnIuam9pbignJyk7XG59XG5mdW5jdGlvbiBpc0VtcHR5KHN0cikge1xuICAgIGlmICghc3RyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIS9bXiBcXHRdKy8udGVzdChzdHIpO1xufVxudmFyIE5vZGVXYWxrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZVdhbGtlcihyb290KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHJvb3Q7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSB0aGlzLmVudGVyaW5nO1xuICAgICAgICBpZiAoY3VyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbmVyID0gaXNDb250YWluZXIoY3VyKTtcbiAgICAgICAgaWYgKGVudGVyaW5nICYmIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGN1ci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzdGF5IG9uIG5vZGUgYnV0IGV4aXRcbiAgICAgICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmVudGVyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXIubmV4dDtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVudGVyaW5nOiBlbnRlcmluZywgbm9kZTogY3VyIH07XG4gICAgfTtcbiAgICBOb2RlV2Fsa2VyLnByb3RvdHlwZS5yZXN1bWVBdCA9IGZ1bmN0aW9uIChub2RlLCBlbnRlcmluZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICB0aGlzLmVudGVyaW5nID0gZW50ZXJpbmcgPT09IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZVdhbGtlcjtcbn0oKSk7XG5mdW5jdGlvbiBpc0NvbnRhaW5lcihub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICBjYXNlICdibG9ja1F1b3RlJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgY2FzZSAnZW1waCc6XG4gICAgICAgIGNhc2UgJ3N0cm9uZyc6XG4gICAgICAgIGNhc2UgJ3N0cmlrZSc6XG4gICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgY2FzZSAndGFibGVIZWFkJzpcbiAgICAgICAgY2FzZSAndGFibGVCb2R5JzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUNlbGwnOlxuICAgICAgICBjYXNlICd0YWJsZURlbGltUm93JzpcbiAgICAgICAgY2FzZSAnY3VzdG9tSW5saW5lJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbnZhciBsYXN0Tm9kZUlkID0gMTtcbnZhciBub2RlTWFwID0ge307XG5mdW5jdGlvbiBnZXROb2RlQnlJZChpZCkge1xuICAgIHJldHVybiBub2RlTWFwW2lkXTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU5vZGVCeUlkKGlkKSB7XG4gICAgZGVsZXRlIG5vZGVNYXBbaWRdO1xufVxuZnVuY3Rpb24gcmVtb3ZlQWxsTm9kZSgpIHtcbiAgICBub2RlTWFwID0ge307XG59XG52YXIgZXNtX05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZShub2RlVHlwZSwgc291cmNlcG9zKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gb25seSBmb3IgY29udGFpbmVyIG5vZGVcbiAgICAgICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICAvLyBvbmx5IGZvciBsZWFmIG5vZGVcbiAgICAgICAgdGhpcy5saXRlcmFsID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGVUeXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gbGFzdE5vZGVJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGVUeXBlO1xuICAgICAgICB0aGlzLnNvdXJjZXBvcyA9IHNvdXJjZXBvcztcbiAgICAgICAgbm9kZU1hcFt0aGlzLmlkXSA9IHRoaXM7XG4gICAgfVxuICAgIE5vZGUucHJvdG90eXBlLmlzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNDb250YWluZXIodGhpcyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByZXYpIHtcbiAgICAgICAgICAgIHRoaXMucHJldi5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5maXJzdENoaWxkID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5wcmV2ID0gdGhpcy5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5sYXN0Q2hpbGQgPSB0aGlzLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUucmVwbGFjZVdpdGggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgdGhpcy51bmxpbmsoKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKHNpYmxpbmcpIHtcbiAgICAgICAgc2libGluZy51bmxpbmsoKTtcbiAgICAgICAgc2libGluZy5uZXh0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoc2libGluZy5uZXh0KSB7XG4gICAgICAgICAgICBzaWJsaW5nLm5leHQucHJldiA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wcmV2ID0gdGhpcztcbiAgICAgICAgdGhpcy5uZXh0ID0gc2libGluZztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLm5leHQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nLnBhcmVudC5sYXN0Q2hpbGQgPSBzaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoc2libGluZykge1xuICAgICAgICBzaWJsaW5nLnVubGluaygpO1xuICAgICAgICBzaWJsaW5nLnByZXYgPSB0aGlzLnByZXY7XG4gICAgICAgIGlmIChzaWJsaW5nLnByZXYpIHtcbiAgICAgICAgICAgIHNpYmxpbmcucHJldi5uZXh0ID0gc2libGluZztcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLm5leHQgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZXYgPSBzaWJsaW5nO1xuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXNpYmxpbmcucHJldikge1xuICAgICAgICAgICAgc2libGluZy5wYXJlbnQuZmlyc3RDaGlsZCA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnVubGluaygpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkLm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLnByZXYgPSB0aGlzLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnByZXBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC51bmxpbmsoKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLnByZXYgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLm5leHQgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUud2Fsa2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXYWxrZXIodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG52YXIgQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKEJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja05vZGUobm9kZVR5cGUsIHNvdXJjZXBvcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub2RlVHlwZSwgc291cmNlcG9zKSB8fCB0aGlzO1xuICAgICAgICAvLyB0ZW1wb3JhbCBkYXRhIChmb3IgcGFyc2luZylcbiAgICAgICAgX3RoaXMub3BlbiA9IHRydWU7XG4gICAgICAgIF90aGlzLmxpbmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RMaW5lQmxhbmsgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubGFzdExpbmVDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnR5cGUgPSBub2RlVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQmxvY2tOb2RlO1xufShlc21fTm9kZSkpO1xudmFyIExpc3ROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKExpc3ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpc3ROb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGlzdERhdGEgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBMaXN0Tm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgSGVhZGluZ05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoSGVhZGluZ05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhZGluZ05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIF90aGlzLmhlYWRpbmdUeXBlID0gJ2F0eCc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhlYWRpbmdOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBDb2RlQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKENvZGVCbG9ja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29kZUJsb2NrTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzRmVuY2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmZlbmNlQ2hhciA9IG51bGw7XG4gICAgICAgIF90aGlzLmZlbmNlTGVuZ3RoID0gMDtcbiAgICAgICAgX3RoaXMuZmVuY2VPZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIF90aGlzLmluZm9QYWRkaW5nID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29kZUJsb2NrTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKFRhYmxlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhYmxlTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgVGFibGVDZWxsTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhUYWJsZUNlbGxOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbE5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGFydElkeCA9IDA7XG4gICAgICAgIF90aGlzLmVuZElkeCA9IDA7XG4gICAgICAgIF90aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgX3RoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgX3RoaXMuaWdub3JlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUYWJsZUNlbGxOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBSZWZEZWZOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKFJlZkRlZk5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmRGVmTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRpdGxlID0gJyc7XG4gICAgICAgIF90aGlzLmRlc3QgPSAnJztcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVmRGVmTm9kZTtcbn0oQmxvY2tOb2RlKSk7XG52YXIgQ3VzdG9tQmxvY2tOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKEN1c3RvbUJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDdXN0b21CbG9ja05vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW50YXhMZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy5vZmZzZXQgPSAtMTtcbiAgICAgICAgX3RoaXMuaW5mbyA9ICcnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDdXN0b21CbG9ja05vZGU7XG59KEJsb2NrTm9kZSkpO1xudmFyIEh0bWxCbG9ja05vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgZXNtX2V4dGVuZHMoSHRtbEJsb2NrTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sQmxvY2tOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaHRtbEJsb2NrVHlwZSA9IC0xO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBIdG1sQmxvY2tOb2RlO1xufShCbG9ja05vZGUpKTtcbnZhciBMaW5rTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhMaW5rTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rTm9kZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMudGl0bGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5leHRlbmRlZEF1dG9saW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIExpbmtOb2RlO1xufShlc21fTm9kZSkpO1xudmFyIENvZGVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGVzbV9leHRlbmRzKENvZGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvZGVOb2RlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudGlja0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29kZU5vZGU7XG59KGVzbV9Ob2RlKSk7XG52YXIgQ3VzdG9tSW5saW5lTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlc21fZXh0ZW5kcyhDdXN0b21JbmxpbmVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1c3RvbUlubGluZU5vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmZvID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEN1c3RvbUlubGluZU5vZGU7XG59KGVzbV9Ob2RlKSk7XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHR5cGUsIHNvdXJjZXBvcykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIGNhc2UgJ2l0ZW0nOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0Tm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5rTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlQmxvY2snOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2RlQmxvY2tOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGNhc2UgJ2h0bWxCbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEh0bWxCbG9ja05vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFibGVDZWxsTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrUXVvdGUnOlxuICAgICAgICBjYXNlICd0aGVtYXRpY0JyZWFrJzpcbiAgICAgICAgY2FzZSAndGFibGVSb3cnOlxuICAgICAgICBjYXNlICd0YWJsZUJvZHknOlxuICAgICAgICBjYXNlICd0YWJsZUhlYWQnOlxuICAgICAgICBjYXNlICdmcm9udE1hdHRlcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29kZU5vZGUodHlwZSwgc291cmNlcG9zKTtcbiAgICAgICAgY2FzZSAncmVmRGVmJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmRGVmTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21CbG9jayc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUJsb2NrTm9kZSh0eXBlLCBzb3VyY2Vwb3MpO1xuICAgICAgICBjYXNlICdjdXN0b21JbmxpbmUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21JbmxpbmVOb2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IGVzbV9Ob2RlKHR5cGUsIHNvdXJjZXBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNDb2RlQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjb2RlQmxvY2snO1xufVxuZnVuY3Rpb24gaXNIdG1sQmxvY2sobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdodG1sQmxvY2snO1xufVxuZnVuY3Rpb24gaXNIZWFkaW5nKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnaGVhZGluZyc7XG59XG5mdW5jdGlvbiBpc0xpc3Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdsaXN0Jztcbn1cbmZ1bmN0aW9uIGlzVGFibGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICd0YWJsZSc7XG59XG5mdW5jdGlvbiBpc1JlZkRlZihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ3JlZkRlZic7XG59XG5mdW5jdGlvbiBpc0N1c3RvbUJsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSAnY3VzdG9tQmxvY2snO1xufVxuZnVuY3Rpb24gaXNDdXN0b21JbmxpbmUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdjdXN0b21JbmxpbmUnO1xufVxuZnVuY3Rpb24gZXNtX3RleHQocywgc291cmNlcG9zKSB7XG4gICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlKCd0ZXh0Jywgc291cmNlcG9zKTtcbiAgICBub2RlLmxpdGVyYWwgPSBzO1xuICAgIHJldHVybiBub2RlO1xufVxudmFyIFRBR05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVOQU1FID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcbnZhciBVTlFVT1RFRFZBTFVFID0gJ1teXCJcXCc9PD5gXFxcXHgwMC1cXFxceDIwXSsnO1xudmFyIFNJTkdMRVFVT1RFRFZBTFVFID0gXCInW14nXSonXCI7XG52YXIgRE9VQkxFUVVPVEVEVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFVkFMVUUgPSBcIig/OlwiICsgVU5RVU9URURWQUxVRSArIFwifFwiICsgU0lOR0xFUVVPVEVEVkFMVUUgKyBcInxcIiArIERPVUJMRVFVT1RFRFZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFVkFMVUVTUEVDID0gXCJcIiArICcoPzpcXFxccyo9XFxcXHMqJyArIEFUVFJJQlVURVZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFID0gXCJcIiArICcoPzpcXFxccysnICsgQVRUUklCVVRFTkFNRSArIEFUVFJJQlVURVZBTFVFU1BFQyArIFwiPylcIjtcbnZhciBPUEVOVEFHID0gXCI8XCIgKyBUQUdOQU1FICsgQVRUUklCVVRFICsgXCIqXFxcXHMqLz8+XCI7XG52YXIgQ0xPU0VUQUcgPSBcIjwvXCIgKyBUQUdOQU1FICsgXCJcXFxccypbPl1cIjtcbnZhciBIVE1MQ09NTUVOVCA9ICc8IS0tLS0+fDwhLS0oPzotP1tePi1dKSg/Oi0/W14tXSkqLS0+JztcbnZhciBQUk9DRVNTSU5HSU5TVFJVQ1RJT04gPSAnWzxdWz9dLio/Wz9dWz5dJztcbnZhciBERUNMQVJBVElPTiA9ICc8IVtBLVpdK1xcXFxzK1tePl0qPic7XG52YXIgQ0RBVEEgPSAnPCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JztcbnZhciBIVE1MVEFHID0gXCIoPzpcIiArIE9QRU5UQUcgKyBcInxcIiArIENMT1NFVEFHICsgXCJ8XCIgKyBIVE1MQ09NTUVOVCArIFwifFwiICsgUFJPQ0VTU0lOR0lOU1RSVUNUSU9OICsgXCJ8XCIgKyBERUNMQVJBVElPTiArIFwifFwiICsgQ0RBVEEgKyBcIilcIjtcbnZhciByZUh0bWxUYWcgPSBuZXcgUmVnRXhwKFwiXlwiICsgSFRNTFRBRywgJ2knKTtcbi8vIGRlcml2ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcuZnJvbUNvZGVQb2ludFxuLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMi4xIGJ5IEBtYXRoaWFzICovXG52YXIgZnJvbUNvZGVQb2ludDtcbmlmIChTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xuICAgIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KF8pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweGZmZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5lbHNlIHtcbiAgICB2YXIgc3RyaW5nRnJvbUNoYXJDb2RlXzEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIHZhciBmbG9vcl8xID0gTWF0aC5mbG9vcjtcbiAgICBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNQVhfU0laRSA9IDB4NDAwMDtcbiAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdO1xuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZTtcbiAgICAgICAgdmFyIGxvd1N1cnJvZ2F0ZTtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICghaXNGaW5pdGUoY29kZVBvaW50KSB8fCAvLyBgTmFOYCwgYCtJbmZpbml0eWAsIG9yIGAtSW5maW5pdHlgXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwZmZmZiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBmbG9vcl8xKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZmZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4ZDgwMDtcbiAgICAgICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhkYzAwO1xuICAgICAgICAgICAgICAgIGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZV8xLmFwcGx5KHZvaWQgMCwgY29kZVVuaXRzKTtcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG52YXIgZnJvbUNvZGVQb2ludCQxID0gZnJvbUNvZGVQb2ludDtcbnZhciBET01BSU4gPSAnKD86W3ctXSsuKSpbQS1aYS16MC05LV0rLltBLVphLXowLTktXSsnO1xudmFyIFBBVEggPSAnW148XFxcXHNdKltePD8hLiw6Kl8/flxcXFxzXSc7XG52YXIgRU1BSUwgPSAnW1xcXFx3ListXStAKD86W1xcXFx3LV0rXFxcXC4pK1tcXFxcdy1dKyc7XG5mdW5jdGlvbiB0cmltVW5tYXRjaGVkVHJhaWxpbmdQYXJlbnMoc291cmNlKSB7XG4gICAgdmFyIHRyYWlsaW5nUGFyZW4gPSAvXFwpKyQvLmV4ZWMoc291cmNlKTtcbiAgICBpZiAodHJhaWxpbmdQYXJlbikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHNvdXJjZV8xID0gc291cmNlOyBfaSA8IHNvdXJjZV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNoID0gc291cmNlXzFbX2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAgICAgdmFyIHRyaW1Db3VudCA9IE1hdGgubWluKC1jb3VudCwgdHJhaWxpbmdQYXJlblswXS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzdHJpbmcoMCwgc291cmNlLmxlbmd0aCAtIHRyaW1Db3VudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIHRyaW1UcmFpbGluZ0VudGl0eShzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnJlcGxhY2UoLyZbQS1aYS16MC05XSs7JC8sICcnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRW1haWxMaW5rKHNvdXJjZSkge1xuICAgIHZhciByZUVtYWlsTGluayA9IG5ldyBSZWdFeHAoRU1BSUwsICdnJyk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBtO1xuICAgIHdoaWxlICgobSA9IHJlRW1haWxMaW5rLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgdmFyIHRleHRfMSA9IG1bMF07XG4gICAgICAgIGlmICghL1tfLV0rJC8udGVzdCh0ZXh0XzEpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgdGV4dDogdGV4dF8xLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbbS5pbmRleCwgbS5pbmRleCArIHRleHRfMS5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgICAgICB1cmw6IFwibWFpbHRvOlwiICsgdGV4dF8xLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVXJsTGluayhzb3VyY2UpIHtcbiAgICB2YXIgcmVXd3dBdXRvbGluayA9IG5ldyBSZWdFeHAoXCIod3d3fGh0dHBzPzovLykuXCIgKyBET01BSU4gKyBQQVRILCAnZycpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAoKG0gPSByZVd3d0F1dG9saW5rLmV4ZWMoc291cmNlKSkpIHtcbiAgICAgICAgdmFyIHRleHRfMiA9IHRyaW1UcmFpbGluZ0VudGl0eSh0cmltVW5tYXRjaGVkVHJhaWxpbmdQYXJlbnMobVswXSkpO1xuICAgICAgICB2YXIgc2NoZW1lID0gbVsxXSA9PT0gJ3d3dycgPyAnaHR0cDovLycgOiAnJztcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdGV4dDogdGV4dF8yLFxuICAgICAgICAgICAgcmFuZ2U6IFttLmluZGV4LCBtLmluZGV4ICsgdGV4dF8yLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgdXJsOiBcIlwiICsgc2NoZW1lICsgdGV4dF8yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJhc2VBdXRvbGlua1BhcnNlcihzb3VyY2UpIHtcbiAgICByZXR1cm4gZXNtX3NwcmVhZEFycmF5KGVzbV9zcHJlYWRBcnJheShbXSwgcGFyc2VVcmxMaW5rKHNvdXJjZSkpLCBwYXJzZUVtYWlsTGluayhzb3VyY2UpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLnJhbmdlWzBdIC0gYi5yYW5nZVswXTsgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RXh0QXV0b0xpbmtzKHdhbGtlciwgYXV0b2xpbmtQYXJzZXIpIHtcbiAgICBpZiAodHlwZW9mIGF1dG9saW5rUGFyc2VyID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgYXV0b2xpbmtQYXJzZXIgPSBiYXNlQXV0b2xpbmtQYXJzZXI7XG4gICAgfVxuICAgIHZhciBldmVudDtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmcsIG5vZGUgPSBldmVudC5ub2RlO1xuICAgICAgICBpZiAoZW50ZXJpbmcgJiYgbm9kZS50eXBlID09PSAndGV4dCcgJiYgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IG5vZGUubGl0ZXJhbDtcbiAgICAgICAgICAgIHZhciBsaW5rSW5mb3MgPSBhdXRvbGlua1BhcnNlcihsaXRlcmFsKTtcbiAgICAgICAgICAgIGlmICghbGlua0luZm9zIHx8ICFsaW5rSW5mb3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYXN0SWR4ID0gMDtcbiAgICAgICAgICAgIHZhciBfYSA9IG5vZGUuc291cmNlcG9zWzBdLCBsaW5lTnVtXzEgPSBfYVswXSwgY2hQb3NfMSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHNvdXJjZXBvcyA9IGZ1bmN0aW9uIChzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIHN0YXJ0SWR4XSxcbiAgICAgICAgICAgICAgICAgICAgW2xpbmVOdW1fMSwgY2hQb3NfMSArIGVuZElkeF0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlua0luZm9zXzEgPSBsaW5rSW5mb3M7IF9pIDwgbGlua0luZm9zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gbGlua0luZm9zXzFbX2ldLCByYW5nZSA9IF9iLnJhbmdlLCB1cmwgPSBfYi51cmwsIGxpbmtUZXh0ID0gX2IudGV4dDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMF0gPiBsYXN0SWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGVzLnB1c2goZXNtX3RleHQobGl0ZXJhbC5zdWJzdHJpbmcobGFzdElkeCwgcmFuZ2VbMF0pLCBzb3VyY2Vwb3MobGFzdElkeCwgcmFuZ2VbMF0gLSAxKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlua05vZGUgPSBjcmVhdGVOb2RlKCdsaW5rJywgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKTtcbiAgICAgICAgICAgICAgICBsaW5rTm9kZS5hcHBlbmRDaGlsZChlc21fdGV4dChsaW5rVGV4dCwgc291cmNlcG9zLmFwcGx5KHZvaWQgMCwgcmFuZ2UpKSk7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuZGVzdGluYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgbGlua05vZGUuZXh0ZW5kZWRBdXRvbGluayA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaChsaW5rTm9kZSk7XG4gICAgICAgICAgICAgICAgbGFzdElkeCA9IHJhbmdlWzFdICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0SWR4IDwgbGl0ZXJhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKGVzbV90ZXh0KGxpdGVyYWwuc3Vic3RyaW5nKGxhc3RJZHgpLCBzb3VyY2Vwb3MobGFzdElkeCwgbGl0ZXJhbC5sZW5ndGggLSAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSAwLCBuZXdOb2Rlc18xID0gbmV3Tm9kZXM7IF9jIDwgbmV3Tm9kZXNfMS5sZW5ndGg7IF9jKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ld05vZGVzXzFbX2NdO1xuICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIF9sb29wXzEoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsYXN0KGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuLy8gbm9ybWFsaXplIGEgcmVmZXJlbmNlIGluIHJlZmVyZW5jZSBsaW5rIChyZW1vdmUgW11zLCB0cmltLFxuLy8gY29sbGFwc2UgaW50ZXJuYWwgc3BhY2UsIHVuaWNvZGUgY2FzZSBmb2xkLlxuLy8gU2VlIGNvbW1vbm1hcmsvY29tbW9ubWFyay5qcyMxNjguXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAuc2xpY2UoMSwgc3RyLmxlbmd0aCAtIDEpXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1sgXFx0XFxyXFxuXSsvLCAnICcpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuZnVuY3Rpb24gaXRlcmF0ZU9iamVjdChvYmosIGl0ZXJhdGVlKSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaXRlcmF0ZWUoa2V5LCBvYmpba2V5XSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBvbWl0KG9iaikge1xuICAgIHZhciBwcm9wTmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwcm9wTmFtZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRNYXAgPSBlc21fYXNzaWduKHt9LCBvYmopO1xuICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdE1hcFtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG59XG5mdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgIHJldHVybiAhT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGVhck9iaihvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgfSk7XG59XG52YXIgQ19ORVdMSU5FID0gMTA7XG52YXIgQ19BU1RFUklTSyA9IDQyO1xudmFyIENfVU5ERVJTQ09SRSA9IDk1O1xudmFyIENfQkFDS1RJQ0sgPSA5NjtcbnZhciBDX09QRU5fQlJBQ0tFVCQxID0gOTE7XG52YXIgQ19DTE9TRV9CUkFDS0VUID0gOTM7XG52YXIgQ19USUxERSA9IDEyNjtcbnZhciBDX0xFU1NUSEFOJDEgPSA2MDtcbnZhciBDX0JBTkcgPSAzMztcbnZhciBDX0JBQ0tTTEFTSCA9IDkyO1xudmFyIENfQU1QRVJTQU5EID0gMzg7XG52YXIgQ19PUEVOX1BBUkVOID0gNDA7XG52YXIgQ19DTE9TRV9QQVJFTiA9IDQxO1xudmFyIENfQ09MT04gPSA1ODtcbnZhciBDX1NJTkdMRVFVT1RFID0gMzk7XG52YXIgQ19ET1VCTEVRVU9URSA9IDM0O1xudmFyIENfRE9MTEFSID0gMzY7XG4vLyBTb21lIHJlZ2V4cHMgdXNlZCBpbiBpbmxpbmUgcGFyc2VyOlxudmFyIEVTQ0FQRURfQ0hBUiA9IFwiXFxcXFxcXFxcIiArIEVTQ0FQQUJMRTtcbnZhciByZVB1bmN0dWF0aW9uID0gbmV3IFJlZ0V4cCgvWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9flxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNDJcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDRbXFx1REM0Ny1cXHVEQzREXFx1RENCQlxcdURDQkNcXHVEQ0JFLVxcdURDQzFcXHVERDQwLVxcdURENDNcXHVERDc0XFx1REQ3NVxcdUREQzUtXFx1RERDOVxcdUREQ0RcXHVERERCXFx1RERERC1cXHVERERGXFx1REUzOC1cXHVERTNEXFx1REVBOV18XFx1RDgwNVtcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REYzQy1cXHVERjNFXXxcXHVEODA5W1xcdURDNzAtXFx1REM3NF18XFx1RDgxQVtcXHVERTZFXFx1REU2RlxcdURFRjVcXHVERjM3LVxcdURGM0JcXHVERjQ0XXxcXHVEODJGXFx1REM5RnxcXHVEODM2W1xcdURFODctXFx1REU4Ql0vKTtcbnZhciByZUxpbmtUaXRsZSA9IG5ldyBSZWdFeHAoXCJeKD86XFxcIihcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteXFxcIlxcXFx4MDBdKSpcXFwiXCIgK1xuICAgIFwifFwiICtcbiAgICAoXCInKFwiICsgRVNDQVBFRF9DSEFSICsgXCJ8W14nXFxcXHgwMF0pKidcIikgK1xuICAgIFwifFwiICtcbiAgICAoXCJcXFxcKChcIiArIEVTQ0FQRURfQ0hBUiArIFwifFteKClcXFxceDAwXSkqXFxcXCkpXCIpKTtcbnZhciByZUxpbmtEZXN0aW5hdGlvbkJyYWNlcyA9IC9eKD86PCg/OltePD5cXG5cXFxcXFx4MDBdfFxcXFwuKSo+KS87XG52YXIgcmVFc2NhcGFibGUgPSBuZXcgUmVnRXhwKFwiXlwiICsgRVNDQVBBQkxFKTtcbnZhciByZUVudGl0eUhlcmUgPSBuZXcgUmVnRXhwKFwiXlwiICsgRU5USVRZLCAnaScpO1xudmFyIHJlVGlja3MgPSAvYCsvO1xudmFyIHJlVGlja3NIZXJlID0gL15gKy87XG52YXIgcmVFbGxpcHNlcyA9IC9cXC5cXC5cXC4vZztcbnZhciByZURhc2ggPSAvLS0rL2c7XG52YXIgcmVFbWFpbEF1dG9saW5rID0gL148KFthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSopPi87XG52YXIgcmVBdXRvbGluayA9IC9ePFtBLVphLXpdW0EtWmEtejAtOS4rLV17MSwzMX06W148PlxceDAwLVxceDIwXSo+L2k7XG52YXIgcmVTcG5sID0gL14gKig/OlxcbiAqKT8vO1xudmFyIHJlV2hpdGVzcGFjZUNoYXIgPSAvXlsgXFx0XFxuXFx4MGJcXHgwY1xceDBkXS87XG52YXIgcmVVbmljb2RlV2hpdGVzcGFjZUNoYXIgPSAvXlxccy87XG52YXIgcmVGaW5hbFNwYWNlID0gLyAqJC87XG52YXIgcmVJbml0aWFsU3BhY2UgPSAvXiAqLztcbnZhciByZVNwYWNlQXRFbmRPZkxpbmUgPSAvXiAqKD86XFxufCQpLztcbnZhciByZUxpbmtMYWJlbCA9IC9eXFxbKD86W15cXFxcXFxbXFxdXXxcXFxcLil7MCwxMDAwfVxcXS87XG4vLyBNYXRjaGVzIGEgc3RyaW5nIG9mIG5vbi1zcGVjaWFsIGNoYXJhY3RlcnMuXG52YXIgcmVNYWluID0gL15bXlxcbmBcXFtcXF1cXFxcITwmKl8nXCJ+JF0rL207XG52YXIgSW5saW5lUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElubGluZVBhcnNlcihvcHRpb25zKSB7XG4gICAgICAgIC8vIEFuIElubGluZVBhcnNlciBrZWVwcyB0cmFjayBvZiBhIHN1YmplY3QgKGEgc3RyaW5nIHRvIGJlIHBhcnNlZClcbiAgICAgICAgLy8gYW5kIGEgcG9zaXRpb24gaW4gdGhhdCBzdWJqZWN0LlxuICAgICAgICB0aGlzLnN1YmplY3QgPSAnJztcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gbnVsbDsgLy8gdXNlZCBieSBoYW5kbGVEZWxpbSBtZXRob2RcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5saW5lU3RhcnROdW0gPSAwO1xuICAgICAgICB0aGlzLmxpbmVJZHggPSAwO1xuICAgICAgICB0aGlzLmxpbmVPZmZzZXRzID0gWzBdO1xuICAgICAgICB0aGlzLmxpbmVQb3NPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zb3VyY2Vwb3MgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgbGluZVBvc09mZnNldCA9IHRoaXMubGluZVBvc09mZnNldCArIHRoaXMubGluZU9mZnNldHNbdGhpcy5saW5lSWR4XTtcbiAgICAgICAgdmFyIGxpbmVOdW0gPSB0aGlzLmxpbmVTdGFydE51bSArIHRoaXMubGluZUlkeDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gW2xpbmVOdW0sIHN0YXJ0ICsgbGluZVBvc09mZnNldF07XG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydHBvcywgW2xpbmVOdW0sIGVuZCArIGxpbmVQb3NPZmZzZXRdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnRwb3M7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLm5leHRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpbmVJZHggKz0gMTtcbiAgICAgICAgdGhpcy5saW5lUG9zT2Zmc2V0ID0gLXRoaXMucG9zO1xuICAgIH07XG4gICAgLy8gSWYgcmUgbWF0Y2hlcyBhdCBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzdWJqZWN0LCBhZHZhbmNlXG4gICAgLy8gcG9zaXRpb24gaW4gc3ViamVjdCBhbmQgcmV0dXJuIHRoZSBtYXRjaDsgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAocmUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHRoaXMuc3ViamVjdC5zbGljZSh0aGlzLnBvcykpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbVswXTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIGNvZGUgZm9yIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIGN1cnJlbnQgc3ViamVjdCBwb3NpdGlvbiwgb3IgLTFcbiAgICAvLyB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdWJqZWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvLyBQYXJzZSB6ZXJvIG9yIG1vcmUgc3BhY2UgY2hhcmFjdGVycywgaW5jbHVkaW5nIGF0IG1vc3Qgb25lIG5ld2xpbmVcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnNwbmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWF0Y2gocmVTcG5sKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBbGwgb2YgdGhlIHBhcnNlcnMgYmVsb3cgdHJ5IHRvIG1hdGNoIHNvbWV0aGluZyBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgIC8vIGluIHRoZSBzdWJqZWN0LiAgSWYgdGhleSBzdWNjZWVkIGluIG1hdGNoaW5nIGFueXRoaW5nLCB0aGV5XG4gICAgLy8gcmV0dXJuIHRoZSBpbmxpbmUgbWF0Y2hlZCwgYWR2YW5jaW5nIHRoZSBzdWJqZWN0LlxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYmFja3RpY2tzLCBhZGRpbmcgZWl0aGVyIGEgYmFja3RpY2sgY29kZSBzcGFuIG9yIGFcbiAgICAvLyBsaXRlcmFsIHNlcXVlbmNlIG9mIGJhY2t0aWNrcy5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFja3RpY2tzID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGhpcy5tYXRjaChyZVRpY2tzSGVyZSk7XG4gICAgICAgIGlmICh0aWNrcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZnRlck9wZW5UaWNrcyA9IHRoaXMucG9zO1xuICAgICAgICB2YXIgbWF0Y2hlZDtcbiAgICAgICAgd2hpbGUgKChtYXRjaGVkID0gdGhpcy5tYXRjaChyZVRpY2tzKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID09PSB0aWNrcykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IHRoaXMuc3ViamVjdC5zbGljZShhZnRlck9wZW5UaWNrcywgdGhpcy5wb3MgLSB0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2Vwb3MgPSB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNvbnRlbnRzLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsYXN0KGxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lSWR4ICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IC0odGhpcy5wb3MgLSBsYXN0TGluZS5sZW5ndGggLSB0aWNrcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2Vwb3NbMV0gPSB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gbGluZXMuam9pbignICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoJ2NvZGUnLCBzb3VyY2Vwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLm1hdGNoKC9bXiBdLykgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHNbMF0gPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzW2NvbnRlbnRzLmxlbmd0aCAtIDFdID09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmxpdGVyYWwgPSBjb250ZW50cy5zbGljZSgxLCBjb250ZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IGNvbnRlbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnRpY2tDb3VudCA9IHRpY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgd2UgZGlkbid0IG1hdGNoIGEgY2xvc2luZyBiYWNrdGljayBzZXF1ZW5jZS5cbiAgICAgICAgdGhpcy5wb3MgPSBhZnRlck9wZW5UaWNrcztcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQodGlja3MsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gUGFyc2UgYSBiYWNrc2xhc2gtZXNjYXBlZCBzcGVjaWFsIGNoYXJhY3RlciwgYWRkaW5nIGVpdGhlciB0aGUgZXNjYXBlZFxuICAgIC8vIGNoYXJhY3RlciwgYSBoYXJkIGxpbmUgYnJlYWsgKGlmIHRoZSBiYWNrc2xhc2ggaXMgZm9sbG93ZWQgYnkgYSBuZXdsaW5lKSxcbiAgICAvLyBvciBhIGxpdGVyYWwgYmFja3NsYXNoIHRvIHRoZSBibG9jaydzIGNoaWxkcmVuLiAgQXNzdW1lcyBjdXJyZW50IGNoYXJhY3RlclxuICAgIC8vIGlzIGEgYmFja3NsYXNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VCYWNrc2xhc2ggPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN1YmogPSB0aGlzLnN1YmplY3Q7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSgnbGluZWJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MgLSAxLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVFc2NhcGFibGUudGVzdChzdWJqLmNoYXJBdCh0aGlzLnBvcykpKSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dChzdWJqLmNoYXJBdCh0aGlzLnBvcyksIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXFxcXCcsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gYXV0b2xpbmsgKFVSTCBvciBlbWFpbCBpbiBwb2ludHkgYnJhY2tldHMpLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VBdXRvbGluayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgdmFyIGRlc3Q7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIGlmICgobSA9IHRoaXMubWF0Y2gocmVFbWFpbEF1dG9saW5rKSkpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSgnbGluaycsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSShcIm1haWx0bzpcIiArIGRlc3QpO1xuICAgICAgICAgICAgbm9kZS50aXRsZSA9ICcnO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChlc21fdGV4dChkZXN0LCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcyArIDEsIHRoaXMucG9zIC0gMSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUF1dG9saW5rKSkpIHtcbiAgICAgICAgICAgIGRlc3QgPSBtLnNsaWNlKDEsIG0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBub2RlID0gY3JlYXRlTm9kZSgnbGluaycsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IG5vcm1hbGl6ZVVSSShkZXN0KTtcbiAgICAgICAgICAgIG5vZGUudGl0bGUgPSAnJztcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZXNtX3RleHQoZGVzdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MgKyAxLCB0aGlzLnBvcyAtIDEpKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYSByYXcgSFRNTCB0YWcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUh0bWxUYWcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVIdG1sVGFnKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoJ2h0bWxJbmxpbmUnLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgbm9kZS5saXRlcmFsID0gbTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gU2NhbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgd2l0aCBjb2RlIGNjLCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0XG4gICAgLy8gdGhlIG51bWJlciBvZiBkZWxpbWl0ZXJzIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHBvc2l0aW9uZWQgc3VjaCB0aGF0XG4gICAgLy8gdGhleSBjYW4gb3BlbiBhbmQvb3IgY2xvc2UgZW1waGFzaXMgb3Igc3Ryb25nIGVtcGhhc2lzLiAgQSB1dGlsaXR5XG4gICAgLy8gZnVuY3Rpb24gZm9yIHN0cm9uZy9lbXBoIHBhcnNpbmcuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5zY2FuRGVsaW1zID0gZnVuY3Rpb24gKGNjKSB7XG4gICAgICAgIHZhciBudW1kZWxpbXMgPSAwO1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgaWYgKGNjID09PSBDX1NJTkdMRVFVT1RFIHx8IGNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICBudW1kZWxpbXMrKztcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09IGNjKSB7XG4gICAgICAgICAgICAgICAgbnVtZGVsaW1zKys7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtZGVsaW1zID09PSAwIHx8IChudW1kZWxpbXMgPCAyICYmIChjYyA9PT0gQ19USUxERSB8fCBjYyA9PT0gQ19ET0xMQVIpKSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyQmVmb3JlID0gc3RhcnRwb3MgPT09IDAgPyAnXFxuJyA6IHRoaXMuc3ViamVjdC5jaGFyQXQoc3RhcnRwb3MgLSAxKTtcbiAgICAgICAgdmFyIGNjQWZ0ZXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgdmFyIGNoYXJBZnRlcjtcbiAgICAgICAgaWYgKGNjQWZ0ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICBjaGFyQWZ0ZXIgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYXJBZnRlciA9IGZyb21Db2RlUG9pbnQkMShjY0FmdGVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWZ0ZXJJc1doaXRlc3BhY2UgPSByZVVuaWNvZGVXaGl0ZXNwYWNlQ2hhci50ZXN0KGNoYXJBZnRlcik7XG4gICAgICAgIHZhciBhZnRlcklzUHVuY3R1YXRpb24gPSByZVB1bmN0dWF0aW9uLnRlc3QoY2hhckFmdGVyKTtcbiAgICAgICAgdmFyIGJlZm9yZUlzV2hpdGVzcGFjZSA9IHJlVW5pY29kZVdoaXRlc3BhY2VDaGFyLnRlc3QoY2hhckJlZm9yZSk7XG4gICAgICAgIHZhciBiZWZvcmVJc1B1bmN0dWF0aW9uID0gcmVQdW5jdHVhdGlvbi50ZXN0KGNoYXJCZWZvcmUpO1xuICAgICAgICB2YXIgbGVmdEZsYW5raW5nID0gIWFmdGVySXNXaGl0ZXNwYWNlICYmICghYWZ0ZXJJc1B1bmN0dWF0aW9uIHx8IGJlZm9yZUlzV2hpdGVzcGFjZSB8fCBiZWZvcmVJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgdmFyIHJpZ2h0RmxhbmtpbmcgPSAhYmVmb3JlSXNXaGl0ZXNwYWNlICYmICghYmVmb3JlSXNQdW5jdHVhdGlvbiB8fCBhZnRlcklzV2hpdGVzcGFjZSB8fCBhZnRlcklzUHVuY3R1YXRpb24pO1xuICAgICAgICB2YXIgY2FuT3BlbjtcbiAgICAgICAgdmFyIGNhbkNsb3NlO1xuICAgICAgICBpZiAoY2MgPT09IENfVU5ERVJTQ09SRSkge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAoIXJpZ2h0RmxhbmtpbmcgfHwgYmVmb3JlSXNQdW5jdHVhdGlvbik7XG4gICAgICAgICAgICBjYW5DbG9zZSA9IHJpZ2h0RmxhbmtpbmcgJiYgKCFsZWZ0RmxhbmtpbmcgfHwgYWZ0ZXJJc1B1bmN0dWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSB8fCBjYyA9PT0gQ19ET1VCTEVRVU9URSkge1xuICAgICAgICAgICAgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAhcmlnaHRGbGFua2luZztcbiAgICAgICAgICAgIGNhbkNsb3NlID0gcmlnaHRGbGFua2luZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgIGNhbk9wZW4gPSAhYWZ0ZXJJc1doaXRlc3BhY2U7XG4gICAgICAgICAgICBjYW5DbG9zZSA9ICFiZWZvcmVJc1doaXRlc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5PcGVuID0gbGVmdEZsYW5raW5nO1xuICAgICAgICAgICAgY2FuQ2xvc2UgPSByaWdodEZsYW5raW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgIHJldHVybiB7IG51bWRlbGltczogbnVtZGVsaW1zLCBjYW5PcGVuOiBjYW5PcGVuLCBjYW5DbG9zZTogY2FuQ2xvc2UgfTtcbiAgICB9O1xuICAgIC8vIEhhbmRsZSBhIGRlbGltaXRlciBtYXJrZXIgZm9yIGVtcGhhc2lzIG9yIGEgcXVvdGUuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5oYW5kbGVEZWxpbSA9IGZ1bmN0aW9uIChjYywgYmxvY2spIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuc2NhbkRlbGltcyhjYyk7XG4gICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG51bWRlbGltcyA9IHJlcy5udW1kZWxpbXM7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgdmFyIGNvbnRlbnRzO1xuICAgICAgICB0aGlzLnBvcyArPSBudW1kZWxpbXM7XG4gICAgICAgIGlmIChjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICAgICAgY29udGVudHMgPSAnXFx1MjAxOSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2MgPT09IENfRE9VQkxFUVVPVEUpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gJ1xcdTIwMUMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGVudHMgPSB0aGlzLnN1YmplY3Quc2xpY2Uoc3RhcnRwb3MgLSAxLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dChjb250ZW50cywgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSk7XG4gICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAvLyBBZGQgZW50cnkgdG8gc3RhY2sgZm9yIHRoaXMgb3BlbmVyXG4gICAgICAgIGlmICgocmVzLmNhbk9wZW4gfHwgcmVzLmNhbkNsb3NlKSAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5zbWFydCB8fCAoY2MgIT09IENfU0lOR0xFUVVPVEUgJiYgY2MgIT09IENfRE9VQkxFUVVPVEUpKSkge1xuICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICBudW1kZWxpbXM6IG51bWRlbGltcyxcbiAgICAgICAgICAgICAgICBvcmlnZGVsaW1zOiBudW1kZWxpbXMsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY2FuT3BlbjogcmVzLmNhbk9wZW4sXG4gICAgICAgICAgICAgICAgY2FuQ2xvc2U6IHJlcy5jYW5DbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxpbWl0ZXJzLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxpbWl0ZXJzLnByZXZpb3VzLm5leHQgPSB0aGlzLmRlbGltaXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZURlbGltaXRlciA9IGZ1bmN0aW9uIChkZWxpbSkge1xuICAgICAgICBpZiAoZGVsaW0ucHJldmlvdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGltLnByZXZpb3VzLm5leHQgPSBkZWxpbS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxpbS5uZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB0b3Agb2Ygc3RhY2tcbiAgICAgICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IGRlbGltLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsaW0ubmV4dC5wcmV2aW91cyA9IGRlbGltLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnJlbW92ZURlbGltaXRlcnNCZXR3ZWVuID0gZnVuY3Rpb24gKGJvdHRvbSwgdG9wKSB7XG4gICAgICAgIGlmIChib3R0b20ubmV4dCAhPT0gdG9wKSB7XG4gICAgICAgICAgICBib3R0b20ubmV4dCA9IHRvcDtcbiAgICAgICAgICAgIHRvcC5wcmV2aW91cyA9IGJvdHRvbTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhbGwgZGVsaW1pdGVycyAtIGVtcGhhc2lzLCBzdHJvbmcgZW1waGFzaXMsIHN0cmlrZXRocm91Z2goZ2ZtKVxuICAgICAqIElmIHRoZSBzbWFydCBwdW5jdHVhdGlvbiBvcHRpb25zIGlzIHRydWUsXG4gICAgICogY29udmVydCBzaW5nbGUvZG91YmxlIHF1b3RlcyB0byBjb3JyZXNwb25kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAgKiovXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzRW1waGFzaXMgPSBmdW5jdGlvbiAoc3RhY2tCb3R0b20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgb3BlbmVyO1xuICAgICAgICB2YXIgY2xvc2VyO1xuICAgICAgICB2YXIgb2xkQ2xvc2VyO1xuICAgICAgICB2YXIgb3BlbmVySW5sLCBjbG9zZXJJbmw7XG4gICAgICAgIHZhciBvcGVuZXJGb3VuZDtcbiAgICAgICAgdmFyIG9kZE1hdGNoID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuZXJzQm90dG9tID0gKF9hID0ge30sXG4gICAgICAgICAgICBfYVtDX1VOREVSU0NPUkVdID0gW3N0YWNrQm90dG9tLCBzdGFja0JvdHRvbSwgc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2FbQ19BU1RFUklTS10gPSBbc3RhY2tCb3R0b20sIHN0YWNrQm90dG9tLCBzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX1NJTkdMRVFVT1RFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0RPVUJMRVFVT1RFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX1RJTERFXSA9IFtzdGFja0JvdHRvbV0sXG4gICAgICAgICAgICBfYVtDX0RPTExBUl0gPSBbc3RhY2tCb3R0b21dLFxuICAgICAgICAgICAgX2EpO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IGNsb3NlciBhYm92ZSBzdGFja0JvdHRvbTpcbiAgICAgICAgY2xvc2VyID0gdGhpcy5kZWxpbWl0ZXJzO1xuICAgICAgICB3aGlsZSAoY2xvc2VyICE9PSBudWxsICYmIGNsb3Nlci5wcmV2aW91cyAhPT0gc3RhY2tCb3R0b20pIHtcbiAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIGZvcndhcmQsIGxvb2tpbmcgZm9yIGNsb3NlcnMsIGFuZCBoYW5kbGluZyBlYWNoXG4gICAgICAgIHdoaWxlIChjbG9zZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZXJjYyA9IGNsb3Nlci5jYztcbiAgICAgICAgICAgIHZhciBjbG9zZXJFbXBoID0gY2xvc2VyY2MgPT09IENfVU5ERVJTQ09SRSB8fCBjbG9zZXJjYyA9PT0gQ19BU1RFUklTSztcbiAgICAgICAgICAgIGlmICghY2xvc2VyLmNhbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBlbXBoYXNpcyBjbG9zZXIuIG5vdyBsb29rIGJhY2sgZm9yIGZpcnN0IG1hdGNoaW5nIG9wZW5lcjpcbiAgICAgICAgICAgICAgICBvcGVuZXIgPSBjbG9zZXIucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgb3BlbmVyRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlbmVyICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZW5lciAhPT0gc3RhY2tCb3R0b20gJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyICE9PSBvcGVuZXJzQm90dG9tW2Nsb3NlcmNjXVtjbG9zZXJFbXBoID8gY2xvc2VyLm9yaWdkZWxpbXMgJSAzIDogMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2RkTWF0Y2ggPVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyRW1waCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbG9zZXIuY2FuT3BlbiB8fCBvcGVuZXIuY2FuQ2xvc2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VyLm9yaWdkZWxpbXMgJSAzICE9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wZW5lci5vcmlnZGVsaW1zICsgY2xvc2VyLm9yaWdkZWxpbXMpICUgMyA9PT0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5jYyA9PT0gY2xvc2VyLmNjICYmIG9wZW5lci5jYW5PcGVuICYmICFvZGRNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvbGRDbG9zZXIgPSBjbG9zZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlckVtcGggfHwgY2xvc2VyY2MgPT09IENfVElMREUgfHwgY2xvc2VyY2MgPT09IENfRE9MTEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IGNsb3Nlci5uZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKG51bGwgb3BlbmVyIGNoZWNrIGZvciB0eXBlIG5hcnJvd2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBhY3R1YWwgbnVtYmVyIG9mIGRlbGltaXRlcnMgdXNlZCBmcm9tIGNsb3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZURlbGltcyA9IGNsb3Nlci5udW1kZWxpbXMgPj0gMiAmJiBvcGVuZXIubnVtZGVsaW1zID49IDIgPyAyIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbXB0eURlbGltcyA9IGNsb3NlckVtcGggPyAwIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubCA9IG9wZW5lci5ub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sID0gY2xvc2VyLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjb250ZW50cyBmb3IgbmV3IGVtcGggZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gY2xvc2VyRW1waFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXNlRGVsaW1zID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2VtcGgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ3N0cm9uZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdzdHJpa2UnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlcmNjID09PSBDX0RPTExBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUeXBlID0gJ2N1c3RvbUlubGluZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5lckVuZFBvcyA9IG9wZW5lcklubC5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VyU3RhcnRQb3MgPSBjbG9zZXJJbmwuc291cmNlcG9zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zb3VyY2Vwb3MgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wZW5lckVuZFBvc1swXSwgb3BlbmVyRW5kUG9zWzFdIC0gdXNlRGVsaW1zICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Nsb3NlclN0YXJ0UG9zWzBdLCBjbG9zZXJTdGFydFBvc1sxXSArIHVzZURlbGltcyAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lcklubC5zb3VyY2Vwb3NbMV1bMV0gLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VySW5sLnNvdXJjZXBvc1swXVsxXSArPSB1c2VEZWxpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJJbmwubGl0ZXJhbCA9IG9wZW5lcklubC5saXRlcmFsLnNsaWNlKHVzZURlbGltcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwubGl0ZXJhbCA9IGNsb3NlcklubC5saXRlcmFsLnNsaWNlKHVzZURlbGltcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuZXIubnVtZGVsaW1zIC09IHVzZURlbGltcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlci5udW1kZWxpbXMgLT0gdXNlRGVsaW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHVzZWQgZGVsaW1pdGVycyBmcm9tIHN0YWNrIGVsdHMgYW5kIGlubGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBvcGVuZXJJbmwubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRtcCAmJiB0bXAgIT09IGNsb3NlcklubCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0bXAubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWlsZCBjdXN0b20gaW5saW5lIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXJjYyA9PT0gQ19ET0xMQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBuZXdOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSB0ZXh0Tm9kZS5saXRlcmFsIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvID0gbGl0ZXJhbC5zcGxpdCgvXFxzLylbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5pbmZvID0gaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbC5sZW5ndGggPD0gaW5mby5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5zb3VyY2Vwb3NbMF1bMV0gKz0gaW5mby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlLmxpdGVyYWwgPSBsaXRlcmFsLnJlcGxhY2UoaW5mbyArIFwiIFwiLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLmluc2VydEFmdGVyKG5ld05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVsdHMgYmV0d2VlbiBvcGVuZXIgYW5kIGNsb3NlciBpbiBkZWxpbWl0ZXJzIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcnNCZXR3ZWVuKG9wZW5lciwgY2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG9wZW5lciBoYXMgMCBkZWxpbXMsIHJlbW92ZSBpdCBhbmQgdGhlIGlubGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb3BlbmVyIGhhcyAxIGRlbGltcyBhbmQgY2hhcmFjdGVyIGlzIHRpbGRlLCByZW1vdmUgZGVsaW1pdGVyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIubnVtZGVsaW1zIDw9IGVtcHR5RGVsaW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lci5udW1kZWxpbXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVySW5sLnVubGluaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihvcGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2xvc2VyIGhhcyAwIGRlbGltcywgcmVtb3ZlIGl0IGFuZCB0aGUgaW5saW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjbG9zZXIgaGFzIDEgZGVsaW1zIGFuZCBjaGFyYWN0ZXIgaXMgdGlsZGUsIHJlbW92ZSBkZWxpbWl0ZXIgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlci5udW1kZWxpbXMgPD0gZW1wdHlEZWxpbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VyLm51bWRlbGltcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXJJbmwudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wc3RhY2sgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcihjbG9zZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlciA9IHRlbXBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbG9zZXJjYyA9PT0gQ19TSU5HTEVRVU9URSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXIubm9kZS5saXRlcmFsID0gJ1xcdTIwMTknO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbmVyRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5lci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxOCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyID0gY2xvc2VyLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlcmNjID09PSBDX0RPVUJMRVFVT1RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlci5ub2RlLmxpdGVyYWwgPSAnXFx1MjAxRCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLm5vZGUubGl0ZXJhbCA9ICdcXHUyMDFDJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9zZXIgPSBjbG9zZXIubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuZXJGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgZm9yIGZ1dHVyZSBzZWFyY2hlcyBmb3Igb3BlbmVyczpcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXJjY11bY2xvc2VyRW1waCA/IG9sZENsb3Nlci5vcmlnZGVsaW1zICUgMyA6IDBdID0gb2xkQ2xvc2VyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENsb3Nlci5jYW5PcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcmVtb3ZlIGEgY2xvc2VyIHRoYXQgY2FuJ3QgYmUgYW4gb3BlbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25jZSB3ZSd2ZSBzZWVuIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgb3BlbmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVEZWxpbWl0ZXIob2xkQ2xvc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYWxsIGRlbGltaXRlcnNcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVsaW1pdGVycyAhPT0gbnVsbCAmJiB0aGlzLmRlbGltaXRlcnMgIT09IHN0YWNrQm90dG9tKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZURlbGltaXRlcih0aGlzLmRlbGltaXRlcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGxpbmsgdGl0bGUgKHNhbnMgcXVvdGVzKSwgcmV0dXJuaW5nIHRoZSBzdHJpbmdcbiAgICAvLyBvciBudWxsIGlmIG5vIG1hdGNoLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VMaW5rVGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMubWF0Y2gocmVMaW5rVGl0bGUpO1xuICAgICAgICBpZiAodGl0bGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNob3Agb2ZmIHF1b3RlcyBmcm9tIHRpdGxlIGFuZCB1bmVzY2FwZTpcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlU3RyaW5nKHRpdGxlLnN1YnN0cigxLCB0aXRsZS5sZW5ndGggLSAyKSk7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGxpbmsgZGVzdGluYXRpb24sIHJldHVybmluZyB0aGUgc3RyaW5nIG9yIG51bGwgaWYgbm8gbWF0Y2guXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMubWF0Y2gocmVMaW5rRGVzdGluYXRpb25CcmFjZXMpO1xuICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfTEVTU1RIQU4kMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQFRPRE8gaGFuZHJvbGxlZCBwYXJzZXI7IHJlcyBzaG91bGQgYmUgbnVsbCBvciB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgc2F2ZXBvcyA9IHRoaXMucG9zO1xuICAgICAgICAgICAgdmFyIG9wZW5wYXJlbnMgPSAwO1xuICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoKGMgPSB0aGlzLnBlZWsoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IENfQkFDS1NMQVNIICYmIHJlRXNjYXBhYmxlLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZWVrKCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IENfT1BFTl9QQVJFTikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBvcGVucGFyZW5zICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5wYXJlbnMgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVucGFyZW5zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVXaGl0ZXNwYWNlQ2hhci5leGVjKGZyb21Db2RlUG9pbnQkMShjKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gc2F2ZXBvcyAmJiBjICE9PSBDX0NMT1NFX1BBUkVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BlbnBhcmVucyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gdGhpcy5zdWJqZWN0LnN1YnN0cihzYXZlcG9zLCB0aGlzLnBvcyAtIHNhdmVwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVSSSh1bmVzY2FwZVN0cmluZyhyZXMpKTtcbiAgICAgICAgfSAvLyBjaG9wIG9mZiBzdXJyb3VuZGluZyA8Li4+OlxuICAgICAgICByZXR1cm4gbm9ybWFsaXplVVJJKHVuZXNjYXBlU3RyaW5nKHJlcy5zdWJzdHIoMSwgcmVzLmxlbmd0aCAtIDIpKSk7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgbGluayBsYWJlbCwgcmV0dXJuaW5nIG51bWJlciBvZiBjaGFyYWN0ZXJzIHBhcnNlZC5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlTGlua0xhYmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubWF0Y2gocmVMaW5rTGFiZWwpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCB8fCBtLmxlbmd0aCA+IDEwMDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLmxlbmd0aDtcbiAgICB9O1xuICAgIC8vIEFkZCBvcGVuIGJyYWNrZXQgdG8gZGVsaW1pdGVyIHN0YWNrIGFuZCBhZGQgYSB0ZXh0IG5vZGUgdG8gYmxvY2sncyBjaGlsZHJlbi5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlT3BlbkJyYWNrZXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBub2RlID0gZXNtX3RleHQoJ1snLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgdGhpcy5hZGRCcmFja2V0KG5vZGUsIHN0YXJ0cG9zLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gSUYgbmV4dCBjaGFyYWN0ZXIgaXMgWywgYW5kICEgZGVsaW1pdGVyIHRvIGRlbGltaXRlciBzdGFjayBhbmRcbiAgICAvLyBhZGQgYSB0ZXh0IG5vZGUgdG8gYmxvY2sncyBjaGlsZHJlbi4gIE90aGVyd2lzZSBqdXN0IGFkZCBhIHRleHQgbm9kZS5cbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLnBhcnNlQmFuZyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgc3RhcnRwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5wb3MgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpID09PSBDX09QRU5fQlJBQ0tFVCQxKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dCgnIVsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIDEsIHRoaXMucG9zKSk7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIC8vIEFkZCBlbnRyeSB0byBzdGFjayBmb3IgdGhpcyBvcGVuZXJcbiAgICAgICAgICAgIHRoaXMuYWRkQnJhY2tldChub2RlLCBzdGFydHBvcyArIDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dCgnIScsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcykpO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBUcnkgdG8gbWF0Y2ggY2xvc2UgYnJhY2tldCBhZ2FpbnN0IGFuIG9wZW5pbmcgaW4gdGhlIGRlbGltaXRlclxuICAgIC8vIHN0YWNrLiAgQWRkIGVpdGhlciBhIGxpbmsgb3IgaW1hZ2UsIG9yIGEgcGxhaW4gWyBjaGFyYWN0ZXIsXG4gICAgLy8gdG8gYmxvY2sncyBjaGlsZHJlbi4gIElmIHRoZXJlIGlzIGEgbWF0Y2hpbmcgZGVsaW1pdGVyLFxuICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBkZWxpbWl0ZXIgc3RhY2suXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsb3NlQnJhY2tldCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgZGVzdCA9IG51bGw7XG4gICAgICAgIHZhciB0aXRsZSA9IG51bGw7XG4gICAgICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zO1xuICAgICAgICAvLyBnZXQgbGFzdCBbIG9yICFbXG4gICAgICAgIHZhciBvcGVuZXIgPSB0aGlzLmJyYWNrZXRzO1xuICAgICAgICBpZiAob3BlbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaGVkIG9wZW5lciwganVzdCByZXR1cm4gYSBsaXRlcmFsXG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BlbmVyLmFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gbm8gbWF0Y2hlZCBvcGVuZXIsIGp1c3QgcmV0dXJuIGEgbGl0ZXJhbFxuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQoJ10nLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgc3RhcnRwb3MpKSk7XG4gICAgICAgICAgICAvLyB0YWtlIG9wZW5lciBvZmYgYnJhY2tldHMgc3RhY2tcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIG9wZW4gaXMgYSBwb3RlbnRpYWwgb3BlbmVyXG4gICAgICAgIHZhciBpc0ltYWdlID0gb3BlbmVyLmltYWdlO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGxpbmsvaW1hZ2VcbiAgICAgICAgdmFyIHNhdmVwb3MgPSB0aGlzLnBvcztcbiAgICAgICAgLy8gSW5saW5lIGxpbms/XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gQ19PUEVOX1BBUkVOKSB7XG4gICAgICAgICAgICB0aGlzLnBvcysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgKGRlc3QgPSB0aGlzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKCkpICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zcG5sKCkgJiZcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJlZm9yZSB0aGUgdGl0bGU6XG4gICAgICAgICAgICAgICAgKChyZVdoaXRlc3BhY2VDaGFyLnRlc3QodGhpcy5zdWJqZWN0LmNoYXJBdCh0aGlzLnBvcyAtIDEpKSAmJlxuICAgICAgICAgICAgICAgICAgICAodGl0bGUgPSB0aGlzLnBhcnNlTGlua1RpdGxlKCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICB0cnVlKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3BubCgpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrKCkgPT09IENfQ0xPU0VfUEFSRU4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSAxO1xuICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBzYXZlcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWZMYWJlbCA9ICcnO1xuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgICAgICAgIC8vIE5leHQsIHNlZSBpZiB0aGVyZSdzIGEgbGluayBsYWJlbFxuICAgICAgICAgICAgdmFyIGJlZm9yZWxhYmVsID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChuID4gMikge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gdGhpcy5zdWJqZWN0LnNsaWNlKGJlZm9yZWxhYmVsLCBiZWZvcmVsYWJlbCArIG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wZW5lci5icmFja2V0QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBFbXB0eSBvciBtaXNzaW5nIHNlY29uZCBsYWJlbCBtZWFucyB0byB1c2UgdGhlIGZpcnN0IGxhYmVsIGFzIHRoZSByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBtdXN0IG5vdCBjb250YWluIGEgYnJhY2tldC4gSWYgd2Uga25vdyB0aGVyZSdzIGEgYnJhY2tldCwgd2UgZG9uJ3QgZXZlbiBib3RoZXIgY2hlY2tpbmcgaXQuXG4gICAgICAgICAgICAgICAgcmVmTGFiZWwgPSB0aGlzLnN1YmplY3Quc2xpY2Uob3BlbmVyLmluZGV4LCBzdGFydHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rLCByZXdpbmQgYmVmb3JlIHNwYWNlcyB3ZSBza2lwcGVkLlxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gc2F2ZXBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZMYWJlbCkge1xuICAgICAgICAgICAgICAgIHJlZkxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHJlZkxhYmVsKTtcbiAgICAgICAgICAgICAgICAvLyBsb29rdXAgcmF3bGFiZWwgaW4gcmVmTWFwXG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLnJlZk1hcFtyZWZMYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdCA9IGxpbmsuZGVzdGluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGluay50aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZU5vZGUoaXNJbWFnZSA/ICdpbWFnZScgOiAnbGluaycpO1xuICAgICAgICAgICAgbm9kZS5kZXN0aW5hdGlvbiA9IGRlc3Q7XG4gICAgICAgICAgICBub2RlLnRpdGxlID0gdGl0bGUgfHwgJyc7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvcyA9IFtvcGVuZXIuc3RhcnRwb3MsIHRoaXMuc291cmNlcG9zKHRoaXMucG9zKV07XG4gICAgICAgICAgICB2YXIgdG1wID0gb3BlbmVyLm5vZGUubmV4dDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuICAgICAgICAgICAgd2hpbGUgKHRtcCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0bXAubmV4dDtcbiAgICAgICAgICAgICAgICB0bXAudW5saW5rKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0bXApO1xuICAgICAgICAgICAgICAgIHRtcCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VtcGhhc2lzKG9wZW5lci5wcmV2aW91c0RlbGltaXRlcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUJyYWNrZXQoKTtcbiAgICAgICAgICAgIG9wZW5lci5ub2RlLnVubGluaygpO1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlIHRoaXMgYnJhY2tldCBhbmQgcHJvY2Vzc0VtcGhhc2lzIHdpbGwgcmVtb3ZlIGxhdGVyIGRlbGltaXRlcnMuXG4gICAgICAgICAgICAvLyBOb3csIGZvciBhIGxpbmssIHdlIGFsc28gZGVhY3RpdmF0ZSBlYXJsaWVyIGxpbmsgb3BlbmVycy5cbiAgICAgICAgICAgIC8vIChubyBsaW5rcyBpbiBsaW5rcylcbiAgICAgICAgICAgIGlmICghaXNJbWFnZSkge1xuICAgICAgICAgICAgICAgIG9wZW5lciA9IHRoaXMuYnJhY2tldHM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZW5lci5pbWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbmVyLmFjdGl2ZSA9IGZhbHNlOyAvLyBkZWFjdGl2YXRlIHRoaXMgb3BlbmVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyID0gb3BlbmVyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcFtibG9jay5pZF0gPSB7IG5vZGU6IGJsb2NrLCByZWZMYWJlbDogcmVmTGFiZWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIG5vIG1hdGNoXG4gICAgICAgIHRoaXMucmVtb3ZlQnJhY2tldCgpOyAvLyByZW1vdmUgdGhpcyBvcGVuZXIgZnJvbSBzdGFja1xuICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dCgnXScsIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCBzdGFydHBvcykpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXBbYmxvY2suaWRdID0geyBub2RlOiBibG9jaywgcmVmTGFiZWw6IHJlZkxhYmVsIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBJbmxpbmVQYXJzZXIucHJvdG90eXBlLmFkZEJyYWNrZXQgPSBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIGltYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLmJyYWNrZXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJyYWNrZXRzLmJyYWNrZXRBZnRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5icmFja2V0cyA9IHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICBzdGFydHBvczogdGhpcy5zb3VyY2Vwb3MoaW5kZXggKyAoaW1hZ2UgPyAwIDogMSkpLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuYnJhY2tldHMsXG4gICAgICAgICAgICBwcmV2aW91c0RlbGltaXRlcjogdGhpcy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVCcmFja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5icmFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5icmFja2V0cyA9IHRoaXMuYnJhY2tldHMucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgYW4gZW50aXR5LlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VFbnRpdHkgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZUVudGl0eUhlcmUpKSkge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoZXNtX3RleHQobGliLmRlY29kZUhUTUwobSksIHRoaXMuc291cmNlcG9zKHN0YXJ0cG9zLCB0aGlzLnBvcykpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgcnVuIG9mIG9yZGluYXJ5IGNoYXJhY3RlcnMsIG9yIGEgc2luZ2xlIGNoYXJhY3RlciB3aXRoXG4gICAgLy8gYSBzcGVjaWFsIG1lYW5pbmcgaW4gbWFya2Rvd24sIGFzIGEgcGxhaW4gc3RyaW5nLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHZhciBzdGFydHBvcyA9IHRoaXMucG9zICsgMTtcbiAgICAgICAgaWYgKChtID0gdGhpcy5tYXRjaChyZU1haW4pKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydCkge1xuICAgICAgICAgICAgICAgIHZhciBsaXQgPSBtLnJlcGxhY2UocmVFbGxpcHNlcywgJ1xcdTIwMjYnKS5yZXBsYWNlKHJlRGFzaCwgZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNpYmxlIGJ5IDMsIHVzZSBhbGwgZW0gZGFzaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBlbUNvdW50ID0gY2hhcnMubGVuZ3RoIC8gMztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFycy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc2libGUgYnkgMiwgdXNlIGFsbCBlbiBkYXNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSBjaGFycy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXJzLmxlbmd0aCAlIDMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIDIgZXh0cmEgZGFzaGVzLCB1c2UgZW4gZGFzaCBmb3IgbGFzdCAyOyBlbSBkYXNoZXMgZm9yIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuQ291bnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1Db3VudCA9IChjaGFycy5sZW5ndGggLSAyKSAvIDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZW4gZGFzaGVzIGZvciBsYXN0IDQgaHlwaGVuczsgZW0gZGFzaGVzIGZvciByZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBlbkNvdW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtQ291bnQgPSAoY2hhcnMubGVuZ3RoIC0gNCkgLyAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBlYXQoJ1xcdTIwMTQnLCBlbUNvdW50KSArIHJlcGVhdCgnXFx1MjAxMycsIGVuQ291bnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJsb2NrLmFwcGVuZENoaWxkKGVzbV90ZXh0KGxpdCwgdGhpcy5zb3VyY2Vwb3Moc3RhcnRwb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBlc21fdGV4dChtLCB0aGlzLnNvdXJjZXBvcyhzdGFydHBvcywgdGhpcy5wb3MpKTtcbiAgICAgICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIFBhcnNlIGEgbmV3bGluZS4gIElmIGl0IHdhcyBwcmVjZWRlZCBieSB0d28gc3BhY2VzLCByZXR1cm4gYSBoYXJkXG4gICAgLy8gbGluZSBicmVhazsgb3RoZXJ3aXNlIGEgc29mdCBsaW5lIGJyZWFrLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2VOZXdsaW5lID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHRoaXMucG9zICs9IDE7IC8vIGFzc3VtZSB3ZSdyZSBhdCBhIFxcblxuICAgICAgICAvLyBjaGVjayBwcmV2aW91cyBub2RlIGZvciB0cmFpbGluZyBzcGFjZXNcbiAgICAgICAgdmFyIGxhc3RjID0gYmxvY2subGFzdENoaWxkO1xuICAgICAgICBpZiAobGFzdGMgJiYgbGFzdGMudHlwZSA9PT0gJ3RleHQnICYmIGxhc3RjLmxpdGVyYWxbbGFzdGMubGl0ZXJhbC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB2YXIgaGFyZGJyZWFrID0gbGFzdGMubGl0ZXJhbFtsYXN0Yy5saXRlcmFsLmxlbmd0aCAtIDJdID09PSAnICc7XG4gICAgICAgICAgICB2YXIgbGl0TGVuID0gbGFzdGMubGl0ZXJhbC5sZW5ndGg7XG4gICAgICAgICAgICBsYXN0Yy5saXRlcmFsID0gbGFzdGMubGl0ZXJhbC5yZXBsYWNlKHJlRmluYWxTcGFjZSwgJycpO1xuICAgICAgICAgICAgdmFyIGZpbmFsU3BhY2VMZW4gPSBsaXRMZW4gLSBsYXN0Yy5saXRlcmFsLmxlbmd0aDtcbiAgICAgICAgICAgIGxhc3RjLnNvdXJjZXBvc1sxXVsxXSAtPSBmaW5hbFNwYWNlTGVuO1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZShoYXJkYnJlYWsgPyAnbGluZWJyZWFrJyA6ICdzb2Z0YnJlYWsnLCB0aGlzLnNvdXJjZXBvcyh0aGlzLnBvcyAtIGZpbmFsU3BhY2VMZW4sIHRoaXMucG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYXBwZW5kQ2hpbGQoY3JlYXRlTm9kZSgnc29mdGJyZWFrJywgdGhpcy5zb3VyY2Vwb3ModGhpcy5wb3MsIHRoaXMucG9zKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgdGhpcy5tYXRjaChyZUluaXRpYWxTcGFjZSk7IC8vIGdvYmJsZSBsZWFkaW5nIHNwYWNlcyBpbiBuZXh0IGxpbmVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIGEgbGluayByZWZlcmVuY2UsIG1vZGlmeWluZyByZWZtYXAuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChibG9jaywgcmVmTWFwKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdmFyIHRpdGxlID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0cG9zID0gdGhpcy5wb3M7XG4gICAgICAgIC8vIGxhYmVsOlxuICAgICAgICB2YXIgbWF0Y2hDaGFycyA9IHRoaXMucGFyc2VMaW5rTGFiZWwoKTtcbiAgICAgICAgaWYgKG1hdGNoQ2hhcnMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXdsYWJlbCA9IHRoaXMuc3ViamVjdC5zdWJzdHIoMCwgbWF0Y2hDaGFycyk7XG4gICAgICAgIC8vIGNvbG9uOlxuICAgICAgICBpZiAodGhpcy5wZWVrKCkgPT09IENfQ09MT04pIHtcbiAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIGxpbmsgdXJsXG4gICAgICAgIHRoaXMuc3BubCgpO1xuICAgICAgICB2YXIgZGVzdCA9IHRoaXMucGFyc2VMaW5rRGVzdGluYXRpb24oKTtcbiAgICAgICAgaWYgKGRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gc3RhcnRwb3M7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVmb3JldGl0bGUgPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5zcG5sKCk7XG4gICAgICAgIGlmICh0aGlzLnBvcyAhPT0gYmVmb3JldGl0bGUpIHtcbiAgICAgICAgICAgIHRpdGxlID0gdGhpcy5wYXJzZUxpbmtUaXRsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aXRsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIC8vIHJld2luZCBiZWZvcmUgc3BhY2VzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IGJlZm9yZXRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSdyZSBhdCBsaW5lIGVuZDpcbiAgICAgICAgdmFyIGF0TGluZUVuZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHJlU3BhY2VBdEVuZE9mTGluZSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aXRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBhdExpbmVFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3RlbnRpYWwgdGl0bGUgd2UgZm91bmQgaXMgbm90IGF0IHRoZSBsaW5lIGVuZCxcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSBsZWdhbCBsaW5rIHJlZmVyZW5jZSBpZiB3ZVxuICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgdGhlIHRpdGxlXG4gICAgICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICAgICAgICAvLyByZXdpbmQgYmVmb3JlIHNwYWNlc1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gYmVmb3JldGl0bGU7XG4gICAgICAgICAgICAgICAgLy8gYW5kIGluc3RlYWQgY2hlY2sgaWYgdGhlIGxpbmsgVVJMIGlzIGF0IHRoZSBsaW5lIGVuZFxuICAgICAgICAgICAgICAgIGF0TGluZUVuZCA9IHRoaXMubWF0Y2gocmVTcGFjZUF0RW5kT2ZMaW5lKSAhPT0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF0TGluZUVuZCkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBzdGFydHBvcztcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3JtYWxMYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShyYXdsYWJlbCk7XG4gICAgICAgIGlmIChub3JtYWxMYWJlbCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIGxhYmVsIG11c3QgY29udGFpbiBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHN0YXJ0cG9zO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZXBvcyA9IHRoaXMuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zKGJsb2NrKTtcbiAgICAgICAgYmxvY2suc291cmNlcG9zWzBdWzBdID0gc291cmNlcG9zWzFdWzBdICsgMTtcbiAgICAgICAgdmFyIG5vZGUgPSBjcmVhdGVOb2RlKCdyZWZEZWYnLCBzb3VyY2Vwb3MpO1xuICAgICAgICBub2RlLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIG5vZGUuZGVzdCA9IGRlc3Q7XG4gICAgICAgIG5vZGUubGFiZWwgPSBub3JtYWxMYWJlbDtcbiAgICAgICAgYmxvY2suaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICBpZiAoIXJlZk1hcFtub3JtYWxMYWJlbF0pIHtcbiAgICAgICAgICAgIHJlZk1hcFtub3JtYWxMYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwW25vZGUuaWRdID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSBzdGFydHBvcztcbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUubWVyZ2VUZXh0Tm9kZXMgPSBmdW5jdGlvbiAod2Fsa2VyKSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgdmFyIHRleHROb2RlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoKGV2ZW50ID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IGV2ZW50LmVudGVyaW5nLCBub2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgICAgIGlmIChlbnRlcmluZyAmJiBub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRleHROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRleHROb2RlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3ROb2RlID0gdGV4dE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9kZS5zb3VyY2Vwb3MgJiYgbGFzdE5vZGUuc291cmNlcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zb3VyY2Vwb3NbMV0gPSBsYXN0Tm9kZS5zb3VyY2Vwb3NbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5uZXh0ID0gbGFzdE5vZGUubmV4dDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb2RlLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLm5leHQucHJldiA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZXh0Tm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlLmxpdGVyYWwgKz0gdGV4dE5vZGVzW2ldLmxpdGVyYWw7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2Rlc1tpXS51bmxpbmsoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dE5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUuZ2V0UmVmZXJlbmNlRGVmU291cmNlcG9zID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGJsb2NrLnN0cmluZ0NvbnRlbnQuc3BsaXQoL1xcbnxcXHJcXG4vKTtcbiAgICAgICAgdmFyIHBhc3NlZFVybExpbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHF1b3RhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiAwLCBjaDogMCB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHJlV2hpdGVzcGFjZUNoYXIudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKC9cXDovLnRlc3QobGluZSkgJiYgcXVvdGF0aW9uQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VkVXJsTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSBsaW5lLmluZGV4T2YoJzonKSA9PT0gbGluZS5sZW5ndGggLSAxID8gaSArIDEgOiBpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBsaW5lT2Zmc2V0LCBjaDogbGluZXNbbGluZU9mZnNldF0ubGVuZ3RoIH07XG4gICAgICAgICAgICAgICAgcGFzc2VkVXJsTGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzaG91bGQgY29uc2lkZXIgZXh0ZW5kYWJsZSB0aXRsZVxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBsaW5lLm1hdGNoKC8nfFwiL2cpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBxdW90YXRpb25Db3VudCArPSBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChxdW90YXRpb25Db3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lT2Zmc2V0ID0geyBsaW5lOiBpLCBjaDogbGluZS5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgW2Jsb2NrLnNvdXJjZXBvc1swXVswXSwgYmxvY2suc291cmNlcG9zWzBdWzFdXSxcbiAgICAgICAgICAgIFtibG9jay5zb3VyY2Vwb3NbMF1bMF0gKyBsYXN0TGluZU9mZnNldC5saW5lLCBsYXN0TGluZU9mZnNldC5jaF0sXG4gICAgICAgIF07XG4gICAgfTtcbiAgICAvLyBQYXJzZSB0aGUgbmV4dCBpbmxpbmUgZWxlbWVudCBpbiBzdWJqZWN0LCBhZHZhbmNpbmcgc3ViamVjdCBwb3NpdGlvbi5cbiAgICAvLyBPbiBzdWNjZXNzLCBhZGQgdGhlIHJlc3VsdCB0byBibG9jaydzIGNoaWxkcmVuIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAvLyBPbiBmYWlsdXJlLCByZXR1cm4gZmFsc2UuXG4gICAgSW5saW5lUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIENfTkVXTElORTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlTmV3bGluZShibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfQkFDS1NMQVNIOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrc2xhc2goYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBQ0tUSUNLOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VCYWNrdGlja3MoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0FTVEVSSVNLOlxuICAgICAgICAgICAgY2FzZSBDX1VOREVSU0NPUkU6XG4gICAgICAgICAgICBjYXNlIENfVElMREU6XG4gICAgICAgICAgICBjYXNlIENfRE9MTEFSOlxuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuaGFuZGxlRGVsaW0oYywgYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX1NJTkdMRVFVT1RFOlxuICAgICAgICAgICAgY2FzZSBDX0RPVUJMRVFVT1RFOlxuICAgICAgICAgICAgICAgIHJlcyA9ICEhKChfYSA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNtYXJ0KSAmJiB0aGlzLmhhbmRsZURlbGltKGMsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19PUEVOX0JSQUNLRVQkMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlT3BlbkJyYWNrZXQoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0JBTkc6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUJhbmcoYmxvY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDX0NMT1NFX0JSQUNLRVQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZUNsb3NlQnJhY2tldChibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENfTEVTU1RIQU4kMTpcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlQXV0b2xpbmsoYmxvY2spIHx8IHRoaXMucGFyc2VIdG1sVGFnKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ19BTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5kaXNhYmxlZEVudGl0eVBhcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucGFyc2VFbnRpdHkoYmxvY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZyhibG9jayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IDE7XG4gICAgICAgICAgICBibG9jay5hcHBlbmRDaGlsZChlc21fdGV4dChmcm9tQ29kZVBvaW50JDEoYyksIHRoaXMuc291cmNlcG9zKHRoaXMucG9zLCB0aGlzLnBvcyArIDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBQYXJzZSBzdHJpbmcgY29udGVudCBpbiBibG9jayBpbnRvIGlubGluZSBjaGlsZHJlbixcbiAgICAvLyB1c2luZyByZWZtYXAgdG8gcmVzb2x2ZSByZWZlcmVuY2VzLlxuICAgIElubGluZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gYmxvY2suc3RyaW5nQ29udGVudC50cmltKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmFja2V0cyA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZU9mZnNldHMgPSBibG9jay5saW5lT2Zmc2V0cyB8fCBbMF07XG4gICAgICAgIHRoaXMubGluZUlkeCA9IDA7XG4gICAgICAgIHRoaXMubGluZVBvc09mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0TnVtID0gYmxvY2suc291cmNlcG9zWzBdWzBdO1xuICAgICAgICBpZiAoaXNIZWFkaW5nKGJsb2NrKSkge1xuICAgICAgICAgICAgdGhpcy5saW5lT2Zmc2V0c1swXSArPSBibG9jay5sZXZlbCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VJbmxpbmUoYmxvY2spKSB7IH1cbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IHJhdyBzdHJpbmcgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgdGhpcy5wcm9jZXNzRW1waGFzaXMobnVsbCk7XG4gICAgICAgIHRoaXMubWVyZ2VUZXh0Tm9kZXMoYmxvY2sud2Fsa2VyKCkpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2EuZXh0ZW5kZWRBdXRvbGlua3MsIGN1c3RvbVBhcnNlciA9IF9hLmN1c3RvbVBhcnNlcjtcbiAgICAgICAgaWYgKGV4dGVuZGVkQXV0b2xpbmtzKSB7XG4gICAgICAgICAgICBjb252ZXJ0RXh0QXV0b0xpbmtzKGJsb2NrLndhbGtlcigpLCBleHRlbmRlZEF1dG9saW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1c3RvbVBhcnNlciAmJiBibG9jay5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMTtcbiAgICAgICAgICAgIHZhciB3YWxrZXIgPSBibG9jay5maXJzdENoaWxkLndhbGtlcigpO1xuICAgICAgICAgICAgd2hpbGUgKChldmVudF8xID0gd2Fsa2VyLm5leHQoKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50XzEubm9kZSwgZW50ZXJpbmcgPSBldmVudF8xLmVudGVyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChjdXN0b21QYXJzZXJbbm9kZS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXJzZXJbbm9kZS50eXBlXShub2RlLCB7IGVudGVyaW5nOiBlbnRlcmluZywgb3B0aW9uczogdGhpcy5vcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElubGluZVBhcnNlcjtcbn0oKSk7XG52YXIgcmVUYXNrTGlzdEl0ZW1NYXJrZXIgPSAvXlxcWyhbIFxcdHhYXSlcXF1bIFxcdF0rLztcbi8vIGZpbmFsaXplIGZvciBibG9jayBoYW5kbGVyXG5mdW5jdGlvbiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZShfLCBibG9jaykge1xuICAgIGlmIChibG9jay5maXJzdENoaWxkICYmIGJsb2NrLmZpcnN0Q2hpbGQudHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgdmFyIHAgPSBibG9jay5maXJzdENoaWxkO1xuICAgICAgICB2YXIgbSA9IHAuc3RyaW5nQ29udGVudC5tYXRjaChyZVRhc2tMaXN0SXRlbU1hcmtlcik7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICB2YXIgbUxlbiA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcC5zdHJpbmdDb250ZW50ID0gcC5zdHJpbmdDb250ZW50LnN1YnN0cmluZyhtTGVuIC0gMSk7XG4gICAgICAgICAgICBwLnNvdXJjZXBvc1swXVsxXSArPSBtTGVuO1xuICAgICAgICAgICAgcC5saW5lT2Zmc2V0c1swXSArPSBtTGVuO1xuICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGFzayA9IHRydWU7XG4gICAgICAgICAgICBibG9jay5saXN0RGF0YS5jaGVja2VkID0gL1t4WF0vLnRlc3QobVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgdGFibGUgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVIZWFkJyB8fCB0ID09PSAndGFibGVCb2R5JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlQm9keSQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ3RhYmxlUm93JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlSGVhZCQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVSb3cnIHx8IHQgPT09ICd0YWJsZURlbGltUm93JztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlRGVsaW1Sb3cgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09ICd0YWJsZURlbGltQ2VsbCc7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0YWJsZURlbGltQ2VsbCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlUm93ID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAndGFibGVDZWxsJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIHRhYmxlQ2VsbCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIENPREVfSU5ERU5UID0gNDtcbnZhciBDX1RBQiA9IDk7XG52YXIgQ19HUkVBVEVSVEhBTiA9IDYyO1xudmFyIENfTEVTU1RIQU4gPSA2MDtcbnZhciBDX1NQQUNFID0gMzI7XG52YXIgQ19PUEVOX0JSQUNLRVQgPSA5MTtcbnZhciByZU5vblNwYWNlID0gL1teIFxcdFxcZlxcdlxcclxcbl0vO1xudmFyIHJlQ2xvc2luZ0NvZGVGZW5jZSA9IC9eKD86YHszLH18fnszLH0pKD89ICokKS87XG4vLyBSZXR1cm5zIHRydWUgaWYgYmxvY2sgZW5kcyB3aXRoIGEgYmxhbmsgbGluZSwgZGVzY2VuZGluZyBpZiBuZWVkZWRcbi8vIGludG8gbGlzdHMgYW5kIHN1Ymxpc3RzLlxuZnVuY3Rpb24gZW5kc1dpdGhCbGFua0xpbmUoYmxvY2spIHtcbiAgICB2YXIgY3VyQmxvY2sgPSBibG9jaztcbiAgICB3aGlsZSAoY3VyQmxvY2spIHtcbiAgICAgICAgaWYgKGN1ckJsb2NrLmxhc3RMaW5lQmxhbmspIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gY3VyQmxvY2sudHlwZTtcbiAgICAgICAgaWYgKCFjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgJiYgKHQgPT09ICdsaXN0JyB8fCB0ID09PSAnaXRlbScpKSB7XG4gICAgICAgICAgICBjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgY3VyQmxvY2sgPSBjdXJCbG9jay5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJCbG9jay5sYXN0TGluZUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcGVlayhsbiwgcG9zKSB7XG4gICAgaWYgKHBvcyA8IGxuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbG4uY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgc3RyaW5nIGNvbnRhaW5zIG9ubHkgc3BhY2UgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIGlzQmxhbmsocykge1xuICAgIHJldHVybiAhcmVOb25TcGFjZS50ZXN0KHMpO1xufVxuZnVuY3Rpb24gaXNTcGFjZU9yVGFiKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gQ19TUEFDRSB8fCBjID09PSBDX1RBQjtcbn1cbnZhciByZUNsb3NpbmdDdXN0b21CbG9jayA9IC9eXFwkXFwkJC87XG52YXIgY3VzdG9tQmxvY2skMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlQ2xvc2luZ0N1c3RvbUJsb2NrKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBjbG9zaW5nIGN1c3RvbSBibG9ja1xuICAgICAgICAgICAgcGFyc2VyLmxhc3RMaW5lTGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgcGFyc2VyLmxpbmVOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIDIgLyogRmluaXNoZWQgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBvcHRpb25hbCBzcGFjZXMgb2YgY3VzdG9tIGJsb2NrIG9mZnNldFxuICAgICAgICB2YXIgaSA9IGNvbnRhaW5lci5vZmZzZXQ7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiBpc1NwYWNlT3JUYWIocGVlayhsaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdvICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uIChfLCBibG9jaykge1xuICAgICAgICBpZiAoYmxvY2suc3RyaW5nQ29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpcnN0IGxpbmUgYmVjb21lcyBpbmZvIHN0cmluZ1xuICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgIHZhciBuZXdsaW5lUG9zID0gY29udGVudC5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGNvbnRlbnQuc2xpY2UoMCwgbmV3bGluZVBvcyk7XG4gICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgIHZhciBpbmZvU3RyaW5nID0gZmlyc3RMaW5lLm1hdGNoKC9eKFxccyopKC4qKS8pO1xuICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICBibG9jay5saXRlcmFsID0gcmVzdDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgbm9vcCA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgZG9jdW1lbnQkMSA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGxpc3QgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBpdGVtID0gYmxvY2suZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBub24tZmluYWwgbGlzdCBpdGVtIGVuZGluZyB3aXRoIGJsYW5rIGxpbmU6XG4gICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUoaXRlbSkgJiYgaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBjaGlsZHJlbiBvZiBsaXN0IGl0ZW0sIHRvIHNlZSBpZiB0aGVyZSBhcmVcbiAgICAgICAgICAgIC8vIHNwYWNlcyBiZXR3ZWVuIGFueSBvZiB0aGVtOlxuICAgICAgICAgICAgdmFyIHN1Yml0ZW0gPSBpdGVtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoc3ViaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZShzdWJpdGVtKSAmJiAoaXRlbS5uZXh0IHx8IHN1Yml0ZW0ubmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2subGlzdERhdGEudGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Yml0ZW0gPSBzdWJpdGVtLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5uZXh0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgYmxvY2tRdW90ZSQxID0ge1xuICAgIGNvbnRpbnVlOiBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHZhciBsbiA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhsbiwgcGFyc2VyLm5leHROb25zcGFjZSkgPT09IENfR1JFQVRFUlRIQU4pIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldCgxLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgIT09ICdpdGVtJztcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGl0ZW0gPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBCbGFuayBsaW5lIGFmdGVyIGVtcHR5IGxpc3QgaXRlbVxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlci5pbmRlbnQgPj0gY29udGFpbmVyLmxpc3REYXRhLm1hcmtlck9mZnNldCArIGNvbnRhaW5lci5saXN0RGF0YS5wYWRkaW5nKSB7XG4gICAgICAgICAgICBwYXJzZXIuYWR2YW5jZU9mZnNldChjb250YWluZXIubGlzdERhdGEubWFya2VyT2Zmc2V0ICsgY29udGFpbmVyLmxpc3REYXRhLnBhZGRpbmcsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiB0YXNrTGlzdEl0ZW1GaW5hbGl6ZSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdCAhPT0gJ2l0ZW0nO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiBmYWxzZSxcbn07XG52YXIgaGVhZGluZyA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBhIGhlYWRpbmcgY2FuIG5ldmVyIGNvbnRhaW5lciA+IDEgbGluZSwgc28gZmFpbCB0byBtYXRjaDpcbiAgICAgICAgcmV0dXJuIDEgLyogU3RvcCAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IGZhbHNlLFxufTtcbnZhciB0aGVtYXRpY0JyZWFrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYSB0aGVtYXRpYyBicmVhayBjYW4gbmV2ZXIgY29udGFpbmVyID4gMSBsaW5lLCBzbyBmYWlsIHRvIG1hdGNoOlxuICAgICAgICByZXR1cm4gMSAvKiBTdG9wICovO1xuICAgIH0sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogZmFsc2UsXG59O1xudmFyIGNvZGVCbG9jayA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsbiA9IHBhcnNlci5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGluZGVudCA9IHBhcnNlci5pbmRlbnQ7XG4gICAgICAgIGlmIChjb250YWluZXIuaXNGZW5jZWQpIHtcbiAgICAgICAgICAgIC8vIGZlbmNlZFxuICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5kZW50IDw9IDMgJiZcbiAgICAgICAgICAgICAgICBsbi5jaGFyQXQocGFyc2VyLm5leHROb25zcGFjZSkgPT09IGNvbnRhaW5lci5mZW5jZUNoYXIgJiZcbiAgICAgICAgICAgICAgICBsbi5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKS5tYXRjaChyZUNsb3NpbmdDb2RlRmVuY2UpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+PSBjb250YWluZXIuZmVuY2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9zaW5nIGZlbmNlIC0gd2UncmUgYXQgZW5kIG9mIGxpbmUsIHNvIHdlIGNhbiByZXR1cm5cbiAgICAgICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBwYXJzZXIub2Zmc2V0ICsgaW5kZW50ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhcnNlci5maW5hbGl6ZShjb250YWluZXIsIHBhcnNlci5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgb3B0aW9uYWwgc3BhY2VzIG9mIGZlbmNlIG9mZnNldFxuICAgICAgICAgICAgdmFyIGkgPSBjb250YWluZXIuZmVuY2VPZmZzZXQ7XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgaXNTcGFjZU9yVGFiKHBlZWsobG4sIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluZGVudGVkXG4gICAgICAgICAgICBpZiAoaW5kZW50ID49IENPREVfSU5ERU5UKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoQ09ERV9JTkRFTlQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyc2VyLmJsYW5rKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFN0b3AgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2suaXNGZW5jZWQpIHtcbiAgICAgICAgICAgIC8vIGZlbmNlZFxuICAgICAgICAgICAgLy8gZmlyc3QgbGluZSBiZWNvbWVzIGluZm8gc3RyaW5nXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGJsb2NrLnN0cmluZ0NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgbmV3bGluZVBvcyA9IGNvbnRlbnQuaW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICB2YXIgZmlyc3RMaW5lID0gY29udGVudC5zbGljZSgwLCBuZXdsaW5lUG9zKTtcbiAgICAgICAgICAgIHZhciByZXN0ID0gY29udGVudC5zbGljZShuZXdsaW5lUG9zICsgMSk7XG4gICAgICAgICAgICB2YXIgaW5mb1N0cmluZyA9IGZpcnN0TGluZS5tYXRjaCgvXihcXHMqKSguKikvKTtcbiAgICAgICAgICAgIGJsb2NrLmluZm9QYWRkaW5nID0gaW5mb1N0cmluZ1sxXS5sZW5ndGg7XG4gICAgICAgICAgICBibG9jay5pbmZvID0gdW5lc2NhcGVTdHJpbmcoaW5mb1N0cmluZ1syXS50cmltKCkpO1xuICAgICAgICAgICAgYmxvY2subGl0ZXJhbCA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbmRlbnRlZFxuICAgICAgICAgICAgYmxvY2subGl0ZXJhbCA9IChfYSA9IGJsb2NrLnN0cmluZ0NvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oXFxuICopKyQvLCAnXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7IC8vIGFsbG93IEdDXG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgaHRtbEJsb2NrJDEgPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gcGFyc2VyLmJsYW5rICYmIChjb250YWluZXIuaHRtbEJsb2NrVHlwZSA9PT0gNiB8fCBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA9PT0gNylcbiAgICAgICAgICAgID8gMSAvKiBTdG9wICovXG4gICAgICAgICAgICA6IDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKF8sIGJsb2NrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYmxvY2subGl0ZXJhbCA9ICgoX2EgPSBibG9jay5zdHJpbmdDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvKFxcbiAqKSskLywgJycpKSB8fCBudWxsO1xuICAgICAgICBibG9jay5zdHJpbmdDb250ZW50ID0gbnVsbDsgLy8gYWxsb3cgR0NcbiAgICB9LFxuICAgIGNhbkNvbnRhaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgYWNjZXB0c0xpbmVzOiB0cnVlLFxufTtcbnZhciBwYXJhZ3JhcGggPSB7XG4gICAgY29udGludWU6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5ibGFuayA/IDEgLyogU3RvcCAqLyA6IDAgLyogR28gKi87XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKHBhcnNlciwgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zO1xuICAgICAgICB2YXIgaGFzUmVmZXJlbmNlRGVmcyA9IGZhbHNlO1xuICAgICAgICAvLyB0cnkgcGFyc2luZyB0aGUgYmVnaW5uaW5nIGFzIGxpbmsgcmVmZXJlbmNlIGRlZmluaXRpb25zOlxuICAgICAgICB3aGlsZSAocGVlayhibG9jay5zdHJpbmdDb250ZW50LCAwKSA9PT0gQ19PUEVOX0JSQUNLRVQgJiZcbiAgICAgICAgICAgIChwb3MgPSBwYXJzZXIuaW5saW5lUGFyc2VyLnBhcnNlUmVmZXJlbmNlKGJsb2NrLCBwYXJzZXIucmVmTWFwKSkpIHtcbiAgICAgICAgICAgIGJsb2NrLnN0cmluZ0NvbnRlbnQgPSBibG9jay5zdHJpbmdDb250ZW50LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICBoYXNSZWZlcmVuY2VEZWZzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlRGVmcyAmJiBpc0JsYW5rKGJsb2NrLnN0cmluZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICBibG9jay51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2FuQ29udGFpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBhY2NlcHRzTGluZXM6IHRydWUsXG59O1xudmFyIHJlZkRlZiA9IG5vb3A7XG52YXIgZnJvbnRNYXR0ZXIkMiA9IG5vb3A7XG52YXIgYmxvY2tIYW5kbGVycyA9IHtcbiAgICBkb2N1bWVudDogZG9jdW1lbnQkMSxcbiAgICBsaXN0OiBsaXN0LFxuICAgIGJsb2NrUXVvdGU6IGJsb2NrUXVvdGUkMSxcbiAgICBpdGVtOiBpdGVtLFxuICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgdGhlbWF0aWNCcmVhazogdGhlbWF0aWNCcmVhayQxLFxuICAgIGNvZGVCbG9jazogY29kZUJsb2NrLFxuICAgIGh0bWxCbG9jazogaHRtbEJsb2NrJDEsXG4gICAgcGFyYWdyYXBoOiBwYXJhZ3JhcGgsXG4gICAgdGFibGU6IHRhYmxlLFxuICAgIHRhYmxlQm9keTogdGFibGVCb2R5JDEsXG4gICAgdGFibGVIZWFkOiB0YWJsZUhlYWQkMSxcbiAgICB0YWJsZVJvdzogdGFibGVSb3csXG4gICAgdGFibGVDZWxsOiB0YWJsZUNlbGwsXG4gICAgdGFibGVEZWxpbVJvdzogdGFibGVEZWxpbVJvdyxcbiAgICB0YWJsZURlbGltQ2VsbDogdGFibGVEZWxpbUNlbGwsXG4gICAgcmVmRGVmOiByZWZEZWYsXG4gICAgY3VzdG9tQmxvY2s6IGN1c3RvbUJsb2NrJDEsXG4gICAgZnJvbnRNYXR0ZXI6IGZyb250TWF0dGVyJDIsXG59O1xuZnVuY3Rpb24gcGFyc2VSb3dDb250ZW50KGNvbnRlbnQpIHtcbiAgICB2YXIgc3RhcnRJZHggPSAwO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoY29udGVudFtpXSA9PT0gJ3wnICYmIGNvbnRlbnRbaSAtIDFdICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJZHgsIGkpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0SWR4ID09PSAwICYmIGlzRW1wdHkoY2VsbCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydElkeCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydElkeCA8IGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjZWxsID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRJZHgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGNlbGwpKSB7XG4gICAgICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbb2Zmc2V0LCBjZWxsc107XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRhYmxlQ2VsbHMoY2VsbFR5cGUsIGNvbnRlbnRzLCBsaW5lTnVtLCBjaFBvcykge1xuICAgIHZhciBjZWxscyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgY29udGVudHNfMSA9IGNvbnRlbnRzOyBfaSA8IGNvbnRlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gY29udGVudHNfMVtfaV07XG4gICAgICAgIHZhciBwcmVTcGFjZXMgPSBjb250ZW50Lm1hdGNoKC9eWyBcXHRdKy8pO1xuICAgICAgICB2YXIgcGFkZGluZ0xlZnQgPSBwcmVTcGFjZXMgPyBwcmVTcGFjZXNbMF0ubGVuZ3RoIDogMDtcbiAgICAgICAgdmFyIHBhZGRpbmdSaWdodCA9IHZvaWQgMCwgdHJpbW1lZCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHBhZGRpbmdMZWZ0ID09PSBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRyaW1tZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb3N0U3BhY2VzID0gY29udGVudC5tYXRjaCgvWyBcXHRdKyQvKTtcbiAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHBvc3RTcGFjZXMgPyBwb3N0U3BhY2VzWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICB0cmltbWVkID0gY29udGVudC5zbGljZShwYWRkaW5nTGVmdCwgY29udGVudC5sZW5ndGggLSBwYWRkaW5nUmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaFBvc1N0YXJ0ID0gY2hQb3MgKyBwYWRkaW5nTGVmdDtcbiAgICAgICAgdmFyIHRhYmxlQ2VsbCA9IGNyZWF0ZU5vZGUoY2VsbFR5cGUsIFtcbiAgICAgICAgICAgIFtsaW5lTnVtLCBjaFBvc10sXG4gICAgICAgICAgICBbbGluZU51bSwgY2hQb3MgKyBjb250ZW50Lmxlbmd0aCAtIDFdLFxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGVDZWxsLnN0cmluZ0NvbnRlbnQgPSB0cmltbWVkLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTsgLy8gcmVwbGFjZSBlc2FjcGVkIHBpcGUoXFx8KVxuICAgICAgICB0YWJsZUNlbGwuc3RhcnRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5lbmRJZHggPSBjZWxscy5sZW5ndGg7XG4gICAgICAgIHRhYmxlQ2VsbC5saW5lT2Zmc2V0cyA9IFtjaFBvc1N0YXJ0IC0gMV07XG4gICAgICAgIHRhYmxlQ2VsbC5wYWRkaW5nTGVmdCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICB0YWJsZUNlbGwucGFkZGluZ1JpZ2h0ID0gcGFkZGluZ1JpZ2h0O1xuICAgICAgICBjZWxscy5wdXNoKHRhYmxlQ2VsbCk7XG4gICAgICAgIGNoUG9zICs9IGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuZnVuY3Rpb24gZ2V0Q29sdW1uRnJvbURlbGltQ2VsbChjZWxsTm9kZSkge1xuICAgIHZhciBhbGlnbiA9IG51bGw7XG4gICAgdmFyIGNvbnRlbnQgPSBjZWxsTm9kZS5zdHJpbmdDb250ZW50O1xuICAgIHZhciBmaXJzdENoID0gY29udGVudFswXTtcbiAgICB2YXIgbGFzdENoID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0Q2ggPT09ICc6Jykge1xuICAgICAgICBhbGlnbiA9IGZpcnN0Q2ggPT09ICc6JyA/ICdjZW50ZXInIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RDaCA9PT0gJzonKSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH1cbiAgICByZXR1cm4geyBhbGlnbjogYWxpZ24gfTtcbn1cbnZhciB0YWJsZUhlYWQgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgc3RyaW5nQ29udGVudCA9IGNvbnRhaW5lci5zdHJpbmdDb250ZW50O1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5pbmRlbnRlZCAmJiAhcGFyc2VyLmJsYW5rKSB7XG4gICAgICAgIHZhciBsYXN0TmV3TGluZUlkeCA9IHN0cmluZ0NvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RMaW5lU3RhcnRJZHggPSBzdHJpbmdDb250ZW50Lmxhc3RJbmRleE9mKCdcXG4nLCBsYXN0TmV3TGluZUlkeCAtIDEpICsgMTtcbiAgICAgICAgdmFyIGhlYWRlckNvbnRlbnQgPSBzdHJpbmdDb250ZW50LnNsaWNlKGxhc3RMaW5lU3RhcnRJZHgsIGxhc3ROZXdMaW5lSWR4KTtcbiAgICAgICAgdmFyIGRlbGltQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZS5zbGljZShwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGhlYWRlckNvbnRlbnQpLCBoZWFkZXJPZmZzZXQgPSBfYVswXSwgaGVhZGVyQ2VsbHMgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gcGFyc2VSb3dDb250ZW50KGRlbGltQ29udGVudCksIGRlbGltT2Zmc2V0ID0gX2JbMF0sIGRlbGltQ2VsbHMgPSBfYlsxXTtcbiAgICAgICAgdmFyIHJlVmFsaWREZWxpbUNlbGxfMSA9IC9eWyBcXHRdKjo/LSs6P1sgXFx0XSokLztcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgY2hlY2tpbmcgaWYgdGhlIG51bWJlciBvZiBoZWFkZXIgY2VsbHMgYW5kIGRlbGltaXRlciBjZWxscyBhcmUgdGhlIHNhbWVcbiAgICAgICAgLy8gdG8gY29uc2lkZXIgdGhlIGNhc2Ugb2YgbWVyZ2VkLWNvbHVtbiAodmlhIHBsdWdpbilcbiAgICAgICAgIWhlYWRlckNlbGxzLmxlbmd0aCB8fFxuICAgICAgICAgICAgIWRlbGltQ2VsbHMubGVuZ3RoIHx8XG4gICAgICAgICAgICBkZWxpbUNlbGxzLnNvbWUoZnVuY3Rpb24gKGNlbGwpIHsgcmV0dXJuICFyZVZhbGlkRGVsaW1DZWxsXzEudGVzdChjZWxsKTsgfSkgfHxcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgdG8gcmVnYXJkIHNldFRleHRIZWFkaW5nIGFzIHRhYmVsIGRlbGltIGNlbGwgd2l0aCAnZGlzYWxsb3dEZWVwSGVhZGluZycgb3B0aW9uXG4gICAgICAgICAgICAoZGVsaW1DZWxscy5sZW5ndGggPT09IDEgJiYgZGVsaW1Db250ZW50LmluZGV4T2YoJ3wnKSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gY29udGFpbmVyLmxpbmVPZmZzZXRzO1xuICAgICAgICB2YXIgZmlyc3RMaW5lTnVtID0gcGFyc2VyLmxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB2YXIgZmlyc3RMaW5lU3RhcnQgPSBsYXN0KGxpbmVPZmZzZXRzKSArIDE7XG4gICAgICAgIHZhciB0YWJsZSA9IGNyZWF0ZU5vZGUoJ3RhYmxlJywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJvdy1ib2R5LXN0eWxlXG4gICAgICAgIHRhYmxlLmNvbHVtbnMgPSBkZWxpbUNlbGxzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBhbGlnbjogbnVsbCB9KTsgfSk7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZnRlcih0YWJsZSk7XG4gICAgICAgIGlmIChsaW5lT2Zmc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmxpbmsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ID0gc3RyaW5nQ29udGVudC5zbGljZSgwLCBsYXN0TGluZVN0YXJ0SWR4KTtcbiAgICAgICAgICAgIHZhciBwYXJhTGFzdExpbmVTdGFydElkeCA9IHN0cmluZ0NvbnRlbnQubGFzdEluZGV4T2YoJ1xcbicsIGxhc3RMaW5lU3RhcnRJZHggLSAyKSArIDE7XG4gICAgICAgICAgICB2YXIgcGFyYUxhc3RMaW5lTGVuID0gbGFzdExpbmVTdGFydElkeCAtIHBhcmFMYXN0TGluZVN0YXJ0SWR4IC0gMTtcbiAgICAgICAgICAgIHBhcnNlci5sYXN0TGluZUxlbmd0aCA9IGxpbmVPZmZzZXRzW2xpbmVPZmZzZXRzLmxlbmd0aCAtIDJdICsgcGFyYUxhc3RMaW5lTGVuO1xuICAgICAgICAgICAgcGFyc2VyLmZpbmFsaXplKGNvbnRhaW5lciwgZmlyc3RMaW5lTnVtIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZF8xID0gY3JlYXRlTm9kZSgndGFibGVIZWFkJywgW1xuICAgICAgICAgICAgW2ZpcnN0TGluZU51bSwgZmlyc3RMaW5lU3RhcnRdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRhYmxlSGVhZF8xKTtcbiAgICAgICAgdmFyIHRhYmxlSGVhZFJvd18xID0gY3JlYXRlTm9kZSgndGFibGVSb3cnLCBbXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydF0sXG4gICAgICAgICAgICBbZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlckNvbnRlbnQubGVuZ3RoIC0gMV0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdGFibGVEZWxpbVJvd18xID0gY3JlYXRlTm9kZSgndGFibGVEZWxpbVJvdycsIFtcbiAgICAgICAgICAgIFtwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDFdLFxuICAgICAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIub2Zmc2V0XSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlSGVhZF8xLmFwcGVuZENoaWxkKHRhYmxlSGVhZFJvd18xKTtcbiAgICAgICAgdGFibGVIZWFkXzEuYXBwZW5kQ2hpbGQodGFibGVEZWxpbVJvd18xKTtcbiAgICAgICAgZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZUNlbGwnLCBoZWFkZXJDZWxscywgZmlyc3RMaW5lTnVtLCBmaXJzdExpbmVTdGFydCArIGhlYWRlck9mZnNldCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUpIHtcbiAgICAgICAgICAgIHRhYmxlSGVhZFJvd18xLmFwcGVuZENoaWxkKGNlbGxOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxpbUNlbGxOb2RlcyA9IGdlbmVyYXRlVGFibGVDZWxscygndGFibGVEZWxpbUNlbGwnLCBkZWxpbUNlbGxzLCBwYXJzZXIubGluZU51bWJlciwgcGFyc2VyLm5leHROb25zcGFjZSArIDEgKyBkZWxpbU9mZnNldCk7XG4gICAgICAgIGRlbGltQ2VsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNlbGxOb2RlKSB7XG4gICAgICAgICAgICB0YWJsZURlbGltUm93XzEuYXBwZW5kQ2hpbGQoY2VsbE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGFibGUuY29sdW1ucyA9IGRlbGltQ2VsbE5vZGVzLm1hcChnZXRDb2x1bW5Gcm9tRGVsaW1DZWxsKTtcbiAgICAgICAgcGFyc2VyLnRpcCA9IHRhYmxlO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciB0YWJsZUJvZHkgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICBpZiAoKGNvbnRhaW5lci50eXBlICE9PSAndGFibGUnICYmIGNvbnRhaW5lci50eXBlICE9PSAndGFibGVCb2R5JykgfHxcbiAgICAgICAgKCFwYXJzZXIuYmxhbmsgJiYgcGFyc2VyLmN1cnJlbnRMaW5lLmluZGV4T2YoJ3wnKSA9PT0gLTEpKSB7XG4gICAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0LCBmYWxzZSk7XG4gICAgaWYgKHBhcnNlci5ibGFuaykge1xuICAgICAgICB2YXIgdGFibGVfMSA9IGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAndGFibGVCb2R5Jykge1xuICAgICAgICAgICAgdGFibGVfMSA9IGNvbnRhaW5lci5wYXJlbnQ7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5maW5hbGl6ZSh0YWJsZV8xLCBwYXJzZXIubGluZU51bWJlciAtIDEpO1xuICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgIH1cbiAgICB2YXIgdGFibGVCb2R5ID0gY29udGFpbmVyO1xuICAgIGlmIChjb250YWluZXIudHlwZSA9PT0gJ3RhYmxlJykge1xuICAgICAgICB0YWJsZUJvZHkgPSBwYXJzZXIuYWRkQ2hpbGQoJ3RhYmxlQm9keScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB0YWJsZUJvZHkuc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIHZhciB0YWJsZVJvdyA9IGNyZWF0ZU5vZGUoJ3RhYmxlUm93JywgW1xuICAgICAgICBbcGFyc2VyLmxpbmVOdW1iZXIsIHBhcnNlci5uZXh0Tm9uc3BhY2UgKyAxXSxcbiAgICAgICAgW3BhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIuY3VycmVudExpbmUubGVuZ3RoXSxcbiAgICBdKTtcbiAgICB0YWJsZUJvZHkuYXBwZW5kQ2hpbGQodGFibGVSb3cpO1xuICAgIHZhciB0YWJsZSA9IHRhYmxlQm9keS5wYXJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgdmFyIF9hID0gcGFyc2VSb3dDb250ZW50KGNvbnRlbnQpLCBvZmZzZXQgPSBfYVswXSwgY2VsbENvbnRlbnRzID0gX2FbMV07XG4gICAgZ2VuZXJhdGVUYWJsZUNlbGxzKCd0YWJsZUNlbGwnLCBjZWxsQ29udGVudHMsIHBhcnNlci5saW5lTnVtYmVyLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgMSArIG9mZnNldCkuZm9yRWFjaChmdW5jdGlvbiAoY2VsbE5vZGUsIGlkeCkge1xuICAgICAgICBpZiAoaWR4ID49IHRhYmxlLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjZWxsTm9kZS5pZ25vcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVJvdy5hcHBlbmRDaGlsZChjZWxsTm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbn07XG52YXIgcmVDdXN0b21CbG9jayA9IC9eKFxcJFxcJCkoXFxzKlthLXpBLVpdKSsvO1xudmFyIHJlQ2FuQmVDdXN0b21JbmxpbmUgPSAvXihcXCRcXCQpKFxccypbYS16QS1aXSkrLiooXFwkXFwkKS87XG52YXIgY3VzdG9tQmxvY2sgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgdmFyIG1hdGNoO1xuICAgIGlmICghcGFyc2VyLmluZGVudGVkICYmXG4gICAgICAgICFyZUNhbkJlQ3VzdG9tSW5saW5lLnRlc3QocGFyc2VyLmN1cnJlbnRMaW5lKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUubWF0Y2gocmVDdXN0b21CbG9jaykpKSB7XG4gICAgICAgIHZhciBzeW50YXhMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjdXN0b21CbG9jaycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBjb250YWluZXIuc3ludGF4TGVuZ3RoID0gc3ludGF4TGVuZ3RoO1xuICAgICAgICBjb250YWluZXIub2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoc3ludGF4TGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIHJlQ29kZUZlbmNlID0gL15gezMsfSg/IS4qYCl8Xn57Myx9LztcbnZhciByZUh0bWxCbG9ja09wZW4gPSBbXG4gICAgLy4vLFxuICAgIC9ePCg/OnNjcmlwdHxwcmV8c3R5bGUpKD86XFxzfD58JCkvaSxcbiAgICAvXjwhLS0vLFxuICAgIC9ePFs/XS8sXG4gICAgL148IVtBLVpdLyxcbiAgICAvXjwhXFxbQ0RBVEFcXFsvLFxuICAgIC9ePFsvXT8oPzphZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbnxjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aFsxMjM0NTZdfGhlYWR8aGVhZGVyfGhyfGh0bWx8aWZyYW1lfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxuYXZ8bm9mcmFtZXN8b2x8b3B0Z3JvdXB8b3B0aW9ufHB8cGFyYW18c2VjdGlvbnxzb3VyY2V8c3VtbWFyeXx0YWJsZXx0Ym9keXx0ZHx0Zm9vdHx0aHx0aGVhZHx0aXRsZXx0cnx0cmFja3x1bCkoPzpcXHN8Wy9dP1s+XXwkKS9pLFxuICAgIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBPUEVOVEFHICsgXCJ8XCIgKyBDTE9TRVRBRyArIFwiKVxcXFxzKiRcIiwgJ2knKSxcbl07XG52YXIgcmVTZXRleHRIZWFkaW5nTGluZSA9IC9eKD86PSt8LSspWyBcXHRdKiQvO1xudmFyIHJlQVRYSGVhZGluZ01hcmtlciA9IC9eI3sxLDZ9KD86WyBcXHRdK3wkKS87XG52YXIgcmVUaGVtYXRpY0JyZWFrID0gL14oPzooPzpcXCpbIFxcdF0qKXszLH18KD86X1sgXFx0XSopezMsfXwoPzotWyBcXHRdKil7Myx9KVsgXFx0XSokLztcbnZhciByZUJ1bGxldExpc3RNYXJrZXIgPSAvXlsqKy1dLztcbnZhciByZU9yZGVyZWRMaXN0TWFya2VyID0gL14oXFxkezEsOX0pKFsuKV0pLztcbi8vIFBhcnNlIGEgbGlzdCBtYXJrZXIgYW5kIHJldHVybiBkYXRhIG9uIHRoZSBtYXJrZXIgKHR5cGUsXG4vLyBzdGFydCwgZGVsaW1pdGVyLCBidWxsZXQgY2hhcmFjdGVyLCBwYWRkaW5nKSBvciBudWxsLlxuZnVuY3Rpb24gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIHJlc3QgPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBuZXh0YztcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgdHlwZTogJ2J1bGxldCcsXG4gICAgICAgIHRpZ2h0OiB0cnVlLFxuICAgICAgICBidWxsZXRDaGFyOiAnJyxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGRlbGltaXRlcjogJycsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmtlck9mZnNldDogcGFyc2VyLmluZGVudCxcbiAgICAgICAgLy8gR0ZNOiBUYXNrIExpc3QgSXRlbVxuICAgICAgICB0YXNrOiBmYWxzZSxcbiAgICAgICAgY2hlY2tlZDogZmFsc2UsXG4gICAgfTtcbiAgICBpZiAocGFyc2VyLmluZGVudCA+PSA0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKG1hdGNoID0gcmVzdC5tYXRjaChyZUJ1bGxldExpc3RNYXJrZXIpKSkge1xuICAgICAgICBkYXRhLnR5cGUgPSAnYnVsbGV0JztcbiAgICAgICAgZGF0YS5idWxsZXRDaGFyID0gbWF0Y2hbMF1bMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKChtYXRjaCA9IHJlc3QubWF0Y2gocmVPcmRlcmVkTGlzdE1hcmtlcikpICYmXG4gICAgICAgIChjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgfHwgbWF0Y2hbMV0gPT09ICcxJykpIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ29yZGVyZWQnO1xuICAgICAgICBkYXRhLnN0YXJ0ID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgZGF0YS5kZWxpbWl0ZXIgPSBtYXRjaFsyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBzcGFjZXMgYWZ0ZXJcbiAgICBuZXh0YyA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIubmV4dE5vbnNwYWNlICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBpZiAoIShuZXh0YyA9PT0gLTEgfHwgbmV4dGMgPT09IENfVEFCIHx8IG5leHRjID09PSBDX1NQQUNFKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgaXQgaW50ZXJydXB0cyBwYXJhZ3JhcGgsIG1ha2Ugc3VyZSBmaXJzdCBsaW5lIGlzbid0IGJsYW5rXG4gICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJyAmJlxuICAgICAgICAhcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UgKyBtYXRjaFswXS5sZW5ndGgpLm1hdGNoKHJlTm9uU3BhY2UpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyB3ZSd2ZSBnb3QgYSBtYXRjaCEgYWR2YW5jZSBvZmZzZXQgYW5kIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTsgLy8gdG8gc3RhcnQgb2YgbWFya2VyXG4gICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCB0cnVlKTsgLy8gdG8gZW5kIG9mIG1hcmtlclxuICAgIHZhciBzcGFjZXNTdGFydENvbCA9IHBhcnNlci5jb2x1bW47XG4gICAgdmFyIHNwYWNlc1N0YXJ0T2Zmc2V0ID0gcGFyc2VyLm9mZnNldDtcbiAgICBkbyB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICBuZXh0YyA9IHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KTtcbiAgICB9IHdoaWxlIChwYXJzZXIuY29sdW1uIC0gc3BhY2VzU3RhcnRDb2wgPCA1ICYmIGlzU3BhY2VPclRhYihuZXh0YykpO1xuICAgIHZhciBibGFua0l0ZW0gPSBwZWVrKHBhcnNlci5jdXJyZW50TGluZSwgcGFyc2VyLm9mZnNldCkgPT09IC0xO1xuICAgIHZhciBzcGFjZXNBZnRlck1hcmtlciA9IHBhcnNlci5jb2x1bW4gLSBzcGFjZXNTdGFydENvbDtcbiAgICBpZiAoc3BhY2VzQWZ0ZXJNYXJrZXIgPj0gNSB8fCBzcGFjZXNBZnRlck1hcmtlciA8IDEgfHwgYmxhbmtJdGVtKSB7XG4gICAgICAgIGRhdGEucGFkZGluZyA9IG1hdGNoWzBdLmxlbmd0aCArIDE7XG4gICAgICAgIHBhcnNlci5jb2x1bW4gPSBzcGFjZXNTdGFydENvbDtcbiAgICAgICAgcGFyc2VyLm9mZnNldCA9IHNwYWNlc1N0YXJ0T2Zmc2V0O1xuICAgICAgICBpZiAoaXNTcGFjZU9yVGFiKHBlZWsocGFyc2VyLmN1cnJlbnRMaW5lLCBwYXJzZXIub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhLnBhZGRpbmcgPSBtYXRjaFswXS5sZW5ndGggKyBzcGFjZXNBZnRlck1hcmtlcjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBsaXN0IGl0ZW1zIGFyZSBvZiB0aGUgc2FtZSB0eXBlLFxuLy8gd2l0aCB0aGUgc2FtZSBkZWxpbWl0ZXIgYW5kIGJ1bGxldCBjaGFyYWN0ZXIuICBUaGlzIGlzIHVzZWRcbi8vIGluIGFnZ2xvbWVyYXRpbmcgbGlzdCBpdGVtcyBpbnRvIGxpc3RzLlxuZnVuY3Rpb24gbGlzdHNNYXRjaChsaXN0RGF0YSwgaXRlbURhdGEpIHtcbiAgICByZXR1cm4gKGxpc3REYXRhLnR5cGUgPT09IGl0ZW1EYXRhLnR5cGUgJiZcbiAgICAgICAgbGlzdERhdGEuZGVsaW1pdGVyID09PSBpdGVtRGF0YS5kZWxpbWl0ZXIgJiZcbiAgICAgICAgbGlzdERhdGEuYnVsbGV0Q2hhciA9PT0gaXRlbURhdGEuYnVsbGV0Q2hhcik7XG59XG5mdW5jdGlvbiBpc0Rpc2FsbG93ZWREZWVwSGVhZGluZyhwYXJzZXIsIG5vZGUpIHtcbiAgICByZXR1cm4gcGFyc2VyLm9wdGlvbnMuZGlzYWxsb3dEZWVwSGVhZGluZyAmJiAobm9kZS50eXBlID09PSAnYmxvY2tRdW90ZScgfHwgbm9kZS50eXBlID09PSAnaXRlbScpO1xufVxudmFyIGJsb2NrUXVvdGUgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0dSRUFURVJUSEFOKSB7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KDEsIGZhbHNlKTtcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9sbG93aW5nIHNwYWNlXG4gICAgICAgIGlmIChpc1NwYWNlT3JUYWIocGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgnYmxvY2tRdW90ZScsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICByZXR1cm4gMSAvKiBDb250YWluZXIgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGF0eEhlYWRpbmcgPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgbWF0Y2g7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiZcbiAgICAgICAgLy8gVGhlIG5lc3RlZCBIZWFkaW5nIGlzIGRpc2FsbG93ZWQgaW4gbGlzdCBhbmQgYmxvY2txdW90ZSB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgIWlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgY29udGFpbmVyKSAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVBVFhIZWFkaW5nTWFya2VyKSkpIHtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQobWF0Y2hbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgaGVhZGluZyA9IHBhcnNlci5hZGRDaGlsZCgnaGVhZGluZycsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICBoZWFkaW5nLmxldmVsID0gbWF0Y2hbMF0udHJpbSgpLmxlbmd0aDsgLy8gbnVtYmVyIG9mICNzXG4gICAgICAgIGhlYWRpbmcuaGVhZGluZ1R5cGUgPSAnYXR4JztcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICMjI3M6XG4gICAgICAgIGhlYWRpbmcuc3RyaW5nQ29udGVudCA9IHBhcnNlci5jdXJyZW50TGluZVxuICAgICAgICAgICAgLnNsaWNlKHBhcnNlci5vZmZzZXQpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlsgXFx0XSojK1sgXFx0XSokLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvWyBcXHRdKyMrWyBcXHRdKiQvLCAnJyk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KHBhcnNlci5jdXJyZW50TGluZS5sZW5ndGggLSBwYXJzZXIub2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgZmVuY2VkQ29kZUJsb2NrID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICAobWF0Y2ggPSBwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkubWF0Y2gocmVDb2RlRmVuY2UpKSkge1xuICAgICAgICB2YXIgZmVuY2VMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyc2VyLmFkZENoaWxkKCdjb2RlQmxvY2snLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgY29udGFpbmVyLmlzRmVuY2VkID0gdHJ1ZTtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlTGVuZ3RoID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIGNvbnRhaW5lci5mZW5jZUNoYXIgPSBtYXRjaFswXVswXTtcbiAgICAgICAgY29udGFpbmVyLmZlbmNlT2Zmc2V0ID0gcGFyc2VyLmluZGVudDtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQoZmVuY2VMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgaHRtbEJsb2NrID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgaWYgKCFwYXJzZXIuaW5kZW50ZWQgJiYgcGVlayhwYXJzZXIuY3VycmVudExpbmUsIHBhcnNlci5uZXh0Tm9uc3BhY2UpID09PSBDX0xFU1NUSEFOKSB7XG4gICAgICAgIHZhciBzID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICB2YXIgZGlzYWxsb3dlZFRhZ3MgPSBwYXJzZXIub3B0aW9ucy5kaXNhbGxvd2VkSHRtbEJsb2NrVGFncztcbiAgICAgICAgdmFyIGJsb2NrVHlwZSA9IHZvaWQgMDtcbiAgICAgICAgZm9yIChibG9ja1R5cGUgPSAxOyBibG9ja1R5cGUgPD0gNzsgYmxvY2tUeXBlKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkID0gcy5tYXRjaChyZUh0bWxCbG9ja09wZW5bYmxvY2tUeXBlXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1R5cGUgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWxsb3dlZFRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlRGlzYWxsb3dlZFRhZ3MgPSBuZXcgUmVnRXhwKFwiPC8/KD86XCIgKyBkaXNhbGxvd2VkVGFncy5qb2luKCd8JykgKyBcIilcIiwgJ2knKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZURpc2FsbG93ZWRUYWdzLnRlc3QobWF0Y2hlZFswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBOb25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGFkanVzdCBwYXJzZXIub2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlcyBhcmUgcGFydCBvZiB0aGUgSFRNTCBibG9jazpcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHBhcnNlci5hZGRDaGlsZCgnaHRtbEJsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYi5odG1sQmxvY2tUeXBlID0gYmxvY2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgc2VUZXh0SGVhZGluZyA9IGZ1bmN0aW9uIChwYXJzZXIsIGNvbnRhaW5lcikge1xuICAgIHZhciBtYXRjaDtcbiAgICBpZiAoY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgIT09IG51bGwgJiZcbiAgICAgICAgIXBhcnNlci5pbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgLy8gVGhlIG5lc3RlZCBIZWFkaW5nIGlzIGRpc2FsbG93ZWQgaW4gbGlzdCBhbmQgYmxvY2txdW90ZSB3aXRoICdkaXNhbGxvd0RlZXBIZWFkaW5nJyBvcHRpb25cbiAgICAgICAgIWlzRGlzYWxsb3dlZERlZXBIZWFkaW5nKHBhcnNlciwgY29udGFpbmVyLnBhcmVudCkgJiZcbiAgICAgICAgKG1hdGNoID0gcGFyc2VyLmN1cnJlbnRMaW5lLnNsaWNlKHBhcnNlci5uZXh0Tm9uc3BhY2UpLm1hdGNoKHJlU2V0ZXh0SGVhZGluZ0xpbmUpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgLy8gcmVzb2x2ZSByZWZlcmVuY2UgbGluayBkZWZpbml0aW9uc1xuICAgICAgICB2YXIgcG9zID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAocGVlayhjb250YWluZXIuc3RyaW5nQ29udGVudCwgMCkgPT09IENfT1BFTl9CUkFDS0VUICYmXG4gICAgICAgICAgICAocG9zID0gcGFyc2VyLmlubGluZVBhcnNlci5wYXJzZVJlZmVyZW5jZShjb250YWluZXIsIHBhcnNlci5yZWZNYXApKSkge1xuICAgICAgICAgICAgY29udGFpbmVyLnN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudC5zbGljZShwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIuc3RyaW5nQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGluZyA9IGNyZWF0ZU5vZGUoJ2hlYWRpbmcnLCBjb250YWluZXIuc291cmNlcG9zKTtcbiAgICAgICAgICAgIGhlYWRpbmcubGV2ZWwgPSBtYXRjaFswXVswXSA9PT0gJz0nID8gMSA6IDI7XG4gICAgICAgICAgICBoZWFkaW5nLmhlYWRpbmdUeXBlID0gJ3NldGV4dCc7XG4gICAgICAgICAgICBoZWFkaW5nLnN0cmluZ0NvbnRlbnQgPSBjb250YWluZXIuc3RyaW5nQ29udGVudDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRBZnRlcihoZWFkaW5nKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci51bmxpbmsoKTtcbiAgICAgICAgICAgIHBhcnNlci50aXAgPSBoZWFkaW5nO1xuICAgICAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgdGhlbWF0aWNCcmVhayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5pbmRlbnRlZCAmJiByZVRoZW1hdGljQnJlYWsudGVzdChwYXJzZXIuY3VycmVudExpbmUuc2xpY2UocGFyc2VyLm5leHROb25zcGFjZSkpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICBwYXJzZXIuYWRkQ2hpbGQoJ3RoZW1hdGljQnJlYWsnLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgcGFyc2VyLmFkdmFuY2VPZmZzZXQocGFyc2VyLmN1cnJlbnRMaW5lLmxlbmd0aCAtIHBhcnNlci5vZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIDIgLyogTGVhZiAqLztcbiAgICB9XG4gICAgcmV0dXJuIDAgLyogTm9uZSAqLztcbn07XG52YXIgbGlzdEl0ZW0gPSBmdW5jdGlvbiAocGFyc2VyLCBjb250YWluZXIpIHtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgY3Vyck5vZGUgPSBjb250YWluZXI7XG4gICAgaWYgKCghcGFyc2VyLmluZGVudGVkIHx8IGNvbnRhaW5lci50eXBlID09PSAnbGlzdCcpICYmXG4gICAgICAgIChkYXRhID0gcGFyc2VMaXN0TWFya2VyKHBhcnNlciwgY3Vyck5vZGUpKSkge1xuICAgICAgICBwYXJzZXIuY2xvc2VVbm1hdGNoZWRCbG9ja3MoKTtcbiAgICAgICAgLy8gYWRkIHRoZSBsaXN0IGlmIG5lZWRlZFxuICAgICAgICBpZiAocGFyc2VyLnRpcC50eXBlICE9PSAnbGlzdCcgfHwgIWxpc3RzTWF0Y2goY3Vyck5vZGUubGlzdERhdGEsIGRhdGEpKSB7XG4gICAgICAgICAgICBjdXJyTm9kZSA9IHBhcnNlci5hZGRDaGlsZCgnbGlzdCcsIHBhcnNlci5uZXh0Tm9uc3BhY2UpO1xuICAgICAgICAgICAgY3Vyck5vZGUubGlzdERhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgbGlzdCBpdGVtXG4gICAgICAgIGN1cnJOb2RlID0gcGFyc2VyLmFkZENoaWxkKCdpdGVtJywgcGFyc2VyLm5leHROb25zcGFjZSk7XG4gICAgICAgIGN1cnJOb2RlLmxpc3REYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIDEgLyogQ29udGFpbmVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbi8vIGluZGVudGVkIGNvZGUgYmxvY2tcbnZhciBpbmRlbnRlZENvZGVCbG9jayA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICBpZiAocGFyc2VyLmluZGVudGVkICYmIHBhcnNlci50aXAudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiYgIXBhcnNlci5ibGFuaykge1xuICAgICAgICAvLyBpbmRlbnRlZCBjb2RlXG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KENPREVfSU5ERU5ULCB0cnVlKTtcbiAgICAgICAgcGFyc2VyLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgIHBhcnNlci5hZGRDaGlsZCgnY29kZUJsb2NrJywgcGFyc2VyLm9mZnNldCk7XG4gICAgICAgIHJldHVybiAyIC8qIExlYWYgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG59O1xudmFyIGJsb2NrU3RhcnRzID0gW1xuICAgIGJsb2NrUXVvdGUsXG4gICAgYXR4SGVhZGluZyxcbiAgICBmZW5jZWRDb2RlQmxvY2ssXG4gICAgaHRtbEJsb2NrLFxuICAgIHNlVGV4dEhlYWRpbmcsXG4gICAgdGhlbWF0aWNCcmVhayxcbiAgICBsaXN0SXRlbSxcbiAgICBpbmRlbnRlZENvZGVCbG9jayxcbiAgICB0YWJsZUhlYWQsXG4gICAgdGFibGVCb2R5LFxuICAgIGN1c3RvbUJsb2NrLFxuXTtcbi8vIGAtLS1gIGZvciBZQU1MLCBgKysrYCBmb3IgVE9NTCwgYDs7O2AgZm9yIEpTT05cbnZhciByZUZyb250TWF0dGVyID0gL14oLXszfXxcXCt7M318O3szfSkkLztcbnZhciBmcm9udE1hdHRlciQxID0gZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lLCBsaW5lTnVtYmVyID0gcGFyc2VyLmxpbmVOdW1iZXIsIGluZGVudGVkID0gcGFyc2VyLmluZGVudGVkO1xuICAgIGlmIChsaW5lTnVtYmVyID09PSAxICYmXG4gICAgICAgICFpbmRlbnRlZCAmJlxuICAgICAgICBjb250YWluZXIudHlwZSA9PT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICByZUZyb250TWF0dGVyLnRlc3QoY3VycmVudExpbmUpKSB7XG4gICAgICAgIHBhcnNlci5jbG9zZVVubWF0Y2hlZEJsb2NrcygpO1xuICAgICAgICB2YXIgZnJvbnRNYXR0ZXJfMSA9IHBhcnNlci5hZGRDaGlsZCgnZnJvbnRNYXR0ZXInLCBwYXJzZXIubmV4dE5vbnNwYWNlKTtcbiAgICAgICAgZnJvbnRNYXR0ZXJfMS5zdHJpbmdDb250ZW50ID0gY3VycmVudExpbmU7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5hZHZhbmNlT2Zmc2V0KGN1cnJlbnRMaW5lLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gMiAvKiBMZWFmICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBOb25lICovO1xufTtcbnZhciBmcm9udE1hdHRlciA9IHtcbiAgICBjb250aW51ZTogZnVuY3Rpb24gKHBhcnNlciwgY29udGFpbmVyKSB7XG4gICAgICAgIHZhciBsaW5lID0gcGFyc2VyLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKHJlRnJvbnRNYXR0ZXIpO1xuICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgPT09ICdmcm9udE1hdHRlcicgJiYgbWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5zdHJpbmdDb250ZW50ICs9IGxpbmU7XG4gICAgICAgICAgICBwYXJzZXIubGFzdExpbmVMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBwYXJzZXIuZmluYWxpemUoY29udGFpbmVyLCBwYXJzZXIubGluZU51bWJlcik7XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBGaW5pc2hlZCAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMCAvKiBHbyAqLztcbiAgICB9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoXywgYmxvY2spIHtcbiAgICAgICAgaWYgKGJsb2NrLnN0cmluZ0NvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5saXRlcmFsID0gYmxvY2suc3RyaW5nQ29udGVudDtcbiAgICAgICAgYmxvY2suc3RyaW5nQ29udGVudCA9IG51bGw7XG4gICAgfSxcbiAgICBjYW5Db250YWluOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2VwdHNMaW5lczogdHJ1ZSxcbn07XG52YXIgcmVIdG1sQmxvY2tDbG9zZSA9IFtcbiAgICAvLi8sXG4gICAgLzxcXC8oPzpzY3JpcHR8cHJlfHN0eWxlKT4vaSxcbiAgICAvLS0+LyxcbiAgICAvXFw/Pi8sXG4gICAgLz4vLFxuICAgIC9cXF1cXF0+Lyxcbl07XG52YXIgcmVNYXliZVNwZWNpYWwgPSAvXlsjYH4qK189PD4wLTktOyRdLztcbnZhciByZUxpbmVFbmRpbmckMSA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBlc21fZG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUoJ2RvY3VtZW50JywgW1xuICAgICAgICBbMSwgMV0sXG4gICAgICAgIFswLCAwXSxcbiAgICBdKTtcbn1cbnZhciBkZWZhdWx0T3B0aW9ucyQxID0ge1xuICAgIHNtYXJ0OiBmYWxzZSxcbiAgICB0YWdGaWx0ZXI6IGZhbHNlLFxuICAgIGV4dGVuZGVkQXV0b2xpbmtzOiBmYWxzZSxcbiAgICBkaXNhbGxvd2VkSHRtbEJsb2NrVGFnczogW10sXG4gICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgZGlzYWxsb3dEZWVwSGVhZGluZzogZmFsc2UsXG4gICAgY3VzdG9tUGFyc2VyOiBudWxsLFxuICAgIGZyb250TWF0dGVyOiBmYWxzZSxcbn07XG52YXIgUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGVzbV9hc3NpZ24oZXNtX2Fzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMkMSksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRvYyA9IGVzbV9kb2N1bWVudCgpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLm9sZHRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSAwO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB0aGlzLmluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxhbmsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbENsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5yZWZNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwID0ge307XG4gICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZnJvbnRNYXR0ZXIpIHtcbiAgICAgICAgICAgIGJsb2NrSGFuZGxlcnMuZnJvbnRNYXR0ZXIgPSBmcm9udE1hdHRlcjtcbiAgICAgICAgICAgIGJsb2NrU3RhcnRzLnVuc2hpZnQoZnJvbnRNYXR0ZXIkMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIgPSBuZXcgSW5saW5lUGFyc2VyKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU9mZnNldCA9IGZ1bmN0aW9uIChjb3VudCwgY29sdW1ucykge1xuICAgICAgICBpZiAoY29sdW1ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb2x1bW5zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gdGhpcy5jdXJyZW50TGluZTtcbiAgICAgICAgdmFyIGNoYXJzVG9UYWIsIGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCAmJiAoYyA9IGN1cnJlbnRMaW5lW3RoaXMub2Zmc2V0XSkpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIGNoYXJzVG9UYWIgPSA0IC0gKHRoaXMuY29sdW1uICUgNCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGNoYXJzVG9UYWIgPiBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNUb0FkdmFuY2UgPSBjaGFyc1RvVGFiID4gY291bnQgPyBjb3VudCA6IGNoYXJzVG9UYWI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSB0aGlzLnBhcnRpYWxseUNvbnN1bWVkVGFiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IGNoYXJzVG9BZHZhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiArPSBjaGFyc1RvVGFiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uICs9IDE7IC8vIGFzc3VtZSBhc2NpaTsgYmxvY2sgc3RhcnRzIGFyZSBhc2NpaVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuYWR2YW5jZU5leHROb25zcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLm5leHROb25zcGFjZTtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSB0aGlzLm5leHROb25zcGFjZUNvbHVtbjtcbiAgICAgICAgdGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYiA9IGZhbHNlO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5maW5kTmV4dE5vbnNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudExpbmUgPSB0aGlzLmN1cnJlbnRMaW5lO1xuICAgICAgICB2YXIgaSA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgY29scyA9IHRoaXMuY29sdW1uO1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKChjID0gY3VycmVudExpbmUuY2hhckF0KGkpKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29scyArPSA0IC0gKGNvbHMgJSA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxhbmsgPSBjID09PSAnXFxuJyB8fCBjID09PSAnXFxyJyB8fCBjID09PSAnJztcbiAgICAgICAgdGhpcy5uZXh0Tm9uc3BhY2UgPSBpO1xuICAgICAgICB0aGlzLm5leHROb25zcGFjZUNvbHVtbiA9IGNvbHM7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gdGhpcy5uZXh0Tm9uc3BhY2VDb2x1bW4gLSB0aGlzLmNvbHVtbjtcbiAgICAgICAgdGhpcy5pbmRlbnRlZCA9IHRoaXMuaW5kZW50ID49IENPREVfSU5ERU5UO1xuICAgIH07XG4gICAgLy8gQWRkIGEgbGluZSB0byB0aGUgYmxvY2sgYXQgdGhlIHRpcC4gIFdlIGFzc3VtZSB0aGUgdGlwXG4gICAgLy8gY2FuIGFjY2VwdCBsaW5lcyAtLSB0aGF0IGNoZWNrIHNob3VsZCBiZSBkb25lIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsbHlDb25zdW1lZFRhYikge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTsgLy8gc2tpcCBvdmVyIHRhYlxuICAgICAgICAgICAgLy8gYWRkIHNwYWNlIGNoYXJhY3RlcnM6XG4gICAgICAgICAgICB2YXIgY2hhcnNUb1RhYiA9IDQgLSAodGhpcy5jb2x1bW4gJSA0KTtcbiAgICAgICAgICAgIHRoaXMudGlwLnN0cmluZ0NvbnRlbnQgKz0gcmVwZWF0KCcgJywgY2hhcnNUb1RhYik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGlwLmxpbmVPZmZzZXRzKSB7XG4gICAgICAgICAgICB0aGlzLnRpcC5saW5lT2Zmc2V0cy5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGlwLmxpbmVPZmZzZXRzID0gW3RoaXMub2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcC5zdHJpbmdDb250ZW50ICs9IHRoaXMuY3VycmVudExpbmUuc2xpY2UodGhpcy5vZmZzZXQpICsgXCJcXG5cIjtcbiAgICB9O1xuICAgIC8vIEFkZCBibG9jayBvZiB0eXBlIHRhZyBhcyBhIGNoaWxkIG9mIHRoZSB0aXAuICBJZiB0aGUgdGlwIGNhbid0XG4gICAgLy8gYWNjZXB0IGNoaWxkcmVuLCBjbG9zZSBhbmQgZmluYWxpemUgaXQgYW5kIHRyeSBpdHMgcGFyZW50LFxuICAgIC8vIGFuZCBzbyBvbiB0aWwgd2UgZmluZCBhIGJsb2NrIHRoYXQgY2FuIGFjY2VwdCBjaGlsZHJlbi5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKHRhZywgb2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlICghYmxvY2tIYW5kbGVyc1t0aGlzLnRpcC50eXBlXS5jYW5Db250YWluKHRhZykpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemUodGhpcy50aXAsIHRoaXMubGluZU51bWJlciAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBvZmZzZXQgKyAxOyAvLyBvZmZzZXQgMCA9IGNvbHVtbiAxXG4gICAgICAgIHZhciBuZXdCbG9jayA9IGNyZWF0ZU5vZGUodGFnLCBbXG4gICAgICAgICAgICBbdGhpcy5saW5lTnVtYmVyLCBjb2x1bW5OdW1iZXJdLFxuICAgICAgICAgICAgWzAsIDBdLFxuICAgICAgICBdKTtcbiAgICAgICAgbmV3QmxvY2suc3RyaW5nQ29udGVudCA9ICcnO1xuICAgICAgICB0aGlzLnRpcC5hcHBlbmRDaGlsZChuZXdCbG9jayk7XG4gICAgICAgIHRoaXMudGlwID0gbmV3QmxvY2s7XG4gICAgICAgIHJldHVybiBuZXdCbG9jaztcbiAgICB9O1xuICAgIC8vIEZpbmFsaXplIGFuZCBjbG9zZSBhbnkgdW5tYXRjaGVkIGJsb2Nrcy5cbiAgICBQYXJzZXIucHJvdG90eXBlLmNsb3NlVW5tYXRjaGVkQmxvY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsQ2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5vbGR0aXAgIT09IHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLm9sZHRpcC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLm9sZHRpcCwgdGhpcy5saW5lTnVtYmVyIC0gMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGR0aXAgPSBwYXJlbnRfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxsQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRmluYWxpemUgYSBibG9jay4gIENsb3NlIGl0IGFuZCBkbyBhbnkgbmVjZXNzYXJ5IHBvc3Rwcm9jZXNzaW5nLFxuICAgIC8vIGUuZy4gY3JlYXRpbmcgc3RyaW5nQ29udGVudCBmcm9tIHN0cmluZ3MsIHNldHRpbmcgdGhlICd0aWdodCdcbiAgICAvLyBvciAnbG9vc2UnIHN0YXR1cyBvZiBhIGxpc3QsIGFuZCBwYXJzaW5nIHRoZSBiZWdpbm5pbmdzXG4gICAgLy8gb2YgcGFyYWdyYXBocyBmb3IgcmVmZXJlbmNlIGRlZmluaXRpb25zLiAgUmVzZXQgdGhlIHRpcCB0byB0aGVcbiAgICAvLyBwYXJlbnQgb2YgdGhlIGNsb3NlZCBibG9jay5cbiAgICBQYXJzZXIucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGJsb2NrLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHZhciBhYm92ZSA9IGJsb2NrLnBhcmVudDtcbiAgICAgICAgYmxvY2sub3BlbiA9IGZhbHNlO1xuICAgICAgICBibG9jay5zb3VyY2Vwb3NbMV0gPSBbbGluZU51bWJlciwgdGhpcy5sYXN0TGluZUxlbmd0aF07XG4gICAgICAgIGJsb2NrSGFuZGxlcnNbYmxvY2sudHlwZV0uZmluYWxpemUodGhpcywgYmxvY2spO1xuICAgICAgICB0aGlzLnRpcCA9IGFib3ZlO1xuICAgIH07XG4gICAgLy8gV2FsayB0aHJvdWdoIGEgYmxvY2sgJiBjaGlsZHJlbiByZWN1cnNpdmVseSwgcGFyc2luZyBzdHJpbmcgY29udGVudFxuICAgIC8vIGludG8gaW5saW5lIGNvbnRlbnQgd2hlcmUgYXBwcm9wcmlhdGUuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzSW5saW5lcyA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgZXZlbnQ7XG4gICAgICAgIHZhciBjdXN0b21QYXJzZXIgPSB0aGlzLm9wdGlvbnMuY3VzdG9tUGFyc2VyO1xuICAgICAgICB2YXIgd2Fsa2VyID0gYmxvY2sud2Fsa2VyKCk7XG4gICAgICAgIHRoaXMuaW5saW5lUGFyc2VyLnJlZk1hcCA9IHRoaXMucmVmTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZMaW5rQ2FuZGlkYXRlTWFwID0gdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlci5yZWZEZWZDYW5kaWRhdGVNYXAgPSB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgICAgICB2YXIgdCA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJzZXIgJiYgY3VzdG9tUGFyc2VyW3RdKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tUGFyc2VyW3RdKG5vZGUsIHsgZW50ZXJpbmc6IGVudGVyaW5nLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVudGVyaW5nICYmXG4gICAgICAgICAgICAgICAgKHQgPT09ICdwYXJhZ3JhcGgnIHx8XG4gICAgICAgICAgICAgICAgICAgIHQgPT09ICdoZWFkaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAodCA9PT0gJ3RhYmxlQ2VsbCcgJiYgIW5vZGUuaWdub3JlZCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVQYXJzZXIucGFyc2Uobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFuYWx5emUgYSBsaW5lIG9mIHRleHQgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgYXBwcm9wcmlhdGVseS5cbiAgICAvLyBXZSBwYXJzZSBtYXJrZG93biB0ZXh0IGJ5IGNhbGxpbmcgdGhpcyBvbiBlYWNoIGxpbmUgb2YgaW5wdXQsXG4gICAgLy8gdGhlbiBmaW5hbGl6aW5nIHRoZSBkb2N1bWVudC5cbiAgICBQYXJzZXIucHJvdG90eXBlLmluY29ycG9yYXRlTGluZSA9IGZ1bmN0aW9uIChsbikge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMub2xkdGlwID0gdGhpcy50aXA7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5jb2x1bW4gPSAwO1xuICAgICAgICB0aGlzLmJsYW5rID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbGx5Q29uc3VtZWRUYWIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lTnVtYmVyICs9IDE7XG4gICAgICAgIC8vIHJlcGxhY2UgTlVMIGNoYXJhY3RlcnMgZm9yIHNlY3VyaXR5XG4gICAgICAgIGlmIChsbi5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICBsbiA9IGxuLnJlcGxhY2UoL1xcMC9nLCAnXFx1RkZGRCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUgPSBsbjtcbiAgICAgICAgLy8gRm9yIGVhY2ggY29udGFpbmluZyBibG9jaywgdHJ5IHRvIHBhcnNlIHRoZSBhc3NvY2lhdGVkIGxpbmUgc3RhcnQuXG4gICAgICAgIC8vIEJhaWwgb3V0IG9uIGZhaWx1cmU6IGNvbnRhaW5lciB3aWxsIHBvaW50IHRvIHRoZSBsYXN0IG1hdGNoaW5nIGJsb2NrLlxuICAgICAgICAvLyBTZXQgYWxsTWF0Y2hlZCB0byBmYWxzZSBpZiBub3QgYWxsIGNvbnRhaW5lcnMgbWF0Y2guXG4gICAgICAgIHZhciBhbGxNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKChsYXN0Q2hpbGQgPSBjb250YWluZXIubGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3Blbikge1xuICAgICAgICAgICAgY29udGFpbmVyID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5maW5kTmV4dE5vbnNwYWNlKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGJsb2NrSGFuZGxlcnNbY29udGFpbmVyLnR5cGVdWydjb250aW51ZSddKHRoaXMsIGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogR28gKi86IC8vIHdlJ3ZlIG1hdGNoZWQsIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFN0b3AgKi86IC8vIHdlJ3ZlIGZhaWxlZCB0byBtYXRjaCBhIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGFsbE1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIEZpbmlzaGVkICovOiAvLyB3ZSd2ZSBoaXQgZW5kIG9mIGxpbmUgZm9yIGZlbmNlZCBjb2RlIGNsb3NlIGFuZCBjYW4gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdExpbmVMZW5ndGggPSBsbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRpbnVlIHJldHVybmVkIGlsbGVnYWwgdmFsdWUsIG11c3QgYmUgMCwgMSwgb3IgMicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudDsgLy8gYmFjayB1cCB0byBsYXN0IG1hdGNoaW5nIGJsb2NrXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxDbG9zZWQgPSBjb250YWluZXIgPT09IHRoaXMub2xkdGlwO1xuICAgICAgICB0aGlzLmxhc3RNYXRjaGVkQ29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB2YXIgbWF0Y2hlZExlYWYgPSBjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiYgYmxvY2tIYW5kbGVyc1tjb250YWluZXIudHlwZV0uYWNjZXB0c0xpbmVzO1xuICAgICAgICB2YXIgYmxvY2tTdGFydHNMZW4gPSBibG9ja1N0YXJ0cy5sZW5ndGg7XG4gICAgICAgIC8vIFVubGVzcyBsYXN0IG1hdGNoZWQgY29udGFpbmVyIGlzIGEgY29kZSBibG9jaywgdHJ5IG5ldyBjb250YWluZXIgc3RhcnRzLFxuICAgICAgICAvLyBhZGRpbmcgY2hpbGRyZW4gdG8gdGhlIGxhc3QgbWF0Y2hlZCBjb250YWluZXI6XG4gICAgICAgIHdoaWxlICghbWF0Y2hlZExlYWYpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZE5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGxpdHRsZSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnR5cGUgIT09ICd0YWJsZScgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHlwZSAhPT0gJ3RhYmxlQm9keScgJiZcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHlwZSAhPT0gJ3BhcmFncmFwaCcgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pbmRlbnRlZCAmJlxuICAgICAgICAgICAgICAgICFyZU1heWJlU3BlY2lhbC50ZXN0KGxuLnNsaWNlKHRoaXMubmV4dE5vbnNwYWNlKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgYmxvY2tTdGFydHNMZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gYmxvY2tTdGFydHNbaV0odGhpcywgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzID09PSAxIC8qIENvbnRhaW5lciAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLnRpcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcyA9PT0gMiAvKiBMZWFmICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMudGlwO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkTGVhZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBibG9ja1N0YXJ0c0xlbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZU5leHROb25zcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoYXQgcmVtYWlucyBhdCB0aGUgb2Zmc2V0IGlzIGEgdGV4dCBsaW5lLiAgQWRkIHRoZSB0ZXh0IHRvIHRoZVxuICAgICAgICAvLyBhcHByb3ByaWF0ZSBjb250YWluZXIuXG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBhIGxhenkgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbjpcbiAgICAgICAgaWYgKCF0aGlzLmFsbENsb3NlZCAmJiAhdGhpcy5ibGFuayAmJiB0aGlzLnRpcC50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgLy8gbGF6eSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCBhIGxhenkgY29udGludWF0aW9uXG4gICAgICAgICAgICAvLyBmaW5hbGl6ZSBhbnkgYmxvY2tzIG5vdCBtYXRjaGVkXG4gICAgICAgICAgICB0aGlzLmNsb3NlVW5tYXRjaGVkQmxvY2tzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ibGFuayAmJiBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmxhc3RDaGlsZC5sYXN0TGluZUJsYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gY29udGFpbmVyLnR5cGU7XG4gICAgICAgICAgICAvLyBCbG9jayBxdW90ZSBsaW5lcyBhcmUgbmV2ZXIgYmxhbmsgYXMgdGhleSBzdGFydCB3aXRoID5cbiAgICAgICAgICAgIC8vIGFuZCB3ZSBkb24ndCBjb3VudCBibGFua3MgaW4gZmVuY2VkIGNvZGUgZm9yIHB1cnBvc2VzIG9mIHRpZ2h0L2xvb3NlXG4gICAgICAgICAgICAvLyBsaXN0cyBvciBicmVha2luZyBvdXQgb2YgbGlzdHMuIFdlIGFsc28gZG9uJ3Qgc2V0IF9sYXN0TGluZUJsYW5rXG4gICAgICAgICAgICAvLyBvbiBhbiBlbXB0eSBsaXN0IGl0ZW0sIG9yIGlmIHdlIGp1c3QgY2xvc2VkIGEgZmVuY2VkIGJsb2NrLlxuICAgICAgICAgICAgdmFyIGxhc3RMaW5lQmxhbmsgPSB0aGlzLmJsYW5rICYmXG4gICAgICAgICAgICAgICAgISh0ID09PSAnYmxvY2tRdW90ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQ29kZUJsb2NrKGNvbnRhaW5lcikgJiYgY29udGFpbmVyLmlzRmVuY2VkKSB8fFxuICAgICAgICAgICAgICAgICAgICAodCA9PT0gJ2l0ZW0nICYmICFjb250YWluZXIuZmlyc3RDaGlsZCAmJiBjb250YWluZXIuc291cmNlcG9zWzBdWzBdID09PSB0aGlzLmxpbmVOdW1iZXIpKTtcbiAgICAgICAgICAgIC8vIHByb3BhZ2F0ZSBsYXN0TGluZUJsYW5rIHVwIHRocm91Z2ggcGFyZW50czpcbiAgICAgICAgICAgIHZhciBjb250ID0gY29udGFpbmVyO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnQpIHtcbiAgICAgICAgICAgICAgICBjb250Lmxhc3RMaW5lQmxhbmsgPSBsYXN0TGluZUJsYW5rO1xuICAgICAgICAgICAgICAgIGNvbnQgPSBjb250LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChibG9ja0hhbmRsZXJzW3RdLmFjY2VwdHNMaW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZSgpO1xuICAgICAgICAgICAgICAgIC8vIGlmIEh0bWxCbG9jaywgY2hlY2sgZm9yIGVuZCBjb25kaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaXNIdG1sQmxvY2soY29udGFpbmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuaHRtbEJsb2NrVHlwZSA+PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5odG1sQmxvY2tUeXBlIDw9IDUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVIdG1sQmxvY2tDbG9zZVtjb250YWluZXIuaHRtbEJsb2NrVHlwZV0udGVzdCh0aGlzLmN1cnJlbnRMaW5lLnNsaWNlKHRoaXMub2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TGluZUxlbmd0aCA9IGxuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbGl6ZShjb250YWluZXIsIHRoaXMubGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vZmZzZXQgPCBsbi5sZW5ndGggJiYgIXRoaXMuYmxhbmspIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgcGFyYWdyYXBoIGNvbnRhaW5lciBmb3IgbGluZVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuYWRkQ2hpbGQoJ3BhcmFncmFwaCcsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VOZXh0Tm9uc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gbG4ubGVuZ3RoO1xuICAgIH07XG4gICAgLy8gVGhlIG1haW4gcGFyc2luZyBmdW5jdGlvbi4gIFJldHVybnMgYSBwYXJzZWQgZG9jdW1lbnQgQVNULlxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoaW5wdXQsIGxpbmVUZXh0cykge1xuICAgICAgICB0aGlzLmRvYyA9IGVzbV9kb2N1bWVudCgpO1xuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuZG9jO1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSAwO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGluZXMgPSBpbnB1dC5zcGxpdChyZUxpbmVFbmRpbmckMSk7XG4gICAgICAgIHZhciBsZW4gPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lVGV4dHMgPyBsaW5lVGV4dHMgOiBsaW5lcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUmVmTWFwcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpID09PSBDX05FV0xJTkUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBsYXN0IGJsYW5rIGxpbmUgY3JlYXRlZCBieSBmaW5hbCBuZXdsaW5lXG4gICAgICAgICAgICBsZW4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudGlwKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsaXplKHRoaXMudGlwLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0lubGluZXModGhpcy5kb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2M7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnRpYWxQYXJzZVN0YXJ0ID0gZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmVzKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZXNtX2RvY3VtZW50KCk7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5kb2M7XG4gICAgICAgIHRoaXMubGluZU51bWJlciA9IGxpbmVOdW1iZXIgLSAxO1xuICAgICAgICB0aGlzLmxhc3RMaW5lTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICAgIHRoaXMubGFzdE1hdGNoZWRDb250YWluZXIgPSB0aGlzLmRvYztcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZSA9ICcnO1xuICAgICAgICB2YXIgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluY29ycG9yYXRlTGluZShsaW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VFeHRlbmRzID0gZnVuY3Rpb24gKGxpbmVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5jb3Jwb3JhdGVMaW5lKGxpbmVzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJ0aWFsUGFyc2VGaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnRpcCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZSh0aGlzLnRpcCwgdGhpcy5saW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NJbmxpbmVzKHRoaXMuZG9jKTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuc2V0UmVmTWFwcyA9IGZ1bmN0aW9uIChyZWZNYXAsIHJlZkxpbmtDYW5kaWRhdGVNYXAsIHJlZkRlZkNhbmRpZGF0ZU1hcCkge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHJlZk1hcDtcbiAgICAgICAgdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwID0gcmVmTGlua0NhbmRpZGF0ZU1hcDtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSByZWZEZWZDYW5kaWRhdGVNYXA7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmNsZWFyUmVmTWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgW3RoaXMucmVmTWFwLCB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAsIHRoaXMucmVmRGVmQ2FuZGlkYXRlTWFwXS5mb3JFYWNoKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGNsZWFyT2JqKG1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5mdW5jdGlvbiBjb21wYXJlUG9zKHAxLCBwMikge1xuICAgIGlmIChwMVswXSA8IHAyWzBdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMF0gPiBwMlswXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIGlmIChwMVsxXSA8IHAyWzFdKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAocDFbMV0gPiBwMlsxXSkge1xuICAgICAgICByZXR1cm4gLTEgLyogR1QgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIEVRICovO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlQW5kUG9zKF9hLCBwb3MpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGNvbXBhcmVQb3MoZW5kUG9zLCBwb3MpID09PSAxIC8qIExUICovKSB7XG4gICAgICAgIHJldHVybiAxIC8qIExUICovO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZVBvcyhzdGFydFBvcywgcG9zKSA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIHJlbW92ZU5leHRVbnRpbChub2RlLCBsYXN0KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ICE9PSBsYXN0LnBhcmVudCB8fCBub2RlID09PSBsYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPT0gbGFzdCkge1xuICAgICAgICB2YXIgdGVtcCA9IG5leHQubmV4dDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsncGFyZW50JywgJ3ByZXYnLCAnbmV4dCddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAobmV4dFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVCeUlkKG5leHRbdHlwZV0uaWQpO1xuICAgICAgICAgICAgICAgIG5leHRbdHlwZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQgPSB0ZW1wO1xuICAgIH1cbiAgICBub2RlLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgaWYgKGxhc3QubmV4dCkge1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnBhcmVudC5sYXN0Q2hpbGQgPSBub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkTm9kZXMocGFyZW50KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGN1cnIgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgICBub2Rlcy5wdXNoKGN1cnIpO1xuICAgICAgICBjdXJyID0gY3Vyci5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59XG5mdW5jdGlvbiBpbnNlcnROb2Rlc0JlZm9yZSh0YXJnZXQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBub2Rlc18xID0gbm9kZXM7IF9pIDwgbm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc18xW19pXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVwZW5kQ2hpbGROb2RlcyhwYXJlbnQsIG5vZGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHBhcmVudC5wcmVwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhiYXNlLCBkaWZmKSB7XG4gICAgaWYgKCFiYXNlIHx8ICFiYXNlLnBhcmVudCB8fCBkaWZmID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhbGtlciA9IGJhc2UucGFyZW50LndhbGtlcigpO1xuICAgIHdhbGtlci5yZXN1bWVBdChiYXNlLCB0cnVlKTtcbiAgICB2YXIgZXZlbnQ7XG4gICAgd2hpbGUgKChldmVudCA9IHdhbGtlci5uZXh0KCkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICBub2RlLnNvdXJjZXBvc1swXVswXSArPSBkaWZmO1xuICAgICAgICAgICAgbm9kZS5zb3VyY2Vwb3NbMV1bMF0gKz0gZGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBhcmVSYW5nZUFuZExpbmUoX2EsIGxpbmUpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSBfYVswXSwgZW5kUG9zID0gX2FbMV07XG4gICAgaWYgKGVuZFBvc1swXSA8IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIDEgLyogTFQgKi87XG4gICAgfVxuICAgIGlmIChzdGFydFBvc1swXSA+IGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIC0xIC8qIEdUICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBFUSAqLztcbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZE5vZGVBdExpbmUocGFyZW50LCBsaW5lKSB7XG4gICAgdmFyIG5vZGUgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZExpbmUobm9kZS5zb3VyY2Vwb3MsIGxpbmUpO1xuICAgICAgICBpZiAoY29tcCA9PT0gMCAvKiBFUSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICAvLyBUbyBjb25zaWRlciB0aGF0IHRvcCBsaW5lIGlzIGJsYW5rIGxpbmVcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByZXYgfHwgbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Lmxhc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGxhc3RMZWFmTm9kZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzYW1lTGluZVRvcEFuY2VzdG9yKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQgJiZcbiAgICAgICAgbm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50JyAmJlxuICAgICAgICBub2RlLnBhcmVudC5zb3VyY2Vwb3NbMF1bMF0gPT09IG5vZGUuc291cmNlcG9zWzBdWzBdKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3ROb2RlQXRMaW5lKHBhcmVudCwgbGluZSkge1xuICAgIHZhciBub2RlID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBjb21wID0gY29tcGFyZVJhbmdlQW5kTGluZShub2RlLnNvdXJjZXBvcywgbGluZSk7XG4gICAgICAgIGlmIChjb21wID09PSAwIC8qIEVRICovKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zb3VyY2Vwb3NbMF1bMF0gPT09IGxpbmUgfHwgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPT09IC0xIC8qIEdUICovKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldikge1xuICAgICAgICByZXR1cm4gc2FtZUxpbmVUb3BBbmNlc3RvcihsYXN0TGVhZk5vZGUocHJldikpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlQXRQb3NpdGlvbihwYXJlbnQsIHBvcykge1xuICAgIHZhciBub2RlID0gcGFyZW50O1xuICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBhcmVSYW5nZUFuZFBvcyhub2RlLnNvdXJjZXBvcywgcG9zKTtcbiAgICAgICAgaWYgKGNvbXAgPT09IDAgLyogRVEgKi8pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcCA9PT0gLTEgLyogR1QgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmV4dCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZmluZE5vZGVCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGdldE5vZGVCeUlkKGlkKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gaW52b2tlTmV4dFVudGlsKGNhbGxiYWNrLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVuZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGFydCkge1xuICAgICAgICB2YXIgd2Fsa2VyID0gc3RhcnQud2Fsa2VyKCk7XG4gICAgICAgIHdoaWxlIChzdGFydCAmJiBzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGFydCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHdhbGtlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV4dC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1VubGlua2VkKGlkKSB7XG4gICAgdmFyIG5vZGUgPSBmaW5kTm9kZUJ5SWQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgbm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudCAmJiAhbm9kZS5wcmV2ICYmICFub2RlLm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHJlTGluZUVuZGluZyA9IC9cXHJcXG58XFxufFxcci87XG5mdW5jdGlvbiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKGxpbmVUZXh0KSB7XG4gICAgdmFyIHNwYWNlTWF0Y2ggPSBsaW5lVGV4dC5tYXRjaCgvXlsgXFx0XSsvKTtcbiAgICBpZiAoc3BhY2VNYXRjaCAmJiAoc3BhY2VNYXRjaFswXS5sZW5ndGggPj0gMiB8fCAvXFx0Ly50ZXN0KHNwYWNlTWF0Y2hbMF0pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlZnRUcmltbWVkID0gc3BhY2VNYXRjaCA/IGxpbmVUZXh0LnNsaWNlKHNwYWNlTWF0Y2gubGVuZ3RoKSA6IGxpbmVUZXh0O1xuICAgIHJldHVybiByZUJ1bGxldExpc3RNYXJrZXIudGVzdChsZWZ0VHJpbW1lZCkgfHwgcmVPcmRlcmVkTGlzdE1hcmtlci50ZXN0KGxlZnRUcmltbWVkKTtcbn1cbmZ1bmN0aW9uIGNhbkJlQ29udGludWVkVGFibGVCb2R5KGxpbmVUZXh0KSB7XG4gICAgcmV0dXJuICFpc0JsYW5rKGxpbmVUZXh0KSAmJiBsaW5lVGV4dC5pbmRleE9mKCd8JykgIT09IC0xO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmRGVmU3RhdGUobm9kZSkge1xuICAgIHZhciBpZCA9IG5vZGUuaWQsIHRpdGxlID0gbm9kZS50aXRsZSwgc291cmNlcG9zID0gbm9kZS5zb3VyY2Vwb3MsIGRlc3QgPSBub2RlLmRlc3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIHNvdXJjZXBvczogc291cmNlcG9zLFxuICAgICAgICB1bmxpbmtlZDogZmFsc2UsXG4gICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIH07XG59XG52YXIgVG9hc3RNYXJrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0TWFyayhjb250ZW50cywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZk1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJlZkxpbmtDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZmVyZW5jZURlZmluaXRpb24pO1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGFyc2VyLnNldFJlZk1hcHModGhpcy5yZWZNYXAsIHRoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgdGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcCA9IHsgY2hhbmdlOiBbXSB9O1xuICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzIHx8ICcnO1xuICAgICAgICB0aGlzLmxpbmVUZXh0cyA9IGNvbnRlbnRzLnNwbGl0KHJlTGluZUVuZGluZyk7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGFyc2VyLnBhcnNlKGNvbnRlbnRzLCB0aGlzLmxpbmVUZXh0cyk7XG4gICAgfVxuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlTGluZVRleHRzID0gZnVuY3Rpb24gKHN0YXJ0UG9zLCBlbmRQb3MsIG5ld1RleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgc3RhcnRMaW5lID0gc3RhcnRQb3NbMF0sIHN0YXJ0Q29sID0gc3RhcnRQb3NbMV07XG4gICAgICAgIHZhciBlbmRMaW5lID0gZW5kUG9zWzBdLCBlbmRDb2wgPSBlbmRQb3NbMV07XG4gICAgICAgIHZhciBuZXdMaW5lcyA9IG5ld1RleHQuc3BsaXQocmVMaW5lRW5kaW5nKTtcbiAgICAgICAgdmFyIG5ld0xpbmVMZW4gPSBuZXdMaW5lcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdGFydExpbmVUZXh0ID0gdGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV07XG4gICAgICAgIHZhciBlbmRMaW5lVGV4dCA9IHRoaXMubGluZVRleHRzW2VuZExpbmUgLSAxXTtcbiAgICAgICAgbmV3TGluZXNbMF0gPSBzdGFydExpbmVUZXh0LnNsaWNlKDAsIHN0YXJ0Q29sIC0gMSkgKyBuZXdMaW5lc1swXTtcbiAgICAgICAgbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdID0gbmV3TGluZXNbbmV3TGluZUxlbiAtIDFdICsgZW5kTGluZVRleHQuc2xpY2UoZW5kQ29sIC0gMSk7XG4gICAgICAgIHZhciByZW1vdmVkTGluZUxlbiA9IGVuZExpbmUgLSBzdGFydExpbmUgKyAxO1xuICAgICAgICAoX2EgPSB0aGlzLmxpbmVUZXh0cykuc3BsaWNlLmFwcGx5KF9hLCBlc21fc3ByZWFkQXJyYXkoW3N0YXJ0TGluZSAtIDEsIHJlbW92ZWRMaW5lTGVuXSwgbmV3TGluZXMpKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVMZW4gLSByZW1vdmVkTGluZUxlbjtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUudXBkYXRlUm9vdE5vZGVTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVRleHRzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmxpbmVUZXh0c1swXSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5sYXN0TGluZUJsYW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zb3VyY2Vwb3MgPSBbXG4gICAgICAgICAgICAgICAgWzEsIDFdLFxuICAgICAgICAgICAgICAgIFsxLCAwXSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm9vdC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5sYXN0TGluZUJsYW5rID0gdGhpcy5yb290Lmxhc3RDaGlsZC5sYXN0TGluZUJsYW5rO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lVGV4dHMgPSB0aGlzLmxpbmVUZXh0cztcbiAgICAgICAgdmFyIGlkeCA9IGxpbmVUZXh0cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGluZVRleHRzW2lkeF0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZHggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVRleHRzLmxlbmd0aCAtIDIgPiBpZHgpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2Vwb3NbMV0gPSBbaWR4ICsgMSwgbGluZVRleHRzW2lkeF0ubGVuZ3RoXTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVJhbmdlTm9kZXMgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlLCBuZXdOb2Rlcykge1xuICAgICAgICBpZiAoIXN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKGVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnROb2Rlc0JlZm9yZShlbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZUJ5SWQoZW5kTm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgZW5kTm9kZS51bmxpbmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXBlbmRDaGlsZE5vZGVzKHRoaXMucm9vdCwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0Tm9kZXNCZWZvcmUoc3RhcnROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgICAgICByZW1vdmVOZXh0VW50aWwoc3RhcnROb2RlLCBlbmROb2RlKTtcbiAgICAgICAgICAgIFtzdGFydE5vZGUuaWQsIGVuZE5vZGUuaWRdLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZW1vdmVOb2RlQnlJZChpZCk7IH0pO1xuICAgICAgICAgICAgc3RhcnROb2RlLnVubGluaygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldE5vZGVSYW5nZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICAgIHZhciBzdGFydE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgc3RhcnRQb3NbMF0pO1xuICAgICAgICB2YXIgZW5kTm9kZSA9IGZpbmRDaGlsZE5vZGVBdExpbmUodGhpcy5yb290LCBlbmRQb3NbMF0pO1xuICAgICAgICAvLyBleHRlbmQgbm9kZSByYW5nZSB0byBpbmNsdWRlIGEgZm9sbG93aW5nIGJsb2NrIHdoaWNoIGRvZXNuJ3QgaGF2ZSBwcmVjZWRpbmcgYmxhbmsgbGluZVxuICAgICAgICBpZiAoZW5kTm9kZSAmJiBlbmROb2RlLm5leHQgJiYgZW5kUG9zWzBdICsgMSA9PT0gZW5kTm9kZS5uZXh0LnNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICAgICAgZW5kTm9kZSA9IGVuZE5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3N0YXJ0Tm9kZSwgZW5kTm9kZV07XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBwYXJhbSkge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZXh0ZW5kRW5kTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmxpbmVUZXh0c1tsaW5lXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICAgICAgICAvLyBleHRlbmRzIHN0YXJ0aW5nIHJhbmdlIGlmIHRoZSBmaXJzdCBub2RlIGNhbiBiZSBhIGNvbnRpbnVlZCBsaXN0IGl0ZW1cbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJlxuICAgICAgICAgICAgc3RhcnROb2RlLnByZXYgJiZcbiAgICAgICAgICAgICgoaXNMaXN0KHN0YXJ0Tm9kZS5wcmV2KSAmJiBjYW5CZUNvbnRpbnVlZExpc3RJdGVtKHRoaXMubGluZVRleHRzW3N0YXJ0TGluZSAtIDFdKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNUYWJsZShzdGFydE5vZGUucHJldikgJiYgY2FuQmVDb250aW51ZWRUYWJsZUJvZHkodGhpcy5saW5lVGV4dHNbc3RhcnRMaW5lIC0gMV0pKSkpIHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS5wcmV2O1xuICAgICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdGVkTGluZXMgPSB0aGlzLmxpbmVUZXh0cy5zbGljZShzdGFydExpbmUgLSAxLCBlbmRMaW5lKTtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnBhcnNlci5wYXJ0aWFsUGFyc2VTdGFydChzdGFydExpbmUsIGVkaXRlZExpbmVzKTtcbiAgICAgICAgLy8gZXh0ZW5kcyBlbmRpbmcgcmFuZ2UgaWYgdGhlIGZvbGxvd2luZyBub2RlIGNhbiBiZSBhIGZlbmNlZCBjb2RlIGJsb2NrIG9yIGEgY29udGludWVkIGxpc3QgaXRlbVxuICAgICAgICB2YXIgbmV4dE5vZGUgPSBlbmROb2RlID8gZW5kTm9kZS5uZXh0IDogdGhpcy5yb290LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBsYXN0Q2hpbGQgPSByb290Lmxhc3RDaGlsZDtcbiAgICAgICAgdmFyIGlzT3BlbmVkTGFzdENoaWxkQ29kZUJsb2NrID0gbGFzdENoaWxkICYmIGlzQ29kZUJsb2NrKGxhc3RDaGlsZCkgJiYgbGFzdENoaWxkLm9wZW47XG4gICAgICAgIHZhciBpc09wZW5lZExhc3RDaGlsZEN1c3RvbUJsb2NrID0gbGFzdENoaWxkICYmIGlzQ3VzdG9tQmxvY2sobGFzdENoaWxkKSAmJiBsYXN0Q2hpbGQub3BlbjtcbiAgICAgICAgdmFyIGlzTGFzdENoaWxkTGlzdCA9IGxhc3RDaGlsZCAmJiBpc0xpc3QobGFzdENoaWxkKTtcbiAgICAgICAgd2hpbGUgKCgoaXNPcGVuZWRMYXN0Q2hpbGRDb2RlQmxvY2sgfHwgaXNPcGVuZWRMYXN0Q2hpbGRDdXN0b21CbG9jaykgJiYgbmV4dE5vZGUpIHx8XG4gICAgICAgICAgICAoaXNMYXN0Q2hpbGRMaXN0ICYmIG5leHROb2RlICYmIChuZXh0Tm9kZS50eXBlID09PSAnbGlzdCcgfHwgbmV4dE5vZGUuc291cmNlcG9zWzBdWzFdID49IDIpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZExpbmUgPSB0aGlzLmV4dGVuZEVuZExpbmUobmV4dE5vZGUuc291cmNlcG9zWzFdWzBdKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLnBhcnRpYWxQYXJzZUV4dGVuZHModGhpcy5saW5lVGV4dHMuc2xpY2UoZW5kTGluZSwgbmV3RW5kTGluZSkpO1xuICAgICAgICAgICAgaWYgKCFzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSBlbmROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kTm9kZSA9IG5leHROb2RlO1xuICAgICAgICAgICAgZW5kTGluZSA9IG5ld0VuZExpbmU7XG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZXIucGFydGlhbFBhcnNlRmluaXNoKCk7XG4gICAgICAgIHZhciBuZXdOb2RlcyA9IGdldENoaWxkTm9kZXMocm9vdCk7XG4gICAgICAgIHJldHVybiB7IG5ld05vZGVzOiBuZXdOb2RlcywgZXh0U3RhcnROb2RlOiBzdGFydE5vZGUsIGV4dEVuZE5vZGU6IGVuZE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZ2V0UmVtb3ZlZE5vZGVSYW5nZSA9IGZ1bmN0aW9uIChleHRTdGFydE5vZGUsIGV4dEVuZE5vZGUpIHtcbiAgICAgICAgaWYgKCFleHRTdGFydE5vZGUgfHxcbiAgICAgICAgICAgIChleHRTdGFydE5vZGUgJiYgaXNSZWZEZWYoZXh0U3RhcnROb2RlKSkgfHxcbiAgICAgICAgICAgIChleHRFbmROb2RlICYmIGlzUmVmRGVmKGV4dEVuZE5vZGUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBbZXh0U3RhcnROb2RlLmlkLCBleHRFbmROb2RlLmlkXSxcbiAgICAgICAgICAgIGxpbmU6IFtleHRTdGFydE5vZGUuc291cmNlcG9zWzBdWzBdIC0gMSwgZXh0RW5kTm9kZS5zb3VyY2Vwb3NbMV1bMF0gLSAxXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUubWFya0RlbGV0ZWRSZWZNYXAgPSBmdW5jdGlvbiAoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIHZhciBtYXJrRGVsZXRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmRGVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtub2RlLmxhYmVsXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkRlZlN0YXRlICYmIG5vZGUuaWQgPT09IHJlZkRlZlN0YXRlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZEZWZTdGF0ZS51bmxpbmtlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dFN0YXJ0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChtYXJrRGVsZXRlZCwgZXh0U3RhcnROb2RlLnBhcmVudCwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0RW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGludm9rZU5leHRVbnRpbChtYXJrRGVsZXRlZCwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVdpdGhOZXdSZWZEZWZTdGF0ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZVdpdGhfMSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmRGVmKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGUubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZEZWZTdGF0ZSA9IF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVmRGVmU3RhdGUgfHwgcmVmRGVmU3RhdGUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZk1hcFtsYWJlbF0gPSBjcmVhdGVSZWZEZWZTdGF0ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlTmV4dFVudGlsKHJlcGxhY2VXaXRoXzEsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucmVwbGFjZVdpdGhSZWZEZWZDYW5kaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChfLCBjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBjYW5kaWRhdGUubGFiZWwsIHNvdXJjZXBvcyA9IGNhbmRpZGF0ZS5zb3VyY2Vwb3M7XG4gICAgICAgICAgICAgICAgdmFyIHJlZkRlZlN0YXRlID0gX3RoaXMucmVmTWFwW2xhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZkRlZlN0YXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnVubGlua2VkIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZkRlZlN0YXRlLnNvdXJjZXBvc1swXVswXSA+IHNvdXJjZXBvc1swXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZNYXBbbGFiZWxdID0gY3JlYXRlUmVmRGVmU3RhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSYW5nZVdpdGhSZWZEZWYgPSBmdW5jdGlvbiAoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydE5vZGUsIGVuZE5vZGUsIGxpbmVEaWZmKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZURlZmluaXRpb24gJiYgIWlzRW1wdHlPYmoodGhpcy5yZWZNYXApKSB7XG4gICAgICAgICAgICB2YXIgcHJldk5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgc3RhcnRMaW5lIC0gMSk7XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBmaW5kQ2hpbGROb2RlQXRMaW5lKHRoaXMucm9vdCwgZW5kTGluZSArIDEpO1xuICAgICAgICAgICAgaWYgKHByZXZOb2RlICYmIGlzUmVmRGVmKHByZXZOb2RlKSAmJiBwcmV2Tm9kZSAhPT0gc3RhcnROb2RlICYmIHByZXZOb2RlICE9PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnROb2RlLnNvdXJjZXBvc1swXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJiBpc1JlZkRlZihuZXh0Tm9kZSkgJiYgbmV4dE5vZGUgIT09IHN0YXJ0Tm9kZSAmJiBuZXh0Tm9kZSAhPT0gZW5kTm9kZSkge1xuICAgICAgICAgICAgICAgIGVuZE5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICBlbmRMaW5lID0gdGhpcy5leHRlbmRFbmRMaW5lKGVuZE5vZGUuc291cmNlcG9zWzFdWzBdICsgbGluZURpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RhcnROb2RlLCBlbmROb2RlLCBzdGFydExpbmUsIGVuZExpbmVdO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZikge1xuICAgICAgICBpZiAobGluZURpZmYgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbGluZURpZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Tm9kZVJhbmdlKHN0YXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gcmFuZ2VbMF0sIGVuZE5vZGUgPSByYW5nZVsxXTtcbiAgICAgICAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0Tm9kZSA/IE1hdGgubWluKHN0YXJ0Tm9kZS5zb3VyY2Vwb3NbMF1bMF0sIHN0YXJ0UG9zWzBdKSA6IHN0YXJ0UG9zWzBdO1xuICAgICAgICB2YXIgZW5kTGluZSA9IHRoaXMuZXh0ZW5kRW5kTGluZSgoZW5kTm9kZSA/IE1hdGgubWF4KGVuZE5vZGUuc291cmNlcG9zWzFdWzBdLCBlbmRQb3NbMF0pIDogZW5kUG9zWzBdKSArIGxpbmVEaWZmKTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZVJhbmdlLmFwcGx5KHRoaXMsIHRoaXMuZ2V0UmFuZ2VXaXRoUmVmRGVmKHN0YXJ0TGluZSwgZW5kTGluZSwgc3RhcnROb2RlLCBlbmROb2RlLCBsaW5lRGlmZikpO1xuICAgICAgICB2YXIgbmV3Tm9kZXMgPSBwYXJzZVJlc3VsdC5uZXdOb2RlcywgZXh0U3RhcnROb2RlID0gcGFyc2VSZXN1bHQuZXh0U3RhcnROb2RlLCBleHRFbmROb2RlID0gcGFyc2VSZXN1bHQuZXh0RW5kTm9kZTtcbiAgICAgICAgdmFyIHJlbW92ZWROb2RlUmFuZ2UgPSB0aGlzLmdldFJlbW92ZWROb2RlUmFuZ2UoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlKTtcbiAgICAgICAgdmFyIG5leHROb2RlID0gZXh0RW5kTm9kZSA/IGV4dEVuZE5vZGUubmV4dCA6IHRoaXMucm9vdC5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGhpcy5yZWZlcmVuY2VEZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtEZWxldGVkUmVmTWFwKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSk7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZU5vZGVzKGV4dFN0YXJ0Tm9kZSwgZXh0RW5kTm9kZSwgbmV3Tm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aE5ld1JlZkRlZlN0YXRlKG5ld05vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZVJhbmdlTm9kZXMoZXh0U3RhcnROb2RlLCBleHRFbmROb2RlLCBuZXdOb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbm9kZXM6IG5ld05vZGVzLCByZW1vdmVkTm9kZVJhbmdlOiByZW1vdmVkTm9kZVJhbmdlLCBuZXh0Tm9kZTogbmV4dE5vZGUgfTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUucGFyc2VSZWZMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghaXNFbXB0eU9iaih0aGlzLnJlZk1hcCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QodGhpcy5yZWZNYXAsIGZ1bmN0aW9uIChsYWJlbCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudW5saW5rZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJlZk1hcFtsYWJlbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZXJhdGVPYmplY3QoX3RoaXMucmVmTGlua0NhbmRpZGF0ZU1hcCwgZnVuY3Rpb24gKF8sIGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNhbmRpZGF0ZS5ub2RlLCByZWZMYWJlbCA9IGNhbmRpZGF0ZS5yZWZMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZkxhYmVsID09PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX3RoaXMucGFyc2Uobm9kZS5zb3VyY2Vwb3NbMF0sIG5vZGUuc291cmNlcG9zWzFdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZVVubGlua2VkQ2FuZGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmoodGhpcy5yZWZEZWZDYW5kaWRhdGVNYXApKSB7XG4gICAgICAgICAgICBbdGhpcy5yZWZMaW5rQ2FuZGlkYXRlTWFwLCB0aGlzLnJlZkRlZkNhbmRpZGF0ZU1hcF0uZm9yRWFjaChmdW5jdGlvbiAoY2FuZGlkYXRlTWFwKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZU9iamVjdChjYW5kaWRhdGVNYXAsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmxpbmtlZChpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYW5kaWRhdGVNYXBbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5lZGl0TWFya2Rvd24gPSBmdW5jdGlvbiAoc3RhcnRQb3MsIGVuZFBvcywgbmV3VGV4dCkge1xuICAgICAgICB2YXIgbGluZURpZmYgPSB0aGlzLnVwZGF0ZUxpbmVUZXh0cyhzdGFydFBvcywgZW5kUG9zLCBuZXdUZXh0KTtcbiAgICAgICAgdmFyIHBhcnNlUmVzdWx0ID0gdGhpcy5wYXJzZShzdGFydFBvcywgZW5kUG9zLCBsaW5lRGlmZik7XG4gICAgICAgIHZhciBlZGl0UmVzdWx0ID0gb21pdChwYXJzZVJlc3VsdCwgJ25leHROb2RlJyk7XG4gICAgICAgIHVwZGF0ZU5leHRMaW5lTnVtYmVycyhwYXJzZVJlc3VsdC5uZXh0Tm9kZSwgbGluZURpZmYpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJvb3ROb2RlU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtlZGl0UmVzdWx0XTtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVVbmxpbmtlZENhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aFJlZkRlZkNhbmRpZGF0ZSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcnNlUmVmTGluaygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLmdldExpbmVUZXh0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVRleHRzO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5nZXRSb290Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdDtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUuZmluZE5vZGVBdFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICB2YXIgbm9kZSA9IGZpbmROb2RlQXRQb3NpdGlvbih0aGlzLnJvb3QsIHBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kRmlyc3ROb2RlQXRMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRGaXJzdE5vZGVBdExpbmUodGhpcy5yb290LCBsaW5lKTtcbiAgICB9O1xuICAgIFRvYXN0TWFyay5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlck1hcFtldmVudE5hbWVdO1xuICAgICAgICB2YXIgaWR4ID0gaGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH07XG4gICAgVG9hc3RNYXJrLnByb3RvdHlwZS5maW5kTm9kZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZpbmROb2RlQnlJZChpZCk7XG4gICAgfTtcbiAgICBUb2FzdE1hcmsucHJvdG90eXBlLnJlbW92ZUFsbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUFsbE5vZGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdE1hcms7XG59KCkpO1xudmFyIGRpc2FsbG93ZWRUYWdzID0gW1xuICAgICd0aXRsZScsXG4gICAgJ3RleHRhcmVhJyxcbiAgICAnc3R5bGUnLFxuICAgICd4bXAnLFxuICAgICdpZnJhbWUnLFxuICAgICdub2VtYmVkJyxcbiAgICAnbm9mcmFtZXMnLFxuICAgICdzY3JpcHQnLFxuICAgICdwbGFpbnRleHQnLFxuXTtcbnZhciByZURpc2FsbG93ZWRUYWcgPSBuZXcgUmVnRXhwKFwiPCgvPyg/OlwiICsgZGlzYWxsb3dlZFRhZ3Muam9pbignfCcpICsgXCIpW14+XSo+KVwiLCAnaWcnKTtcbmZ1bmN0aW9uIGZpbHRlckRpc2FsbG93ZWRUYWdzKHN0cikge1xuICAgIGlmIChyZURpc2FsbG93ZWRUYWcudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZURpc2FsbG93ZWRUYWcsIGZ1bmN0aW9uIChfLCBncm91cCkgeyByZXR1cm4gXCImbHQ7XCIgKyBncm91cDsgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG52YXIgYmFzZUNvbnZlcnRvcnMgPSB7XG4gICAgaGVhZGluZzogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogXCJoXCIgKyBub2RlLmxldmVsLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuc29mdGJyZWFrLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGluZWJyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICBjb250ZW50OiAnPGJyIC8+XFxuJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGVtcGg6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdlbScsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBzdHJvbmc6IGZ1bmN0aW9uIChfLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdzdHJvbmcnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyYWdyYXBoOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIGdyYW5kcGFyZW50ID0gKF9iID0gbm9kZS5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQ7XG4gICAgICAgIGlmIChncmFuZHBhcmVudCAmJiBncmFuZHBhcmVudC50eXBlID09PSAnbGlzdCcpIHtcbiAgICAgICAgICAgIGlmIChncmFuZHBhcmVudC5saXN0RGF0YS50aWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0aGVtYXRpY0JyZWFrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnaHInLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgc2VsZkNsb3NlOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYmxvY2tRdW90ZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgaW5uZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGlzdDogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICB2YXIgX2IgPSBub2RlLmxpc3REYXRhLCB0eXBlID0gX2IudHlwZSwgc3RhcnQgPSBfYi5zdGFydDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0eXBlID09PSAnYnVsbGV0JyA/ICd1bCcgOiAnb2wnO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29sJyAmJiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gMSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5zdGFydCA9IHN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGVudGVyaW5nID8gJ29wZW5UYWcnIDogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgaXRlbTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGh0bWxJbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy50YWdGaWx0ZXIgPyBmaWx0ZXJEaXNhbGxvd2VkVGFncyhub2RlLmxpdGVyYWwpIDogbm9kZS5saXRlcmFsO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGh0bWxCbG9jazogZnVuY3Rpb24gKG5vZGUsIF9hKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBvcHRpb25zLnRhZ0ZpbHRlciA/IGZpbHRlckRpc2FsbG93ZWRUYWdzKG5vZGUubGl0ZXJhbCkgOiBub2RlLmxpdGVyYWw7XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2h0bWwnLCBjb250ZW50OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnZGl2Jywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdodG1sJywgY29udGVudDogY29udGVudCwgb3V0ZXJOZXdMaW5lOiB0cnVlIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGluZm9TdHIgPSBub2RlLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvU3RyID8gaW5mb1N0ci5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBjb2RlQ2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICBpZiAoaW5mb1dvcmRzLmxlbmd0aCA+IDAgJiYgaW5mb1dvcmRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvZGVDbGFzc05hbWVzLnB1c2goXCJsYW5ndWFnZS1cIiArIGVzY2FwZVhtbChpbmZvV29yZHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnY29kZScsIGNsYXNzTmFtZXM6IGNvZGVDbGFzc05hbWVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogbm9kZS5saXRlcmFsIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdjb2RlJyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAncHJlJywgb3V0ZXJOZXdMaW5lOiB0cnVlIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgdmFyIF9iID0gbm9kZSwgdGl0bGUgPSBfYi50aXRsZSwgZGVzdGluYXRpb24gPSBfYi5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdhJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBlc21fYXNzaWduKHsgaHJlZjogZXNjYXBlWG1sKGRlc3RpbmF0aW9uKSB9LCAodGl0bGUgJiYgeyB0aXRsZTogZXNjYXBlWG1sKHRpdGxlKSB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdhJyB9O1xuICAgIH0sXG4gICAgaW1hZ2U6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZ2V0Q2hpbGRyZW5UZXh0ID0gX2EuZ2V0Q2hpbGRyZW5UZXh0LCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBfYiA9IG5vZGUsIHRpdGxlID0gX2IudGl0bGUsIGRlc3RpbmF0aW9uID0gX2IuZGVzdGluYXRpb247XG4gICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2ltZycsXG4gICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBlc21fYXNzaWduKHsgc3JjOiBlc2NhcGVYbWwoZGVzdGluYXRpb24pLCBhbHQ6IGdldENoaWxkcmVuVGV4dChub2RlKSB9LCAodGl0bGUgJiYgeyB0aXRsZTogZXNjYXBlWG1sKHRpdGxlKSB9KSksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjdXN0b21CbG9jazogZnVuY3Rpb24gKG5vZGUsIGNvbnRleHQsIGNvbnZlcnRvcnMpIHtcbiAgICAgICAgdmFyIGluZm8gPSBub2RlLmluZm8udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjdXN0b21Db252ZXJ0b3IgPSBjb252ZXJ0b3JzW2luZm9dO1xuICAgICAgICBpZiAoY3VzdG9tQ29udmVydG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b21Db252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltAdG9hc3QtdWkvZWRpdG9yXSAtIFRoZSBlcnJvciBvY2N1cnJlZCB3aGVuIFwiICsgaW5mbyArIFwiIGJsb2NrIG5vZGUgd2FzIHBhcnNlZCBpbiBtYXJrZG93biByZW5kZXJlcjogXCIgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdkaXYnLCBvdXRlck5ld0xpbmU6IHRydWUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgZnJvbnRNYXR0ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGZyb250IG1hdHRlciBpcyBtZXRhZGF0YSwgaXQgc2hvdWxkIG5vdCBiZSByZW5kZXIuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogJ3doaXRlLXNwYWNlOiBwcmU7IGRpc3BsYXk6IG5vbmU7JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2RpdicsIG91dGVyTmV3TGluZTogdHJ1ZSB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgY3VzdG9tSW5saW5lOiBmdW5jdGlvbiAobm9kZSwgY29udGV4dCwgY29udmVydG9ycykge1xuICAgICAgICB2YXIgX2EgPSBub2RlLCBpbmZvID0gX2EuaW5mbywgZmlyc3RDaGlsZCA9IF9hLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBub21hbGl6ZWRJbmZvID0gaW5mby50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9tYWxpemVkSW5mb107XG4gICAgICAgIHZhciBlbnRlcmluZyA9IGNvbnRleHQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChjdXN0b21Db252ZXJ0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0B0b2FzdC11aS9lZGl0b3JdIC0gVGhlIGVycm9yIG9jY3VycmVkIHdoZW4gXCIgKyBub21hbGl6ZWRJbmZvICsgXCIgaW5saW5lIG5vZGUgd2FzIHBhcnNlZCBpbiBtYXJrZG93biByZW5kZXJlcjogXCIgKyBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50ZXJpbmdcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogXCIkJFwiICsgaW5mbyArIChmaXJzdENoaWxkID8gJyAnIDogJycpIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICd0ZXh0JywgY29udGVudDogJyQkJyB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ3NwYW4nIH0sXG4gICAgICAgICAgICBdO1xuICAgIH0sXG59O1xudmFyIGdmbUNvbnZlcnRvcnMgPSB7XG4gICAgc3RyaWtlOiBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBlbnRlcmluZyA/ICdvcGVuVGFnJyA6ICdjbG9zZVRhZycsXG4gICAgICAgICAgICB0YWdOYW1lOiAnZGVsJyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgdmFyIF9iID0gbm9kZS5saXN0RGF0YSwgY2hlY2tlZCA9IF9iLmNoZWNrZWQsIHRhc2sgPSBfYi50YXNrO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHZhciBpdGVtVGFnID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnbGknLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UYWcsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVuVGFnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdpbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmQ2xvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBlc21fYXNzaWduKGVzbV9hc3NpZ24oe30sIChjaGVja2VkICYmIHsgY2hlY2tlZDogJycgfSkpLCB7IGRpc2FibGVkOiAnJywgdHlwZTogJ2NoZWNrYm94JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJyAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbVRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0YWJsZTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RhYmxlJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlSGVhZDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3RoZWFkJyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlQm9keTogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3Rib2R5JyxcbiAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRhYmxlUm93OiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RyJyxcbiAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uTGVuID0gbm9kZS5wYXJlbnQucGFyZW50LmNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGxhc3RDb2xJZHggPSBub2RlLmxhc3RDaGlsZC5lbmRJZHg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbGFzdENvbElkeCArIDE7IGkgPCBjb2x1bW5MZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29wZW5UYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAndGQnLFxuICAgICAgICAgICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICd0cicsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgdGFibGVDZWxsOiBmdW5jdGlvbiAobm9kZSwgX2EpIHtcbiAgICAgICAgdmFyIGVudGVyaW5nID0gX2EuZW50ZXJpbmc7XG4gICAgICAgIGlmIChub2RlLmlnbm9yZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFibGVQYXJ0ID0gbm9kZS5wYXJlbnQucGFyZW50O1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhYmxlUGFydC50eXBlID09PSAndGFibGVIZWFkJyA/ICd0aCcgOiAndGQnO1xuICAgICAgICB2YXIgdGFibGUgPSB0YWJsZVBhcnQucGFyZW50O1xuICAgICAgICB2YXIgY29sdW1uSW5mbyA9IHRhYmxlLmNvbHVtbnNbbm9kZS5zdGFydElkeF07XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gKGNvbHVtbkluZm8gPT09IG51bGwgfHwgY29sdW1uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uSW5mby5hbGlnbikgPyB7IGFsaWduOiBjb2x1bW5JbmZvLmFsaWduIH0gOiBudWxsO1xuICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlc21fYXNzaWduKHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiB0YWdOYW1lLCBvdXRlck5ld0xpbmU6IHRydWUgfSwgKGF0dHJpYnV0ZXMgJiYgeyBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgc29mdGJyZWFrOiAnXFxuJyxcbiAgICBnZm06IGZhbHNlLFxuICAgIHRhZ0ZpbHRlcjogZmFsc2UsXG4gICAgbm9kZUlkOiBmYWxzZSxcbn07XG5mdW5jdGlvbiBnZXRDaGlsZHJlblRleHQobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZV8xID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKG5vZGVfMS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKG5vZGVfMS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxudmFyIFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlbmRlcmVyKGN1c3RvbU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIGN1c3RvbU9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbnZlcnRvcnMgPSB0aGlzLmNyZWF0ZUNvbnZlcnRvcnMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzO1xuICAgIH1cbiAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29udmVydG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnZlcnRvcnMgPSBlc21fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBjb252ZXJ0b3JzID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBjb252ZXJ0b3JzKSwgZ2ZtQ29udmVydG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb252ZXJ0b3JzKSB7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQ29udmVydG9yc18xID0gdGhpcy5vcHRpb25zLmNvbnZlcnRvcnM7XG4gICAgICAgICAgICB2YXIgbm9kZVR5cGVzID0gT2JqZWN0LmtleXMoY3VzdG9tQ29udmVydG9yc18xKTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q29udmVydG9yc18xID0gZXNtX2Fzc2lnbihlc21fYXNzaWduKHt9LCBiYXNlQ29udmVydG9ycyksIGdmbUNvbnZlcnRvcnMpO1xuICAgICAgICAgICAgbm9kZVR5cGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSBjdXN0b21Db252ZXJ0b3JzXzFbbm9kZVR5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBjb252ZXJ0b3JUeXBlID0gT2JqZWN0LmtleXMoZGVmYXVsdENvbnZlcnRvcnNfMSkuaW5kZXhPZihub2RlVHlwZSkgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZVR5cGUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChvcmdDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydG9yc1tjb252ZXJ0b3JUeXBlXSA9IGZ1bmN0aW9uIChub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcihub2RlLCBjb250ZXh0LCBjb252ZXJ0b3JzKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0b3Iobm9kZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW2NvbnZlcnRvclR5cGVdID0gY29udmVydG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0b3JzO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdldENvbnZlcnRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRvcnM7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocm9vdE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdmFyIHdhbGtlciA9IHJvb3ROb2RlLndhbGtlcigpO1xuICAgICAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZXZlbnQubm9kZSwgZW50ZXJpbmcgPSBldmVudC5lbnRlcmluZztcbiAgICAgICAgICAgIHZhciBjb252ZXJ0b3IgPSB0aGlzXzEuY29udmVydG9yc1tub2RlLnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFjb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGVudGVyaW5nOiBlbnRlcmluZyxcbiAgICAgICAgICAgICAgICBsZWFmOiAhaXNDb250YWluZXIobm9kZSksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpc18xLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW5UZXh0OiBnZXRDaGlsZHJlblRleHQsXG4gICAgICAgICAgICAgICAgc2tpcENoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNvbnZlcnRlZCA9IGlzQ3VzdG9tQmxvY2sobm9kZSkgfHwgaXNDdXN0b21JbmxpbmUobm9kZSlcbiAgICAgICAgICAgICAgICA/IGNvbnZlcnRvcihub2RlLCBjb250ZXh0LCB0aGlzXzEuY29udmVydG9ycylcbiAgICAgICAgICAgICAgICA6IGNvbnZlcnRvcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHRtbE5vZGVzID0gQXJyYXkuaXNBcnJheShjb252ZXJ0ZWQpID8gY29udmVydGVkIDogW2NvbnZlcnRlZF07XG4gICAgICAgICAgICAgICAgaHRtbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGh0bWxOb2RlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbE5vZGUudHlwZSA9PT0gJ29wZW5UYWcnICYmIF90aGlzLm9wdGlvbnMubm9kZUlkICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWh0bWxOb2RlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sTm9kZS5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sTm9kZS5hdHRyaWJ1dGVzWydkYXRhLW5vZGVpZCddID0gU3RyaW5nKG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckhUTUxOb2RlKGh0bWxOb2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIucmVzdW1lQXQobm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTmV3TGluZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuam9pbignJyk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVySFRNTE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnb3BlblRhZyc6XG4gICAgICAgICAgICBjYXNlICdjbG9zZVRhZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50Tm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dE5vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJhd0h0bWxOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gbm8tZGVmYXVsdC1jYXNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZU9wZW5UYWdTdHJpbmcgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IG5vZGUudGFnTmFtZSwgY2xhc3NOYW1lcyA9IG5vZGUuY2xhc3NOYW1lcywgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChcIjxcIiArIHRhZ05hbWUpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCIgY2xhc3M9XFxcIlwiICsgY2xhc3NOYW1lcy5qb2luKCcgJykgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1ZmZlci5wdXNoKFwiIFwiICsgYXR0ck5hbWUgKyBcIj1cXFwiXCIgKyBhdHRyVmFsdWUgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5zZWxmQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJyAvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCgnPicpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlQ2xvc2VUYWdTdHJpbmcgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBfYS50YWdOYW1lO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIik7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkTmV3TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCAmJiBsYXN0KGxhc3QodGhpcy5idWZmZXIpKSAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2goJ1xcbicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUuYWRkT3V0ZXJOZXdMaW5lID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUub3V0ZXJOZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5ld0xpbmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLmFkZElubmVyTmV3TGluZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlubmVyTmV3TGluZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goZXNjYXBlWG1sKG5vZGUuY29udGVudCkpO1xuICAgIH07XG4gICAgUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclJhd0h0bWxOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2gobm9kZS5jb250ZW50KTtcbiAgICAgICAgdGhpcy5hZGRPdXRlck5ld0xpbmUobm9kZSk7XG4gICAgfTtcbiAgICBSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRWxlbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb3BlblRhZycpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT3V0ZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZU9wZW5UYWdTdHJpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5zZWxmQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5uZXJOZXdMaW5lKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRJbm5lck5ld0xpbmUobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlQ2xvc2VUYWdTdHJpbmcobm9kZSk7XG4gICAgICAgICAgICB0aGlzLmFkZE91dGVyTmV3TGluZShub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlcmVyO1xufSgpKTtcblxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L2NvbGxlY3Rpb24vZm9yRWFjaE93blByb3BlcnRpZXMuanNcbnZhciBjb2xsZWN0aW9uX2ZvckVhY2hPd25Qcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTYpO1xudmFyIGZvckVhY2hPd25Qcm9wZXJ0aWVzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvbGxlY3Rpb25fZm9yRWFjaE93blByb3BlcnRpZXMpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9vYmplY3QvZXh0ZW5kLmpzXG52YXIgZXh0ZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjkpO1xudmFyIGV4dGVuZF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihleHRlbmQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21FdmVudC9vbi5qc1xudmFyIG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDgpO1xudmFyIG9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKG9uKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvZG9tRXZlbnQvb2ZmLmpzXG52YXIgb2ZmID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDkpO1xudmFyIG9mZl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihvZmYpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL2FkZENsYXNzLmpzXG52YXIgYWRkQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNCk7XG52YXIgYWRkQ2xhc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYWRkQ2xhc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL3JlbW92ZUNsYXNzLmpzXG52YXIgcmVtb3ZlQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2Mik7XG52YXIgcmVtb3ZlQ2xhc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVtb3ZlQ2xhc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL2Nzcy5qc1xudmFyIGNzcyA9IF9fd2VicGFja19yZXF1aXJlX18oNTIyKTtcbnZhciBjc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3NzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvY29sbGVjdGlvbi90b0FycmF5LmpzXG52YXIgY29sbGVjdGlvbl90b0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTApO1xudmFyIHRvQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29sbGVjdGlvbl90b0FycmF5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0FycmF5LmpzXG52YXIgdHlwZV9pc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjIpO1xudmFyIGlzQXJyYXlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odHlwZV9pc0FycmF5KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc1N0cmluZy5qc1xudmFyIHR5cGVfaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc1OCk7XG52YXIgaXNTdHJpbmdfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odHlwZV9pc1N0cmluZyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L3R5cGUvaXNVbmRlZmluZWQuanNcbnZhciB0eXBlX2lzVW5kZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MjkpO1xudmFyIGlzVW5kZWZpbmVkX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHR5cGVfaXNVbmRlZmluZWQpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL2hhc0NsYXNzLmpzXG52YXIgaGFzQ2xhc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNCk7XG52YXIgaGFzQ2xhc3NfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaGFzQ2xhc3MpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdHVpLWNvZGUtc25pcHBldC9kb21VdGlsL21hdGNoZXMuanNcbnZhciBkb21VdGlsX21hdGNoZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3MSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvY29uc3RhbnRzLnRzXG52YXIgVEFHX05BTUUgPSAnW0EtWmEtel1bQS1aYS16MC05LV0qJztcbnZhciBBVFRSSUJVVEVfTkFNRSA9ICdbYS16QS1aXzpdW2EtekEtWjAtOTouXy1dKic7XG52YXIgVU5RVU9URURfVkFMVUUgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgU0lOR0xFX1FVT1RFRF9WQUxVRSA9IFwiJ1teJ10qJ1wiO1xudmFyIERPVUJMRV9RVU9URURfVkFMVUUgPSAnXCJbXlwiXSpcIic7XG52YXIgQVRUUklCVVRFX1ZBTFVFID0gXCIoPzpcIiArIFVOUVVPVEVEX1ZBTFVFICsgXCJ8XCIgKyBTSU5HTEVfUVVPVEVEX1ZBTFVFICsgXCJ8XCIgKyBET1VCTEVfUVVPVEVEX1ZBTFVFICsgXCIpXCI7XG52YXIgQVRUUklCVVRFX1ZBTFVFX1NQRUMgPSBcIlwiICsgJyg/OlxcXFxzKj1cXFxccyonICsgQVRUUklCVVRFX1ZBTFVFICsgXCIpXCI7XG52YXIgY29uc3RhbnRzX0FUVFJJQlVURSA9IFwiXCIgKyAnKD86XFxcXHMrJyArIEFUVFJJQlVURV9OQU1FICsgQVRUUklCVVRFX1ZBTFVFX1NQRUMgKyBcIj8pXCI7XG52YXIgY29uc3RhbnRzX09QRU5fVEFHID0gXCI8KFwiICsgVEFHX05BTUUgKyBcIikoXCIgKyBjb25zdGFudHNfQVRUUklCVVRFICsgXCIpKlxcXFxzKi8/PlwiO1xudmFyIENMT1NFX1RBRyA9IFwiPC8oXCIgKyBUQUdfTkFNRSArIFwiKVxcXFxzKls+XVwiO1xudmFyIGNvbnN0YW50c19IVE1MX1RBRyA9IFwiKD86XCIgKyBjb25zdGFudHNfT1BFTl9UQUcgKyBcInxcIiArIENMT1NFX1RBRyArIFwiKVwiO1xudmFyIHJlSFRNTFRhZyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBjb25zdGFudHNfSFRNTF9UQUcsICdpJyk7XG52YXIgY29uc3RhbnRzX3JlQlIgPSAvPGJyXFxzKlxcLyo+L2k7XG52YXIgcmVIVE1MQ29tbWVudCA9IC88ISAtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPi87XG52YXIgY29uc3RhbnRzX0FMVEVSTkFUSVZFX1RBR19GT1JfQlIgPSAnPC9wPjxwPic7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc051bGwuanNcbnZhciB0eXBlX2lzTnVsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTM0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvcmVxdWVzdC9zZW5kSG9zdG5hbWUuanNcbnZhciByZXF1ZXN0X3NlbmRIb3N0bmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkxKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9jb21tb24udHNcblxuXG5cblxuXG52YXIgaXNNYWMgPSAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgcmVTcGFjZU1vcmVUaGFuT25lID0gL1tcXHUwMDIwXSsvZztcbnZhciBjb21tb25fcmVFc2NhcGVDaGFycyA9IC9bPigpe31bXFxdKy0uISN8XS9nO1xudmFyIHJlRXNjYXBlSFRNTCA9IC88KFthLXpBLVpfXVthLXpBLVowLTlcXC0uX10qKShcXHN8W15cXFxcPl0pKlxcLz8+fDwoXFwvKShbYS16QS1aX11bYS16QS1aMC05XFwtLl9dKilcXHMqXFwvPz58PCEtLVteLV0rLS0+fDwoW2EtekEtWl9dW2EtekEtWjAtOVxcLS46L10qKT4vZztcbnZhciByZUVzY2FwZUJhY2tTbGFzaCA9IC9cXFxcWyFcIiMkJSYnKCkqKywtLi86Ozw9Pj9AW1xcXV5fYHt8fX5cXFxcXS9nO1xudmFyIHJlRXNjYXBlUGFpcmVkQ2hhcnMgPSAvWypffmBdL2c7XG52YXIgcmVNZEltYWdlU3ludGF4ID0gLyFcXFsuKlxcXVxcKC4qXFwpL2c7XG52YXIgcmVFc2NhcGVkQ2hhckluTGlua1N5bnRheCA9IC9bW1xcXV0vZztcbnZhciByZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UgPSAvKD86XnxbXlxcXFxdKVxcXFwoPyFcXFxcKS9nO1xudmFyIGNvbW1vbl9YTUxTUEVDSUFMID0gJ1smPD5cIl0nO1xudmFyIGNvbW1vbl9yZVhtbFNwZWNpYWwgPSBuZXcgUmVnRXhwKGNvbW1vbl9YTUxTUEVDSUFMLCAnZycpO1xuZnVuY3Rpb24gY29tbW9uX3JlcGxhY2VVbnNhZmVDaGFyKGNoYXIpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnJmd0Oyc7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbW1vbl9lc2NhcGVYbWwodGV4dCkge1xuICAgIGlmIChjb21tb25fcmVYbWxTcGVjaWFsLnRlc3QodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShjb21tb25fcmVYbWxTcGVjaWFsLCBjb21tb25fcmVwbGFjZVVuc2FmZUNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cbmZ1bmN0aW9uIHNlbmRIb3N0TmFtZSgpIHtcbiAgICBzZW5kSG9zdG5hbWUoJ2VkaXRvcicsICdVQS0xMjk5NjY5MjktMScpO1xufVxuZnVuY3Rpb24gY29tbW9uX2luY2x1ZGVzKGFyciwgdGFyZ2V0SXRlbSkge1xuICAgIHJldHVybiBhcnIuaW5kZXhPZih0YXJnZXRJdGVtKSAhPT0gLTE7XG59XG52YXIgYXZhaWxhYmxlTGlua0F0dHJpYnV0ZXMgPSBbJ3JlbCcsICd0YXJnZXQnLCAnaHJlZmxhbmcnLCAndHlwZSddO1xudmFyIHJlTWFya2Rvd25UZXh0VG9Fc2NhcGVNYXAgPSB7XG4gICAgY29kZWJsb2NrOiAvKF4gezR9W15cXG5dK1xcbiopKy8sXG4gICAgdGhlbWF0aWNCcmVhazogL14gKigoXFwqICopezMsfXwoLSAqKXszLH0gKnwoXyAqKXszLH0pICovLFxuICAgIGF0eEhlYWRpbmc6IC9eKCN7MSw2fSkgK1tcXHNcXFNdKy8sXG4gICAgc2VUZXh0aGVhZGluZzogL14oW15cXG5dKylcXG4gKig9fC0pezIsfSAqLyxcbiAgICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rLiopKy8sXG4gICAgbGlzdDogL14gKihcXCorfC0rfFxcZCtcXC4pIFtcXHNcXFNdKy8sXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqLyxcbiAgICBsaW5rOiAvIT9cXFsuKlxcXVxcKC4qXFwpLyxcbiAgICByZWZsaW5rOiAvIT9cXFsuKlxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICAgIHZlcnRpY2FsQmFyOiAvXFx1MDA3Qy8sXG4gICAgZmVuY2VkQ29kZWJsb2NrOiAvXigoYHx+KXszLH0pLyxcbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUxpbmtBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IHt9O1xuICAgIGF2YWlsYWJsZUxpbmtBdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkX2RlZmF1bHQoKShhdHRyaWJ1dGVba2V5XSkpIHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzW2tleV0gPSBhdHRyaWJ1dGVba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsaW5rQXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIGNvbW1vbl9yZXBlYXQodGV4dCwgY291bnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHJlc3VsdCArPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOZWVkRXNjYXBlVGV4dCh0ZXh0KSB7XG4gICAgdmFyIG5lZWRFc2NhcGUgPSBmYWxzZTtcbiAgICBmb3JFYWNoT3duUHJvcGVydGllcyhyZU1hcmtkb3duVGV4dFRvRXNjYXBlTWFwLCBmdW5jdGlvbiAocmVNYXJrZG93blRleHRUb0VzY2FwZSkge1xuICAgICAgICBpZiAocmVNYXJrZG93blRleHRUb0VzY2FwZS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBuZWVkRXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW5lZWRFc2NhcGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5lZWRFc2NhcGU7XG59XG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yTGluayh0ZXh0KSB7XG4gICAgdmFyIGltYWdlU3ludGF4UmFuZ2VzID0gW107XG4gICAgdmFyIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIHdoaWxlIChyZXN1bHQpIHtcbiAgICAgICAgaW1hZ2VTeW50YXhSYW5nZXMucHVzaChbcmVzdWx0LmluZGV4LCByZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoXSk7XG4gICAgICAgIHJlc3VsdCA9IHJlTWRJbWFnZVN5bnRheC5leGVjKHRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlRXNjYXBlZENoYXJJbkxpbmtTeW50YXgsIGZ1bmN0aW9uIChtYXRjaGVkLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIGlzRGVsaW1pdGVyID0gaW1hZ2VTeW50YXhSYW5nZXMuc29tZShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG9mZnNldCA+IHJhbmdlWzBdICYmIG9mZnNldCA8IHJhbmdlWzFdOyB9KTtcbiAgICAgICAgcmV0dXJuIGlzRGVsaW1pdGVyID8gbWF0Y2hlZCA6IFwiXFxcXFwiICsgbWF0Y2hlZDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbW1vbl9lc2NhcGUodGV4dCkge1xuICAgIHZhciBhaGVhZFJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoZWQpIHsgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hlZDsgfTtcbiAgICB2YXIgYmVoaW5kUmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2hlZCkgeyByZXR1cm4gbWF0Y2hlZCArIFwiXFxcXFwiOyB9O1xuICAgIHZhciBlc2NhcGVkVGV4dCA9IHRleHQucmVwbGFjZShyZVNwYWNlTW9yZVRoYW5PbmUsICcgJyk7XG4gICAgaWYgKHJlRXNjYXBlQmFja1NsYXNoLnRlc3QoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShyZUVzY2FwZUJhY2tTbGFzaCwgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIGlmIChyZUVzY2FwZUJhY2tTbGFzaEluU2VudGVuY2UudGVzdChlc2NhcGVkVGV4dCkpIHtcbiAgICAgICAgZXNjYXBlZFRleHQgPSBlc2NhcGVkVGV4dC5yZXBsYWNlKHJlRXNjYXBlQmFja1NsYXNoSW5TZW50ZW5jZSwgYmVoaW5kUmVwbGFjZXIpO1xuICAgIH1cbiAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVQYWlyZWRDaGFycywgYWhlYWRSZXBsYWNlcik7XG4gICAgaWYgKHJlRXNjYXBlSFRNTC50ZXN0KGVzY2FwZWRUZXh0KSkge1xuICAgICAgICBlc2NhcGVkVGV4dCA9IGVzY2FwZWRUZXh0LnJlcGxhY2UocmVFc2NhcGVIVE1MLCBhaGVhZFJlcGxhY2VyKTtcbiAgICB9XG4gICAgaWYgKGlzTmVlZEVzY2FwZVRleHQoZXNjYXBlZFRleHQpKSB7XG4gICAgICAgIGVzY2FwZWRUZXh0ID0gZXNjYXBlZFRleHQucmVwbGFjZShjb21tb25fcmVFc2NhcGVDaGFycywgYWhlYWRSZXBsYWNlcik7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbn1cbmZ1bmN0aW9uIHF1b3RlKHRleHQpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICh0ZXh0LmluZGV4T2YoJ1wiJykgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdCA9ICdcIlwiJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRleHQuaW5kZXhPZihcIidcIikgPT09IC0xID8gXCInJ1wiIDogJygpJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFswXSArIHRleHQgKyByZXN1bHRbMV07XG59XG5mdW5jdGlvbiBjb21tb25faXNOaWwodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOdWxsKHZhbHVlKSB8fCBpc1VuZGVmaW5lZCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwobzEsIG8yKSB7XG4gICAgaWYgKG8xID09PSBudWxsICYmIG8xID09PSBvMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG8yICE9PSAnb2JqZWN0JyB8fCBjb21tb25faXNOaWwobzEpIHx8IGNvbW1vbl9pc05pbChvMikpIHtcbiAgICAgICAgcmV0dXJuIG8xID09PSBvMjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8xKSB7XG4gICAgICAgIGlmIChvMVtrZXldICE9PSBvMltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG8yKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBvMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNvbW1vbl9sYXN0KGFycikge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gY29tbW9uX2JldHdlZW4odmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXg7XG59XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZGVlcE1lcmdlZENvcHkodGFyZ2V0T2JqLCBvYmopIHtcbiAgICB2YXIgcmVzdWx0T2JqID0gdHNsaWJfZXM2X2Fzc2lnbih7fSwgdGFyZ2V0T2JqKTtcbiAgICBpZiAodGFyZ2V0T2JqICYmIG9iaikge1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChyZXN1bHRPYmpbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weUFycmF5KG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdE9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwTWVyZ2VkQ29weShyZXN1bHRPYmpbcHJvcF0sIG9ialtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRPYmpbcHJvcF0gPSBkZWVwQ29weShvYmpbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRPYmo7XG59XG5mdW5jdGlvbiBkZWVwQ29weUFycmF5KGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pID8gZGVlcENvcHlBcnJheShpdGVtKSA6IGRlZXBDb3B5KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgIGFjY1twcm9wXSA9IEFycmF5LmlzQXJyYXkob2JqW3Byb3BdKSA/IGRlZXBDb3B5QXJyYXkob2JqW3Byb3BdKSA6IGRlZXBDb3B5KG9ialtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2NbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjb21tb25fYXNzaWduKHRhcmdldE9iaiwgb2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSB7IG9iaiA9IHt9OyB9XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXRPYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdHlwZW9mIHRhcmdldE9ialtwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmpbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21tb25fYXNzaWduKHRhcmdldE9ialtwcm9wXSwgb2JqW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE9ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXRPYmo7XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWROdW1QYWlyKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgcmV0dXJuIHZhbHVlQSA+IHZhbHVlQiA/IFt2YWx1ZUIsIHZhbHVlQV0gOiBbdmFsdWVBLCB2YWx1ZUJdO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdXRpbHMvZG9tLnRzXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGlzUG9zaXRpb25JbkJveChzdHlsZSwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciBsZWZ0ID0gcGFyc2VJbnQoc3R5bGUubGVmdCwgMTApO1xuICAgIHZhciB0b3AgPSBwYXJzZUludChzdHlsZS50b3AsIDEwKTtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUludChzdHlsZS53aWR0aCwgMTApICsgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuICAgIHZhciBoZWlnaHQgPSBwYXJzZUludChzdHlsZS5oZWlnaHQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKTtcbiAgICByZXR1cm4gb2Zmc2V0WCA+PSBsZWZ0ICYmIG9mZnNldFggPD0gbGVmdCArIHdpZHRoICYmIG9mZnNldFkgPj0gdG9wICYmIG9mZnNldFkgPD0gdG9wICsgaGVpZ2h0O1xufVxudmFyIENMU19QUkVGSVggPSAndG9hc3R1aS1lZGl0b3ItJztcbmZ1bmN0aW9uIGNscygpIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgX2EgPSAwLCBuYW1lc18xID0gbmFtZXM7IF9hIDwgbmFtZXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc18xW19hXTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5hbWVbMF0gPyBuYW1lWzFdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJcIiArIENMU19QUkVGSVggKyBjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xufVxuZnVuY3Rpb24gY2xzV2l0aE1kUHJlZml4KCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5tYXAoZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gQ0xTX1BSRUZJWCArIFwibWQtXCIgKyBjbGFzc05hbWU7IH0pLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5vZGVUeXBlKSA9PT0gTm9kZS5URVhUX05PREU7XG59XG5mdW5jdGlvbiBpc0VsZW1Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTGlzdCA9IHRvQXJyYXkoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgaWYgKG5vZGVMaXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbm9kZUxpc3Q7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKG5vZGUsIG5vZGVzVG9BcHBlbmQpIHtcbiAgICBub2Rlc1RvQXBwZW5kID0gaXNBcnJheShub2Rlc1RvQXBwZW5kKSA/IHRvQXJyYXkobm9kZXNUb0FwcGVuZCkgOiBbbm9kZXNUb0FwcGVuZF07XG4gICAgbm9kZXNUb0FwcGVuZC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVG9BcHBlbmQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChub2RlVG9BcHBlbmQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlTm9kZShpbnNlcnRlZE5vZGUsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zZXJ0ZWROb2RlLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bndyYXBOb2RlKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICByZXN1bHQucHVzaChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUuZmlyc3RDaGlsZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTm9kZShub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBzdGF0ZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZF9kZWZhdWx0KCkoc3RhdGUpKSB7XG4gICAgICAgIHN0YXRlID0gIWhhc0NsYXNzX2RlZmF1bHQoKShlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cbiAgICB2YXIgdG9nZ2xlRm4gPSBzdGF0ZSA/IChhZGRDbGFzc19kZWZhdWx0KCkpIDogKHJlbW92ZUNsYXNzX2RlZmF1bHQoKSk7XG4gICAgdG9nZ2xlRm4oZWxlbWVudCwgY2xhc3NOYW1lKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoKGNvbnRlbnRzLCB0YXJnZXQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKGlzU3RyaW5nX2RlZmF1bHQoKShjb250ZW50cykpIHtcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRlbnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBnZXRPdXRlcldpZHRoKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHJldHVybiAoWydtYXJnaW4tbGVmdCcsICdtYXJnaW4tcmlnaHQnXS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHlwZSkgeyByZXR1cm4gYWNjICsgcGFyc2VJbnQoY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSh0eXBlKSwgMTApOyB9LCAwKSArIGVsLm9mZnNldFdpZHRoKTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3Qobm9kZSwgZm91bmQpIHtcbiAgICB2YXIgY29uZGl0aW9uO1xuICAgIGlmIChpc1N0cmluZyhmb3VuZCkpIHtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gbWF0Y2hlcyh0YXJnZXQsIGZvdW5kKTsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmRpdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgcmV0dXJuIHRhcmdldCA9PT0gZm91bmQ7IH07XG4gICAgfVxuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChpc0VsZW1Ob2RlKG5vZGUpICYmIGNvbmRpdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUb3RhbE9mZnNldChlbCwgcm9vdCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gMDtcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IHJvb3QpIHtcbiAgICAgICAgdmFyIHRvcCA9IGVsLm9mZnNldFRvcCwgbGVmdCA9IGVsLm9mZnNldExlZnQsIG9mZnNldFBhcmVudCA9IGVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IHRvcDtcbiAgICAgICAgb2Zmc2V0TGVmdCArPSBsZWZ0O1xuICAgICAgICBpZiAob2Zmc2V0UGFyZW50ID09PSByb290Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB7IG9mZnNldFRvcDogb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0IH07XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUh0bWwoaHRtbCwgbmVlZEh0bWxUZXh0KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobmVlZEh0bWxUZXh0KSB7XG4gICAgICAgIHJlc3VsdCA9IGh0bWwuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdG9BcnJheShodG1sLmNoaWxkTm9kZXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZnJhZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvbV9lbXB0eShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kTm9kZShub2RlLCBhcHBlbmRlZCkge1xuICAgIGlmIChpc1N0cmluZyhhcHBlbmRlZCkpIHtcbiAgICAgICAgbm9kZS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGFwcGVuZGVkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBub2RlcyA9IGFwcGVuZGVkLmxlbmd0aFxuICAgICAgICAgICAgPyB0b0FycmF5KGFwcGVuZGVkKVxuICAgICAgICAgICAgOiBbYXBwZW5kZWRdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJlcGVuZE5vZGUobm9kZSwgYXBwZW5kZWQpIHtcbiAgICBpZiAoaXNTdHJpbmcoYXBwZW5kZWQpKSB7XG4gICAgICAgIG5vZGUuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgYXBwZW5kZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vZGVzID0gYXBwZW5kZWQubGVuZ3RoXG4gICAgICAgICAgICA/IHRvQXJyYXkoYXBwZW5kZWQpXG4gICAgICAgICAgICA6IFthcHBlbmRlZF07XG4gICAgICAgIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxLCBsZW4gPSAwOyBpID49IGxlbjsgaSAtPSAxKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShub2Rlc1tpXSwgbm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZWxlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XG4gICAgICAgIGlmIChpc05pbChhdHRyaWJ1dGVzW2F0dHJOYW1lXSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCUldpdGhFbXB0eUJsb2NrKGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYnIgaW4gcGFyYWdyYXBoIHRvIGNvbXBhdGlibGUgd2l0aCBtYXJrZG93blxuICAgIHZhciByZXBsYWNlZEhUTUwgPSBodG1sLnJlcGxhY2UoLzxwPjxiclxccypcXC8qPjxcXC9wPi9naSwgJzxwPjwvcD4nKTtcbiAgICB2YXIgcmVIVE1MVGFnID0gbmV3IFJlZ0V4cChIVE1MX1RBRywgJ2lnJyk7XG4gICAgdmFyIGh0bWxUYWdNYXRjaGVkID0gcmVwbGFjZWRIVE1MLm1hdGNoKHJlSFRNTFRhZyk7XG4gICAgaHRtbFRhZ01hdGNoZWQgPT09IG51bGwgfHwgaHRtbFRhZ01hdGNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0bWxUYWdNYXRjaGVkLmZvckVhY2goZnVuY3Rpb24gKGh0bWxUYWcsIGluZGV4KSB7XG4gICAgICAgIGlmIChyZUJSLnRlc3QoaHRtbFRhZykpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGl2ZVRhZyA9IEFMVEVSTkFUSVZFX1RBR19GT1JfQlI7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlRhZyA9IGh0bWxUYWdNYXRjaGVkW2luZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5UYWdNYXRjaGVkID0gcHJldlRhZy5tYXRjaChPUEVOX1RBRyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5UYWdNYXRjaGVkICYmICEvYnIvaS50ZXN0KG9wZW5UYWdNYXRjaGVkWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnTmFtZSA9IG9wZW5UYWdNYXRjaGVkWzFdO1xuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZVRhZyA9IFwiPC9cIiArIHRhZ05hbWUgKyBcIj48XCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZWRIVE1MID0gcmVwbGFjZWRIVE1MLnJlcGxhY2UocmVCUiwgYWx0ZXJuYXRpdmVUYWcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcGxhY2VkSFRNTDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKGh0bWwpIHtcbiAgICB2YXIgcmVQcm9zZU1pcnJvckltYWdlID0gLzxpbWcgY2xhc3M9XCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIiBhbHQ9XCJcIj4vZztcbiAgICB2YXIgcmVQcm9zZU1pcnJvclRyYWlsaW5nQnJlYWsgPSAvIGNsYXNzPVwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiL2c7XG4gICAgdmFyIHJlc3VsdEhUTUwgPSBodG1sO1xuICAgIHJlc3VsdEhUTUwgPSByZXN1bHRIVE1MLnJlcGxhY2UocmVQcm9zZU1pcnJvckltYWdlLCAnJyk7XG4gICAgcmVzdWx0SFRNTCA9IHJlc3VsdEhUTUwucmVwbGFjZShyZVByb3NlTWlycm9yVHJhaWxpbmdCcmVhaywgJycpO1xuICAgIHJldHVybiByZXN1bHRIVE1MO1xufVxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy90dWktY29kZS1zbmlwcGV0L3R5cGUvaXNGdW5jdGlvbi5qc1xudmFyIGlzRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5NCk7XG52YXIgaXNGdW5jdGlvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpc0Z1bmN0aW9uKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9tYXJrZG93bi50c1xuXG5mdW5jdGlvbiBoYXNTcGVjaWZpY1R5cGVBbmNlc3RvcihtZE5vZGUpIHtcbiAgICB2YXIgdHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0eXBlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgd2hpbGUgKG1kTm9kZSAmJiBtZE5vZGUucGFyZW50ICYmIG1kTm9kZS5wYXJlbnQudHlwZSAhPT0gJ2RvY3VtZW50Jykge1xuICAgICAgICBpZiAoaW5jbHVkZXModHlwZXMsIG1kTm9kZS5wYXJlbnQudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1hcmtkb3duX2dldE1kU3RhcnRMaW5lKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzBdWzBdO1xufVxuZnVuY3Rpb24gbWFya2Rvd25fZ2V0TWRFbmRMaW5lKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzFdWzBdO1xufVxuZnVuY3Rpb24gZ2V0TWRTdGFydENoKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUuc291cmNlcG9zWzBdWzFdO1xufVxuZnVuY3Rpb24gZ2V0TWRFbmRDaChtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlLnNvdXJjZXBvc1sxXVsxXTtcbn1cbmZ1bmN0aW9uIGlzTXVsdGlMaW5lTm9kZShtZE5vZGUpIHtcbiAgICB2YXIgdHlwZSA9IG1kTm9kZS50eXBlO1xuICAgIHJldHVybiB0eXBlID09PSAnY29kZUJsb2NrJyB8fCB0eXBlID09PSAncGFyYWdyYXBoJztcbn1cbmZ1bmN0aW9uIGlzSFRNTE5vZGUobWROb2RlKSB7XG4gICAgdmFyIHR5cGUgPSBtZE5vZGUudHlwZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2h0bWxCbG9jaycgfHwgdHlwZSA9PT0gJ2h0bWxJbmxpbmUnO1xufVxuZnVuY3Rpb24gbWFya2Rvd25faXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkge1xuICAgIHZhciB0eXBlID0gbWROb2RlLnR5cGU7XG4gICAgcmV0dXJuICh0eXBlID09PSAnc3RyaWtlJyB8fFxuICAgICAgICB0eXBlID09PSAnc3Ryb25nJyB8fFxuICAgICAgICB0eXBlID09PSAnZW1waCcgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2NvZGUnIHx8XG4gICAgICAgIHR5cGUgPT09ICdsaW5rJyB8fFxuICAgICAgICB0eXBlID09PSAnaW1hZ2UnKTtcbn1cbmZ1bmN0aW9uIGlzQ29kZUJsb2NrTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIG1kTm9kZS50eXBlID09PSAnY29kZUJsb2NrJztcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tQmxvY2tOb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgbWROb2RlLnR5cGUgPT09ICdjdXN0b21CbG9jayc7XG59XG5mdW5jdGlvbiBpc0xpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBtZE5vZGUgJiYgKG1kTm9kZS50eXBlID09PSAnaXRlbScgfHwgbWROb2RlLnR5cGUgPT09ICdsaXN0Jyk7XG59XG5mdW5jdGlvbiBpc09yZGVyZWRMaXN0Tm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gaXNMaXN0Tm9kZShtZE5vZGUpICYmIG1kTm9kZS5saXN0RGF0YS50eXBlID09PSAnb3JkZXJlZCc7XG59XG5mdW5jdGlvbiBpc0J1bGxldExpc3ROb2RlKG1kTm9kZSkge1xuICAgIHJldHVybiBpc0xpc3ROb2RlKG1kTm9kZSkgJiYgbWROb2RlLmxpc3REYXRhLnR5cGUgIT09ICdvcmRlcmVkJztcbn1cbmZ1bmN0aW9uIGlzVGFibGVDZWxsTm9kZShtZE5vZGUpIHtcbiAgICByZXR1cm4gbWROb2RlICYmIChtZE5vZGUudHlwZSA9PT0gJ3RhYmxlQ2VsbCcgfHwgbWROb2RlLnR5cGUgPT09ICd0YWJsZURlbGltQ2VsbCcpO1xufVxuZnVuY3Rpb24gaXNJbmxpbmVOb2RlKG1kTm9kZSkge1xuICAgIHN3aXRjaCAobWROb2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgY2FzZSAnc3RyaWtlJzpcbiAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgY2FzZSAnaHRtbElubGluZSc6XG4gICAgICAgIGNhc2UgJ2xpbmVicmVhayc6XG4gICAgICAgIGNhc2UgJ3NvZnRicmVhayc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdE5vZGUobWROb2RlLCBjb25kaXRpb24sIGluY2x1ZGVTZWxmKSB7XG4gICAgaWYgKGluY2x1ZGVTZWxmID09PSB2b2lkIDApIHsgaW5jbHVkZVNlbGYgPSB0cnVlOyB9XG4gICAgbWROb2RlID0gaW5jbHVkZVNlbGYgPyBtZE5vZGUgOiBtZE5vZGUucGFyZW50O1xuICAgIHdoaWxlIChtZE5vZGUgJiYgbWROb2RlLnR5cGUgIT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihtZE5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWROb2RlO1xuICAgICAgICB9XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnROb2RlcyhtZE5vZGUsIGl0ZXJhdGVlLCBpbmNsdWRlU2VsZikge1xuICAgIGlmIChpbmNsdWRlU2VsZiA9PT0gdm9pZCAwKSB7IGluY2x1ZGVTZWxmID0gdHJ1ZTsgfVxuICAgIG1kTm9kZSA9IGluY2x1ZGVTZWxmID8gbWROb2RlIDogbWROb2RlLnBhcmVudDtcbiAgICB3aGlsZSAobWROb2RlICYmIG1kTm9kZS50eXBlICE9PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgIGl0ZXJhdGVlKG1kTm9kZSk7XG4gICAgICAgIG1kTm9kZSA9IG1kTm9kZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkT2Zmc2V0UG9zKG9yaWdpblBvcywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIFtvcmlnaW5Qb3NbMF0sIG9yaWdpblBvc1sxXSArIG9mZnNldF07XG59XG5mdW5jdGlvbiBzZXRPZmZzZXRQb3Mob3JpZ2luUG9zLCBuZXdPZmZzZXQpIHtcbiAgICByZXR1cm4gW29yaWdpblBvc1swXSwgbmV3T2Zmc2V0XTtcbn1cbmZ1bmN0aW9uIGdldElubGluZU1hcmtkb3duVGV4dChtZE5vZGUpIHtcbiAgICB2YXIgdGV4dCA9IG1kTm9kZS5maXJzdENoaWxkLmxpdGVyYWw7XG4gICAgc3dpdGNoIChtZE5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdlbXBoJzpcbiAgICAgICAgICAgIHJldHVybiBcIipcIiArIHRleHQgKyBcIipcIjtcbiAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHJldHVybiBcIioqXCIgKyB0ZXh0ICsgXCIqKlwiO1xuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICAgICAgcmV0dXJuIFwifn5cIiArIHRleHQgKyBcIn5+XCI7XG4gICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgcmV0dXJuIFwiYFwiICsgdGV4dCArIFwiYFwiO1xuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbiAgICAgICAgICAgIHZhciBfYSA9IG1kTm9kZSwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbiwgdGl0bGUgPSBfYS50aXRsZTtcbiAgICAgICAgICAgIHZhciBkZWxpbSA9IG1kTm9kZS50eXBlID09PSAnbGluaycgPyAnJyA6ICchJztcbiAgICAgICAgICAgIHJldHVybiBkZWxpbSArIFwiW1wiICsgdGV4dCArIFwiXShcIiArIGRlc3RpbmF0aW9uICsgKHRpdGxlID8gXCIgXFxcIlwiICsgdGl0bGUgKyBcIlxcXCJcIiA6ICcnKSArIFwiKVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFya2Rvd25faXNDb250YWluZXIobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgY2FzZSAnYmxvY2tRdW90ZSc6XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdpdGVtJzpcbiAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgY2FzZSAnaGVhZGluZyc6XG4gICAgICAgIGNhc2UgJ2VtcGgnOlxuICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICBjYXNlICdzdHJpa2UnOlxuICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlSGVhZCc6XG4gICAgICAgIGNhc2UgJ3RhYmxlQm9keSc6XG4gICAgICAgIGNhc2UgJ3RhYmxlUm93JzpcbiAgICAgICAgY2FzZSAndGFibGVDZWxsJzpcbiAgICAgICAgY2FzZSAndGFibGVEZWxpbVJvdyc6XG4gICAgICAgIGNhc2UgJ2N1c3RvbUlubGluZSc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXJrZG93bl9nZXRDaGlsZHJlblRleHQobm9kZSkge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgd2Fsa2VyID0gbm9kZS53YWxrZXIoKTtcbiAgICB2YXIgZXZlbnQgPSBudWxsO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gZXZlbnQubm9kZTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNoaWxkTm9kZS5saXRlcmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd2lkZ2V0L3J1bGVzLnRzXG5cbnZhciB3aWRnZXRSdWxlcyA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtdKSk7XG52YXIgd2lkZ2V0UnVsZU1hcCA9IHt9O1xudmFyIHJlV2lkZ2V0UHJlZml4ID0gL1xcJFxcJHdpZGdldFxcZCtcXHMvO1xuZnVuY3Rpb24gdW53cmFwV2lkZ2V0U3ludGF4KHRleHQpIHtcbiAgICB2YXIgaW5kZXggPSB0ZXh0LnNlYXJjaChyZVdpZGdldFByZWZpeCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB2YXIgcmVzdCA9IHRleHQuc3Vic3RyaW5nKGluZGV4KTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gcmVzdC5yZXBsYWNlKHJlV2lkZ2V0UHJlZml4LCAnJykucmVwbGFjZSgnJCQnLCAnJyk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIHRleHQgKz0gdW53cmFwV2lkZ2V0U3ludGF4KHJlcGxhY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIHRleHQpIHtcbiAgICByZXR1cm4gXCIkJFwiICsgaW5mbyArIFwiIFwiICsgdGV4dCArIFwiJCRcIjtcbn1cbmZ1bmN0aW9uIHdpZGdldFRvRE9NKGluZm8sIHRleHQpIHtcbiAgICB2YXIgX2EgPSB3aWRnZXRSdWxlTWFwW2luZm9dLCBydWxlID0gX2EucnVsZSwgdG9ET00gPSBfYS50b0RPTTtcbiAgICB2YXIgbWF0Y2hlcyA9IHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KS5tYXRjaChydWxlKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB0ZXh0ID0gbWF0Y2hlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHRvRE9NKHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0V2lkZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHdpZGdldFJ1bGVzO1xufVxuZnVuY3Rpb24gc2V0V2lkZ2V0UnVsZXMocnVsZXMpIHtcbiAgICB3aWRnZXRSdWxlcyA9IHJ1bGVzO1xuICAgIHdpZGdldFJ1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgIHdpZGdldFJ1bGVNYXBbXCJ3aWRnZXRcIiArIGluZGV4XSA9IHJ1bGU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZU5vZGVzKG5vZGVzLCB0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkge1xuICAgIHJldHVybiBub2Rlcy5jb25jYXQoY3JlYXRlTm9kZXNXaXRoV2lkZ2V0KHRleHQsIHNjaGVtYSwgcnVsZUluZGV4KSk7XG59XG4vKipcbiAqIGNyZWF0ZSBub2RlcyB3aXRoIHBsYWluIHRleHQgYW5kIHJlcGxhY2UgdGV4dCBtYXRjaGVkIHRvIHRoZSB3aWRnZXQgcnVsZXMgd2l0aCB0aGUgd2lkZ2V0IG5vZGVcbiAqIEZvciBleGFtcGxlLCBpbiBjYXNlIHRoZSB0ZXh0IGFuZCB3aWRnZXQgcnVsZXMgYXMgYmVsb3dcbiAqXG4gKiB0ZXh0OiAkdGVzdCBwbGFpbiB0ZXh0ICN0ZXN0XG4gKiB3aWRnZXQgcnVsZXM6IFt7IHJ1bGU6IC8kLisvIH0sIHsgcnVsZTogLyMuKy8gfV1cbiAqXG4gKiBUaGUgY3JlYXRpbmcgbm9kZSBwcm9jZXNzIGlzIHJlY3Vyc2l2ZSBhbmQgaXMgYXMgZm9sbG93cy5cbiAqXG4gKiBpbiBmaXJzdCB3aWRnZXQgcnVsZSgvJC4rLylcbiAqICAkdGVzdCAtPiB3aWRnZXQgbm9kZVxuICogIHBsYWluIHRleHQgLT4gbWF0Y2ggd2l0aCBuZXh0IHdpZGdldCBydWxlXG4gKiAgI3Rlc3QgLT4gbWF0Y2ggd2l0aCBuZXh0IHdpZGdldCBydWxlXG4gKlxuICogaW4gc2Vjb25kIHdpZGdldCBydWxlKC8jLisvKVxuICogIHBsYWluIHRleHQgLT4gdGV4dCBub2RlKG5vIHJ1bGUgZm9yIG1hdGNoaW5nKVxuICogICN0ZXN0IC0+IHdpZGdldCBub2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzV2l0aFdpZGdldCh0ZXh0LCBzY2hlbWEsIHJ1bGVJbmRleCkge1xuICAgIGlmIChydWxlSW5kZXggPT09IHZvaWQgMCkgeyBydWxlSW5kZXggPSAwOyB9XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIHJ1bGUgPSAod2lkZ2V0UnVsZXNbcnVsZUluZGV4XSB8fCB7fSkucnVsZTtcbiAgICB2YXIgbmV4dFJ1bGVJbmRleCA9IHJ1bGVJbmRleCArIDE7XG4gICAgdGV4dCA9IHVud3JhcFdpZGdldFN5bnRheCh0ZXh0KTtcbiAgICBpZiAocnVsZSAmJiBydWxlLnRlc3QodGV4dCkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoKGluZGV4ID0gdGV4dC5zZWFyY2gocnVsZSkpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0ZXh0LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAvLyBnZXQgd2lkZ2V0IG5vZGUgb24gZmlyc3Qgc3BsaXR0ZWQgdGV4dCB1c2luZyBuZXh0IHdpZGdldCBydWxlXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIG5vZGVzID0gbWVyZ2VOb2Rlcyhub2RlcywgcHJldiwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJ1aWxkIHdpZGdldCBub2RlIHVzaW5nIGN1cnJlbnQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRleHQubWF0Y2gocnVsZSlbMF07XG4gICAgICAgICAgICB2YXIgaW5mbyA9IFwid2lkZ2V0XCIgKyBydWxlSW5kZXg7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHNjaGVtYS5ub2Rlcy53aWRnZXQuY3JlYXRlKHsgaW5mbzogaW5mbyB9LCBzY2hlbWEudGV4dChjcmVhdGVXaWRnZXRDb250ZW50KGluZm8sIGxpdGVyYWwpKSkpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKGxpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgd2lkZ2V0IG5vZGUgb24gbGFzdCBzcGxpdHRlZCB0ZXh0IHVzaW5nIG5leHQgd2lkZ2V0IHJ1bGVcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbWVyZ2VOb2Rlcyhub2RlcywgdGV4dCwgc2NoZW1hLCBuZXh0UnVsZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0ZXh0KSB7XG4gICAgICAgIG5vZGVzID1cbiAgICAgICAgICAgIHJ1bGVJbmRleCA8IHdpZGdldFJ1bGVzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICA/IG1lcmdlTm9kZXMobm9kZXMsIHRleHQsIHNjaGVtYSwgbmV4dFJ1bGVJbmRleClcbiAgICAgICAgICAgICAgICA6IFtzY2hlbWEudGV4dCh0ZXh0KV07XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldFdpZGdldENvbnRlbnQod2lkZ2V0Tm9kZSkge1xuICAgIHZhciBldmVudDtcbiAgICB2YXIgdGV4dCA9ICcnO1xuICAgIHZhciB3YWxrZXIgPSB3aWRnZXROb2RlLndhbGtlcigpO1xuICAgIHdoaWxlICgoZXZlbnQgPSB3YWxrZXIubmV4dCgpKSkge1xuICAgICAgICB2YXIgbm9kZSA9IGV2ZW50Lm5vZGUsIGVudGVyaW5nID0gZXZlbnQuZW50ZXJpbmc7XG4gICAgICAgIGlmIChlbnRlcmluZykge1xuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHdpZGdldE5vZGUgJiYgbm9kZS50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IGdldElubGluZU1hcmtkb3duVGV4dChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHdhbGtlci5yZXN1bWVBdCh3aWRnZXROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgd2Fsa2VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLmxpdGVyYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2RvbXB1cmlmeS9kaXN0L3B1cmlmeS5qc1xudmFyIHB1cmlmeSA9IF9fd2VicGFja19yZXF1aXJlX18oMzY4KTtcbnZhciBwdXJpZnlfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocHVyaWZ5KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9zYW5pdGl6ZXIvaHRtbFNhbml0aXplci50c1xuXG5cblxudmFyIENBTl9CRV9XSElURV9UQUdfTElTVCA9IFsnaWZyYW1lJywgJ2VtYmVkJ107XG52YXIgd2hpdGVUYWdMaXN0ID0gW107XG5mdW5jdGlvbiBodG1sU2FuaXRpemVyX3JlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0YWdOYW1lKSB7XG4gICAgaWYgKGNvbW1vbl9pbmNsdWRlcyhDQU5fQkVfV0hJVEVfVEFHX0xJU1QsIHRhZ05hbWUpKSB7XG4gICAgICAgIHdoaXRlVGFnTGlzdC5wdXNoKHRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FuaXRpemVIVE1MKGh0bWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHVyaWZ5X2RlZmF1bHQoKS5zYW5pdGl6ZShodG1sLCB0c2xpYl9lczZfYXNzaWduKHsgQUREX1RBR1M6IHdoaXRlVGFnTGlzdCwgQUREX0FUVFI6IFsncmVsJywgJ3RhcmdldCcsICdocmVmbGFuZycsICd0eXBlJ10sIEZPUkJJRF9UQUdTOiBbXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgICAgICAndGV4dGFyZWEnLFxuICAgICAgICAgICAgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAnc2VsZWN0JyxcbiAgICAgICAgICAgICdtZXRhJyxcbiAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICAnbGluaycsXG4gICAgICAgICAgICAndGl0bGUnLFxuICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAnYmFzZScsXG4gICAgICAgIF0gfSwgb3B0aW9ucykpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd3lzaXd5Zy9ub2Rlcy9odG1sLnRzXG5cblxuXG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuSFRNTChub2RlLCB0eXBlTmFtZSkge1xuICAgIHJldHVybiBub2RlXG4gICAgICAgIC5saXRlcmFsLnJlcGxhY2UobmV3IFJlZ0V4cChcIig8XFxcXHMqXCIgKyB0eXBlTmFtZSArIFwiW14+XSo+KXwoPC9cIiArIHR5cGVOYW1lICsgXCJcXFxccypbPl0pXCIsICdpZycpLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGdldEhUTUxBdHRyc0J5SFRNTFN0cmluZyhodG1sKSB7XG4gICAgaHRtbCA9IGh0bWwubWF0Y2gocmVIVE1MVGFnKVswXTtcbiAgICB2YXIgYXR0cnMgPSBodG1sLm1hdGNoKG5ldyBSZWdFeHAoY29uc3RhbnRzX0FUVFJJQlVURSwgJ2cnKSk7XG4gICAgcmV0dXJuIGF0dHJzXG4gICAgICAgID8gYXR0cnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGF0dHIudHJpbSgpLnNwbGl0KCc9JyksIG5hbWUgPSBfYVswXSwgdmFsdWVzID0gX2Euc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IHZhbHVlcy5qb2luKCc9JykucmVwbGFjZSgvJ3xcIi9nLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pXG4gICAgICAgIDoge307XG59XG5mdW5jdGlvbiBnZXRIVE1MQXR0cnMoZG9tKSB7XG4gICAgcmV0dXJuIHRvQXJyYXlfZGVmYXVsdCgpKGRvbS5hdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgYXR0cikge1xuICAgICAgICBhY2NbYXR0ci5ub2RlTmFtZV0gPSBhdHRyLm5vZGVWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZURPTShub2RlLCB0eXBlTmFtZSwgc2FuaXRpemVyLCB3d1RvRE9NQWRhcHRvcikge1xuICAgIHZhciBkb20gPSB3d1RvRE9NQWRhcHRvci5nZXRUb0RPTU5vZGUodHlwZU5hbWUpKG5vZGUpO1xuICAgIHZhciBodG1sID0gc2FuaXRpemVyKGRvbS5vdXRlckhUTUwpO1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICBkb20gPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB2YXIgaHRtbEF0dHJzID0gZ2V0SFRNTEF0dHJzKGRvbSk7XG4gICAgcmV0dXJuIHsgZG9tOiBkb20sIGh0bWxBdHRyczogaHRtbEF0dHJzIH07XG59XG52YXIgc2NoZW1hRmFjdG9yeSA9IHtcbiAgICBodG1sQmxvY2s6IGZ1bmN0aW9uICh0eXBlTmFtZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXRvbTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdibG9jaysnLFxuICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGh0bWxBdHRyczogeyBkZWZhdWx0OiB7fSB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuSFRNTDogeyBkZWZhdWx0OiAnJyB9LFxuICAgICAgICAgICAgICAgIGh0bWxCbG9jazogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyczogZ2V0SFRNTEF0dHJzKGRvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IVE1MOiBkb20uaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHRvRE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKSwgZG9tID0gX2EuZG9tLCBodG1sQXR0cnMgPSBfYS5odG1sQXR0cnM7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzLmNsYXNzID0gaHRtbEF0dHJzLmNsYXNzID8gaHRtbEF0dHJzLmNsYXNzICsgXCIgaHRtbC1ibG9ja1wiIDogJ2h0bWwtYmxvY2snO1xuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFt0eXBlTmFtZSwgaHRtbEF0dHJzXSwgdG9BcnJheV9kZWZhdWx0KCkoZG9tLmNoaWxkTm9kZXMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBodG1sSW5saW5lOiBmdW5jdGlvbiAodHlwZU5hbWUsIHNhbml0aXplSFRNTCwgd3dUb0RPTUFkYXB0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IHt9IH0sXG4gICAgICAgICAgICAgICAgaHRtbElubGluZTogeyBkZWZhdWx0OiB0cnVlIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogdHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWxBdHRyczogZ2V0SFRNTEF0dHJzKGRvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdG9ET006IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxBdHRycyA9IHNhbml0aXplRE9NKG5vZGUsIHR5cGVOYW1lLCBzYW5pdGl6ZUhUTUwsIHd3VG9ET01BZGFwdG9yKS5odG1sQXR0cnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0eXBlTmFtZSwgaHRtbEF0dHJzLCAwXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVIVE1MU2NoZW1hTWFwKGNvbnZlcnRvck1hcCwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcikge1xuICAgIHZhciBodG1sU2NoZW1hTWFwID0geyBub2Rlczoge30sIG1hcmtzOiB7fSB9O1xuICAgIFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sVHlwZSkge1xuICAgICAgICBpZiAoY29udmVydG9yTWFwW2h0bWxUeXBlXSkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udmVydG9yTWFwW2h0bWxUeXBlXSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUeXBlID0gaHRtbFR5cGUgPT09ICdodG1sQmxvY2snID8gJ25vZGVzJyA6ICdtYXJrcyc7XG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgdGFnIHdoaXRlIGxpc3QgZm9yIHByZXZlbnRpbmcgdG8gcmVtb3ZlIHRoZSBodG1sIGluIHNhbml0aXplclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyVGFnV2hpdGVsaXN0SWZQb3NzaWJsZSh0eXBlKTtcbiAgICAgICAgICAgICAgICBodG1sU2NoZW1hTWFwW3RhcmdldFR5cGVdW3R5cGVdID0gc2NoZW1hRmFjdG9yeVtodG1sVHlwZV0odHlwZSwgc2FuaXRpemVIVE1MLCB3d1RvRE9NQWRhcHRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBodG1sU2NoZW1hTWFwO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFya2Rvd24vaHRtbFJlbmRlckNvbnZlcnRvcnMudHNcblxuXG5cblxuXG5cbnZhciByZUNsb3NlVGFnID0gL15cXHMqPFxccypcXC8vO1xudmFyIGh0bWxSZW5kZXJDb252ZXJ0b3JzX2Jhc2VDb252ZXJ0b3JzID0ge1xuICAgIHBhcmFncmFwaDogZnVuY3Rpb24gKF8sIF9hKSB7XG4gICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW4sIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogZW50ZXJpbmcgPyAnb3BlblRhZycgOiAnY2xvc2VUYWcnLFxuICAgICAgICAgICAgICAgIG91dGVyTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAncCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4oKTtcbiAgICB9LFxuICAgIHNvZnRicmVhazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGlzUHJldk5vZGVIVE1MID0gbm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSAnaHRtbElubGluZSc7XG4gICAgICAgIHZhciBpc1ByZXZCUiA9IGlzUHJldk5vZGVIVE1MICYmIC88YnIgP1xcLz8+Ly50ZXN0KG5vZGUucHJldi5saXRlcmFsKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBpc1ByZXZCUiA/ICdcXG4nIDogJzxicj5cXG4nO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICB9LFxuICAgIGl0ZW06IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgZW50ZXJpbmcgPSBfYS5lbnRlcmluZztcbiAgICAgICAgaWYgKGVudGVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChub2RlLmxpc3REYXRhLnRhc2spIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2snXSA9ICcnO1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgndGFzay1saXN0LWl0ZW0nKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5saXN0RGF0YS5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnY2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWydkYXRhLXRhc2stY2hlY2tlZCddID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3BlblRhZycsXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2xpJyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3V0ZXJOZXdMaW5lOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2Nsb3NlVGFnJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdsaScsXG4gICAgICAgICAgICBvdXRlck5ld0xpbmU6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHsgJ2RhdGEtYmFja3RpY2tzJzogU3RyaW5nKG5vZGUudGlja0NvdW50KSB9O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdjb2RlJywgYXR0cmlidXRlczogYXR0cmlidXRlcyB9LFxuICAgICAgICAgICAgeyB0eXBlOiAndGV4dCcsIGNvbnRlbnQ6IG5vZGUubGl0ZXJhbCB9LFxuICAgICAgICAgICAgeyB0eXBlOiAnY2xvc2VUYWcnLCB0YWdOYW1lOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGNvZGVCbG9jazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF9hID0gbm9kZSwgZmVuY2VMZW5ndGggPSBfYS5mZW5jZUxlbmd0aCwgaW5mbyA9IF9hLmluZm87XG4gICAgICAgIHZhciBpbmZvV29yZHMgPSBpbmZvID8gaW5mby5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgIHZhciBwcmVDbGFzc2VzID0gW107XG4gICAgICAgIHZhciBjb2RlQXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGZlbmNlTGVuZ3RoID4gMykge1xuICAgICAgICAgICAgY29kZUF0dHJzWydkYXRhLWJhY2t0aWNrcyddID0gZmVuY2VMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZm9Xb3Jkcy5sZW5ndGggPiAwICYmIGluZm9Xb3Jkc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFuZyA9IGluZm9Xb3Jkc1swXTtcbiAgICAgICAgICAgIHByZUNsYXNzZXMucHVzaChcImxhbmctXCIgKyBsYW5nKTtcbiAgICAgICAgICAgIGNvZGVBdHRyc1snZGF0YS1sYW5ndWFnZSddID0gbGFuZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiAnb3BlblRhZycsIHRhZ05hbWU6ICdwcmUnLCBjbGFzc05hbWVzOiBwcmVDbGFzc2VzIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdvcGVuVGFnJywgdGFnTmFtZTogJ2NvZGUnLCBhdHRyaWJ1dGVzOiBjb2RlQXR0cnMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCBjb250ZW50OiBub2RlLmxpdGVyYWwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogJ2Nsb3NlVGFnJywgdGFnTmFtZTogJ2NvZGUnIH0sXG4gICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdwcmUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBjdXN0b21JbmxpbmU6IGZ1bmN0aW9uIChub2RlLCBfYSkge1xuICAgICAgICB2YXIgb3JpZ2luID0gX2Eub3JpZ2luLCBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBza2lwQ2hpbGRyZW4gPSBfYS5za2lwQ2hpbGRyZW47XG4gICAgICAgIHZhciBpbmZvID0gbm9kZS5pbmZvO1xuICAgICAgICBpZiAoaW5mby5pbmRleE9mKCd3aWRnZXQnKSAhPT0gLTEgJiYgZW50ZXJpbmcpIHtcbiAgICAgICAgICAgIHNraXBDaGlsZHJlbigpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBnZXRXaWRnZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgdmFyIGh0bWxJbmxpbmUgPSB3aWRnZXRUb0RPTShpbmZvLCBjb250ZW50KS5vdXRlckhUTUw7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ29wZW5UYWcnLCB0YWdOYW1lOiAnc3BhbicsIGNsYXNzTmFtZXM6IFsndHVpLXdpZGdldCddIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnaHRtbCcsIGNvbnRlbnQ6IGh0bWxJbmxpbmUgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6ICdjbG9zZVRhZycsIHRhZ05hbWU6ICdzcGFuJyB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBnZXRIVE1MUmVuZGVyQ29udmVydG9ycyhsaW5rQXR0cmlidXRlcywgY3VzdG9tQ29udmVydG9ycykge1xuICAgIHZhciBjb252ZXJ0b3JzID0gdHNsaWJfZXM2X2Fzc2lnbih7fSwgaHRtbFJlbmRlckNvbnZlcnRvcnNfYmFzZUNvbnZlcnRvcnMpO1xuICAgIGlmIChsaW5rQXR0cmlidXRlcykge1xuICAgICAgICBjb252ZXJ0b3JzLmxpbmsgPSBmdW5jdGlvbiAoXywgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbnRlcmluZyA9IF9hLmVudGVyaW5nLCBvcmlnaW4gPSBfYS5vcmlnaW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gb3JpZ2luKCk7XG4gICAgICAgICAgICBpZiAoZW50ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXR0cmlidXRlcyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgcmVzdWx0LmF0dHJpYnV0ZXMpLCBsaW5rQXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY3VzdG9tQ29udmVydG9ycykge1xuICAgICAgICBPYmplY3Qua2V5cyhjdXN0b21Db252ZXJ0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICAgICAgICAgICAgdmFyIG9yZ0NvbnZlcnRvciA9IGNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgdmFyIGN1c3RvbUNvbnZlcnRvciA9IGN1c3RvbUNvbnZlcnRvcnNbbm9kZVR5cGVdO1xuICAgICAgICAgICAgaWYgKG9yZ0NvbnZlcnRvciAmJiBpc0Z1bmN0aW9uX2RlZmF1bHQoKShjdXN0b21Db252ZXJ0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q29udGV4dCA9IHRzbGliX2VzNl9hc3NpZ24oe30sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lm9yaWdpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yZ0NvbnZlcnRvcihub2RlLCBjb250ZXh0KTsgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnZlcnRvcihub2RlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbW9uX2luY2x1ZGVzKFsnaHRtbEJsb2NrJywgJ2h0bWxJbmxpbmUnXSwgbm9kZVR5cGUpICYmICFpc0Z1bmN0aW9uX2RlZmF1bHQoKShjdXN0b21Db252ZXJ0b3IpKSB7XG4gICAgICAgICAgICAgICAgY29udmVydG9yc1tub2RlVHlwZV0gPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IG5vZGUubGl0ZXJhbC5tYXRjaChyZUhUTUxUYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RIVE1MID0gbWF0Y2hlZFswXSwgb3BlblRhZ05hbWUgPSBtYXRjaGVkWzFdLCBjbG9zZVRhZ05hbWUgPSBtYXRjaGVkWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gKG9wZW5UYWdOYW1lIHx8IGNsb3NlVGFnTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodG1sQ29udmVydG9yID0gY3VzdG9tQ29udmVydG9yW3R5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbkhUTUwgPSBnZXRDaGlsZHJlbkhUTUwobm9kZSwgdHlwZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh0bWxDb252ZXJ0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3B5IGZvciBwcmV2ZW50aW5nIHRvIG92ZXJ3cml0ZSB0aGUgb3JpZ2luaWFsIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSB0c2xpYl9lczZfYXNzaWduKHt9LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmF0dHJzID0gZ2V0SFRNTEF0dHJzQnlIVE1MU3RyaW5nKHJvb3RIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmNoaWxkcmVuSFRNTCA9IGNoaWxkcmVuSFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnR5cGUgPSB0eXBlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVudGVyaW5nID0gIXJlQ2xvc2VUYWcudGVzdChub2RlLmxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sQ29udmVydG9yKG5ld05vZGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0Lm9yaWdpbigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb252ZXJ0b3JzW25vZGVUeXBlXSA9IGN1c3RvbUNvbnZlcnRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0b3JzO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvbWFya2Rvd24vc2Nyb2xsL2RvbS50c1xuXG5cbnZhciBuZXN0YWJsZVR5cGVzID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoWydsaXN0JywgJ2l0ZW0nLCAnYmxvY2tRdW90ZSddKSk7XG52YXIgbmVzdGFibGVUYWdOYW1lcyA9IFsnVUwnLCAnT0wnLCAnQkxPQ0tRVU9URSddO1xuZnVuY3Rpb24gaXNCbGFua0xpbmUoZG9jLCBpbmRleCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcG1Ob2RlID0gZG9jLmNoaWxkKGluZGV4KTtcbiAgICByZXR1cm4gIXBtTm9kZS5jaGlsZENvdW50IHx8IChwbU5vZGUuY2hpbGRDb3VudCA9PT0gMSAmJiAhKChfYSA9IHBtTm9kZS5maXJzdENoaWxkLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmltKCkpKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclJhbmdlSGVpZ2h0SW5mbyhkb2MsIG1kTm9kZSwgY2hpbGRyZW4pIHtcbiAgICB2YXIgc3RhcnQgPSBnZXRNZFN0YXJ0TGluZShtZE5vZGUpIC0gMTtcbiAgICB2YXIgZW5kID0gZ2V0TWRFbmRMaW5lKG1kTm9kZSkgLSAxO1xuICAgIHZhciByZWN0ID0gY2hpbGRyZW5bc3RhcnRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBoZWlnaHQgPSBjaGlsZHJlbltlbmRdLm9mZnNldFRvcCAtXG4gICAgICAgIGNoaWxkcmVuW3N0YXJ0XS5vZmZzZXRUb3AgK1xuICAgICAgICBjaGlsZHJlbltlbmRdLmNsaWVudEhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGhlaWdodCA8PSAwXG4gICAgICAgICAgICA/IGNoaWxkcmVuW3N0YXJ0XS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIDogaGVpZ2h0ICsgZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBNYXRoLm1pbihlbmQgKyAxLCBkb2MuY2hpbGRDb3VudCAtIDEpKSxcbiAgICAgICAgcmVjdDogcmVjdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QmxhbmtMaW5lc0hlaWdodChkb2MsIGNoaWxkcmVuLCBzdGFydCkge1xuICAgIHZhciBlbmQgPSBkb2MuY2hpbGRDb3VudCAtIDE7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCAmJiBpc0JsYW5rTGluZShkb2MsIHN0YXJ0KSkge1xuICAgICAgICBoZWlnaHQgKz0gY2hpbGRyZW5bc3RhcnRdLmNsaWVudEhlaWdodDtcbiAgICAgICAgc3RhcnQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodDtcbn1cbmZ1bmN0aW9uIGZpbmRBbmNlc3RvckhhdmluZ0lkKGVsLCByb290KSB7XG4gICAgd2hpbGUgKCFlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbm9kZWlkJykgJiYgZWwucGFyZW50RWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGRvbV9nZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkge1xuICAgIHZhciBvZmZzZXRUb3AgPSAwO1xuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gcm9vdCkge1xuICAgICAgICBpZiAoIWNvbW1vbl9pbmNsdWRlcyhuZXN0YWJsZVRhZ05hbWVzLCBlbC50YWdOYW1lKSkge1xuICAgICAgICAgICAgb2Zmc2V0VG9wICs9IGVsLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwub2Zmc2V0UGFyZW50ID09PSByb290Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0VG9wO1xufVxuZnVuY3Rpb24gZmluZEFkamFjZW50RWxlbWVudFRvU2Nyb2xsVG9wKHNjcm9sbFRvcCwgcm9vdCkge1xuICAgIHZhciBlbCA9IHJvb3Q7XG4gICAgdmFyIHByZXYgPSBudWxsO1xuICAgIHdoaWxlIChlbCkge1xuICAgICAgICB2YXIgZmlyc3RFbGVtZW50Q2hpbGQgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgaWYgKCFmaXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RTaWJsaW5nID0gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGZpcnN0RWxlbWVudENoaWxkLCBzY3JvbGxUb3AsIGRvbV9nZXRUb3RhbE9mZnNldFRvcChlbCwgcm9vdCkpO1xuICAgICAgICBwcmV2ID0gZWw7XG4gICAgICAgIGVsID0gbGFzdFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciBhZGphY2VudEVsID0gZWwgfHwgcHJldjtcbiAgICByZXR1cm4gYWRqYWNlbnRFbCA9PT0gcm9vdCA/IG51bGwgOiBhZGphY2VudEVsO1xufVxuZnVuY3Rpb24gZmluZExhc3RTaWJsaW5nRWxlbWVudFRvU2Nyb2xsVG9wKGVsLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkge1xuICAgIGlmIChlbCAmJiBzY3JvbGxUb3AgPiBvZmZzZXRUb3AgKyBlbC5vZmZzZXRUb3ApIHtcbiAgICAgICAgcmV0dXJuIChmaW5kTGFzdFNpYmxpbmdFbGVtZW50VG9TY3JvbGxUb3AoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCBzY3JvbGxUb3AsIG9mZnNldFRvcCkgfHwgZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEFkZGl0aW9uYWxQb3Moc2Nyb2xsVG9wLCBvZmZzZXRUb3AsIGhlaWdodCwgdGFyZ2V0Tm9kZUhlaWdodCkge1xuICAgIHZhciByYXRpbyA9IE1hdGgubWluKChzY3JvbGxUb3AgLSBvZmZzZXRUb3ApIC8gaGVpZ2h0LCAxKTtcbiAgICByZXR1cm4gcmF0aW8gKiB0YXJnZXROb2RlSGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZU9iaihwcmV2aWV3Q29udGVudCwgbWROb2RlKSB7XG4gICAgdmFyIGVsID0gcHJldmlld0NvbnRlbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLW5vZGVpZD1cXFwiXCIgKyBtZE5vZGUuaWQgKyBcIlxcXCJdXCIpO1xuICAgIHdoaWxlICghZWwgfHwgaXNTdHlsZWRJbmxpbmVOb2RlKG1kTm9kZSkpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLnBhcmVudDtcbiAgICAgICAgZWwgPSBwcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG1kTm9kZS5pZCArIFwiXFxcIl1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZXROb25OZXN0YWJsZU5vZGVPYmooeyBtZE5vZGU6IG1kTm9kZSwgZWw6IGVsIH0pO1xufVxuZnVuY3Rpb24gZ2V0Tm9uTmVzdGFibGVOb2RlT2JqKF9hKSB7XG4gICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgZWwgPSBfYS5lbDtcbiAgICB3aGlsZSAoKGluY2x1ZGVzKG5lc3RhYmxlVHlwZXMsIG1kTm9kZS50eXBlKSB8fCBtZE5vZGUudHlwZSA9PT0gJ3RhYmxlJykgJiYgbWROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbWROb2RlID0gbWROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGVsID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB7IG1kTm9kZTogbWROb2RlLCBlbDogZWwgfTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL21hcmtkb3duL3Njcm9sbC9vZmZzZXQudHNcblxuXG52YXIgb2Zmc2V0SW5mb01hcCA9IHt9O1xuZnVuY3Rpb24gc2V0SGVpZ2h0KGlkLCBoZWlnaHQpIHtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXSA9IG9mZnNldEluZm9NYXBbaWRdIHx8IHt9O1xuICAgIG9mZnNldEluZm9NYXBbaWRdLmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHNldE9mZnNldFRvcChpZCwgb2Zmc2V0VG9wKSB7XG4gICAgb2Zmc2V0SW5mb01hcFtpZF0gPSBvZmZzZXRJbmZvTWFwW2lkXSB8fCB7fTtcbiAgICBvZmZzZXRJbmZvTWFwW2lkXS5vZmZzZXRUb3AgPSBvZmZzZXRUb3A7XG59XG5mdW5jdGlvbiBnZXRIZWlnaHQoaWQpIHtcbiAgICByZXR1cm4gb2Zmc2V0SW5mb01hcFtpZF0gJiYgb2Zmc2V0SW5mb01hcFtpZF0uaGVpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0VG9wKGlkKSB7XG4gICAgcmV0dXJuIG9mZnNldEluZm9NYXBbaWRdICYmIG9mZnNldEluZm9NYXBbaWRdLm9mZnNldFRvcDtcbn1cbmZ1bmN0aW9uIHJlbW92ZU9mZnNldEluZm9CeU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIGRlbGV0ZSBvZmZzZXRJbmZvTWFwW051bWJlcihub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKSldO1xuICAgICAgICB0b0FycmF5X2RlZmF1bHQoKShub2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFuZFNhdmVPZmZzZXRJbmZvKG5vZGUsIHJvb3QsIG1kTm9kZUlkKSB7XG4gICAgdmFyIGNhY2hlZEhlaWdodCA9IGdldEhlaWdodChtZE5vZGVJZCk7XG4gICAgdmFyIGNhY2hlZFRvcCA9IGdldE9mZnNldFRvcChtZE5vZGVJZCk7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBjYWNoZWRIZWlnaHQgfHwgbm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFRvcCA9IGNhY2hlZFRvcCB8fCBnZXRUb3RhbE9mZnNldFRvcChub2RlLCByb290KSB8fCBub2RlLm9mZnNldFRvcDtcbiAgICBpZiAoIWNhY2hlZEhlaWdodCkge1xuICAgICAgICBzZXRIZWlnaHQobWROb2RlSWQsIG5vZGVIZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlZFRvcCkge1xuICAgICAgICBzZXRPZmZzZXRUb3AobWROb2RlSWQsIG9mZnNldFRvcCk7XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGVIZWlnaHQ6IG5vZGVIZWlnaHQsIG9mZnNldFRvcDogb2Zmc2V0VG9wIH07XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9tYXJrZG93bi9tZFByZXZpZXcudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgQ0xBU1NfSElHSExJR0hUID0gY2xzKCdtZC1wcmV2aWV3LWhpZ2hsaWdodCcpO1xuZnVuY3Rpb24gZmluZFRhYmxlQ2VsbCh0YWJsZVJvdywgY2hPZmZzZXQpIHtcbiAgICB2YXIgY2VsbCA9IHRhYmxlUm93LmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNlbGwgJiYgY2VsbC5uZXh0KSB7XG4gICAgICAgIGlmIChnZXRNZFN0YXJ0Q2goY2VsbC5uZXh0KSA+IGNoT2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbCA9IGNlbGwubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG59XG4vKipcbiAqIENsYXNzIE1hcmtkb3duIFByZXZpZXdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gYmFzZSBlbGVtZW50XG4gKiBAcGFyYW0ge2V2ZW50RW1pdHRlcn0gZXZlbnRFbWl0dGVyIC0gZXZlbnQgbWFuYWdlclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5pc1ZpZXdlciAtIHRydWUgZm9yIHZpZXctb25seSBtb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuaGlnaGxpZ2h0IC0gdHJ1ZSBmb3IgdXNpbmcgbGl2ZS1oaWdobGlnaHQgZmVhdHVyZVxuICogQHBhcmFtIHtvYmplY3R9IG9waXRvbnMubGlua0F0dHJpYnV0ZXMgLSBhdHRyaWJ1dGVzIGZvciBsaW5rIGVsZW1lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcGl0b25zLmN1c3RvbUhUTUxSZW5kZXJlciAtIG1hcCBvZiBjdXN0b20gSFRNTCByZW5kZXIgZnVuY3Rpb25zXG4gKlxuICogQGlnbm9yZVxuICovXG52YXIgTWFya2Rvd25QcmV2aWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcmtkb3duUHJldmlldyhldmVudEVtaXR0ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIgPSBldmVudEVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaXNWaWV3ZXIgPSAhIW9wdGlvbnMuaXNWaWV3ZXI7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gY2xzKCdtZC1wcmV2aWV3Jyk7XG4gICAgICAgIHZhciBsaW5rQXR0cmlidXRlcyA9IG9wdGlvbnMubGlua0F0dHJpYnV0ZXMsIGN1c3RvbUhUTUxSZW5kZXJlciA9IG9wdGlvbnMuY3VzdG9tSFRNTFJlbmRlcmVyLCBzYW5pdGl6ZXIgPSBvcHRpb25zLnNhbml0aXplciwgX2EgPSBvcHRpb25zLmhpZ2hsaWdodCwgaGlnaGxpZ2h0ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2E7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoe1xuICAgICAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICAgICAgbm9kZUlkOiB0cnVlLFxuICAgICAgICAgICAgY29udmVydG9yczogZ2V0SFRNTFJlbmRlckNvbnZlcnRvcnMobGlua0F0dHJpYnV0ZXMsIGN1c3RvbUhUTUxSZW5kZXJlciksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1cnNvck5vZGVJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xuICAgICAgICB0aGlzLmluaXRFdmVudChoaWdobGlnaHQpO1xuICAgICAgICB0aGlzLmluaXRDb250ZW50U2VjdGlvbigpO1xuICAgICAgICAvLyBUbyBwcmV2ZW50IG92ZXJmbG93aW5nIGNvbnRlbnRzIGluIHRoZSB2aWV3ZXJcbiAgICAgICAgaWYgKHRoaXMuaXNWaWV3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuc3R5bGUub3ZlcmZsb3dXcmFwID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuaW5pdENvbnRlbnRTZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZXZpZXdDb250ZW50ID0gY3JlYXRlRWxlbWVudFdpdGgoXCI8ZGl2IGNsYXNzPVxcXCJcIiArIGNscygnY29udGVudHMnKSArIFwiXFxcIj48L2Rpdj5cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZCh0aGlzLnByZXZpZXdDb250ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS50b2dnbGVBY3RpdmUgPSBmdW5jdGlvbiAoYWN0aXZlKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWwsICdhY3RpdmUnLCBhY3RpdmUpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbiAoaGlnaGxpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbigndXBkYXRlUHJldmlldycsIHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWdobGlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3RlbignY2hhbmdlVG9vbGJhclN0YXRlJywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1kTm9kZSA9IF9hLm1kTm9kZSwgY3Vyc29yUG9zID0gX2EuY3Vyc29yUG9zO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUN1cnNvck5vZGUobWROb2RlLCBjdXJzb3JQb3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbl9kZWZhdWx0KCkodGhpcy5lbCwgJ3Njcm9sbCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3Njcm9sbCcsICdwcmV2aWV3JywgZmluZEFkamFjZW50RWxlbWVudFRvU2Nyb2xsVG9wKGV2ZW50LnRhcmdldC5zY3JvbGxUb3AsIF90aGlzLnByZXZpZXdDb250ZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5saXN0ZW4oJ2NoYW5nZVByZXZpZXdUYWJQcmV2aWV3JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudG9nZ2xlQWN0aXZlKHRydWUpOyB9KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKCdjaGFuZ2VQcmV2aWV3VGFiV3JpdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50b2dnbGVBY3RpdmUoZmFsc2UpOyB9KTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUucmVtb3ZlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JOb2RlSWQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZCh0aGlzLmN1cnNvck5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEVsKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfZGVmYXVsdCgpKGN1cnJlbnRFbCwgQ0xBU1NfSElHSExJR0hUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS51cGRhdGVDdXJzb3JOb2RlID0gZnVuY3Rpb24gKGN1cnNvck5vZGUsIGN1cnNvclBvcykge1xuICAgICAgICBpZiAoY3Vyc29yTm9kZSkge1xuICAgICAgICAgICAgY3Vyc29yTm9kZSA9IGZpbmRDbG9zZXN0Tm9kZShjdXJzb3JOb2RlLCBmdW5jdGlvbiAobWROb2RlKSB7IHJldHVybiAhaXNJbmxpbmVOb2RlKG1kTm9kZSk7IH0pO1xuICAgICAgICAgICAgaWYgKGN1cnNvck5vZGUudHlwZSA9PT0gJ3RhYmxlUm93Jykge1xuICAgICAgICAgICAgICAgIGN1cnNvck5vZGUgPSBmaW5kVGFibGVDZWxsKGN1cnNvck5vZGUsIGN1cnNvclBvc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJzb3JOb2RlLnR5cGUgPT09ICd0YWJsZUJvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgbGluZSBuZXh0IHRvIHRhYmxlXG4gICAgICAgICAgICAgICAgY3Vyc29yTm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvck5vZGVJZCA9IGN1cnNvck5vZGUgPyBjdXJzb3JOb2RlLmlkIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yTm9kZUlkID09PSBjdXJzb3JOb2RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkRUwgPSB0aGlzLmdldEVsZW1lbnRCeU5vZGVJZCh0aGlzLmN1cnNvck5vZGVJZCk7XG4gICAgICAgIHZhciBuZXdFTCA9IHRoaXMuZ2V0RWxlbWVudEJ5Tm9kZUlkKGN1cnNvck5vZGVJZCk7XG4gICAgICAgIGlmIChvbGRFTCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3NfZGVmYXVsdCgpKG9sZEVMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdFTCkge1xuICAgICAgICAgICAgYWRkQ2xhc3NfZGVmYXVsdCgpKG5ld0VMLCBDTEFTU19ISUdITElHSFQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yTm9kZUlkID0gY3Vyc29yTm9kZUlkO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50QnlOb2RlSWQgPSBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBub2RlSWRcbiAgICAgICAgICAgID8gdGhpcy5wcmV2aWV3Q29udGVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtbm9kZWlkPVxcXCJcIiArIG5vZGVJZCArIFwiXFxcIl1cIilcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNoYW5nZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2hhbmdlZC5mb3JFYWNoKGZ1bmN0aW9uIChlZGl0UmVzdWx0KSB7IHJldHVybiBfdGhpcy5yZXBsYWNlUmFuZ2VOb2RlcyhlZGl0UmVzdWx0KTsgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2FmdGVyUHJldmlld1JlbmRlcicsIHRoaXMpO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5yZXBsYWNlUmFuZ2VOb2RlcyA9IGZ1bmN0aW9uIChlZGl0UmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub2RlcyA9IGVkaXRSZXN1bHQubm9kZXMsIHJlbW92ZWROb2RlUmFuZ2UgPSBlZGl0UmVzdWx0LnJlbW92ZWROb2RlUmFuZ2U7XG4gICAgICAgIHZhciBjb250ZW50RWwgPSB0aGlzLnByZXZpZXdDb250ZW50O1xuICAgICAgICB2YXIgbmV3SHRtbCA9IHRoaXMuZXZlbnRFbWl0dGVyLmVtaXRSZWR1Y2UoJ2JlZm9yZVByZXZpZXdSZW5kZXInLCB0aGlzLnNhbml0aXplcihub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLnJlbmRlcihub2RlKTsgfSkuam9pbignJykpKTtcbiAgICAgICAgaWYgKCFyZW1vdmVkTm9kZVJhbmdlKSB7XG4gICAgICAgICAgICBjb250ZW50RWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgbmV3SHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZW1vdmVkTm9kZVJhbmdlLmlkLCBzdGFydE5vZGVJZCA9IF9hWzBdLCBlbmROb2RlSWQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBzdGFydEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoc3RhcnROb2RlSWQpO1xuICAgICAgICAgICAgdmFyIGVuZEVsID0gdGhpcy5nZXRFbGVtZW50QnlOb2RlSWQoZW5kTm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzdGFydEVsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRFbC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgbmV3SHRtbCk7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gc3RhcnRFbDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGVuZEVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0RWwgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoZWwpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVPZmZzZXRJbmZvQnlOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSBuZXh0RWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT2Zmc2V0SW5mb0J5Tm9kZShlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLmdldFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmX2RlZmF1bHQoKSh0aGlzLmVsLCAnc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMuZWwgPSBudWxsO1xuICAgIH07XG4gICAgTWFya2Rvd25QcmV2aWV3LnByb3RvdHlwZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuZ2V0SFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVByb3NlTWlycm9ySGFja05vZGVzKHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MKTtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SFRNTCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9O1xuICAgIE1hcmtkb3duUHJldmlldy5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICBjc3NfZGVmYXVsdCgpKHRoaXMuZWwsIHsgaGVpZ2h0OiBoZWlnaHQgKyBcInB4XCIgfSk7XG4gICAgfTtcbiAgICBNYXJrZG93blByZXZpZXcucHJvdG90eXBlLnNldE1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgY3NzX2RlZmF1bHQoKSh0aGlzLmVsLCB7IG1pbkhlaWdodDogbWluSGVpZ2h0ICsgXCJweFwiIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcmtkb3duUHJldmlldztcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtZFByZXZpZXcgPSAoTWFya2Rvd25QcmV2aWV3KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicHJvc2VtaXJyb3Itc3RhdGVcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3Itc3RhdGVcIixcImFtZFwiOlwicHJvc2VtaXJyb3Itc3RhdGVcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9zdGF0ZV9jb21tb25qczJfcHJvc2VtaXJyb3Jfc3RhdGVfYW1kX3Byb3NlbWlycm9yX3N0YXRlXyA9IF9fd2VicGFja19yZXF1aXJlX18oODE0KTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInByb3NlbWlycm9yLWlucHV0cnVsZXNcIixcImNvbW1vbmpzMlwiOlwicHJvc2VtaXJyb3ItaW5wdXRydWxlc1wiLFwiYW1kXCI6XCJwcm9zZW1pcnJvci1pbnB1dHJ1bGVzXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19jb21tb25qczJfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19hbWRfcHJvc2VtaXJyb3JfaW5wdXRydWxlc18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OSk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJwcm9zZW1pcnJvci12aWV3XCIsXCJjb21tb25qczJcIjpcInByb3NlbWlycm9yLXZpZXdcIixcImFtZFwiOlwicHJvc2VtaXJyb3Itdmlld1wifVxudmFyIGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3ZpZXdfY29tbW9uanMyX3Byb3NlbWlycm9yX3ZpZXdfYW1kX3Byb3NlbWlycm9yX3ZpZXdfID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTEpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicHJvc2VtaXJyb3Ita2V5bWFwXCIsXCJjb21tb25qczJcIjpcInByb3NlbWlycm9yLWtleW1hcFwiLFwiYW1kXCI6XCJwcm9zZW1pcnJvci1rZXltYXBcIn1cbnZhciBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9rZXltYXBfY29tbW9uanMyX3Byb3NlbWlycm9yX2tleW1hcF9hbWRfcHJvc2VtaXJyb3Jfa2V5bWFwXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDgxKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcInByb3NlbWlycm9yLW1vZGVsXCIsXCJjb21tb25qczJcIjpcInByb3NlbWlycm9yLW1vZGVsXCIsXCJhbWRcIjpcInByb3NlbWlycm9yLW1vZGVsXCJ9XG52YXIgZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfbW9kZWxfY29tbW9uanMyX3Byb3NlbWlycm9yX21vZGVsX2FtZF9wcm9zZW1pcnJvcl9tb2RlbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvYXJyYXkvaW5BcnJheS5qc1xudmFyIGluQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyOCk7XG52YXIgaW5BcnJheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbkFycmF5KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy91dGlscy9tYXAudHNcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBpZ25vcmVcbiAqIEBjbGFzc2Rlc2MgRVM2IE1hcFxuICovXG52YXIgbWFwX01hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBNYXAucHJvdG90eXBlLmdldEtleUluZGV4ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaW5BcnJheV9kZWZhdWx0KCkoa2V5LCB0aGlzLmtleXMpO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmdldEtleUluZGV4KGtleSldO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIga2V5SW5kZXggPSB0aGlzLmdldEtleUluZGV4KGtleSk7XG4gICAgICAgIGlmIChrZXlJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc1trZXlJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXlJbmRleChrZXkpID4gLTE7XG4gICAgfTtcbiAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGtleUluZGV4ID0gdGhpcy5nZXRLZXlJbmRleChrZXkpO1xuICAgICAgICBpZiAoa2V5SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShrZXlJbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2Uoa2V5SW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzQXJnID09PSB2b2lkIDApIHsgdGhpc0FyZyA9IHRoaXM7IH1cbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgX3RoaXMua2V5c1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBfdGhpcy5rZXlzW2luZGV4XSwgX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcDtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsc19tYXAgPSAobWFwX01hcCk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pMThuL2kxOG4udHNcbi8qKlxuICogQGZpbGVvdmVydmlldyBJbXBsZW1lbnRzIGkxOG5cbiAqIEBhdXRob3IgTkhOIENsb3VkIEZFIERldmVsb3BtZW50IExhYiA8ZGxfamF2YXNjcmlwdEBuaG4uY29tPlxuICovXG5cblxudmFyIERFRkFVTFRfQ09ERSA9ICdlbi1VUyc7XG4vKipcbiAqIENsYXNzIEkxOG5cbiAqIEBpZ25vcmVcbiAqL1xudmFyIEkxOG4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSTE4bigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gREVGQVVMVF9DT0RFO1xuICAgICAgICB0aGlzLmxhbmdzID0gbmV3IHV0aWxzX21hcCgpO1xuICAgIH1cbiAgICBJMThuLnByb3RvdHlwZS5zZXRDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZSB8fCBERUZBVUxUX0NPREU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbGFuZ3VhZ2Ugc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNvZGVzIGxvY2FsZSBjb2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgbGFuZ3VhZ2Ugc2V0XG4gICAgICovXG4gICAgSTE4bi5wcm90b3R5cGUuc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbiAoY29kZXMsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29kZXMgPSBbXS5jb25jYXQoY29kZXMpO1xuICAgICAgICBjb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmxhbmdzLmhhcyhjb2RlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxhbmdzLnNldChjb2RlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nRGF0YSA9IF90aGlzLmxhbmdzLmdldChjb2RlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYW5ncy5zZXQoY29kZSwgZXh0ZW5kX2RlZmF1bHQoKShsYW5nRGF0YSwgZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEkxOG4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGNvZGUpIHtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYW5nU2V0ID0gdGhpcy5sYW5ncy5nZXQoY29kZSk7XG4gICAgICAgIGlmICghbGFuZ1NldCkge1xuICAgICAgICAgICAgbGFuZ1NldCA9IHRoaXMubGFuZ3MuZ2V0KERFRkFVTFRfQ09ERSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSBsYW5nU2V0W2tleV07XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgbm8gdGV4dCBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIFwiICsgY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcbiAgICByZXR1cm4gSTE4bjtcbn0oKSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGkxOG4gPSAobmV3IEkxOG4oKSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93eXNpd3lnL2hlbHBlci9ub2RlLnRzXG5cblxuZnVuY3Rpb24gZmluZE5vZGVCeShwb3MsIGNvbmRpdGlvbikge1xuICAgIHZhciBkZXB0aCA9IHBvcy5kZXB0aDtcbiAgICB3aGlsZSAoZGVwdGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChjb25kaXRpb24obm9kZSwgZGVwdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZGVwdGggPiAwID8gcG9zLmJlZm9yZShkZXB0aCkgOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5vZGVfaXNMaXN0Tm9kZShfYSkge1xuICAgIHZhciB0eXBlID0gX2EudHlwZTtcbiAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnYnVsbGV0TGlzdCcgfHwgdHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnO1xufVxuZnVuY3Rpb24gaXNJbkxpc3ROb2RlKHBvcykge1xuICAgIHJldHVybiAhIWZpbmROb2RlQnkocG9zLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAnbGlzdEl0ZW0nIHx8IHR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IHR5cGUubmFtZSA9PT0gJ29yZGVyZWRMaXN0JztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzSW5UYWJsZU5vZGUocG9zKSB7XG4gICAgcmV0dXJuICEhZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICd0YWJsZUhlYWRDZWxsJyB8fCB0eXBlLm5hbWUgPT09ICd0YWJsZUJvZHlDZWxsJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0SXRlbShwb3MpIHtcbiAgICByZXR1cm4gZmluZE5vZGVCeShwb3MsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09ICdsaXN0SXRlbSc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVET01JbmZvUGFyc2VkUmF3SFRNTCh0YWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIChkb20pIHtcbiAgICAgICAgICAgIHZhciByYXdIVE1MID0gZG9tLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXctaHRtbCcpO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCAocmF3SFRNTCAmJiB7IHJhd0hUTUw6IHJhd0hUTUwgfSkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDZWxsQXR0cnMoYXR0cnMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICBpZiAoYXR0ck5hbWUgIT09ICdyYXdIVE1MJyAmJiBhdHRyc1thdHRyTmFtZV0pIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ck5hbWUgPT09ICdjbGFzc05hbWUnID8gJ2NsYXNzJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlZENlbGxET00odGFnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgIGdldEF0dHJzOiBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gWydyYXdIVE1MJywgJ2NvbHNwYW4nLCAncm93c3BhbicsICdleHRlbmRlZCddLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZUluRE9NID0gYXR0ck5hbWUgPT09ICdyYXdIVE1MJyA/ICdkYXRhLXJhdy1odG1sJyA6IGF0dHJOYW1lO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBkb20uZ2V0QXR0cmlidXRlKGF0dHJOYW1lSW5ET00pO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IGluY2x1ZGVzKFsncmF3SFRNTCcsICdleHRlbmRlZCddLCBhdHRyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYXR0clZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE51bWJlcihhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q3VzdG9tQXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaHRtbEF0dHJzOiB7IGRlZmF1bHQ6IG51bGwgfSxcbiAgICAgICAgY2xhc3NOYW1lczogeyBkZWZhdWx0OiBudWxsIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEN1c3RvbUF0dHJzKGF0dHJzKSB7XG4gICAgdmFyIGh0bWxBdHRycyA9IGF0dHJzLmh0bWxBdHRycywgY2xhc3NOYW1lcyA9IGF0dHJzLmNsYXNzTmFtZXM7XG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBodG1sQXR0cnMpLCB7IGNsYXNzOiBjbGFzc05hbWVzID8gY2xhc3NOYW1lcy5qb2luKCcgJykgOiBudWxsIH0pO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvd3lzaXd5Zy9oZWxwZXIvdGFibGVPZmZzZXRNYXAudHNcblxuXG52YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBUYWJsZU9mZnNldE1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZU9mZnNldE1hcCh0YWJsZSwgdGFibGVSb3dzLCB0YWJsZVN0YXJ0UG9zLCByb3dJbmZvKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy50YWJsZVJvd3MgPSB0YWJsZVJvd3M7XG4gICAgICAgIHRoaXMudGFibGVTdGFydFBvcyA9IHRhYmxlU3RhcnRQb3M7XG4gICAgICAgIHRoaXMucm93SW5mbyA9IHJvd0luZm87XG4gICAgfVxuICAgIFRhYmxlT2Zmc2V0TWFwLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZWxsUG9zKSB7XG4gICAgICAgIHZhciB0YWJsZSA9IGZpbmROb2RlQnkoY2VsbFBvcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSAndGFibGUnO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRhYmxlLm5vZGUsIGRlcHRoID0gdGFibGUuZGVwdGgsIG9mZnNldCA9IHRhYmxlLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgICAgICAgICBpZiAoKGNhY2hlZCA9PT0gbnVsbCB8fCBjYWNoZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhY2hlZC50YWJsZVN0YXJ0UG9zKSA9PT0gb2Zmc2V0ICsgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcm93c18xID0gW107XG4gICAgICAgICAgICB2YXIgdGFibGVQb3MgPSBjZWxsUG9zLnN0YXJ0KGRlcHRoKTtcbiAgICAgICAgICAgIHZhciB0aGVhZCA9IG5vZGUuY2hpbGQoMCk7XG4gICAgICAgICAgICB2YXIgdGJvZHkgPSBub2RlLmNoaWxkKDEpO1xuICAgICAgICAgICAgdmFyIHRoZWFkQ2VsbEluZm8gPSBjcmVhdGVPZmZzZXRNYXAodGhlYWQsIHRhYmxlUG9zKTtcbiAgICAgICAgICAgIHZhciB0Ym9keUNlbGxJbmZvID0gY3JlYXRlT2Zmc2V0TWFwKHRib2R5LCB0YWJsZVBvcyArIHRoZWFkLm5vZGVTaXplKTtcbiAgICAgICAgICAgIHRoZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93c18xLnB1c2gocm93KTsgfSk7XG4gICAgICAgICAgICB0Ym9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd3NfMS5wdXNoKHJvdyk7IH0pO1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBUYWJsZU9mZnNldE1hcChub2RlLCByb3dzXzEsIHRhYmxlUG9zLCB0aGVhZENlbGxJbmZvLmNvbmNhdCh0Ym9keUNlbGxJbmZvKSk7XG4gICAgICAgICAgICBjYWNoZS5zZXQobm9kZSwgbWFwKTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLCBcInRvdGFsUm93Q291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0luZm8ubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgXCJ0b3RhbENvbHVtbkNvdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvWzBdLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVTdGFydE9mZnNldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFibGVTdGFydFBvcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUsIFwidGFibGVFbmRPZmZzZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYmxlU3RhcnRQb3MgKyB0aGlzLnRhYmxlLm5vZGVTaXplIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsSW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5wb3NBdCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgcm93U3RhcnQgPSB0aGlzLnRhYmxlU3RhcnRQb3M7OyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciByb3dFbmQgPSByb3dTdGFydCArIHRoaXMudGFibGVSb3dzW2ldLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkgPT09IHJvd0lkeCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbElkeDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxscyBmcm9tIHByZXZpb3VzIHJvdyh2aWEgcm93c3BhbilcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB0aGlzLnRvdGFsQ29sdW1uQ291bnQgJiYgdGhpcy5yb3dJbmZvW2ldW2luZGV4XS5vZmZzZXQgPCByb3dTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IHRoaXMudG90YWxDb2x1bW5Db3VudCA/IHJvd0VuZCA6IHRoaXMucm93SW5mb1tpXVtpbmRleF0ub2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U3RhcnQgPSByb3dFbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXROb2RlQW5kUG9zID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBjZWxsSW5mbyA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlOiB0aGlzLnRhYmxlLm5vZGVBdChjZWxsSW5mby5vZmZzZXQgLSB0aGlzLnRhYmxlU3RhcnRPZmZzZXQpLFxuICAgICAgICAgICAgcG9zOiBjZWxsSW5mby5vZmZzZXQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZXh0ZW5kZWRSb3dzcGFuID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5leHRlbmRlZENvbHNwYW4gPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldFJvd3NwYW5Db3VudCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VDb2xzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZGVjcmVhc2VSb3dzcGFuQ291bnQgPSBmdW5jdGlvbiAocm93SWR4LCBjb2xJZHgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q29sc3BhblN0YXJ0SW5mbyA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSb3dzcGFuU3RhcnRJbmZvID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGVPZmZzZXRNYXAucHJvdG90eXBlLmdldENlbGxTdGFydE9mZnNldCA9IGZ1bmN0aW9uIChyb3dJZHgsIGNvbElkeCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yb3dJbmZvW3Jvd0lkeF1bY29sSWR4XS5vZmZzZXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZGVkUm93c3Bhbihyb3dJZHgsIGNvbElkeCkgPyB0aGlzLnBvc0F0KHJvd0lkeCwgY29sSWR4KSA6IG9mZnNldDtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRDZWxsRW5kT2Zmc2V0ID0gZnVuY3Rpb24gKHJvd0lkeCwgY29sSWR4KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucm93SW5mb1tyb3dJZHhdW2NvbElkeF0sIG9mZnNldCA9IF9hLm9mZnNldCwgbm9kZVNpemUgPSBfYS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kZWRSb3dzcGFuKHJvd0lkeCwgY29sSWR4KSA/IHRoaXMucG9zQXQocm93SWR4LCBjb2xJZHgpIDogb2Zmc2V0ICsgbm9kZVNpemU7XG4gICAgfTtcbiAgICBUYWJsZU9mZnNldE1hcC5wcm90b3R5cGUuZ2V0Q2VsbEluZGV4ID0gZnVuY3Rpb24gKGNlbGxQb3MpIHtcbiAgICAgICAgZm9yICh2YXIgcm93SWR4ID0gMDsgcm93SWR4IDwgdGhpcy50b3RhbFJvd0NvdW50OyByb3dJZHggKz0gMSkge1xuICAgICAgICAgICAgdmFyIHJvd0luZm8gPSB0aGlzLnJvd0luZm9bcm93SWR4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGNvbElkeCA9IDA7IGNvbElkeCA8IHRoaXMudG90YWxDb2x1bW5Db3VudDsgY29sSWR4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocm93SW5mb1tjb2xJZHhdLm9mZnNldCArIDEgPiBjZWxsUG9zLnBvcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Jvd0lkeCwgY29sSWR4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRSZWN0T2Zmc2V0cyA9IGZ1bmN0aW9uIChzdGFydENlbGxQb3MsIGVuZENlbGxQb3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmIChlbmRDZWxsUG9zID09PSB2b2lkIDApIHsgZW5kQ2VsbFBvcyA9IHN0YXJ0Q2VsbFBvczsgfVxuICAgICAgICBpZiAoc3RhcnRDZWxsUG9zLnBvcyA+IGVuZENlbGxQb3MucG9zKSB7XG4gICAgICAgICAgICBfYSA9IFtlbmRDZWxsUG9zLCBzdGFydENlbGxQb3NdLCBzdGFydENlbGxQb3MgPSBfYVswXSwgZW5kQ2VsbFBvcyA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZCA9IHRoaXMuZ2V0Q2VsbEluZGV4KHN0YXJ0Q2VsbFBvcyksIHN0YXJ0Um93SWR4ID0gX2RbMF0sIHN0YXJ0Q29sSWR4ID0gX2RbMV07XG4gICAgICAgIHZhciBfZSA9IHRoaXMuZ2V0Q2VsbEluZGV4KGVuZENlbGxQb3MpLCBlbmRSb3dJZHggPSBfZVswXSwgZW5kQ29sSWR4ID0gX2VbMV07XG4gICAgICAgIF9iID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydFJvd0lkeCwgZW5kUm93SWR4KSwgc3RhcnRSb3dJZHggPSBfYlswXSwgZW5kUm93SWR4ID0gX2JbMV07XG4gICAgICAgIF9jID0gZ2V0U29ydGVkTnVtUGFpcihzdGFydENvbElkeCwgZW5kQ29sSWR4KSwgc3RhcnRDb2xJZHggPSBfY1swXSwgZW5kQ29sSWR4ID0gX2NbMV07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNwYW5uZWRPZmZzZXRzKHsgc3RhcnRSb3dJZHg6IHN0YXJ0Um93SWR4LCBzdGFydENvbElkeDogc3RhcnRDb2xJZHgsIGVuZFJvd0lkeDogZW5kUm93SWR4LCBlbmRDb2xJZHg6IGVuZENvbElkeCB9KTtcbiAgICB9O1xuICAgIFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZS5nZXRTcGFubmVkT2Zmc2V0cyA9IGZ1bmN0aW9uIChzZWxlY3Rpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25JbmZvO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlT2Zmc2V0TWFwO1xufSgpKTtcblxuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbnZhciBjcmVhdGVPZmZzZXRNYXAgPSBmdW5jdGlvbiAoaGVhZE9yQm9keSwgc3RhcnRPZmZzZXQpIHtcbiAgICB2YXIgY2VsbEluZm9NYXRyaXggPSBbXTtcbiAgICBoZWFkT3JCb2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdywgcm93T2Zmc2V0KSB7XG4gICAgICAgIC8vIGdldCByb3cgaW5kZXggYmFzZWQgb24gdGFibGUobm90IHRhYmxlIGhlYWQgb3IgdGFibGUgYm9keSlcbiAgICAgICAgdmFyIHJvd0luZm8gPSB7IHJvd3NwYW5NYXA6IHt9LCBjb2xzcGFuTWFwOiB7fSwgbGVuZ3RoOiAwIH07XG4gICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgY2VsbE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG5vZGVTaXplID0gX2Eubm9kZVNpemU7XG4gICAgICAgICAgICB2YXIgY29sSWR4ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChyb3dJbmZvW2NvbElkeF0pIHtcbiAgICAgICAgICAgICAgICBjb2xJZHggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0luZm9bY29sSWR4XSA9IHtcbiAgICAgICAgICAgICAgICAvLyAyIGlzIHRoZSBzdW0gb2YgdGhlIGZyb250IGFuZCBiYWNrIHBvc2l0aW9ucyBvZiB0aGUgdGFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCArIHJvd09mZnNldCArIGNlbGxPZmZzZXQgKyAyLFxuICAgICAgICAgICAgICAgIG5vZGVTaXplOiBub2RlU2l6ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb3dJbmZvLmxlbmd0aCArPSAxO1xuICAgICAgICB9KTtcbiAgICAgICAgY2VsbEluZm9NYXRyaXgucHVzaChyb3dJbmZvKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2VsbEluZm9NYXRyaXg7XG59O1xuZnVuY3Rpb24gbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZShvZmZzZXRNYXBNaXhpbiwgY3JlYXRlT2Zmc2V0TWFwTWl4aW4pIHtcbiAgICBjb21tb25fYXNzaWduKFRhYmxlT2Zmc2V0TWFwLnByb3RvdHlwZSwgb2Zmc2V0TWFwTWl4aW4pO1xuICAgIGNyZWF0ZU9mZnNldE1hcCA9IGNyZWF0ZU9mZnNldE1hcE1peGluO1xuICAgIHJldHVybiBUYWJsZU9mZnNldE1hcDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2hlbHBlci9wbHVnaW4udHNcblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZXhlY1BsdWdpbihwbHVnaW5JbmZvKSB7XG4gICAgdmFyIHBsdWdpbiA9IHBsdWdpbkluZm8ucGx1Z2luLCBldmVudEVtaXR0ZXIgPSBwbHVnaW5JbmZvLmV2ZW50RW1pdHRlciwgdXNhZ2VTdGF0aXN0aWNzID0gcGx1Z2luSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luSW5mby5pbnN0YW5jZTtcbiAgICB2YXIgcG1TdGF0ZSA9IHsgUGx1Z2luOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9zdGF0ZV9jb21tb25qczJfcHJvc2VtaXJyb3Jfc3RhdGVfYW1kX3Byb3NlbWlycm9yX3N0YXRlXy5QbHVnaW4sIFBsdWdpbktleTogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfc3RhdGVfY29tbW9uanMyX3Byb3NlbWlycm9yX3N0YXRlX2FtZF9wcm9zZW1pcnJvcl9zdGF0ZV8uUGx1Z2luS2V5LCBTZWxlY3Rpb246IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3N0YXRlX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9zdGF0ZV9hbWRfcHJvc2VtaXJyb3Jfc3RhdGVfLlNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbjogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3Jfc3RhdGVfY29tbW9uanMyX3Byb3NlbWlycm9yX3N0YXRlX2FtZF9wcm9zZW1pcnJvcl9zdGF0ZV8uVGV4dFNlbGVjdGlvbiB9O1xuICAgIHZhciBwbVZpZXcgPSB7IERlY29yYXRpb246IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3ZpZXdfY29tbW9uanMyX3Byb3NlbWlycm9yX3ZpZXdfYW1kX3Byb3NlbWlycm9yX3ZpZXdfLkRlY29yYXRpb24sIERlY29yYXRpb25TZXQ6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX3ZpZXdfY29tbW9uanMyX3Byb3NlbWlycm9yX3ZpZXdfYW1kX3Byb3NlbWlycm9yX3ZpZXdfLkRlY29yYXRpb25TZXQgfTtcbiAgICB2YXIgcG1Nb2RlbCA9IHsgRnJhZ21lbnQ6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX21vZGVsX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9tb2RlbF9hbWRfcHJvc2VtaXJyb3JfbW9kZWxfLkZyYWdtZW50IH07XG4gICAgdmFyIHBtUnVsZXMgPSB7IElucHV0UnVsZTogZXh0ZXJuYWxfY29tbW9uanNfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19jb21tb25qczJfcHJvc2VtaXJyb3JfaW5wdXRydWxlc19hbWRfcHJvc2VtaXJyb3JfaW5wdXRydWxlc18uSW5wdXRSdWxlLCBpbnB1dFJ1bGVzOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2FtZF9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzXy5pbnB1dFJ1bGVzLCB1bmRvSW5wdXRSdWxlOiBleHRlcm5hbF9jb21tb25qc19wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2NvbW1vbmpzMl9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzX2FtZF9wcm9zZW1pcnJvcl9pbnB1dHJ1bGVzXy51bmRvSW5wdXRSdWxlIH07XG4gICAgdmFyIHBtS2V5bWFwID0geyBrZXltYXA6IGV4dGVybmFsX2NvbW1vbmpzX3Byb3NlbWlycm9yX2tleW1hcF9jb21tb25qczJfcHJvc2VtaXJyb3Jfa2V5bWFwX2FtZF9wcm9zZW1pcnJvcl9rZXltYXBfLmtleW1hcCB9O1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICBldmVudEVtaXR0ZXI6IGV2ZW50RW1pdHRlcixcbiAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB1c2FnZVN0YXRpc3RpY3MsXG4gICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgcG1TdGF0ZTogcG1TdGF0ZSxcbiAgICAgICAgcG1WaWV3OiBwbVZpZXcsXG4gICAgICAgIHBtTW9kZWw6IHBtTW9kZWwsXG4gICAgICAgIHBtUnVsZXM6IHBtUnVsZXMsXG4gICAgICAgIHBtS2V5bWFwOiBwbUtleW1hcCxcbiAgICAgICAgaTE4bjogaTE4bixcbiAgICB9O1xuICAgIGlmIChpc0FycmF5X2RlZmF1bHQoKShwbHVnaW4pKSB7XG4gICAgICAgIHZhciBwbHVnaW5GbiA9IHBsdWdpblswXSwgX2EgPSBwbHVnaW5bMV0sIG9wdGlvbnMgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbkZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcGx1Z2luKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UGx1Z2luSW5mbyhwbHVnaW5zSW5mbykge1xuICAgIHZhciBwbHVnaW5zID0gcGx1Z2luc0luZm8ucGx1Z2lucywgZXZlbnRFbWl0dGVyID0gcGx1Z2luc0luZm8uZXZlbnRFbWl0dGVyLCB1c2FnZVN0YXRpc3RpY3MgPSBwbHVnaW5zSW5mby51c2FnZVN0YXRpc3RpY3MsIGluc3RhbmNlID0gcGx1Z2luc0luZm8uaW5zdGFuY2U7XG4gICAgZXZlbnRFbWl0dGVyLmxpc3RlbignbWl4aW5UYWJsZU9mZnNldE1hcFByb3RvdHlwZScsIG1peGluVGFibGVPZmZzZXRNYXBQcm90b3R5cGUpO1xuICAgIHJldHVybiAocGx1Z2lucyAhPT0gbnVsbCAmJiBwbHVnaW5zICE9PSB2b2lkIDAgPyBwbHVnaW5zIDogW10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICAgICAgdmFyIHBsdWdpbkluZm9SZXN1bHQgPSBleGVjUGx1Z2luKHtcbiAgICAgICAgICAgIHBsdWdpbjogcGx1Z2luLFxuICAgICAgICAgICAgZXZlbnRFbWl0dGVyOiBldmVudEVtaXR0ZXIsXG4gICAgICAgICAgICB1c2FnZVN0YXRpc3RpY3M6IHVzYWdlU3RhdGlzdGljcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcGx1Z2luSW5mb1Jlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRlZCBwbHVnaW4gaXMgZW1wdHkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmtkb3duUGFyc2VycyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25QYXJzZXJzLCB0b0hUTUxSZW5kZXJlcnMgPSBwbHVnaW5JbmZvUmVzdWx0LnRvSFRNTFJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyA9IHBsdWdpbkluZm9SZXN1bHQudG9NYXJrZG93blJlbmRlcmVycywgbWFya2Rvd25QbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC5tYXJrZG93blBsdWdpbnMsIHd5c2l3eWdQbHVnaW5zID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnUGx1Z2lucywgd3lzaXd5Z05vZGVWaWV3cyA9IHBsdWdpbkluZm9SZXN1bHQud3lzaXd5Z05vZGVWaWV3cywgbWFya2Rvd25Db21tYW5kcyA9IHBsdWdpbkluZm9SZXN1bHQubWFya2Rvd25Db21tYW5kcywgd3lzaXd5Z0NvbW1hbmRzID0gcGx1Z2luSW5mb1Jlc3VsdC53eXNpd3lnQ29tbWFuZHMsIHRvb2xiYXJJdGVtcyA9IHBsdWdpbkluZm9SZXN1bHQudG9vbGJhckl0ZW1zO1xuICAgICAgICBpZiAodG9IVE1MUmVuZGVyZXJzKSB7XG4gICAgICAgICAgICBhY2MudG9IVE1MUmVuZGVyZXJzID0gZGVlcE1lcmdlZENvcHkoYWNjLnRvSFRNTFJlbmRlcmVycywgdG9IVE1MUmVuZGVyZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9NYXJrZG93blJlbmRlcmVycykge1xuICAgICAgICAgICAgYWNjLnRvTWFya2Rvd25SZW5kZXJlcnMgPSBkZWVwTWVyZ2VkQ29weShhY2MudG9NYXJrZG93blJlbmRlcmVycywgdG9NYXJrZG93blJlbmRlcmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtkb3duUGx1Z2lucykge1xuICAgICAgICAgICAgYWNjLm1kUGx1Z2lucyA9IGFjYy5tZFBsdWdpbnMuY29uY2F0KG1hcmtkb3duUGx1Z2lucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHd5c2l3eWdQbHVnaW5zKSB7XG4gICAgICAgICAgICBhY2Mud3dQbHVnaW5zID0gYWNjLnd3UGx1Z2lucy5jb25jYXQod3lzaXd5Z1BsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3eXNpd3lnTm9kZVZpZXdzKSB7XG4gICAgICAgICAgICBhY2Mud3dOb2RlVmlld3MgPSB0c2xpYl9lczZfYXNzaWduKHRzbGliX2VzNl9hc3NpZ24oe30sIGFjYy53d05vZGVWaWV3cyksIHd5c2l3eWdOb2RlVmlld3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93bkNvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2MubWRDb21tYW5kcyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgYWNjLm1kQ29tbWFuZHMpLCBtYXJrZG93bkNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3lzaXd5Z0NvbW1hbmRzKSB7XG4gICAgICAgICAgICBhY2Mud3dDb21tYW5kcyA9IHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgYWNjLnd3Q29tbWFuZHMpLCB3eXNpd3lnQ29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29sYmFySXRlbXMpIHtcbiAgICAgICAgICAgIGFjYy50b29sYmFySXRlbXMgPSBhY2MudG9vbGJhckl0ZW1zLmNvbmNhdCh0b29sYmFySXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZG93blBhcnNlcnMpIHtcbiAgICAgICAgICAgIGFjYy5tYXJrZG93blBhcnNlcnMgPSB0c2xpYl9lczZfYXNzaWduKHRzbGliX2VzNl9hc3NpZ24oe30sIGFjYy5tYXJrZG93blBhcnNlcnMpLCBtYXJrZG93blBhcnNlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge1xuICAgICAgICB0b0hUTUxSZW5kZXJlcnM6IHt9LFxuICAgICAgICB0b01hcmtkb3duUmVuZGVyZXJzOiB7fSxcbiAgICAgICAgbWRQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dQbHVnaW5zOiBbXSxcbiAgICAgICAgd3dOb2RlVmlld3M6IHt9LFxuICAgICAgICBtZENvbW1hbmRzOiB7fSxcbiAgICAgICAgd3dDb21tYW5kczoge30sXG4gICAgICAgIHRvb2xiYXJJdGVtczogW10sXG4gICAgICAgIG1hcmtkb3duUGFyc2Vyczoge30sXG4gICAgfSk7XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3R1aS1jb2RlLXNuaXBwZXQvdHlwZS9pc0ZhbHN5LmpzXG52YXIgaXNGYWxzeSA9IF9fd2VicGFja19yZXF1aXJlX18oNDA0KTtcbnZhciBpc0ZhbHN5X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzRmFsc3kpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2V2ZW50L2V2ZW50RW1pdHRlci50c1xuXG5cblxuXG52YXIgZXZlbnRUeXBlTGlzdCA9IFtcbiAgICAnYWZ0ZXJQcmV2aWV3UmVuZGVyJyxcbiAgICAndXBkYXRlUHJldmlldycsXG4gICAgJ2NoYW5nZU1vZGUnLFxuICAgICduZWVkQ2hhbmdlTW9kZScsXG4gICAgJ2NvbW1hbmQnLFxuICAgICdjaGFuZ2VQcmV2aWV3U3R5bGUnLFxuICAgICdjaGFuZ2VQcmV2aWV3VGFiUHJldmlldycsXG4gICAgJ2NoYW5nZVByZXZpZXdUYWJXcml0ZScsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ2NvbnRleHRtZW51JyxcbiAgICAnc2hvdycsXG4gICAgJ2hpZGUnLFxuICAgICdjaGFuZ2VMYW5ndWFnZScsXG4gICAgJ2NoYW5nZVRvb2xiYXJTdGF0ZScsXG4gICAgJ3RvZ2dsZVNjcm9sbFN5bmMnLFxuICAgICdtaXhpblRhYmxlT2Zmc2V0TWFwUHJvdG90eXBlJyxcbiAgICAnc2V0Rm9jdXNlZE5vZGUnLFxuICAgICdyZW1vdmVQb3B1cFdpZGdldCcsXG4gICAgJ3F1ZXJ5JyxcbiAgICAvLyBwcm92aWRlIGV2ZW50IGZvciB1c2VyXG4gICAgJ29wZW5Qb3B1cCcsXG4gICAgJ2Nsb3NlUG9wdXAnLFxuICAgICdhZGRJbWFnZUJsb2JIb29rJyxcbiAgICAnYmVmb3JlUHJldmlld1JlbmRlcicsXG4gICAgJ2JlZm9yZUNvbnZlcnRXeXNpd3lnVG9NYXJrZG93bicsXG4gICAgJ2xvYWQnLFxuICAgICdsb2FkVUknLFxuICAgICdjaGFuZ2UnLFxuICAgICdjYXJldENoYW5nZScsXG4gICAgJ2Rlc3Ryb3knLFxuICAgICdmb2N1cycsXG4gICAgJ2JsdXInLFxuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnLFxuXTtcbi8qKlxuICogQ2xhc3MgRXZlbnRFbWl0dGVyXG4gKiBAaWdub3JlXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyB1dGlsc19tYXAoKTtcbiAgICAgICAgdGhpcy5ldmVudFR5cGVzID0gZXZlbnRUeXBlTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHR5cGVzLCB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCB0eXBlcyksIHsgdHlwZTogdHlwZSB9KTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICAgICAgZXZlbnRUeXBlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZEV2ZW50VHlwZShldmVudFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdGVuIGV2ZW50IGFuZCBiaW5kIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIHR5cGVJbmZvID0gdGhpcy5nZXRUeXBlSW5mbyh0eXBlKTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50cy5nZXQodHlwZUluZm8udHlwZSkgfHwgW107XG4gICAgICAgIGlmICghdGhpcy5oYXNFdmVudFR5cGUodHlwZUluZm8udHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGV2ZW50IHR5cGUgXCIgKyB0eXBlSW5mby50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZUluZm8ubmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBoYW5kbGVyLm5hbWVzcGFjZSA9IHR5cGVJbmZvLm5hbWVzcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIHRoaXMuZXZlbnRzLnNldCh0eXBlSW5mby50eXBlLCBldmVudEhhbmRsZXJzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVtaXQgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZW1pdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZUluZm8gPSB0aGlzLmdldFR5cGVJbmZvKHR5cGUpO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlSW5mby50eXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmhvbGQgJiYgZXZlbnRIYW5kbGVycykge1xuICAgICAgICAgICAgZXZlbnRIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkX2RlZmF1bHQoKShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBnaXZlbiBldmVudCBhbmQgcmV0dXJuIHJlc3VsdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBlbWl0XG4gICAgICogQHBhcmFtIHthbnl9IHNvdXJjZSBTb3VyY2UgdG8gY2hhbmdlXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRSZWR1Y2UgPSBmdW5jdGlvbiAodHlwZSwgc291cmNlKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudEhhbmRsZXJzID0gdGhpcy5ldmVudHMuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIXRoaXMuaG9sZCAmJiBldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGFuZGxlci5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW3NvdXJjZV0sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc3lfZGVmYXVsdCgpKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnQgdHlwZSBhbmQgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHJldHVybnMge3t0eXBlOiBzdHJpbmcsIG5hbWVzcGFjZTogc3RyaW5nfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0VHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgc3BsaXRlZCA9IHR5cGUuc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHNwbGl0ZWRbMF0sXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHNwbGl0ZWRbMV0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGV2ZW50IHR5cGUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXNFdmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkX2RlZmF1bHQoKSh0aGlzLmV2ZW50VHlwZXNbdGhpcy5nZXRUeXBlSW5mbyh0eXBlKS50eXBlXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnQgdHlwZSB3aGVuIGdpdmVuIGV2ZW50IG5vdCBleGlzdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0V2ZW50VHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBoYXZlIGV2ZW50IHR5cGUgXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50VHlwZXNbdHlwZV0gPSB0eXBlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGhhbmRsZXIgZnJvbSBnaXZlbiBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl0gLSByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRUeXBlSW5mbyhldmVudFR5cGUpLCB0eXBlID0gX2EudHlwZSwgbmFtZXNwYWNlID0gX2EubmFtZXNwYWNlO1xuICAgICAgICBpZiAodHlwZSAmJiBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhIYW5kbGVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0eXBlICYmIG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoXywgZXZ0VHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50SGFuZGxlcldpdGhUeXBlSW5mbyhldnRUeXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSAmJiBuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aFR5cGVJbmZvKHR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBldmVudCBoYW5kbGVyIHdpdGggZXZlbnQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gZXZlbnQgdHlwZSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRIYW5kbGVyV2l0aEhhbmRsZXIgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVySW5kZXggPSBldmVudEhhbmRsZXJzLmluZGV4T2YoaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShoYW5kbGVySW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgaGFuZGxlciB3aXRoIGV2ZW50IHR5cGUgaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIEV2ZW50IG5hbWVzcGFjZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudEhhbmRsZXJXaXRoVHlwZUluZm8gPSBmdW5jdGlvbiAodHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBoYW5kbGVyc1RvU3Vydml2ZSA9IFtdO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZXZlbnRzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFldmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNUb1N1cnZpdmUucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMuc2V0KHR5cGUsIGhhbmRsZXJzVG9TdXJ2aXZlKTtcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmhvbGRFdmVudEludm9rZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLmhvbGQgPSB0cnVlO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLmhvbGQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZXZlbnRFbWl0dGVyID0gKEV2ZW50RW1pdHRlcik7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy92aWV3ZXIudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBUQVNLX0FUVFJfTkFNRSA9ICdkYXRhLXRhc2snO1xudmFyIERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FID0gJ2RhdGEtdGFzay1kaXNhYmxlZCc7XG52YXIgVEFTS19DSEVDS0VEX0NMQVNTX05BTUUgPSAnY2hlY2tlZCc7XG5mdW5jdGlvbiByZWdpc3RlckhUTUxUYWdUb1doaXRlbGlzdChjb252ZXJ0b3JNYXApIHtcbiAgICBbJ2h0bWxCbG9jaycsICdodG1sSW5saW5lJ10uZm9yRWFjaChmdW5jdGlvbiAoaHRtbFR5cGUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pIHtcbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRhZyB3aGl0ZSBsaXN0IGZvciBwcmV2ZW50aW5nIHRvIHJlbW92ZSB0aGUgaHRtbCBpbiBzYW5pdGl6ZXJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnZlcnRvck1hcFtodG1sVHlwZV0pLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGh0bWxTYW5pdGl6ZXJfcmVnaXN0ZXJUYWdXaGl0ZWxpc3RJZlBvc3NpYmxlKHR5cGUpOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBDbGFzcyBUb2FzdFVJRWRpdG9yVmlld2VyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb24gb2JqZWN0XG4gKiAgICAgQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5lbCAtIGNvbnRhaW5lciBlbGVtZW50XG4gKiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluaXRpYWxWYWx1ZV0gRWRpdG9yJ3MgaW5pdGlhbCB2YWx1ZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ldmVudHNdIC0gRXZlbnRzXG4gKiAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV2ZW50cy5sb2FkXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBlZGl0b3IgZnVsbHkgbG9hZFxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuY2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBjb250ZW50IGNoYW5nZWRcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmNhcmV0Q2hhbmdlXSAtIEl0IHdvdWxkIGJlIGVtaXR0ZWQgd2hlbiBmb3JtYXQgY2hhbmdlIGJ5IGN1cnNvciBwb3NpdGlvblxuICogICAgICAgICBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5ldmVudHMuZm9jdXNdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBnZXQgZm9jdXNcbiAqICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXZlbnRzLmJsdXJdIC0gSXQgd291bGQgYmUgZW1pdHRlZCB3aGVuIGVkaXRvciBsb29zZSBmb2N1c1xuICogICAgIEBwYXJhbSB7QXJyYXkuPGZ1bmN0aW9ufEFycmF5Pn0gW29wdGlvbnMucGx1Z2luc10gLSBBcnJheSBvZiBwbHVnaW5zLiBBIHBsdWdpbiBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW2Z1bmN0aW9uLCBvcHRpb25zXS5cbiAqICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXh0ZW5kZWRBdXRvbGlua3NdIC0gVXNpbmcgZXh0ZW5kZWQgQXV0b2xpbmtzIHNwZWNpZmllZCBpbiBHRk0gc3BlY1xuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5saW5rQXR0cmlidXRlc10gLSBBdHRyaWJ1dGVzIG9mIGFuY2hvciBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbCwgdGFyZ2V0LCBocmVmbGFuZywgdHlwZVxuICogICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXI9bnVsbF0gLSBPYmplY3QgY29udGFpbmluZyBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb25zIGNvcnJlc3BvbmQgdG8gY2hhbmdlIG1hcmtkb3duIG5vZGUgdG8gcHJldmlldyBIVE1MIG9yIHd5c2l3eWcgbm9kZVxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVmZXJlbmNlRGVmaW5pdGlvbj1mYWxzZV0gLSB3aGV0aGVyIHVzZSB0aGUgc3BlY2lmaWNhdGlvbiBvZiBsaW5rIHJlZmVyZW5jZSBkZWZpbml0aW9uXG4gKiAgICAgQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuY3VzdG9tSFRNTFNhbml0aXplcj1udWxsXSAtIGN1c3RvbSBIVE1MIHNhbml0aXplclxuICogICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnJvbnRNYXR0ZXI9ZmFsc2VdIC0gd2hldGhlciB1c2UgdGhlIGZyb250IG1hdHRlclxuICogICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aGVtZV0gLSBUaGUgdGhlbWUgdG8gc3R5bGUgdGhlIHZpZXdlciB3aXRoLiBUaGUgZGVmYXVsdCBpcyBpbmNsdWRlZCBpbiB0b2FzdHVpLWVkaXRvci5jc3MuXG4gKi9cbnZhciBUb2FzdFVJRWRpdG9yVmlld2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0VUlFZGl0b3JWaWV3ZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmRfZGVmYXVsdCgpKHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGZhbHNlLFxuICAgICAgICAgICAgY3VzdG9tSFRNTFJlbmRlcmVyOiBudWxsLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBjdXN0b21IVE1MU2FuaXRpemVyOiBudWxsLFxuICAgICAgICAgICAgZnJvbnRNYXR0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0cnVlLFxuICAgICAgICAgICAgdGhlbWU6ICdsaWdodCcsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlciA9IG5ldyBldmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFyIGxpbmtBdHRyaWJ1dGVzID0gc2FuaXRpemVMaW5rQXR0cmlidXRlKHRoaXMub3B0aW9ucy5saW5rQXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBfYSA9IGdldFBsdWdpbkluZm8oe1xuICAgICAgICAgICAgcGx1Z2luczogdGhpcy5vcHRpb25zLnBsdWdpbnMsXG4gICAgICAgICAgICBldmVudEVtaXR0ZXI6IHRoaXMuZXZlbnRFbWl0dGVyLFxuICAgICAgICAgICAgdXNhZ2VTdGF0aXN0aWNzOiB0aGlzLm9wdGlvbnMudXNhZ2VTdGF0aXN0aWNzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgIH0pIHx8IHt9LCB0b0hUTUxSZW5kZXJlcnMgPSBfYS50b0hUTUxSZW5kZXJlcnMsIG1hcmtkb3duUGFyc2VycyA9IF9hLm1hcmtkb3duUGFyc2VycztcbiAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBjdXN0b21IVE1MUmVuZGVyZXIgPSBfYi5jdXN0b21IVE1MUmVuZGVyZXIsIGV4dGVuZGVkQXV0b2xpbmtzID0gX2IuZXh0ZW5kZWRBdXRvbGlua3MsIHJlZmVyZW5jZURlZmluaXRpb24gPSBfYi5yZWZlcmVuY2VEZWZpbml0aW9uLCBmcm9udE1hdHRlciA9IF9iLmZyb250TWF0dGVyLCBjdXN0b21IVE1MU2FuaXRpemVyID0gX2IuY3VzdG9tSFRNTFNhbml0aXplcjtcbiAgICAgICAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxpbmtBdHRyaWJ1dGVzOiBsaW5rQXR0cmlidXRlcyxcbiAgICAgICAgICAgIGN1c3RvbUhUTUxSZW5kZXJlcjogdHNsaWJfZXM2X2Fzc2lnbih0c2xpYl9lczZfYXNzaWduKHt9LCB0b0hUTUxSZW5kZXJlcnMpLCBjdXN0b21IVE1MUmVuZGVyZXIpLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGZyb250TWF0dGVyOiBmcm9udE1hdHRlcixcbiAgICAgICAgICAgIHNhbml0aXplcjogY3VzdG9tSFRNTFNhbml0aXplciB8fCBzYW5pdGl6ZUhUTUwsXG4gICAgICAgIH07XG4gICAgICAgIHJlZ2lzdGVySFRNTFRhZ1RvV2hpdGVsaXN0KHJlbmRlcmVyT3B0aW9ucy5jdXN0b21IVE1MUmVuZGVyZXIpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgICAgZm9yRWFjaE93blByb3BlcnRpZXNfZGVmYXVsdCgpKHRoaXMub3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub24oa2V5LCBmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2MgPSB0aGlzLm9wdGlvbnMsIGVsID0gX2MuZWwsIGluaXRpYWxWYWx1ZSA9IF9jLmluaXRpYWxWYWx1ZSwgdGhlbWUgPSBfYy50aGVtZTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSFRNTCA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgaWYgKHRoZW1lICE9PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyh0aGVtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnRvYXN0TWFyayA9IG5ldyBUb2FzdE1hcmsoJycsIHtcbiAgICAgICAgICAgIGRpc2FsbG93ZWRIdG1sQmxvY2tUYWdzOiBbJ2JyJywgJ2ltZyddLFxuICAgICAgICAgICAgZXh0ZW5kZWRBdXRvbGlua3M6IGV4dGVuZGVkQXV0b2xpbmtzLFxuICAgICAgICAgICAgcmVmZXJlbmNlRGVmaW5pdGlvbjogcmVmZXJlbmNlRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGRpc2FsbG93RGVlcEhlYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIsXG4gICAgICAgICAgICBjdXN0b21QYXJzZXI6IG1hcmtkb3duUGFyc2VycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldmlldyA9IG5ldyBtZFByZXZpZXcodGhpcy5ldmVudEVtaXR0ZXIsIHRzbGliX2VzNl9hc3NpZ24odHNsaWJfZXM2X2Fzc2lnbih7fSwgcmVuZGVyZXJPcHRpb25zKSwgeyBpc1ZpZXdlcjogdHJ1ZSB9KSk7XG4gICAgICAgIG9uX2RlZmF1bHQoKSh0aGlzLnByZXZpZXcucHJldmlld0NvbnRlbnQsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Rvd24oaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0hUTUwpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlldy5zZXRIVE1MKGV4aXN0aW5nSFRNTCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3LnByZXZpZXdDb250ZW50KTtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIuZW1pdCgnbG9hZCcsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGFzayBieSBkZXRlY3RpbmcgbW91c2Vkb3duIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgLSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUudG9nZ2xlVGFzayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGV2LnRhcmdldDtcbiAgICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnOmJlZm9yZScpO1xuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKERJU0FCTEVEX1RBU0tfQVRUUl9OQU1FKSAmJlxuICAgICAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoVEFTS19BVFRSX05BTUUpICYmXG4gICAgICAgICAgICBpc1Bvc2l0aW9uSW5Cb3goc3R5bGUsIGV2Lm9mZnNldFgsIGV2Lm9mZnNldFkpKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhlbGVtZW50LCBUQVNLX0NIRUNLRURfQ0xBU1NfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAndmlld2VyJyxcbiAgICAgICAgICAgICAgICBkYXRlOiBldixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgY29udGVudCBmb3IgcHJldmlld1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrZG93biBNYXJrZG93biB0ZXh0XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuc2V0TWFya2Rvd24gPSBmdW5jdGlvbiAobWFya2Rvd24pIHtcbiAgICAgICAgdmFyIGxpbmVUZXh0cyA9IHRoaXMudG9hc3RNYXJrLmdldExpbmVUZXh0cygpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGluZVRleHRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhc3RMaW5lID0gY29tbW9uX2xhc3QobGluZVRleHRzKTtcbiAgICAgICAgdmFyIGVuZFNvdXJjZXBvcyA9IFtsZW5ndGgsIGxhc3RMaW5lLmxlbmd0aCArIDFdO1xuICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHRoaXMudG9hc3RNYXJrLmVkaXRNYXJrZG93bihbMSwgMV0sIGVuZFNvdXJjZXBvcywgbWFya2Rvd24gfHwgJycpO1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGVQcmV2aWV3JywgZWRpdFJlc3VsdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCaW5kIGV2ZW50SGFuZGxlciB0byBldmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIubGlzdGVuKHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5iaW5kIGV2ZW50SGFuZGxlciBmcm9tIGV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlRXZlbnRIYW5kbGVyKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGhvb2sgdG8gVFVJRWRpdG9yIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmFkZEhvb2sgPSBmdW5jdGlvbiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmV2ZW50RW1pdHRlci5yZW1vdmVFdmVudEhhbmRsZXIodHlwZSk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmxpc3Rlbih0eXBlLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBWaWV3ZXIgcHJldmlldyBmcm9tIGRvY3VtZW50XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2ZmX2RlZmF1bHQoKSh0aGlzLnByZXZpZXcuZWwsICdtb3VzZWRvd24nLCB0aGlzLnRvZ2dsZVRhc2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucHJldmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGZhbHNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgVG9hc3RVSUVkaXRvclZpZXdlci5wcm90b3R5cGUuaXNNYXJrZG93bk1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFRvYXN0VUlFZGl0b3JWaWV3ZXIucHJvdG90eXBlLmlzV3lzaXd5Z01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBUb2FzdFVJRWRpdG9yVmlld2VyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHZpZXdlciA9IChUb2FzdFVJRWRpdG9yVmlld2VyKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2luZGV4Vmlld2VyLnRzXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaW5kZXhWaWV3ZXIgPSAodmlld2VyKTtcblxufSgpO1xuX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdO1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/react-editor/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/react-editor/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ default_1),\n/* harmony export */   Viewer: () => (/* binding */ ViewerComponent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _toast_ui_editor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @toast-ui/editor */ \"(ssr)/./node_modules/@toast-ui/editor/dist/esm/index.js\");\n/* harmony import */ var _toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @toast-ui/editor/dist/toastui-editor-viewer */ \"(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js\");\n/* harmony import */ var _toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * TOAST UI Editor : React Wrapper\n * @version 3.2.3 | Fri Feb 17 2023\n * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>\n * @license MIT\n */\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar default_1 = /** @class */ (function (_super) {\n    __extends(default_1, _super);\n    function default_1() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootEl = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        return _this;\n    }\n    default_1.prototype.getRootElement = function () {\n        return this.rootEl.current;\n    };\n    default_1.prototype.getInstance = function () {\n        return this.editorInst;\n    };\n    default_1.prototype.getBindingEventNames = function () {\n        var _this = this;\n        return Object.keys(this.props)\n            .filter(function (key) { return /^on[A-Z][a-zA-Z]+/.test(key); })\n            .filter(function (key) { return _this.props[key]; });\n    };\n    default_1.prototype.bindEventHandlers = function (props) {\n        var _this = this;\n        this.getBindingEventNames().forEach(function (key) {\n            var eventName = key[2].toLowerCase() + key.slice(3);\n            _this.editorInst.off(eventName);\n            _this.editorInst.on(eventName, props[key]);\n        });\n    };\n    default_1.prototype.getInitEvents = function () {\n        var _this = this;\n        return this.getBindingEventNames().reduce(function (acc, key) {\n            var eventName = (key[2].toLowerCase() + key.slice(3));\n            acc[eventName] = _this.props[key];\n            return acc;\n        }, {});\n    };\n    default_1.prototype.componentDidMount = function () {\n        this.editorInst = new _toast_ui_editor__WEBPACK_IMPORTED_MODULE_1__[\"default\"](__assign(__assign({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));\n    };\n    default_1.prototype.shouldComponentUpdate = function (nextProps) {\n        var instance = this.getInstance();\n        var height = nextProps.height, previewStyle = nextProps.previewStyle;\n        if (height && this.props.height !== height) {\n            instance.setHeight(height);\n        }\n        if (previewStyle && this.props.previewStyle !== previewStyle) {\n            instance.changePreviewStyle(previewStyle);\n        }\n        this.bindEventHandlers(nextProps);\n        return false;\n    };\n    default_1.prototype.render = function () {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: this.rootEl });\n    };\n    return default_1;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component)));\n\nvar ViewerComponent = /** @class */ (function (_super) {\n    __extends(ViewerComponent, _super);\n    function ViewerComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootEl = react__WEBPACK_IMPORTED_MODULE_0___default().createRef();\n        return _this;\n    }\n    ViewerComponent.prototype.getRootElement = function () {\n        return this.rootEl.current;\n    };\n    ViewerComponent.prototype.getInstance = function () {\n        return this.viewerInst;\n    };\n    ViewerComponent.prototype.getBindingEventNames = function () {\n        var _this = this;\n        return Object.keys(this.props)\n            .filter(function (key) { return /^on[A-Z][a-zA-Z]+/.test(key); })\n            .filter(function (key) { return _this.props[key]; });\n    };\n    ViewerComponent.prototype.bindEventHandlers = function (props) {\n        var _this = this;\n        this.getBindingEventNames().forEach(function (key) {\n            var eventName = key[2].toLowerCase() + key.slice(3);\n            _this.viewerInst.off(eventName);\n            _this.viewerInst.on(eventName, props[key]);\n        });\n    };\n    ViewerComponent.prototype.getInitEvents = function () {\n        var _this = this;\n        return this.getBindingEventNames().reduce(function (acc, key) {\n            var eventName = (key[2].toLowerCase() + key.slice(3));\n            acc[eventName] = _this.props[key];\n            return acc;\n        }, {});\n    };\n    ViewerComponent.prototype.componentDidMount = function () {\n        this.viewerInst = new (_toast_ui_editor_dist_toastui_editor_viewer__WEBPACK_IMPORTED_MODULE_2___default())(__assign(__assign({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));\n    };\n    ViewerComponent.prototype.shouldComponentUpdate = function (nextProps) {\n        this.bindEventHandlers(nextProps);\n        return false;\n    };\n    ViewerComponent.prototype.render = function () {\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { ref: this.rootEl });\n    };\n    return ViewerComponent;\n}((react__WEBPACK_IMPORTED_MODULE_0___default().Component)));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL3JlYWN0LWVkaXRvci9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQjtBQUNZO0FBQzJCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1Q0FBdUM7QUFDNUUscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQU0scUJBQXFCLHlCQUF5QixpQkFBaUIsOEJBQThCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFtQixVQUFVLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0EsQ0FBQyxDQUFDLHdEQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVDQUF1QztBQUM1RSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QixvRkFBTSxxQkFBcUIseUJBQXlCLGlCQUFpQiw4QkFBOEI7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBbUIsVUFBVSxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBLENBQUMsQ0FBQyx3REFBZTs7QUFFeUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHBcXE9uZURyaXZlXFxEZXNrdG9wXFxOQVJSQVRJVkUgTkVYVVNcXGFpLWdlbmVyYXRvclxcbm9kZV9tb2R1bGVzXFxAdG9hc3QtdWlcXHJlYWN0LWVkaXRvclxcZGlzdFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRPQVNUIFVJIEVkaXRvciA6IFJlYWN0IFdyYXBwZXJcbiAqIEB2ZXJzaW9uIDMuMi4zIHwgRnJpIEZlYiAxNyAyMDIzXG4gKiBAYXV0aG9yIE5ITiBDbG91ZCBGRSBEZXZlbG9wbWVudCBMYWIgPGRsX2phdmFzY3JpcHRAbmhuLmNvbT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRWRpdG9yIGZyb20gJ0B0b2FzdC11aS9lZGl0b3InO1xuaW1wb3J0IFZpZXdlciBmcm9tICdAdG9hc3QtdWkvZWRpdG9yL2Rpc3QvdG9hc3R1aS1lZGl0b3Itdmlld2VyJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XG5cbnZhciBkZWZhdWx0XzEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKGRlZmF1bHRfMSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWwgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290RWwuY3VycmVudDtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvckluc3Q7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLmdldEJpbmRpbmdFdmVudE5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wcm9wcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gL15vbltBLVpdW2EtekEtWl0rLy50ZXN0KGtleSk7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLnByb3BzW2tleV07IH0pO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5iaW5kRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmdldEJpbmRpbmdFdmVudE5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0ga2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMyk7XG4gICAgICAgICAgICBfdGhpcy5lZGl0b3JJbnN0Lm9mZihldmVudE5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuZWRpdG9ySW5zdC5vbihldmVudE5hbWUsIHByb3BzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuZ2V0SW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmluZGluZ0V2ZW50TmFtZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgIGFjY1tldmVudE5hbWVdID0gX3RoaXMucHJvcHNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWRpdG9ySW5zdCA9IG5ldyBFZGl0b3IoX19hc3NpZ24oX19hc3NpZ24oeyBlbDogdGhpcy5yb290RWwuY3VycmVudCB9LCB0aGlzLnByb3BzKSwgeyBldmVudHM6IHRoaXMuZ2V0SW5pdEV2ZW50cygpIH0pKTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBuZXh0UHJvcHMuaGVpZ2h0LCBwcmV2aWV3U3R5bGUgPSBuZXh0UHJvcHMucHJldmlld1N0eWxlO1xuICAgICAgICBpZiAoaGVpZ2h0ICYmIHRoaXMucHJvcHMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldEhlaWdodChoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aWV3U3R5bGUgJiYgdGhpcy5wcm9wcy5wcmV2aWV3U3R5bGUgIT09IHByZXZpZXdTdHlsZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY2hhbmdlUHJldmlld1N0eWxlKHByZXZpZXdTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kRXZlbnRIYW5kbGVycyhuZXh0UHJvcHMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBkZWZhdWx0XzEucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRfMTtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5cbnZhciBWaWV3ZXJDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpZXdlckNvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3ZXJDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yb290RWwgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLmdldFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290RWwuY3VycmVudDtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdlckluc3Q7XG4gICAgfTtcbiAgICBWaWV3ZXJDb21wb25lbnQucHJvdG90eXBlLmdldEJpbmRpbmdFdmVudE5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wcm9wcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gL15vbltBLVpdW2EtekEtWl0rLy50ZXN0KGtleSk7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLnByb3BzW2tleV07IH0pO1xuICAgIH07XG4gICAgVmlld2VyQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmdldEJpbmRpbmdFdmVudE5hbWVzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0ga2V5WzJdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMyk7XG4gICAgICAgICAgICBfdGhpcy52aWV3ZXJJbnN0Lm9mZihldmVudE5hbWUpO1xuICAgICAgICAgICAgX3RoaXMudmlld2VySW5zdC5vbihldmVudE5hbWUsIHByb3BzW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuZ2V0SW5pdEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmluZGluZ0V2ZW50TmFtZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gKGtleVsyXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDMpKTtcbiAgICAgICAgICAgIGFjY1tldmVudE5hbWVdID0gX3RoaXMucHJvcHNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmlld2VySW5zdCA9IG5ldyBWaWV3ZXIoX19hc3NpZ24oX19hc3NpZ24oeyBlbDogdGhpcy5yb290RWwuY3VycmVudCB9LCB0aGlzLnByb3BzKSwgeyBldmVudHM6IHRoaXMuZ2V0SW5pdEV2ZW50cygpIH0pKTtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgICB0aGlzLmJpbmRFdmVudEhhbmRsZXJzKG5leHRQcm9wcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFZpZXdlckNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5yb290RWwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld2VyQ29tcG9uZW50O1xufShSZWFjdC5Db21wb25lbnQpKTtcblxuZXhwb3J0IHsgZGVmYXVsdF8xIGFzIEVkaXRvciwgVmlld2VyQ29tcG9uZW50IGFzIFZpZXdlciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/react-editor/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor.css":
/*!***************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor.css ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"dc6b4e2d7563\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRvYXN0LXVpL2VkaXRvci9kaXN0L3RvYXN0dWktZWRpdG9yLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxocFxcT25lRHJpdmVcXERlc2t0b3BcXE5BUlJBVElWRSBORVhVU1xcYWktZ2VuZXJhdG9yXFxub2RlX21vZHVsZXNcXEB0b2FzdC11aVxcZWRpdG9yXFxkaXN0XFx0b2FzdHVpLWVkaXRvci5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkYzZiNGUyZDc1NjNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@toast-ui/editor/dist/toastui-editor.css\n");

/***/ })

};
;